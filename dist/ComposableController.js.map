{"version":3,"file":"ComposableController.js","sourceRoot":"","sources":["../src/ComposableController.ts"],"names":[],"mappings":";;;;;;AAAA,sEAA8C;AAiB9C;;GAEG;AACH,MAAa,oBAAqB,SAAQ,wBAA0B;IAgBlE;;;;;OAKG;IACH,YACE,WAA2B,EAC3B,SAMC;QAED,KAAK,CACH,SAAS,EACT,WAAW,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,UAAU,EAAE,EAAE;YACvC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,UAAU,CAAC,KAAK,CAAC;YAC1C,OAAO,KAAK,CAAC;QACf,CAAC,EAAE,EAAS,CAAC,CACd,CAAC;QArCI,gBAAW,GAAmB,EAAE,CAAC;QAUzC;;WAEG;QACH,SAAI,GAAG,sBAAsB,CAAC;QAyB5B,IAAI,CAAC,UAAU,EAAE,CAAC;QAClB,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;QAC/B,IAAI,CAAC,eAAe,GAAG,SAAS,CAAC;QACjC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC,UAAU,EAAE,EAAE;YACtC,MAAM,EAAE,IAAI,EAAE,GAAG,UAAU,CAAC;YAC5B,IAAK,UAAuC,CAAC,SAAS,KAAK,SAAS,EAAE;gBACnE,UAAuC,CAAC,SAAS,CAAC,CAAC,KAAK,EAAE,EAAE;oBAC3D,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC;gBACjC,CAAC,CAAC,CAAC;aACJ;iBAAM,IAAI,IAAI,CAAC,eAAe,EAAE;gBAC9B,IAAI,CAAC,eAAe,CAAC,SAAiB,CACrC,GAAG,IAAI,cAAc,EACrB,CAAC,KAAU,EAAE,EAAE;oBACb,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC;gBACjC,CAAC,CACF,CAAC;aACH;iBAAM;gBACL,MAAM,IAAI,KAAK,CACb,wEAAwE,CACzE,CAAC;aACH;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;;;;;OAMG;IACH,IAAI,SAAS;QACX,IAAI,SAAS,GAAG,EAAE,CAAC;QACnB,KAAK,MAAM,UAAU,IAAI,IAAI,CAAC,WAAW,EAAE;YACzC,SAAS,mCAAQ,SAAS,GAAK,UAAU,CAAC,KAAK,CAAE,CAAC;SACnD;QACD,OAAO,SAAS,CAAC;IACnB,CAAC;CACF;AA7ED,oDA6EC;AAED,kBAAe,oBAAoB,CAAC","sourcesContent":["import BaseController from './BaseController';\nimport { RestrictedControllerMessenger } from './ControllerMessenger';\n\n/**\n * List of child controller instances\n *\n * This type encompasses controllers based up either BaseController or\n * BaseControllerV2. The BaseControllerV2 type can't be included directly\n * because the generic parameters it expects require knowing the exact state\n * shape, so instead we look for an object with the BaseControllerV2 properties\n * that we use in the ComposableController (name and state).\n */\nexport type ControllerList = (\n  | BaseController<any, any>\n  | { name: string; state: Record<string, unknown> }\n)[];\n\n/**\n * Controller that can be used to compose multiple controllers together\n */\nexport class ComposableController extends BaseController<never, any> {\n  private controllers: ControllerList = [];\n\n  private messagingSystem?: RestrictedControllerMessenger<\n    'ComposableController',\n    never,\n    any,\n    never,\n    any\n  >;\n\n  /**\n   * Name of this controller used during composition\n   */\n  name = 'ComposableController';\n\n  /**\n   * Creates a ComposableController instance\n   *\n   * @param controllers - Map of names to controller instances\n   * @param messenger - The controller messaging system, used for communicating with BaseControllerV2 controllers\n   */\n  constructor(\n    controllers: ControllerList,\n    messenger?: RestrictedControllerMessenger<\n      'ComposableController',\n      never,\n      any,\n      never,\n      any\n    >,\n  ) {\n    super(\n      undefined,\n      controllers.reduce((state, controller) => {\n        state[controller.name] = controller.state;\n        return state;\n      }, {} as any),\n    );\n    this.initialize();\n    this.controllers = controllers;\n    this.messagingSystem = messenger;\n    this.controllers.forEach((controller) => {\n      const { name } = controller;\n      if ((controller as BaseController<any, any>).subscribe !== undefined) {\n        (controller as BaseController<any, any>).subscribe((state) => {\n          this.update({ [name]: state });\n        });\n      } else if (this.messagingSystem) {\n        (this.messagingSystem.subscribe as any)(\n          `${name}:stateChange`,\n          (state: any) => {\n            this.update({ [name]: state });\n          },\n        );\n      } else {\n        throw new Error(\n          `Messaging system required if any BaseControllerV2 controllers are used`,\n        );\n      }\n    });\n  }\n\n  /**\n   * Flat state representation, one that isn't keyed\n   * of controller name. Instead, all child controller state is merged\n   * together into a single, flat object.\n   *\n   * @returns - Merged state representation of all child controllers\n   */\n  get flatState() {\n    let flatState = {};\n    for (const controller of this.controllers) {\n      flatState = { ...flatState, ...controller.state };\n    }\n    return flatState;\n  }\n}\n\nexport default ComposableController;\n"]}