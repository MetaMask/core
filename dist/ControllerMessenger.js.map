{"version":3,"file":"ControllerMessenger.js","sourceRoot":"","sources":["../src/ControllerMessenger.ts"],"names":[],"mappings":";;;AAsEA;;;;;;;;;;;;;GAaG;AACH,MAAa,6BAA6B;IAkBxC;;;;;;;;;;;;;;;;;OAiBG;IACH,YAAY,EACV,mBAAmB,EACnB,IAAI,EACJ,cAAc,EACd,aAAa,GAMd;QACC,IAAI,CAAC,mBAAmB,GAAG,mBAAmB,CAAC;QAC/C,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;QAC3B,IAAI,CAAC,cAAc,GAAG,cAAc,IAAI,IAAI,CAAC;QAC7C,IAAI,CAAC,aAAa,GAAG,aAAa,IAAI,IAAI,CAAC;IAC7C,CAAC;IAED;;;;;;;;;;;;OAYG;IACH,qBAAqB,CACnB,MAAS,EACT,OAAiC;QAEjC,wBAAwB,CAAC,sCAAsC;QAC/D,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC,cAAc,GAAG,CAAC,EAAE;YACjD,MAAM,IAAI,KAAK,CACb,yDAAyD,IAAI,CAAC,cAAc,IAAI,CACjF,CAAC;SACH;QACD,IAAI,CAAC,mBAAmB,CAAC,qBAAqB,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;IAClE,CAAC;IAED;;;;;;;;;OASG;IACH,uBAAuB,CAA0C,MAAS;QACxE,wBAAwB,CAAC,sCAAsC;QAC/D,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC,cAAc,GAAG,CAAC,EAAE;YACjD,MAAM,IAAI,KAAK,CACb,2DAA2D,IAAI,CAAC,cAAc,IAAI,CACnF,CAAC;SACH;QACD,IAAI,CAAC,mBAAmB,CAAC,uBAAuB,CAAC,MAAM,CAAC,CAAC;IAC3D,CAAC;IAED;;;;;;;;;;;;;;OAcG;IACH,IAAI,CACF,MAAS,EACT,GAAG,MAA0C;QAE7C,0BAA0B,CAAC,wCAAwC;QACnE,IAAI,IAAI,CAAC,cAAc,KAAK,IAAI,EAAE;YAChC,MAAM,IAAI,KAAK,CAAC,oBAAoB,CAAC,CAAC;SACvC;aAAM,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE;YAChD,MAAM,IAAI,KAAK,CAAC,mCAAmC,MAAM,EAAE,CAAC,CAAC;SAC9D;QACD,OAAO,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,MAAM,CAAC,CAAC;IAC1D,CAAC;IAED;;;;;;;;;;;OAWG;IACH,OAAO,CACL,KAAQ,EACR,GAAG,OAAsC;QAEzC,wBAAwB,CAAC,sCAAsC;QAC/D,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC,cAAc,GAAG,CAAC,EAAE;YAChD,MAAM,IAAI,KAAK,CACb,+CAA+C,IAAI,CAAC,cAAc,IAAI,CACvE,CAAC;SACH;QACD,IAAI,CAAC,mBAAmB,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,OAAO,CAAC,CAAC;IACtD,CAAC;IA4CD,SAAS,CACP,KAAQ,EACR,OAAsC,EACtC,QAA6D;QAE7D,0BAA0B,CAAC,wCAAwC;QACnE,IAAI,IAAI,CAAC,aAAa,KAAK,IAAI,EAAE;YAC/B,MAAM,IAAI,KAAK,CAAC,mBAAmB,CAAC,CAAC;SACtC;aAAM,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE;YAC9C,MAAM,IAAI,KAAK,CAAC,kCAAkC,KAAK,EAAE,CAAC,CAAC;SAC5D;QAED,IAAI,QAAQ,EAAE;YACZ,OAAO,IAAI,CAAC,mBAAmB,CAAC,SAAS,CAAC,KAAK,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;SACrE;QACD,OAAO,IAAI,CAAC,mBAAmB,CAAC,SAAS,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;IAC5D,CAAC;IAED;;;;;;;;;;;OAWG;IACH,WAAW,CACT,KAAQ,EACR,OAAsC;QAEtC,0BAA0B,CAAC,wCAAwC;QACnE,IAAI,IAAI,CAAC,aAAa,KAAK,IAAI,EAAE;YAC/B,MAAM,IAAI,KAAK,CAAC,mBAAmB,CAAC,CAAC;SACtC;aAAM,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE;YAC9C,MAAM,IAAI,KAAK,CAAC,kCAAkC,KAAK,EAAE,CAAC,CAAC;SAC5D;QACD,IAAI,CAAC,mBAAmB,CAAC,WAAW,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;IACvD,CAAC;IAED;;;;;;;;;OASG;IACH,uBAAuB,CAAyC,KAAQ;QACtE,wBAAwB,CAAC,sCAAsC;QAC/D,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC,cAAc,GAAG,CAAC,EAAE;YAChD,MAAM,IAAI,KAAK,CACb,6CAA6C,IAAI,CAAC,cAAc,IAAI,CACrE,CAAC;SACH;QACD,IAAI,CAAC,mBAAmB,CAAC,uBAAuB,CAAC,KAAK,CAAC,CAAC;IAC1D,CAAC;CACF;AAhQD,sEAgQC;AAED;;;;;;;;;GASG;AACH,MAAa,mBAAmB;IAAhC;QAIU,YAAO,GAAG,IAAI,GAAG,EAA2B,CAAC;QAE7C,WAAM,GAAG,IAAI,GAAG,EAAuC,CAAC;QAEhE;;WAEG;QACK,sBAAiB,GAAG,IAAI,GAAG,EAGhC,CAAC;IAoQN,CAAC;IAlQC;;;;;;;;;;OAUG;IACH,qBAAqB,CACnB,UAAa,EACb,OAAiC;QAEjC,IAAI,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE;YAChC,MAAM,IAAI,KAAK,CACb,iBAAiB,UAAU,8BAA8B,CAC1D,CAAC;SACH;QACD,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;IACxC,CAAC;IAED;;;;;;;OAOG;IACH,uBAAuB,CAA2B,UAAa;QAC7D,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;IAClC,CAAC;IAED;;;;OAIG;IACH,YAAY;QACV,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC;IACvB,CAAC;IAED;;;;;;;;;;;;OAYG;IACH,IAAI,CACF,UAAa,EACb,GAAG,MAA0C;QAE7C,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,UAAU,CAA6B,CAAC;QACzE,IAAI,CAAC,OAAO,EAAE;YACZ,MAAM,IAAI,KAAK,CAAC,iBAAiB,UAAU,0BAA0B,CAAC,CAAC;SACxE;QACD,OAAO,OAAO,CAAC,GAAG,MAAM,CAAC,CAAC;IAC5B,CAAC;IAED;;;;;;;;;OASG;IACH,OAAO,CACL,SAAY,EACZ,GAAG,OAAsC;QAEzC,MAAM,WAAW,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;QAE/C,IAAI,WAAW,EAAE;YACf,KAAK,MAAM,CAAC,OAAO,EAAE,QAAQ,CAAC,IAAI,WAAW,CAAC,OAAO,EAAE,EAAE;gBACvD,IAAI,QAAQ,EAAE;oBACZ,MAAM,aAAa,GAAG,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;oBAC1D,MAAM,QAAQ,GAAG,QAAQ,CAAC,GAAG,OAAO,CAAC,CAAC;oBAEtC,IAAI,QAAQ,KAAK,aAAa,EAAE;wBAC9B,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;wBAC9C,OAAO,CAAC,QAAQ,EAAE,aAAa,CAAC,CAAC;qBAClC;iBACF;qBAAM;oBACJ,OAA+B,CAAC,GAAG,OAAO,CAAC,CAAC;iBAC9C;aACF;SACF;IACH,CAAC;IAwCD,SAAS,CACP,SAAY,EACZ,OAAsC,EACtC,QAA6D;QAE7D,IAAI,WAAW,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;QAC7C,IAAI,CAAC,WAAW,EAAE;YAChB,WAAW,GAAG,IAAI,GAAG,EAAE,CAAC;YACxB,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC;SACzC;QAED,WAAW,CAAC,GAAG,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;IACrC,CAAC;IAED;;;;;;;;;OASG;IACH,WAAW,CACT,SAAY,EACZ,OAAsC;QAEtC,MAAM,WAAW,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;QAE/C,IAAI,CAAC,WAAW,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE;YAC7C,MAAM,IAAI,KAAK,CAAC,qCAAqC,SAAS,EAAE,CAAC,CAAC;SACnE;QAED,MAAM,QAAQ,GAAG,WAAW,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;QAC1C,IAAI,QAAQ,EAAE;YACZ,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;SACxC;QAED,WAAW,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;IAC9B,CAAC;IAED;;;;;;;OAOG;IACH,uBAAuB,CAA0B,SAAY;QAC3D,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;IAChC,CAAC;IAED;;;;OAIG;IACH,kBAAkB;QAChB,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC;IACtB,CAAC;IAED;;;;;;;;;;;;;;;;;;;;;;;OAuBG;IACH,aAAa,CAIX,EACA,IAAI,EACJ,cAAc,EACd,aAAa,GAKd;QAOC,OAAO,IAAI,6BAA6B,CAMtC;YACA,mBAAmB,EAAE,IAAI;YACzB,IAAI;YACJ,cAAc;YACd,aAAa;SACd,CAAC,CAAC;IACL,CAAC;CACF;AAlRD,kDAkRC","sourcesContent":["type ActionHandler<Action, ActionType> = (\n  ...args: ExtractActionParameters<Action, ActionType>\n) => ExtractActionResponse<Action, ActionType>;\ntype ExtractActionParameters<Action, T> = Action extends {\n  type: T;\n  handler: (...args: infer H) => any;\n}\n  ? H\n  : never;\ntype ExtractActionResponse<Action, T> = Action extends {\n  type: T;\n  handler: (...args: any) => infer H;\n}\n  ? H\n  : never;\n\ntype ExtractEventHandler<Event, T> = Event extends { type: T; payload: infer P }\n  ? P extends unknown[]\n    ? (...payload: P) => void\n    : never\n  : never;\ntype ExtractEventPayload<Event, T> = Event extends { type: T; payload: infer P }\n  ? P\n  : never;\n\ntype GenericEventHandler = (...args: unknown[]) => void;\n\ntype SelectorFunction<Args extends unknown[], ReturnValue> = (\n  ...args: Args\n) => ReturnValue;\ntype SelectorEventHandler<SelectorReturnValue> = (\n  newValue: SelectorReturnValue,\n  previousValue: SelectorReturnValue | undefined,\n) => void;\n\nexport type ActionConstraint = {\n  type: string;\n  handler: (...args: any) => unknown;\n};\nexport type EventConstraint = { type: string; payload: unknown[] };\n\ntype EventSubscriptionMap = Map<\n  GenericEventHandler | SelectorEventHandler<unknown>,\n  SelectorFunction<any, unknown> | undefined\n>;\n\n/**\n * A namespaced string\n *\n * This type verifies that the string T is prefixed by the string Name followed by a colon.\n *\n * @template Name - The namespace we're checking for.\n * @template T - The full string, including the namespace.\n */\nexport type Namespaced<Name extends string, T> = T extends `${Name}:${string}`\n  ? T\n  : never;\n\ntype NarrowToNamespace<T, Namespace extends string> = T extends {\n  type: `${Namespace}:${string}`;\n}\n  ? T\n  : never;\n\ntype NarrowToAllowed<T, Allowed extends string> = T extends {\n  type: Allowed;\n}\n  ? T\n  : never;\n\n/**\n * A restricted controller messenger.\n *\n * This acts as a wrapper around the controller messenger instance that restricts access to actions\n * and events.\n *\n * @template N - The namespace for this messenger. Typically this is the name of the controller or\n * module that this messenger has been created for. The authority to publish events and register\n * actions under this namespace is granted to this restricted messenger instance.\n * @template Action - A type union of all Action types.\n * @template Event - A type union of all Event types.\n * @template AllowedAction - A type union of the 'type' string for any allowed actions.\n * @template AllowedEvent - A type union of the 'type' string for any allowed events.\n */\nexport class RestrictedControllerMessenger<\n  N extends string,\n  Action extends ActionConstraint,\n  Event extends EventConstraint,\n  AllowedAction extends string,\n  AllowedEvent extends string,\n> {\n  private controllerMessenger: ControllerMessenger<\n    ActionConstraint,\n    EventConstraint\n  >;\n\n  private controllerName: N;\n\n  private allowedActions: AllowedAction[] | null;\n\n  private allowedEvents: AllowedEvent[] | null;\n\n  /**\n   * Constructs a restricted controller messenger\n   *\n   * The provided allowlists grant the ability to call the listed actions and subscribe to the\n   * listed events. The \"name\" provided grants ownership of any actions and events under that\n   * namespace. Ownership allows registering actions and publishing events, as well as\n   * unregistering actions and clearing event subscriptions.\n   *\n   * @param options - The controller options.\n   * @param options.controllerMessenger - The controller messenger instance that is being wrapped.\n   * @param options.name - The name of the thing this messenger will be handed to (e.g. the\n   * controller name). This grants \"ownership\" of actions and events under this namespace to the\n   * restricted controller messenger returned.\n   * @param options.allowedActions - The list of actions that this restricted controller messenger\n   * should be alowed to call.\n   * @param options.allowedEvents - The list of events that this restricted controller messenger\n   * should be allowed to subscribe to.\n   */\n  constructor({\n    controllerMessenger,\n    name,\n    allowedActions,\n    allowedEvents,\n  }: {\n    controllerMessenger: ControllerMessenger<ActionConstraint, EventConstraint>;\n    name: N;\n    allowedActions?: AllowedAction[];\n    allowedEvents?: AllowedEvent[];\n  }) {\n    this.controllerMessenger = controllerMessenger;\n    this.controllerName = name;\n    this.allowedActions = allowedActions || null;\n    this.allowedEvents = allowedEvents || null;\n  }\n\n  /**\n   * Register an action handler.\n   *\n   * This will make the registered function available to call via the `call` method.\n   *\n   * The action type this handler is registered under *must* be in the current namespace.\n   *\n   * @param action - The action type. This is a unqiue identifier for this action.\n   * @param handler - The action handler. This function gets called when the `call` method is\n   * invoked with the given action type.\n   * @throws Will throw when a handler has been registered for this action type already.\n   * @template T - A type union of Action type strings that are namespaced by N.\n   */\n  registerActionHandler<T extends Namespaced<N, Action['type']>>(\n    action: T,\n    handler: ActionHandler<Action, T>,\n  ) {\n    /* istanbul ignore if */ // Branch unreachable with valid types\n    if (!action.startsWith(`${this.controllerName}:`)) {\n      throw new Error(\n        `Only allowed registering action handlers prefixed by '${this.controllerName}:'`,\n      );\n    }\n    this.controllerMessenger.registerActionHandler(action, handler);\n  }\n\n  /**\n   * Unregister an action handler.\n   *\n   * This will prevent this action from being called.\n   *\n   * The action type being unregistered *must* be in the current namespace.\n   *\n   * @param action - The action type. This is a unqiue identifier for this action.\n   * @template T - A type union of Action type strings that are namespaced by N.\n   */\n  unregisterActionHandler<T extends Namespaced<N, Action['type']>>(action: T) {\n    /* istanbul ignore if */ // Branch unreachable with valid types\n    if (!action.startsWith(`${this.controllerName}:`)) {\n      throw new Error(\n        `Only allowed unregistering action handlers prefixed by '${this.controllerName}:'`,\n      );\n    }\n    this.controllerMessenger.unregisterActionHandler(action);\n  }\n\n  /**\n   * Call an action.\n   *\n   * This function will call the action handler corresponding to the given action type, passing\n   * along any parameters given.\n   *\n   * The action type being called must be on the action allowlist.\n   *\n   * @param action - The action type. This is a unqiue identifier for this action.\n   * @param params - The action parameters. These must match the type of the parameters of the\n   * registered action handler.\n   * @throws Will throw when no handler has been registered for the given type.\n   * @template T - A type union of allowed Action type strings.\n   * @returns The action return value.\n   */\n  call<T extends AllowedAction & string>(\n    action: T,\n    ...params: ExtractActionParameters<Action, T>\n  ): ExtractActionResponse<Action, T> {\n    /* istanbul ignore next */ // Branches unreachable with valid types\n    if (this.allowedActions === null) {\n      throw new Error('No actions allowed');\n    } else if (!this.allowedActions.includes(action)) {\n      throw new Error(`Action missing from allow list: ${action}`);\n    }\n    return this.controllerMessenger.call(action, ...params);\n  }\n\n  /**\n   * Publish an event.\n   *\n   * Publishes the given payload to all subscribers of the given event type.\n   *\n   * The event type being published *must* be in the current namespace.\n   *\n   * @param event - The event type. This is a unique identifier for this event.\n   * @param payload - The event payload. The type of the parameters for each event handler must\n   * match the type of this payload.\n   * @template E - A type union of Event type strings that are namespaced by N.\n   */\n  publish<E extends Namespaced<N, Event['type']>>(\n    event: E,\n    ...payload: ExtractEventPayload<Event, E>\n  ) {\n    /* istanbul ignore if */ // Branch unreachable with valid types\n    if (!event.startsWith(`${this.controllerName}:`)) {\n      throw new Error(\n        `Only allowed publishing events prefixed by '${this.controllerName}:'`,\n      );\n    }\n    this.controllerMessenger.publish(event, ...payload);\n  }\n\n  /**\n   * Subscribe to an event.\n   *\n   * Registers the given function as an event handler for the given event type.\n   *\n   * The event type being subscribed to must be on the event allowlist.\n   *\n   * @param eventType - The event type. This is a unique identifier for this event.\n   * @param handler - The event handler. The type of the parameters for this event handler must\n   * match the type of the payload for this event type.\n   * @template E - A type union of Event type strings.\n   */\n  subscribe<E extends AllowedEvent & string>(\n    eventType: E,\n    handler: ExtractEventHandler<Event, E>,\n  ): void;\n\n  /**\n   * Subscribe to an event, with a selector.\n   *\n   * Registers the given handler function as an event handler for the given\n   * event type. When an event is published, its payload is first passed to the\n   * selector. The event handler is only called if the selector's return value\n   * differs from its last known return value.\n   *\n   * The event type being subscribed to must be on the event allowlist.\n   *\n   * @param eventType - The event type. This is a unique identifier for this event.\n   * @param handler - The event handler. The type of the parameters for this event\n   * handler must match the return type of the selector.\n   * @param selector - The selector function used to select relevant data from\n   * the event payload. The type of the parameters for this selector must match\n   * the type of the payload for this event type.\n   * @template E - A type union of Event type strings.\n   * @template V - The selector return value.\n   */\n  subscribe<E extends AllowedEvent & string, V>(\n    eventType: E,\n    handler: SelectorEventHandler<V>,\n    selector: SelectorFunction<ExtractEventPayload<Event, E>, V>,\n  ): void;\n\n  subscribe<E extends AllowedEvent & string, V>(\n    event: E,\n    handler: ExtractEventHandler<Event, E>,\n    selector?: SelectorFunction<ExtractEventPayload<Event, E>, V>,\n  ) {\n    /* istanbul ignore next */ // Branches unreachable with valid types\n    if (this.allowedEvents === null) {\n      throw new Error('No events allowed');\n    } else if (!this.allowedEvents.includes(event)) {\n      throw new Error(`Event missing from allow list: ${event}`);\n    }\n\n    if (selector) {\n      return this.controllerMessenger.subscribe(event, handler, selector);\n    }\n    return this.controllerMessenger.subscribe(event, handler);\n  }\n\n  /**\n   * Unsubscribe from an event.\n   *\n   * Unregisters the given function as an event handler for the given event.\n   *\n   * The event type being unsubscribed to must be on the event allowlist.\n   *\n   * @param event - The event type. This is a unique identifier for this event.\n   * @param handler - The event handler to unregister.\n   * @throws Will throw when the given event handler is not registered for this event.\n   * @template T - A type union of allowed Event type strings.\n   */\n  unsubscribe<E extends AllowedEvent & string>(\n    event: E,\n    handler: ExtractEventHandler<Event, E>,\n  ) {\n    /* istanbul ignore next */ // Branches unreachable with valid types\n    if (this.allowedEvents === null) {\n      throw new Error('No events allowed');\n    } else if (!this.allowedEvents.includes(event)) {\n      throw new Error(`Event missing from allow list: ${event}`);\n    }\n    this.controllerMessenger.unsubscribe(event, handler);\n  }\n\n  /**\n   * Clear subscriptions for a specific event.\n   *\n   * This will remove all subscribed handlers for this event.\n   *\n   * The event type being cleared *must* be in the current namespace.\n   *\n   * @param event - The event type. This is a unique identifier for this event.\n   * @template E - A type union of Event type strings that are namespaced by N.\n   */\n  clearEventSubscriptions<E extends Namespaced<N, Event['type']>>(event: E) {\n    /* istanbul ignore if */ // Branch unreachable with valid types\n    if (!event.startsWith(`${this.controllerName}:`)) {\n      throw new Error(\n        `Only allowed clearing events prefixed by '${this.controllerName}:'`,\n      );\n    }\n    this.controllerMessenger.clearEventSubscriptions(event);\n  }\n}\n\n/**\n * A messaging system for controllers.\n *\n * The controller messenger allows registering functions as 'actions' that can be called elsewhere,\n * and it allows publishing and subscribing to events. Both actions and events are identified by\n * unique strings.\n *\n * @template Action - A type union of all Action types.\n * @template Event - A type union of all Event types.\n */\nexport class ControllerMessenger<\n  Action extends ActionConstraint,\n  Event extends EventConstraint,\n> {\n  private actions = new Map<Action['type'], unknown>();\n\n  private events = new Map<Event['type'], EventSubscriptionMap>();\n\n  /**\n   * A cache of selector return values for their respective handlers.\n   */\n  private eventPayloadCache = new Map<\n    GenericEventHandler,\n    unknown | undefined\n  >();\n\n  /**\n   * Register an action handler.\n   *\n   * This will make the registered function available to call via the `call` method.\n   *\n   * @param actionType - The action type. This is a unqiue identifier for this action.\n   * @param handler - The action handler. This function gets called when the `call` method is\n   * invoked with the given action type.\n   * @throws Will throw when a handler has been registered for this action type already.\n   * @template T - A type union of Action type strings.\n   */\n  registerActionHandler<T extends Action['type']>(\n    actionType: T,\n    handler: ActionHandler<Action, T>,\n  ) {\n    if (this.actions.has(actionType)) {\n      throw new Error(\n        `A handler for ${actionType} has already been registered`,\n      );\n    }\n    this.actions.set(actionType, handler);\n  }\n\n  /**\n   * Unregister an action handler.\n   *\n   * This will prevent this action from being called.\n   *\n   * @param actionType - The action type. This is a unqiue identifier for this action.\n   * @template T - A type union of Action type strings.\n   */\n  unregisterActionHandler<T extends Action['type']>(actionType: T) {\n    this.actions.delete(actionType);\n  }\n\n  /**\n   * Unregister all action handlers.\n   *\n   * This prevents all actions from being called.\n   */\n  clearActions() {\n    this.actions.clear();\n  }\n\n  /**\n   * Call an action.\n   *\n   * This function will call the action handler corresponding to the given action type, passing\n   * along any parameters given.\n   *\n   * @param actionType - The action type. This is a unqiue identifier for this action.\n   * @param params - The action parameters. These must match the type of the parameters of the\n   * registered action handler.\n   * @throws Will throw when no handler has been registered for the given type.\n   * @template T - A type union of Action type strings.\n   * @returns The action return value.\n   */\n  call<T extends Action['type']>(\n    actionType: T,\n    ...params: ExtractActionParameters<Action, T>\n  ): ExtractActionResponse<Action, T> {\n    const handler = this.actions.get(actionType) as ActionHandler<Action, T>;\n    if (!handler) {\n      throw new Error(`A handler for ${actionType} has not been registered`);\n    }\n    return handler(...params);\n  }\n\n  /**\n   * Publish an event.\n   *\n   * Publishes the given payload to all subscribers of the given event type.\n   *\n   * @param eventType - The event type. This is a unique identifier for this event.\n   * @param payload - The event payload. The type of the parameters for each event handler must\n   * match the type of this payload.\n   * @template E - A type union of Event type strings.\n   */\n  publish<E extends Event['type']>(\n    eventType: E,\n    ...payload: ExtractEventPayload<Event, E>\n  ) {\n    const subscribers = this.events.get(eventType);\n\n    if (subscribers) {\n      for (const [handler, selector] of subscribers.entries()) {\n        if (selector) {\n          const previousValue = this.eventPayloadCache.get(handler);\n          const newValue = selector(...payload);\n\n          if (newValue !== previousValue) {\n            this.eventPayloadCache.set(handler, newValue);\n            handler(newValue, previousValue);\n          }\n        } else {\n          (handler as GenericEventHandler)(...payload);\n        }\n      }\n    }\n  }\n\n  /**\n   * Subscribe to an event.\n   *\n   * Registers the given function as an event handler for the given event type.\n   *\n   * @param eventType - The event type. This is a unique identifier for this event.\n   * @param handler - The event handler. The type of the parameters for this event handler must\n   * match the type of the payload for this event type.\n   * @template E - A type union of Event type strings.\n   */\n  subscribe<E extends Event['type']>(\n    eventType: E,\n    handler: ExtractEventHandler<Event, E>,\n  ): void;\n\n  /**\n   * Subscribe to an event, with a selector.\n   *\n   * Registers the given handler function as an event handler for the given\n   * event type. When an event is published, its payload is first passed to the\n   * selector. The event handler is only called if the selector's return value\n   * differs from its last known return value.\n   *\n   * @param eventType - The event type. This is a unique identifier for this event.\n   * @param handler - The event handler. The type of the parameters for this event\n   * handler must match the return type of the selector.\n   * @param selector - The selector function used to select relevant data from\n   * the event payload. The type of the parameters for this selector must match\n   * the type of the payload for this event type.\n   * @template E - A type union of Event type strings.\n   * @template V - The selector return value.\n   */\n  subscribe<E extends Event['type'], V>(\n    eventType: E,\n    handler: SelectorEventHandler<V>,\n    selector: SelectorFunction<ExtractEventPayload<Event, E>, V>,\n  ): void;\n\n  subscribe<E extends Event['type'], V>(\n    eventType: E,\n    handler: ExtractEventHandler<Event, E>,\n    selector?: SelectorFunction<ExtractEventPayload<Event, E>, V>,\n  ): void {\n    let subscribers = this.events.get(eventType);\n    if (!subscribers) {\n      subscribers = new Map();\n      this.events.set(eventType, subscribers);\n    }\n\n    subscribers.set(handler, selector);\n  }\n\n  /**\n   * Unsubscribe from an event.\n   *\n   * Unregisters the given function as an event handler for the given event.\n   *\n   * @param eventType - The event type. This is a unique identifier for this event.\n   * @param handler - The event handler to unregister.\n   * @throws Will throw when the given event handler is not registered for this event.\n   * @template E - A type union of Event type strings.\n   */\n  unsubscribe<E extends Event['type']>(\n    eventType: E,\n    handler: ExtractEventHandler<Event, E>,\n  ) {\n    const subscribers = this.events.get(eventType);\n\n    if (!subscribers || !subscribers.has(handler)) {\n      throw new Error(`Subscription not found for event: ${eventType}`);\n    }\n\n    const selector = subscribers.get(handler);\n    if (selector) {\n      this.eventPayloadCache.delete(handler);\n    }\n\n    subscribers.delete(handler);\n  }\n\n  /**\n   * Clear subscriptions for a specific event.\n   *\n   * This will remove all subscribed handlers for this event.\n   *\n   * @param eventType - The event type. This is a unique identifier for this event.\n   * @template E - A type union of Event type strings.\n   */\n  clearEventSubscriptions<E extends Event['type']>(eventType: E) {\n    this.events.delete(eventType);\n  }\n\n  /**\n   * Clear all subscriptions.\n   *\n   * This will remove all subscribed handlers for all events.\n   */\n  clearSubscriptions() {\n    this.events.clear();\n  }\n\n  /**\n   * Get a restricted controller messenger\n   *\n   * Returns a wrapper around the controller messenger instance that restricts access to actions\n   * and events. The provided allowlists grant the ability to call the listed actions and subscribe\n   * to the listed events. The \"name\" provided grants ownership of any actions and events under\n   * that namespace. Ownership allows registering actions and publishing events, as well as\n   * unregistering actions and clearing event subscriptions.\n   *\n   * @param options - Controller messenger options.\n   * @param options.name - The name of the thing this messenger will be handed to (e.g. the\n   * controller name). This grants \"ownership\" of actions and events under this namespace to the\n   * restricted controller messenger returned.\n   * @param options.allowedActions - The list of actions that this restricted controller messenger\n   * should be alowed to call.\n   * @param options.allowedEvents - The list of events that this restricted controller messenger\n   * should be allowed to subscribe to.\n   * @template N - The namespace for this messenger. Typically this is the name of the controller or\n   * module that this messenger has been created for. The authority to publish events and register\n   * actions under this namespace is granted to this restricted messenger instance.\n   * @template AllowedAction - A type union of the 'type' string for any allowed actions.\n   * @template AllowedEvent - A type union of the 'type' string for any allowed events.\n   * @returns The restricted controller messenger.\n   */\n  getRestricted<\n    N extends string,\n    AllowedAction extends string,\n    AllowedEvent extends string,\n  >({\n    name,\n    allowedActions,\n    allowedEvents,\n  }: {\n    name: N;\n    allowedActions?: Extract<Action['type'], AllowedAction>[];\n    allowedEvents?: Extract<Event['type'], AllowedEvent>[];\n  }): RestrictedControllerMessenger<\n    N,\n    NarrowToNamespace<Action, N> | NarrowToAllowed<Action, AllowedAction>,\n    NarrowToNamespace<Event, N> | NarrowToAllowed<Event, AllowedEvent>,\n    AllowedAction,\n    AllowedEvent\n  > {\n    return new RestrictedControllerMessenger<\n      N,\n      NarrowToNamespace<Action, N> | NarrowToAllowed<Action, AllowedAction>,\n      NarrowToNamespace<Event, N> | NarrowToAllowed<Event, AllowedEvent>,\n      AllowedAction,\n      AllowedEvent\n    >({\n      controllerMessenger: this,\n      name,\n      allowedActions,\n      allowedEvents,\n    });\n  }\n}\n"]}