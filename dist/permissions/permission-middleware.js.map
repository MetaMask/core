{"version":3,"file":"permission-middleware.js","sourceRoot":"","sources":["../../src/permissions/permission-middleware.ts"],"names":[],"mappings":";;;;;;;;;;;;AACA,qDAMyB;AAGzB,qCAAyC;AAezC;;;;;;;;;;;;;;;;;;;;;GAqBG;AACH,SAAgB,8BAA8B,CAAC,EAC7C,uBAAuB,EACvB,mBAAmB,EACnB,oBAAoB,GACe;IACnC,OAAO,SAAS,0BAA0B,CACxC,OAAkC;QAElC,MAAM,EAAE,MAAM,EAAE,GAAG,OAAO,CAAC;QAC3B,IAAI,OAAO,MAAM,KAAK,QAAQ,IAAI,CAAC,MAAM,EAAE;YACzC,MAAM,IAAI,KAAK,CAAC,kDAAkD,CAAC,CAAC;SACrE;QAED,MAAM,qBAAqB,GAAG,CAC5B,GAA+C,EAC/C,GAAiC,EACjC,IAAoC,EACrB,EAAE;YACjB,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,GAAG,GAAG,CAAC;YAE/B,wCAAwC;YACxC,IAAI,oBAAoB,CAAC,MAAM,CAAC,EAAE;gBAChC,OAAO,IAAI,EAAE,CAAC;aACf;YAED,mEAAmE;YACnE,MAAM,oBAAoB,GAAG,mBAAmB,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;YAEjE,oDAAoD;YACpD,MAAM,MAAM,GAAG,MAAM,uBAAuB,CAC1C,oBAAoB,EACpB,OAAO,EACP,MAAM,EACN,MAAM,CACP,CAAC;YAEF,IAAI,MAAM,KAAK,SAAS,EAAE;gBACxB,GAAG,CAAC,KAAK,GAAG,IAAA,sBAAa,EACvB,uBAAuB,GAAG,CAAC,MAAM,8BAA8B,EAC/D,EAAE,OAAO,EAAE,GAAG,EAAE,CACjB,CAAC;gBACF,OAAO,SAAS,CAAC;aAClB;YAED,GAAG,CAAC,MAAM,GAAG,MAAM,CAAC;YACpB,OAAO,SAAS,CAAC;QACnB,CAAC,CAAA,CAAC;QAEF,OAAO,IAAA,uCAAqB,EAAC,qBAAqB,CAAC,CAAC;IACtD,CAAC,CAAC;AACJ,CAAC;AAlDD,wEAkDC","sourcesContent":["import type { Json } from '@metamask/types';\nimport {\n  JsonRpcMiddleware,\n  AsyncJsonRpcEngineNextCallback,\n  createAsyncMiddleware,\n  PendingJsonRpcResponse,\n  JsonRpcRequest,\n} from 'json-rpc-engine';\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport type { JsonRpcEngine } from 'json-rpc-engine';\nimport { internalError } from './errors';\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport type { PermissionController } from './PermissionController';\nimport {\n  GenericPermissionController,\n  PermissionSubjectMetadata,\n  RestrictedMethodParameters,\n} from '.';\n\ntype PermissionMiddlewareFactoryOptions = {\n  executeRestrictedMethod: GenericPermissionController['_executeRestrictedMethod'];\n  getRestrictedMethod: GenericPermissionController['getRestrictedMethod'];\n  isUnrestrictedMethod: (method: string) => boolean;\n};\n\n/**\n * Creates a permission middleware function factory. Intended for internal use\n * in the {@link PermissionController}. Like any {@link JsonRpcEngine}\n * middleware, each middleware will only receive requests from a particular\n * subject / origin. However, each middleware also requires access to some\n * `PermissionController` internals, which is why this \"factory factory\" exists.\n *\n * The middlewares returned by the factory will pass through requests for\n * unrestricted methods, and attempt to execute restricted methods. If a method\n * is neither restricted nor unrestricted, a \"method not found\" error will be\n * returned.\n * If a method is restricted, the middleware will first attempt to retrieve the\n * subject's permission for that method. If the permission is found, the method\n * will be executed. Otherwise, an \"unauthorized\" error will be returned.\n *\n * @param options - Options bag.\n * @param options.executeRestrictedMethod - {@link PermissionController._executeRestrictedMethod}.\n * @param options.getRestrictedMethod - {@link PermissionController.getRestrictedMethod}.\n * @param options.isUnrestrictedMethod - A function that checks whether a\n * particular method is unrestricted.\n * @returns A permission middleware factory function.\n */\nexport function getPermissionMiddlewareFactory({\n  executeRestrictedMethod,\n  getRestrictedMethod,\n  isUnrestrictedMethod,\n}: PermissionMiddlewareFactoryOptions) {\n  return function createPermissionMiddleware(\n    subject: PermissionSubjectMetadata,\n  ): JsonRpcMiddleware<RestrictedMethodParameters, Json> {\n    const { origin } = subject;\n    if (typeof origin !== 'string' || !origin) {\n      throw new Error('The subject \"origin\" must be a non-empty string.');\n    }\n\n    const permissionsMiddleware = async (\n      req: JsonRpcRequest<RestrictedMethodParameters>,\n      res: PendingJsonRpcResponse<Json>,\n      next: AsyncJsonRpcEngineNextCallback,\n    ): Promise<void> => {\n      const { method, params } = req;\n\n      // Skip registered unrestricted methods.\n      if (isUnrestrictedMethod(method)) {\n        return next();\n      }\n\n      // This will throw if no restricted method implementation is found.\n      const methodImplementation = getRestrictedMethod(method, origin);\n\n      // This will throw if the permission does not exist.\n      const result = await executeRestrictedMethod(\n        methodImplementation,\n        subject,\n        method,\n        params,\n      );\n\n      if (result === undefined) {\n        res.error = internalError(\n          `Request for method \"${req.method}\" returned undefined result.`,\n          { request: req },\n        );\n        return undefined;\n      }\n\n      res.result = result;\n      return undefined;\n    };\n\n    return createAsyncMiddleware(permissionsMiddleware);\n  };\n}\n"]}