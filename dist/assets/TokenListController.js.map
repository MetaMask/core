{"version":3,"file":"TokenListController.js","sourceRoot":"","sources":["../../src/assets/TokenListController.ts"],"names":[],"mappings":"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","sourcesContent":["import contractMap from '@metamask/contract-metadata';\nimport type { Patch } from 'immer';\nimport { Mutex } from 'async-mutex';\n// eslint-disable-next-line import/no-named-as-default\nimport AbortController from 'abort-controller';\nimport { BaseController } from '../BaseControllerV2';\nimport type { RestrictedControllerMessenger } from '../ControllerMessenger';\nimport { safelyExecute } from '../util';\nimport { fetchTokenList, fetchTokenMetadata } from '../apis/token-service';\nimport { NetworkState } from '../network/NetworkController';\nimport { PreferencesState } from '../user/PreferencesController';\n\nconst DEFAULT_INTERVAL = 60 * 60 * 1000;\nconst DEFAULT_THRESHOLD = 60 * 30 * 1000;\n\nconst name = 'TokenListController';\n\ntype BaseToken = {\n  name: string;\n  symbol: string;\n  decimals: number;\n};\n\ntype StaticToken = {\n  logo: string;\n  erc20: boolean;\n} & BaseToken;\n\nexport type ContractMap = {\n  [address: string]: StaticToken;\n};\n\nexport type DynamicToken = {\n  address: string;\n  occurrences: number;\n  iconUrl: string;\n} & BaseToken;\n\nexport type TokenListToken = {\n  address: string;\n  iconUrl: string;\n  occurrences: number | null;\n} & BaseToken;\n\nexport type TokenListMap = {\n  [address: string]: TokenListToken;\n};\n\nexport type TokenListState = {\n  tokenList: TokenListMap;\n  tokensChainsCache: TokensChainsCache;\n};\n\nexport type TokenListStateChange = {\n  type: `${typeof name}:stateChange`;\n  payload: [TokenListState, Patch[]];\n};\n\nexport type GetTokenListState = {\n  type: `${typeof name}:getState`;\n  handler: () => TokenListState;\n};\ntype DataCache = {\n  timestamp: number;\n  data: TokenListToken[];\n};\ntype TokensChainsCache = {\n  [chainSlug: string]: DataCache;\n};\n\ntype TokenListMessenger = RestrictedControllerMessenger<\n  typeof name,\n  GetTokenListState,\n  TokenListStateChange,\n  never,\n  never\n>;\n\nconst metadata = {\n  tokenList: { persist: true, anonymous: true },\n  tokensChainsCache: { persist: true, anonymous: true },\n};\n\nconst defaultState: TokenListState = {\n  tokenList: {},\n  tokensChainsCache: {},\n};\n\n/**\n * Controller that passively polls on a set interval for the list of tokens from metaswaps api\n */\nexport class TokenListController extends BaseController<\n  typeof name,\n  TokenListState,\n  TokenListMessenger\n> {\n  private mutex = new Mutex();\n\n  private intervalId?: NodeJS.Timeout;\n\n  private intervalDelay: number;\n\n  private cacheRefreshThreshold: number;\n\n  private chainId: string;\n\n  private useStaticTokenList: boolean;\n\n  private abortController: AbortController;\n\n  // private abortSignal: AbortSignal;\n\n  /**\n   * Creates a TokenListController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.useStaticTokenList - Indicates whether to use the static token list or not.\n   * @param options.onNetworkStateChange - A function for registering an event handler for network state changes.\n   * @param options.onPreferencesStateChange -A function for registering an event handler for preference state changes.\n   * @param options.interval - The polling interval, in milliseconds.\n   * @param options.cacheRefreshThreshold - The token cache expiry time, in milliseconds.\n   * @param options.messenger - A restricted controller messenger.\n   * @param options.state - Initial state to set on this controller.\n   */\n  constructor({\n    chainId,\n    useStaticTokenList,\n    onNetworkStateChange,\n    onPreferencesStateChange,\n    interval = DEFAULT_INTERVAL,\n    cacheRefreshThreshold = DEFAULT_THRESHOLD,\n    messenger,\n    state,\n  }: {\n    chainId: string;\n    useStaticTokenList: boolean;\n    onNetworkStateChange: (\n      listener: (networkState: NetworkState) => void,\n    ) => void;\n    onPreferencesStateChange: (\n      listener: (preferencesState: PreferencesState) => void,\n    ) => void;\n    interval?: number;\n    cacheRefreshThreshold?: number;\n    messenger: TokenListMessenger;\n    state?: Partial<TokenListState>;\n  }) {\n    super({\n      name,\n      metadata,\n      messenger,\n      state: { ...defaultState, ...state },\n    });\n    this.intervalDelay = interval;\n    this.cacheRefreshThreshold = cacheRefreshThreshold;\n    this.chainId = chainId;\n    this.useStaticTokenList = useStaticTokenList;\n    this.abortController = new AbortController();\n    onNetworkStateChange(async (networkState) => {\n      if (this.chainId !== networkState.provider.chainId) {\n        this.abortController.abort();\n        this.abortController = new AbortController();\n        this.chainId = networkState.provider.chainId;\n        await this.restart();\n      }\n    });\n\n    onPreferencesStateChange(async (preferencesState) => {\n      if (this.useStaticTokenList !== preferencesState.useStaticTokenList) {\n        this.abortController.abort();\n        this.abortController = new AbortController();\n        this.useStaticTokenList = preferencesState.useStaticTokenList;\n        await this.restart();\n      }\n    });\n  }\n\n  /**\n   * Start polling for the token list.\n   */\n  async start() {\n    await this.startPolling();\n  }\n\n  /**\n   * Restart polling for the token list.\n   */\n  async restart() {\n    this.stopPolling();\n    await this.startPolling();\n  }\n\n  /**\n   * Stop polling for the token list.\n   */\n  stop() {\n    this.stopPolling();\n  }\n\n  /**\n   * Prepare to discard this controller.\n   *\n   * This stops any active polling.\n   */\n  destroy() {\n    super.destroy();\n    this.stopPolling();\n  }\n\n  private stopPolling() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n\n  /**\n   * Starts a new polling interval.\n   */\n  private async startPolling(): Promise<void> {\n    await safelyExecute(() => this.fetchTokenList());\n    this.intervalId = setInterval(async () => {\n      await safelyExecute(() => this.fetchTokenList());\n    }, this.intervalDelay);\n  }\n\n  /**\n   * Fetching token list.\n   */\n  async fetchTokenList(): Promise<void> {\n    if (this.useStaticTokenList) {\n      await this.fetchFromStaticTokenList();\n    } else {\n      await this.fetchFromDynamicTokenList();\n    }\n  }\n\n  /**\n   * Fetching token list from the contract-metadata as a fallback.\n   */\n  async fetchFromStaticTokenList(): Promise<void> {\n    const tokenList: TokenListMap = {};\n    for (const tokenAddress in contractMap) {\n      const { erc20, logo: filePath, ...token } = (contractMap as ContractMap)[\n        tokenAddress\n      ];\n      if (erc20) {\n        tokenList[tokenAddress] = {\n          ...token,\n          address: tokenAddress,\n          iconUrl: filePath,\n          occurrences: null,\n        };\n      }\n    }\n\n    this.update(() => {\n      return {\n        tokenList,\n        tokensChainsCache: {},\n      };\n    });\n  }\n\n  /**\n   * Fetching token list from the Token Service API.\n   */\n  async fetchFromDynamicTokenList(): Promise<void> {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      const cachedTokens: TokenListToken[] | null = await safelyExecute(() =>\n        this.fetchFromCache(),\n      );\n      const { tokensChainsCache, ...tokensData } = this.state;\n      const tokenList: TokenListMap = {};\n      if (cachedTokens) {\n        for (const token of cachedTokens) {\n          tokenList[token.address] = token;\n        }\n      } else {\n        const tokensFromAPI: DynamicToken[] = await safelyExecute(() =>\n          fetchTokenList(this.chainId, this.abortController.signal),\n        );\n        if (!tokensFromAPI) {\n          const backupTokenList = tokensChainsCache[this.chainId]\n            ? tokensChainsCache[this.chainId].data\n            : [];\n          for (const token of backupTokenList) {\n            tokenList[token.address] = token;\n          }\n\n          this.update(() => {\n            return {\n              ...tokensData,\n              tokenList,\n              tokensChainsCache,\n            };\n          });\n          return;\n        }\n        // filtering out tokens with less than 2 occurrences\n        const filteredTokenList = tokensFromAPI.filter(\n          (token) => token.occurrences && token.occurrences >= 2,\n        );\n        // removing the tokens with symbol conflicts\n        const symbolsList = filteredTokenList.map((token) => token.symbol);\n        const duplicateSymbols = [\n          ...new Set(\n            symbolsList.filter(\n              (symbol, index) => symbolsList.indexOf(symbol) !== index,\n            ),\n          ),\n        ];\n        const uniqueTokenList = filteredTokenList.filter(\n          (token) => !duplicateSymbols.includes(token.symbol),\n        );\n        for (const token of uniqueTokenList) {\n          tokenList[token.address] = token;\n        }\n      }\n      const updatedTokensChainsCache: TokensChainsCache = {\n        ...tokensChainsCache,\n        [this.chainId]: {\n          timestamp: Date.now(),\n          data: Object.values(tokenList),\n        },\n      };\n      this.update(() => {\n        return {\n          ...tokensData,\n          tokenList,\n          tokensChainsCache: updatedTokensChainsCache,\n        };\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Checks if the Cache timestamp is valid,\n   * if yes data in cache will be returned\n   * otherwise null will be returned.\n   *\n   * @returns The cached data, or `null` if the cache was expired.\n   */\n  async fetchFromCache(): Promise<TokenListToken[] | null> {\n    const { tokensChainsCache }: TokenListState = this.state;\n    const dataCache = tokensChainsCache[this.chainId];\n    const now = Date.now();\n    if (\n      dataCache?.data &&\n      now - dataCache?.timestamp < this.cacheRefreshThreshold\n    ) {\n      return dataCache.data;\n    }\n    return null;\n  }\n\n  /**\n   * Fetch metadata for a token.\n   *\n   * @param tokenAddress - The address of the token.\n   * @returns The token metadata.\n   */\n  async fetchTokenMetadata(tokenAddress: string): Promise<DynamicToken> {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      const token = (await fetchTokenMetadata(\n        this.chainId,\n        tokenAddress,\n        this.abortController.signal,\n      )) as DynamicToken;\n      return token;\n    } finally {\n      releaseLock();\n    }\n  }\n}\n\nexport default TokenListController;\n"]}