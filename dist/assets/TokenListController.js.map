{"version":3,"file":"TokenListController.js","sourceRoot":"","sources":["../../src/assets/TokenListController.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Patch } from 'immer';\nimport { Mutex } from 'async-mutex';\nimport { AbortController } from 'abort-controller';\nimport { BaseController } from '../BaseControllerV2';\nimport type { RestrictedControllerMessenger } from '../ControllerMessenger';\nimport { safelyExecute, isTokenListSupportedForNetwork } from '../util';\nimport { fetchTokenList } from '../apis/token-service';\nimport { NetworkState } from '../network/NetworkController';\nimport { formatAggregatorNames, formatIconUrlWithProxy } from './assetsUtil';\n\nconst DEFAULT_INTERVAL = 24 * 60 * 60 * 1000;\nconst DEFAULT_THRESHOLD = 24 * 60 * 60 * 1000;\n\nconst name = 'TokenListController';\n\nexport type TokenListToken = {\n  name: string;\n  symbol: string;\n  decimals: number;\n  address: string;\n  occurrences: number;\n  aggregators: string[];\n  iconUrl: string;\n};\n\nexport type TokenListMap = Record<string, TokenListToken>;\n\ntype DataCache = {\n  timestamp: number;\n  data: TokenListMap;\n};\ntype TokensChainsCache = {\n  [chainSlug: string]: DataCache;\n};\n\nexport type TokenListState = {\n  tokenList: TokenListMap;\n  tokensChainsCache: TokensChainsCache;\n  preventPollingOnNetworkRestart: boolean;\n};\n\nexport type TokenListStateChange = {\n  type: `${typeof name}:stateChange`;\n  payload: [TokenListState, Patch[]];\n};\n\nexport type GetTokenListState = {\n  type: `${typeof name}:getState`;\n  handler: () => TokenListState;\n};\n\ntype TokenListMessenger = RestrictedControllerMessenger<\n  typeof name,\n  GetTokenListState,\n  TokenListStateChange,\n  never,\n  TokenListStateChange['type']\n>;\n\nconst metadata = {\n  tokenList: { persist: true, anonymous: true },\n  tokensChainsCache: { persist: true, anonymous: true },\n  preventPollingOnNetworkRestart: { persist: true, anonymous: true },\n};\n\nconst defaultState: TokenListState = {\n  tokenList: {},\n  tokensChainsCache: {},\n  preventPollingOnNetworkRestart: false,\n};\n\n/**\n * Controller that passively polls on a set interval for the list of tokens from metaswaps api\n */\nexport class TokenListController extends BaseController<\n  typeof name,\n  TokenListState,\n  TokenListMessenger\n> {\n  private mutex = new Mutex();\n\n  private intervalId?: NodeJS.Timeout;\n\n  private intervalDelay: number;\n\n  private cacheRefreshThreshold: number;\n\n  private chainId: string;\n\n  private abortController: AbortController;\n\n  /**\n   * Creates a TokenListController instance.\n   *\n   * @param options - The controller options.\n   * @param options.chainId - The chain ID of the current network.\n   * @param options.onNetworkStateChange - A function for registering an event handler for network state changes.\n   * @param options.interval - The polling interval, in milliseconds.\n   * @param options.cacheRefreshThreshold - The token cache expiry time, in milliseconds.\n   * @param options.messenger - A restricted controller messenger.\n   * @param options.state - Initial state to set on this controller.\n   * @param options.preventPollingOnNetworkRestart - Determines whether to prevent poilling on network restart in extension.\n   */\n  constructor({\n    chainId,\n    preventPollingOnNetworkRestart = false,\n    onNetworkStateChange,\n    interval = DEFAULT_INTERVAL,\n    cacheRefreshThreshold = DEFAULT_THRESHOLD,\n    messenger,\n    state,\n  }: {\n    chainId: string;\n    preventPollingOnNetworkRestart?: boolean;\n    onNetworkStateChange: (\n      listener: (networkState: NetworkState) => void,\n    ) => void;\n    interval?: number;\n    cacheRefreshThreshold?: number;\n    messenger: TokenListMessenger;\n    state?: Partial<TokenListState>;\n  }) {\n    super({\n      name,\n      metadata,\n      messenger,\n      state: { ...defaultState, ...state },\n    });\n    this.intervalDelay = interval;\n    this.cacheRefreshThreshold = cacheRefreshThreshold;\n    this.chainId = chainId;\n    this.updatePreventPollingOnNetworkRestart(preventPollingOnNetworkRestart);\n    this.abortController = new AbortController();\n    onNetworkStateChange(async (networkState) => {\n      if (this.chainId !== networkState.provider.chainId) {\n        this.abortController.abort();\n        this.abortController = new AbortController();\n        this.chainId = networkState.provider.chainId;\n        if (this.state.preventPollingOnNetworkRestart) {\n          this.clearingTokenListData();\n        } else {\n          // Ensure tokenList is referencing data from correct network\n          this.update(() => {\n            return {\n              ...this.state,\n              tokenList: this.state.tokensChainsCache[this.chainId]?.data || {},\n            };\n          });\n          await this.restart();\n        }\n      }\n    });\n  }\n\n  /**\n   * Start polling for the token list.\n   */\n  async start() {\n    if (!isTokenListSupportedForNetwork(this.chainId)) {\n      return;\n    }\n    await this.startPolling();\n  }\n\n  /**\n   * Restart polling for the token list.\n   */\n  async restart() {\n    this.stopPolling();\n    await this.startPolling();\n  }\n\n  /**\n   * Stop polling for the token list.\n   */\n  stop() {\n    this.stopPolling();\n  }\n\n  /**\n   * Prepare to discard this controller.\n   *\n   * This stops any active polling.\n   */\n  override destroy() {\n    super.destroy();\n    this.stopPolling();\n  }\n\n  private stopPolling() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n\n  /**\n   * Starts a new polling interval.\n   */\n  private async startPolling(): Promise<void> {\n    await safelyExecute(() => this.fetchTokenList());\n    this.intervalId = setInterval(async () => {\n      await safelyExecute(() => this.fetchTokenList());\n    }, this.intervalDelay);\n  }\n\n  /**\n   * Fetching token list from the Token Service API.\n   */\n  async fetchTokenList(): Promise<void> {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      const { tokensChainsCache } = this.state;\n      let tokenList: TokenListMap = {};\n      const cachedTokens: TokenListMap = await safelyExecute(() =>\n        this.fetchFromCache(),\n      );\n      if (cachedTokens) {\n        // Use non-expired cached tokens\n        tokenList = { ...cachedTokens };\n      } else {\n        // Fetch fresh token list\n        const tokensFromAPI: TokenListToken[] = await safelyExecute(() =>\n          fetchTokenList(this.chainId, this.abortController.signal),\n        );\n\n        if (!tokensFromAPI) {\n          // Fallback to expired cached tokens\n          tokenList = { ...(tokensChainsCache[this.chainId]?.data || {}) };\n\n          this.update(() => {\n            return {\n              ...this.state,\n              tokenList,\n              tokensChainsCache,\n            };\n          });\n          return;\n        }\n        // Filtering out tokens with less than 3 occurrences and native tokens\n        const filteredTokenList = tokensFromAPI.filter(\n          (token) =>\n            token.occurrences &&\n            token.occurrences >= 3 &&\n            token.address !== '0x0000000000000000000000000000000000000000',\n        );\n        // Removing the tokens with symbol conflicts\n        const symbolsList = filteredTokenList.map((token) => token.symbol);\n        const duplicateSymbols = [\n          ...new Set(\n            symbolsList.filter(\n              (symbol, index) => symbolsList.indexOf(symbol) !== index,\n            ),\n          ),\n        ];\n        const uniqueTokenList = filteredTokenList.filter(\n          (token) => !duplicateSymbols.includes(token.symbol),\n        );\n        for (const token of uniqueTokenList) {\n          const formattedToken: TokenListToken = {\n            ...token,\n            aggregators: formatAggregatorNames(token.aggregators),\n            iconUrl: formatIconUrlWithProxy({\n              chainId: this.chainId,\n              tokenAddress: token.address,\n            }),\n          };\n          tokenList[token.address] = formattedToken;\n        }\n      }\n      const updatedTokensChainsCache: TokensChainsCache = {\n        ...tokensChainsCache,\n        [this.chainId]: {\n          timestamp: Date.now(),\n          data: tokenList,\n        },\n      };\n      this.update(() => {\n        return {\n          ...this.state,\n          tokenList,\n          tokensChainsCache: updatedTokensChainsCache,\n        };\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Checks if the Cache timestamp is valid,\n   * if yes data in cache will be returned\n   * otherwise null will be returned.\n   *\n   * @returns The cached data, or `null` if the cache was expired.\n   */\n  async fetchFromCache(): Promise<TokenListMap | null> {\n    const { tokensChainsCache }: TokenListState = this.state;\n    const dataCache = tokensChainsCache[this.chainId];\n    const now = Date.now();\n    if (\n      dataCache?.data &&\n      now - dataCache?.timestamp < this.cacheRefreshThreshold\n    ) {\n      return dataCache.data;\n    }\n    return null;\n  }\n\n  /**\n   * Clearing tokenList and tokensChainsCache explicitly.\n   */\n  clearingTokenListData(): void {\n    this.update(() => {\n      return {\n        ...this.state,\n        tokenList: {},\n        tokensChainsCache: {},\n      };\n    });\n  }\n\n  /**\n   * Updates preventPollingOnNetworkRestart from extension.\n   *\n   * @param shouldPreventPolling - Determine whether to prevent polling on network change\n   */\n  updatePreventPollingOnNetworkRestart(shouldPreventPolling: boolean): void {\n    this.update(() => {\n      return {\n        ...this.state,\n        preventPollingOnNetworkRestart: shouldPreventPolling,\n      };\n    });\n  }\n}\n\nexport default TokenListController;\n"]}