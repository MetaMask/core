{"version":3,"file":"CollectiblesController.js","sourceRoot":"","sources":["../../src/assets/CollectiblesController.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events';\nimport { BN, stripHexPrefix } from 'ethereumjs-util';\nimport { Mutex } from 'async-mutex';\n\nimport { BaseController, BaseConfig, BaseState } from '../BaseController';\nimport type { PreferencesState } from '../user/PreferencesController';\nimport type { NetworkState, NetworkType } from '../network/NetworkController';\nimport {\n  safelyExecute,\n  handleFetch,\n  toChecksumHexAddress,\n  BNToHex,\n  getFormattedIpfsUrl,\n  fetchWithErrorHandling,\n} from '../util';\nimport {\n  MAINNET,\n  RINKEBY_CHAIN_ID,\n  IPFS_DEFAULT_GATEWAY_URL,\n  ERC721,\n  ERC1155,\n  OPENSEA_API_URL,\n  OPENSEA_PROXY_URL,\n  OPENSEA_TEST_API_URL,\n} from '../constants';\n\nimport type {\n  ApiCollectible,\n  ApiCollectibleCreator,\n  ApiCollectibleContract,\n  ApiCollectibleLastSale,\n} from './CollectibleDetectionController';\nimport type { AssetsContractController } from './AssetsContractController';\nimport { compareCollectiblesMetadata } from './assetsUtil';\n\n/**\n * @type Collectible\n *\n * Collectible representation\n * @property address - Hex address of a ERC721 contract\n * @property description - The collectible description\n * @property image - URI of custom collectible image associated with this tokenId\n * @property name - Name associated with this tokenId and contract address\n * @property tokenId - The collectible identifier\n * @property numberOfSales - Number of sales\n * @property backgroundColor - The background color to be displayed with the item\n * @property imagePreview - URI of a smaller image associated with this collectible\n * @property imageThumbnail - URI of a thumbnail image associated with this collectible\n * @property imageOriginal - URI of the original image associated with this collectible\n * @property animation - URI of a animation associated with this collectible\n * @property animationOriginal - URI of the original animation associated with this collectible\n * @property externalLink - External link containing additional information\n * @property creator - The collectible owner information object\n * @property isCurrentlyOwned - Boolean indicating whether the address/chainId combination where it's currently stored currently owns this collectible\n */\nexport interface Collectible extends CollectibleMetadata {\n  tokenId: string;\n  address: string;\n  isCurrentlyOwned?: boolean;\n}\n\n/**\n * @type CollectibleContract\n *\n * Collectible contract information representation\n * @property name - Contract name\n * @property logo - Contract logo\n * @property address - Contract address\n * @property symbol - Contract symbol\n * @property description - Contract description\n * @property totalSupply - Total supply of collectibles\n * @property assetContractType - The collectible type, it could be `semi-fungible` or `non-fungible`\n * @property createdDate - Creation date\n * @property schemaName - The schema followed by the contract, it could be `ERC721` or `ERC1155`\n * @property externalLink - External link containing additional information\n */\nexport interface CollectibleContract {\n  name?: string;\n  logo?: string;\n  address: string;\n  symbol?: string;\n  description?: string;\n  totalSupply?: string;\n  assetContractType?: string;\n  createdDate?: string;\n  schemaName?: string;\n  externalLink?: string;\n}\n\n/**\n * @type CollectibleMetadata\n *\n * Collectible custom information\n * @property name - Collectible custom name\n * @property description - The collectible description\n * @property numberOfSales - Number of sales\n * @property backgroundColor - The background color to be displayed with the item\n * @property image - Image custom image URI\n * @property imagePreview - URI of a smaller image associated with this collectible\n * @property imageThumbnail - URI of a thumbnail image associated with this collectible\n * @property imageOriginal - URI of the original image associated with this collectible\n * @property animation - URI of a animation associated with this collectible\n * @property animationOriginal - URI of the original animation associated with this collectible\n * @property externalLink - External link containing additional information\n * @property creator - The collectible owner information object\n * @property standard - NFT standard name for the collectible, e.g., ERC-721 or ERC-1155\n */\nexport interface CollectibleMetadata {\n  name: string | null;\n  description: string | null;\n  image: string | null;\n  standard: string | null;\n  favorite?: boolean;\n  numberOfSales?: number;\n  backgroundColor?: string;\n  imagePreview?: string;\n  imageThumbnail?: string;\n  imageOriginal?: string;\n  animation?: string;\n  animationOriginal?: string;\n  externalLink?: string;\n  creator?: ApiCollectibleCreator;\n  lastSale?: ApiCollectibleLastSale;\n}\n\ninterface AccountParams {\n  userAddress: string;\n  chainId: string;\n}\n\n/**\n * @type CollectiblesConfig\n *\n * Collectibles controller configuration\n * @property networkType - Network ID as per net_version\n * @property selectedAddress - Vault selected address\n */\nexport interface CollectiblesConfig extends BaseConfig {\n  networkType: NetworkType;\n  selectedAddress: string;\n  chainId: string;\n  ipfsGateway: string;\n  openSeaEnabled: boolean;\n  useIPFSSubdomains: boolean;\n}\n\n/**\n * @type CollectiblesState\n *\n * Assets controller state\n * @property allCollectibleContracts - Object containing collectibles contract information\n * @property allCollectibles - Object containing collectibles per account and network\n * @property collectibleContracts - List of collectibles contracts associated with the active vault\n * @property collectibles - List of collectibles associated with the active vault\n * @property ignoredCollectibles - List of collectibles that should be ignored\n */\nexport interface CollectiblesState extends BaseState {\n  allCollectibleContracts: {\n    [key: string]: { [key: string]: CollectibleContract[] };\n  };\n  allCollectibles: { [key: string]: { [key: string]: Collectible[] } };\n  ignoredCollectibles: Collectible[];\n}\n\nconst ALL_COLLECTIBLES_STATE_KEY = 'allCollectibles';\nconst ALL_COLLECTIBLES_CONTRACTS_STATE_KEY = 'allCollectibleContracts';\n\n/**\n * Controller that stores assets and exposes convenience methods\n */\nexport class CollectiblesController extends BaseController<\n  CollectiblesConfig,\n  CollectiblesState\n> {\n  private mutex = new Mutex();\n\n  private getCollectibleApi({\n    contractAddress,\n    tokenId,\n    useProxy,\n  }: {\n    contractAddress: string;\n    tokenId: string;\n    useProxy: boolean;\n  }) {\n    const { chainId } = this.config;\n\n    if (chainId === RINKEBY_CHAIN_ID) {\n      return `${OPENSEA_TEST_API_URL}/asset/${contractAddress}/${tokenId}`;\n    }\n    return useProxy\n      ? `${OPENSEA_PROXY_URL}/asset/${contractAddress}/${tokenId}`\n      : `${OPENSEA_API_URL}/asset/${contractAddress}/${tokenId}`;\n  }\n\n  private getCollectibleContractInformationApi({\n    contractAddress,\n    useProxy,\n  }: {\n    contractAddress: string;\n    useProxy: boolean;\n  }) {\n    const { chainId } = this.config;\n\n    if (chainId === RINKEBY_CHAIN_ID) {\n      return `${OPENSEA_TEST_API_URL}/asset_contract/${contractAddress}`;\n    }\n\n    return useProxy\n      ? `${OPENSEA_PROXY_URL}/asset_contract/${contractAddress}`\n      : `${OPENSEA_API_URL}/asset_contract/${contractAddress}`;\n  }\n\n  /**\n   * Helper method to update nested state for allCollectibles and allCollectibleContracts.\n   *\n   * @param newCollection - the modified piece of state to update in the controller's store\n   * @param baseStateKey - The root key in the store to update.\n   * @param passedConfig - An object containing the selectedAddress and chainId that are passed through the auto-detection flow.\n   * @param passedConfig.userAddress - the address passed through the collectible detection flow to ensure detected assets are stored to the correct account\n   * @param passedConfig.chainId - the chainId passed through the collectible detection flow to ensure detected assets are stored to the correct account\n   */\n  private updateNestedCollectibleState(\n    newCollection: Collectible[] | CollectibleContract[],\n    baseStateKey: 'allCollectibles' | 'allCollectibleContracts',\n    { userAddress, chainId }: AccountParams | undefined = {\n      userAddress: this.config.selectedAddress,\n      chainId: this.config.chainId,\n    },\n  ) {\n    const { [baseStateKey]: oldState } = this.state;\n\n    const addressState = oldState[userAddress];\n    const newAddressState = {\n      ...addressState,\n      ...{ [chainId]: newCollection },\n    };\n    const newState = {\n      ...oldState,\n      ...{ [userAddress]: newAddressState },\n    };\n\n    this.update({\n      [baseStateKey]: newState,\n    });\n  }\n\n  /**\n   * Request individual collectible information from OpenSea API.\n   *\n   * @param contractAddress - Hex address of the collectible contract.\n   * @param tokenId - The collectible identifier.\n   * @returns Promise resolving to the current collectible name and image.\n   */\n  private async getCollectibleInformationFromApi(\n    contractAddress: string,\n    tokenId: string,\n  ): Promise<CollectibleMetadata> {\n    // Attempt to fetch the data with the proxy\n    let collectibleInformation: ApiCollectible | undefined =\n      await fetchWithErrorHandling({\n        url: this.getCollectibleApi({\n          contractAddress,\n          tokenId,\n          useProxy: true,\n        }),\n      });\n\n    // if an openSeaApiKey is set we should attempt to refetch calling directly to OpenSea\n    if (!collectibleInformation && this.openSeaApiKey) {\n      collectibleInformation = await fetchWithErrorHandling({\n        url: this.getCollectibleApi({\n          contractAddress,\n          tokenId,\n          useProxy: false,\n        }),\n        options: {\n          headers: { 'X-API-KEY': this.openSeaApiKey },\n        },\n        // catch 403 errors (in case API key is down we don't want to blow up)\n        errorCodesToCatch: [403],\n      });\n    }\n\n    // if we were still unable to fetch the data we return out the default/null of `CollectibleMetadata`\n    if (!collectibleInformation) {\n      return {\n        name: null,\n        description: null,\n        image: null,\n        standard: null,\n      };\n    }\n\n    // if we've reached this point, we have successfully fetched some data for collectibleInformation\n    // now we reconfigure the data to conform to the `CollectibleMetadata` type for storage.\n    const {\n      num_sales,\n      background_color,\n      image_url,\n      image_preview_url,\n      image_thumbnail_url,\n      image_original_url,\n      animation_url,\n      animation_original_url,\n      name,\n      description,\n      external_link,\n      creator,\n      last_sale,\n      asset_contract: { schema_name },\n    } = collectibleInformation;\n\n    /* istanbul ignore next */\n    const collectibleMetadata: CollectibleMetadata = Object.assign(\n      {},\n      { name: name || null },\n      { description: description || null },\n      { image: image_url || null },\n      creator && { creator },\n      num_sales && { numberOfSales: num_sales },\n      background_color && { backgroundColor: background_color },\n      image_preview_url && { imagePreview: image_preview_url },\n      image_thumbnail_url && { imageThumbnail: image_thumbnail_url },\n      image_original_url && { imageOriginal: image_original_url },\n      animation_url && { animation: animation_url },\n      animation_original_url && {\n        animationOriginal: animation_original_url,\n      },\n      external_link && { externalLink: external_link },\n      last_sale && { lastSale: last_sale },\n      schema_name && { standard: schema_name },\n    );\n\n    return collectibleMetadata;\n  }\n\n  /**\n   * Request individual collectible information from contracts that follows Metadata Interface.\n   *\n   * @param contractAddress - Hex address of the collectible contract.\n   * @param tokenId - The collectible identifier.\n   * @returns Promise resolving to the current collectible name and image.\n   */\n  private async getCollectibleInformationFromTokenURI(\n    contractAddress: string,\n    tokenId: string,\n  ): Promise<CollectibleMetadata> {\n    const { ipfsGateway, useIPFSSubdomains } = this.config;\n    const result = await this.getCollectibleURIAndStandard(\n      contractAddress,\n      tokenId,\n    );\n    let tokenURI = result[0];\n    const standard = result[1];\n\n    if (tokenURI.startsWith('ipfs://')) {\n      tokenURI = getFormattedIpfsUrl(ipfsGateway, tokenURI, useIPFSSubdomains);\n    }\n\n    try {\n      const object = await handleFetch(tokenURI);\n      // TODO: Check image_url existence. This is not part of EIP721 nor EIP1155\n      const image = Object.prototype.hasOwnProperty.call(object, 'image')\n        ? 'image'\n        : /* istanbul ignore next */ 'image_url';\n\n      return {\n        image: object[image],\n        name: object.name,\n        description: object.description,\n        standard,\n        favorite: false,\n      };\n    } catch {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n      };\n    }\n  }\n\n  /**\n   * Retrieve collectible uri with  metadata. TODO Update method to use IPFS.\n   *\n   * @param contractAddress - Collectible contract address.\n   * @param tokenId - Collectible token id.\n   * @returns Promise resolving collectible uri and token standard.\n   */\n  private async getCollectibleURIAndStandard(\n    contractAddress: string,\n    tokenId: string,\n  ): Promise<[string, string]> {\n    // try ERC721 uri\n    try {\n      const uri = await this.getERC721TokenURI(contractAddress, tokenId);\n      return [uri, ERC721];\n    } catch {\n      // Ignore error\n    }\n\n    // try ERC1155 uri\n    try {\n      const tokenURI = await this.getERC1155TokenURI(contractAddress, tokenId);\n\n      /**\n       * According to EIP1155 the URI value allows for ID substitution\n       * in case the string `{id}` exists.\n       * https://eips.ethereum.org/EIPS/eip-1155#metadata\n       */\n\n      if (!tokenURI.includes('{id}')) {\n        return [tokenURI, ERC1155];\n      }\n\n      const hexTokenId = stripHexPrefix(BNToHex(new BN(tokenId)))\n        .padStart(64, '0')\n        .toLowerCase();\n      return [tokenURI.replace('{id}', hexTokenId), ERC1155];\n    } catch {\n      // Ignore error\n    }\n\n    return ['', ''];\n  }\n\n  /**\n   * Request individual collectible information (name, image url and description).\n   *\n   * @param contractAddress - Hex address of the collectible contract.\n   * @param tokenId - The collectible identifier.\n   * @returns Promise resolving to the current collectible name and image.\n   */\n  private async getCollectibleInformation(\n    contractAddress: string,\n    tokenId: string,\n  ): Promise<CollectibleMetadata> {\n    const blockchainMetadata = await safelyExecute(async () => {\n      return await this.getCollectibleInformationFromTokenURI(\n        contractAddress,\n        tokenId,\n      );\n    });\n\n    let openSeaMetadata;\n    if (this.config.openSeaEnabled) {\n      openSeaMetadata = await safelyExecute(async () => {\n        return await this.getCollectibleInformationFromApi(\n          contractAddress,\n          tokenId,\n        );\n      });\n    }\n    return {\n      ...openSeaMetadata,\n      name: blockchainMetadata.name ?? openSeaMetadata?.name ?? null,\n      description:\n        blockchainMetadata.description ?? openSeaMetadata?.description ?? null,\n      image: blockchainMetadata.image ?? openSeaMetadata?.image ?? null,\n      standard:\n        blockchainMetadata.standard ?? openSeaMetadata?.standard ?? null,\n    };\n  }\n\n  /**\n   * Request collectible contract information from OpenSea API.\n   *\n   * @param contractAddress - Hex address of the collectible contract.\n   * @returns Promise resolving to the current collectible name and image.\n   */\n  private async getCollectibleContractInformationFromApi(\n    contractAddress: string,\n  ): Promise<ApiCollectibleContract> {\n    /* istanbul ignore if */\n    let apiCollectibleContractObject: ApiCollectibleContract | undefined =\n      await fetchWithErrorHandling({\n        url: this.getCollectibleContractInformationApi({\n          contractAddress,\n          useProxy: true,\n        }),\n      });\n\n    // if we successfully fetched return the fetched data immediately\n    if (apiCollectibleContractObject) {\n      return apiCollectibleContractObject;\n    }\n\n    // if we were unsuccessful in fetching from the API and an OpenSea API key is present\n    // attempt to refetch directly against the OpenSea API and if successful return the data immediately\n    if (this.openSeaApiKey) {\n      apiCollectibleContractObject = await fetchWithErrorHandling({\n        url: this.getCollectibleContractInformationApi({\n          contractAddress,\n          useProxy: false,\n        }),\n        options: {\n          headers: { 'X-API-KEY': this.openSeaApiKey },\n        },\n        // catch 403 errors (in case API key is down we don't want to blow up)\n        errorCodesToCatch: [403],\n      });\n\n      if (apiCollectibleContractObject) {\n        return apiCollectibleContractObject;\n      }\n    }\n\n    // If we've reached this point we were unable to fetch data from either the proxy or opensea so we return\n    // the default/null of ApiCollectibleContract\n    return {\n      address: contractAddress,\n      asset_contract_type: null,\n      created_date: null,\n      schema_name: null,\n      symbol: null,\n      total_supply: null,\n      description: null,\n      external_link: null,\n      collection: {\n        name: null,\n        image_url: null,\n      },\n    };\n  }\n\n  /**\n   * Request collectible contract information from the contract itself.\n   *\n   * @param contractAddress - Hex address of the collectible contract.\n   * @returns Promise resolving to the current collectible name and image.\n   */\n  private async getCollectibleContractInformationFromContract(\n    contractAddress: string,\n  ): Promise<\n    Partial<ApiCollectibleContract> &\n      Pick<ApiCollectibleContract, 'address'> &\n      Pick<ApiCollectibleContract, 'collection'>\n  > {\n    const name = await this.getERC721AssetName(contractAddress);\n    const symbol = await this.getERC721AssetSymbol(contractAddress);\n    return {\n      collection: { name },\n      symbol,\n      address: contractAddress,\n    };\n  }\n\n  /**\n   * Request collectible contract information from OpenSea API.\n   *\n   * @param contractAddress - Hex address of the collectible contract.\n   * @returns Promise resolving to the collectible contract name, image and description.\n   */\n  private async getCollectibleContractInformation(\n    contractAddress: string,\n  ): Promise<\n    Partial<ApiCollectibleContract> &\n      Pick<ApiCollectibleContract, 'address'> &\n      Pick<ApiCollectibleContract, 'collection'>\n  > {\n    const blockchainContractData: Partial<ApiCollectibleContract> &\n      Pick<ApiCollectibleContract, 'address'> &\n      Pick<ApiCollectibleContract, 'collection'> = await safelyExecute(\n      async () => {\n        return await this.getCollectibleContractInformationFromContract(\n          contractAddress,\n        );\n      },\n    );\n\n    let openSeaContractData: Partial<ApiCollectibleContract> | undefined;\n    if (this.config.openSeaEnabled) {\n      openSeaContractData = await safelyExecute(async () => {\n        return await this.getCollectibleContractInformationFromApi(\n          contractAddress,\n        );\n      });\n    }\n\n    if (blockchainContractData || openSeaContractData) {\n      return {\n        ...openSeaContractData,\n        ...blockchainContractData,\n        collection: {\n          image_url: null,\n          ...openSeaContractData?.collection,\n          ...blockchainContractData?.collection,\n        },\n      };\n    }\n\n    /* istanbul ignore next */\n    return {\n      address: contractAddress,\n      asset_contract_type: null,\n      created_date: null,\n      schema_name: null,\n      symbol: null,\n      total_supply: null,\n      description: null,\n      external_link: null,\n      collection: { name: null, image_url: null },\n    };\n  }\n\n  /**\n   * Adds an individual collectible to the stored collectible list.\n   *\n   * @param address - Hex address of the collectible contract.\n   * @param tokenId - The collectible identifier.\n   * @param collectibleMetadata - Collectible optional information (name, image and description).\n   * @param collectibleContract - An object containing contract data of the collectible being added.\n   * @param detection - The chain ID and address of the currently selected network and account at the moment the collectible was detected.\n   * @returns Promise resolving to the current collectible list.\n   */\n  private async addIndividualCollectible(\n    address: string,\n    tokenId: string,\n    collectibleMetadata: CollectibleMetadata,\n    collectibleContract: CollectibleContract,\n    detection?: AccountParams,\n  ): Promise<Collectible[]> {\n    // TODO: Remove unused return\n    const releaseLock = await this.mutex.acquire();\n    try {\n      address = toChecksumHexAddress(address);\n      const { allCollectibles } = this.state;\n      let chainId, selectedAddress;\n\n      if (detection) {\n        chainId = detection.chainId;\n        selectedAddress = detection.userAddress;\n      } else {\n        chainId = this.config.chainId;\n        selectedAddress = this.config.selectedAddress;\n      }\n\n      const collectibles = allCollectibles[selectedAddress]?.[chainId] || [];\n\n      const existingEntry: Collectible | undefined = collectibles.find(\n        (collectible) =>\n          collectible.address.toLowerCase() === address.toLowerCase() &&\n          collectible.tokenId === tokenId,\n      );\n\n      if (existingEntry) {\n        const differentMetadata = compareCollectiblesMetadata(\n          collectibleMetadata,\n          existingEntry,\n        );\n        if (differentMetadata) {\n          // TODO: Switch to indexToUpdate\n          const indexToRemove = collectibles.findIndex(\n            (collectible) =>\n              collectible.address.toLowerCase() === address.toLowerCase() &&\n              collectible.tokenId === tokenId,\n          );\n          /* istanbul ignore next */\n          if (indexToRemove !== -1) {\n            collectibles.splice(indexToRemove, 1);\n          }\n        } else {\n          return collectibles;\n        }\n      }\n\n      const newEntry: Collectible = {\n        address,\n        tokenId,\n        favorite: existingEntry?.favorite || false,\n        isCurrentlyOwned: true,\n        ...collectibleMetadata,\n      };\n\n      const newCollectibles = [...collectibles, newEntry];\n      this.updateNestedCollectibleState(\n        newCollectibles,\n        ALL_COLLECTIBLES_STATE_KEY,\n        { chainId, userAddress: selectedAddress },\n      );\n\n      if (this.onCollectibleAdded) {\n        this.onCollectibleAdded({\n          address,\n          symbol: collectibleContract.symbol,\n          tokenId: tokenId.toString(),\n          standard: collectibleMetadata.standard,\n          source: detection ? 'detected' : 'custom',\n        });\n      }\n\n      return newCollectibles;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Adds a collectible contract to the stored collectible contracts list.\n   *\n   * @param address - Hex address of the collectible contract.\n   * @param detection - The chain ID and address of the currently selected network and account at the moment the collectible was detected.\n   * @returns Promise resolving to the current collectible contracts list.\n   */\n  private async addCollectibleContract(\n    address: string,\n    detection?: AccountParams,\n  ): Promise<CollectibleContract[]> {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      address = toChecksumHexAddress(address);\n      const { allCollectibleContracts } = this.state;\n\n      let chainId, selectedAddress;\n      if (detection) {\n        chainId = detection.chainId;\n        selectedAddress = detection.userAddress;\n      } else {\n        chainId = this.config.chainId;\n        selectedAddress = this.config.selectedAddress;\n      }\n\n      const collectibleContracts =\n        allCollectibleContracts[selectedAddress]?.[chainId] || [];\n\n      const existingEntry = collectibleContracts.find(\n        (collectibleContract) =>\n          collectibleContract.address.toLowerCase() === address.toLowerCase(),\n      );\n      if (existingEntry) {\n        return collectibleContracts;\n      }\n      const contractInformation = await this.getCollectibleContractInformation(\n        address,\n      );\n\n      const {\n        asset_contract_type,\n        created_date,\n        schema_name,\n        symbol,\n        total_supply,\n        description,\n        external_link,\n        collection: { name, image_url },\n      } = contractInformation;\n      // If being auto-detected opensea information is expected\n      // Otherwise at least name from the contract is needed\n      if (\n        (detection && !name) ||\n        Object.keys(contractInformation).length === 0\n      ) {\n        return collectibleContracts;\n      }\n\n      /* istanbul ignore next */\n      const newEntry: CollectibleContract = Object.assign(\n        {},\n        { address },\n        description && { description },\n        name && { name },\n        image_url && { logo: image_url },\n        symbol && { symbol },\n        total_supply !== null &&\n          typeof total_supply !== 'undefined' && { totalSupply: total_supply },\n        asset_contract_type && { assetContractType: asset_contract_type },\n        created_date && { createdDate: created_date },\n        schema_name && { schemaName: schema_name },\n        external_link && { externalLink: external_link },\n      );\n      const newCollectibleContracts = [...collectibleContracts, newEntry];\n      this.updateNestedCollectibleState(\n        newCollectibleContracts,\n        ALL_COLLECTIBLES_CONTRACTS_STATE_KEY,\n        { chainId, userAddress: selectedAddress },\n      );\n\n      return newCollectibleContracts;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Removes an individual collectible from the stored token list and saves it in ignored collectibles list.\n   *\n   * @param address - Hex address of the collectible contract.\n   * @param tokenId - Token identifier of the collectible.\n   */\n  private removeAndIgnoreIndividualCollectible(\n    address: string,\n    tokenId: string,\n  ) {\n    address = toChecksumHexAddress(address);\n    const { allCollectibles, ignoredCollectibles } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const newIgnoredCollectibles = [...ignoredCollectibles];\n    const collectibles = allCollectibles[selectedAddress]?.[chainId] || [];\n    const newCollectibles = collectibles.filter((collectible) => {\n      if (\n        collectible.address.toLowerCase() === address.toLowerCase() &&\n        collectible.tokenId === tokenId\n      ) {\n        const alreadyIgnored = newIgnoredCollectibles.find(\n          (c) => c.address === address && c.tokenId === tokenId,\n        );\n        !alreadyIgnored && newIgnoredCollectibles.push(collectible);\n        return false;\n      }\n      return true;\n    });\n\n    this.updateNestedCollectibleState(\n      newCollectibles,\n      ALL_COLLECTIBLES_STATE_KEY,\n    );\n\n    this.update({\n      ignoredCollectibles: newIgnoredCollectibles,\n    });\n  }\n\n  /**\n   * Removes an individual collectible from the stored token list.\n   *\n   * @param address - Hex address of the collectible contract.\n   * @param tokenId - Token identifier of the collectible.\n   */\n  private removeIndividualCollectible(address: string, tokenId: string) {\n    address = toChecksumHexAddress(address);\n    const { allCollectibles } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const collectibles = allCollectibles[selectedAddress]?.[chainId] || [];\n    const newCollectibles = collectibles.filter(\n      (collectible) =>\n        !(\n          collectible.address.toLowerCase() === address.toLowerCase() &&\n          collectible.tokenId === tokenId\n        ),\n    );\n    this.updateNestedCollectibleState(\n      newCollectibles,\n      ALL_COLLECTIBLES_STATE_KEY,\n    );\n  }\n\n  /**\n   * Removes a collectible contract to the stored collectible contracts list.\n   *\n   * @param address - Hex address of the collectible contract.\n   * @returns Promise resolving to the current collectible contracts list.\n   */\n  private removeCollectibleContract(address: string): CollectibleContract[] {\n    address = toChecksumHexAddress(address);\n    const { allCollectibleContracts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const collectibleContracts =\n      allCollectibleContracts[selectedAddress]?.[chainId] || [];\n\n    const newCollectibleContracts = collectibleContracts.filter(\n      (collectibleContract) =>\n        !(collectibleContract.address.toLowerCase() === address.toLowerCase()),\n    );\n    this.updateNestedCollectibleState(\n      newCollectibleContracts,\n      ALL_COLLECTIBLES_CONTRACTS_STATE_KEY,\n    );\n\n    return newCollectibleContracts;\n  }\n\n  /**\n   * EventEmitter instance used to listen to specific EIP747 events\n   */\n  hub = new EventEmitter();\n\n  /**\n   * Optional API key to use with opensea\n   */\n  openSeaApiKey?: string;\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'CollectiblesController';\n\n  private getERC721AssetName: AssetsContractController['getERC721AssetName'];\n\n  private getERC721AssetSymbol: AssetsContractController['getERC721AssetSymbol'];\n\n  private getERC721TokenURI: AssetsContractController['getERC721TokenURI'];\n\n  private getERC721OwnerOf: AssetsContractController['getERC721OwnerOf'];\n\n  private getERC1155BalanceOf: AssetsContractController['getERC1155BalanceOf'];\n\n  private getERC1155TokenURI: AssetsContractController['getERC1155TokenURI'];\n\n  private onCollectibleAdded?: (data: {\n    address: string;\n    symbol: string | undefined;\n    tokenId: string;\n    standard: string | null;\n    source: string;\n  }) => void;\n\n  /**\n   * Creates a CollectiblesController instance.\n   *\n   * @param options - The controller options.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.getERC721AssetName - Gets the name of the asset at the given address.\n   * @param options.getERC721AssetSymbol - Gets the symbol of the asset at the given address.\n   * @param options.getERC721TokenURI - Gets the URI of the ERC721 token at the given address, with the given ID.\n   * @param options.getERC721OwnerOf - Get the owner of a ERC-721 collectible.\n   * @param options.getERC1155BalanceOf - Gets balance of a ERC-1155 collectible.\n   * @param options.getERC1155TokenURI - Gets the URI of the ERC1155 token at the given address, with the given ID.\n   * @param options.onCollectibleAdded - Callback that is called when a collectible is added. Currently used pass data\n   * for tracking the collectible added event.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      onPreferencesStateChange,\n      onNetworkStateChange,\n      getERC721AssetName,\n      getERC721AssetSymbol,\n      getERC721TokenURI,\n      getERC721OwnerOf,\n      getERC1155BalanceOf,\n      getERC1155TokenURI,\n      onCollectibleAdded,\n    }: {\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      getERC721AssetName: AssetsContractController['getERC721AssetName'];\n      getERC721AssetSymbol: AssetsContractController['getERC721AssetSymbol'];\n      getERC721TokenURI: AssetsContractController['getERC721TokenURI'];\n      getERC721OwnerOf: AssetsContractController['getERC721OwnerOf'];\n      getERC1155BalanceOf: AssetsContractController['getERC1155BalanceOf'];\n      getERC1155TokenURI: AssetsContractController['getERC1155TokenURI'];\n      onCollectibleAdded?: (data: {\n        address: string;\n        symbol: string | undefined;\n        tokenId: string;\n        standard: string | null;\n        source: string;\n      }) => void;\n    },\n    config?: Partial<BaseConfig>,\n    state?: Partial<CollectiblesState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      networkType: MAINNET,\n      selectedAddress: '',\n      chainId: '',\n      ipfsGateway: IPFS_DEFAULT_GATEWAY_URL,\n      openSeaEnabled: false,\n      useIPFSSubdomains: true,\n    };\n\n    this.defaultState = {\n      allCollectibleContracts: {},\n      allCollectibles: {},\n      ignoredCollectibles: [],\n    };\n    this.initialize();\n    this.getERC721AssetName = getERC721AssetName;\n    this.getERC721AssetSymbol = getERC721AssetSymbol;\n    this.getERC721TokenURI = getERC721TokenURI;\n    this.getERC721OwnerOf = getERC721OwnerOf;\n    this.getERC1155BalanceOf = getERC1155BalanceOf;\n    this.getERC1155TokenURI = getERC1155TokenURI;\n    this.onCollectibleAdded = onCollectibleAdded;\n\n    onPreferencesStateChange(\n      ({ selectedAddress, ipfsGateway, openSeaEnabled }) => {\n        this.configure({ selectedAddress, ipfsGateway, openSeaEnabled });\n      },\n    );\n\n    onNetworkStateChange(({ provider }) => {\n      const { chainId } = provider;\n      this.configure({ chainId });\n    });\n  }\n\n  /**\n   * Sets an OpenSea API key to retrieve collectible information.\n   *\n   * @param openSeaApiKey - OpenSea API key.\n   */\n  setApiKey(openSeaApiKey: string) {\n    this.openSeaApiKey = openSeaApiKey;\n  }\n\n  /**\n   * Checks the ownership of a ERC-721 or ERC-1155 collectible for a given address.\n   *\n   * @param ownerAddress - User public address.\n   * @param collectibleAddress - Collectible contract address.\n   * @param collectibleId - Collectible token ID.\n   * @returns Promise resolving the collectible ownership.\n   */\n  async isCollectibleOwner(\n    ownerAddress: string,\n    collectibleAddress: string,\n    collectibleId: string,\n  ): Promise<boolean> {\n    // Checks the ownership for ERC-721.\n    try {\n      const owner = await this.getERC721OwnerOf(\n        collectibleAddress,\n        collectibleId,\n      );\n      return ownerAddress.toLowerCase() === owner.toLowerCase();\n      // eslint-disable-next-line no-empty\n    } catch {\n      // Ignore ERC-721 contract error\n    }\n\n    // Checks the ownership for ERC-1155.\n    try {\n      const balance = await this.getERC1155BalanceOf(\n        ownerAddress,\n        collectibleAddress,\n        collectibleId,\n      );\n      return balance > 0;\n      // eslint-disable-next-line no-empty\n    } catch {\n      // Ignore ERC-1155 contract error\n    }\n\n    throw new Error(\n      'Unable to verify ownership. Probably because the standard is not supported or the chain is incorrect.',\n    );\n  }\n\n  /**\n   * Verifies currently selected address owns entered collectible address/tokenId combo and\n   * adds the collectible and respective collectible contract to the stored collectible and collectible contracts lists.\n   *\n   * @param address - Hex address of the collectible contract.\n   * @param tokenId - The collectible identifier.\n   */\n  async addCollectibleVerifyOwnership(address: string, tokenId: string) {\n    const { selectedAddress } = this.config;\n    if (!(await this.isCollectibleOwner(selectedAddress, address, tokenId))) {\n      throw new Error('This collectible is not owned by the user');\n    }\n    await this.addCollectible(address, tokenId);\n  }\n\n  /**\n   * Adds a collectible and respective collectible contract to the stored collectible and collectible contracts lists.\n   *\n   * @param address - Hex address of the collectible contract.\n   * @param tokenId - The collectible identifier.\n   * @param collectibleMetadata - Collectible optional metadata.\n   * @param detection - The chain ID and address of the currently selected network and account at the moment the collectible was detected.\n   * @returns Promise resolving to the current collectible list.\n   */\n  async addCollectible(\n    address: string,\n    tokenId: string,\n    collectibleMetadata?: CollectibleMetadata,\n    detection?: AccountParams,\n  ) {\n    address = toChecksumHexAddress(address);\n    const newCollectibleContracts = await this.addCollectibleContract(\n      address,\n      detection,\n    );\n    collectibleMetadata =\n      collectibleMetadata ||\n      (await this.getCollectibleInformation(address, tokenId));\n\n    // If collectible contract was not added, do not add individual collectible\n    const collectibleContract = newCollectibleContracts.find(\n      (contract) => contract.address.toLowerCase() === address.toLowerCase(),\n    );\n\n    // If collectible contract information, add individual collectible\n    if (collectibleContract) {\n      await this.addIndividualCollectible(\n        address,\n        tokenId,\n        collectibleMetadata,\n        collectibleContract,\n        detection,\n      );\n    }\n  }\n\n  /**\n   * Removes a collectible from the stored token list.\n   *\n   * @param address - Hex address of the collectible contract.\n   * @param tokenId - Token identifier of the collectible.\n   */\n  removeCollectible(address: string, tokenId: string) {\n    address = toChecksumHexAddress(address);\n    this.removeIndividualCollectible(address, tokenId);\n    const { allCollectibles } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const collectibles = allCollectibles[selectedAddress]?.[chainId] || [];\n    const remainingCollectible = collectibles.find(\n      (collectible) =>\n        collectible.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (!remainingCollectible) {\n      this.removeCollectibleContract(address);\n    }\n  }\n\n  /**\n   * Removes a collectible from the stored token list and saves it in ignored collectibles list.\n   *\n   * @param address - Hex address of the collectible contract.\n   * @param tokenId - Token identifier of the collectible.\n   */\n  removeAndIgnoreCollectible(address: string, tokenId: string) {\n    address = toChecksumHexAddress(address);\n    this.removeAndIgnoreIndividualCollectible(address, tokenId);\n    const { allCollectibles } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const collectibles = allCollectibles[selectedAddress]?.[chainId] || [];\n    const remainingCollectible = collectibles.find(\n      (collectible) =>\n        collectible.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (!remainingCollectible) {\n      this.removeCollectibleContract(address);\n    }\n  }\n\n  /**\n   * Removes all collectibles from the ignored list.\n   */\n  clearIgnoredCollectibles() {\n    this.update({ ignoredCollectibles: [] });\n  }\n\n  /**\n   * Checks whether input collectible is still owned by the user\n   * And updates the isCurrentlyOwned value on the collectible object accordingly.\n   *\n   * @param collectible - The collectible object to check and update.\n   * @param batch - A boolean indicating whether this method is being called as part of a batch or single update.\n   * @param accountParams - The userAddress and chainId to check ownership against\n   * @param accountParams.userAddress - the address passed through the confirmed transaction flow to ensure detected assets are stored to the correct account\n   * @param accountParams.chainId - the chainId passed through the confirmed transaction flow to ensure detected assets are stored to the correct account\n   * @returns the collectible with the updated isCurrentlyOwned value\n   */\n  async checkAndUpdateSingleCollectibleOwnershipStatus(\n    collectible: Collectible,\n    batch: boolean,\n    { userAddress, chainId }: AccountParams | undefined = {\n      userAddress: this.config.selectedAddress,\n      chainId: this.config.chainId,\n    },\n  ) {\n    const { address, tokenId } = collectible;\n    let isOwned = collectible.isCurrentlyOwned;\n    try {\n      isOwned = await this.isCollectibleOwner(userAddress, address, tokenId);\n    } catch (error) {\n      if (\n        !(\n          error instanceof Error &&\n          error.message.includes('Unable to verify ownership')\n        )\n      ) {\n        throw error;\n      }\n    }\n\n    collectible.isCurrentlyOwned = isOwned;\n\n    if (batch === true) {\n      return collectible;\n    }\n\n    // if this is not part of a batched update we update this one collectible in state\n    const { allCollectibles } = this.state;\n    const collectibles = allCollectibles[userAddress]?.[chainId] || [];\n    const collectibleToUpdate = collectibles.find(\n      (item) =>\n        item.tokenId === tokenId &&\n        item.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (collectibleToUpdate) {\n      collectibleToUpdate.isCurrentlyOwned = isOwned;\n      this.updateNestedCollectibleState(\n        collectibles,\n        ALL_COLLECTIBLES_STATE_KEY,\n        { userAddress, chainId },\n      );\n    }\n    return collectible;\n  }\n\n  /**\n   * Checks whether Collectibles associated with current selectedAddress/chainId combination are still owned by the user\n   * And updates the isCurrentlyOwned value on each accordingly.\n   */\n  async checkAndUpdateAllCollectiblesOwnershipStatus() {\n    const { allCollectibles } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const collectibles = allCollectibles[selectedAddress]?.[chainId] || [];\n    const updatedCollectibles = await Promise.all(\n      collectibles.map(async (collectible) => {\n        return (\n          (await this.checkAndUpdateSingleCollectibleOwnershipStatus(\n            collectible,\n            true,\n          )) ?? collectible\n        );\n      }),\n    );\n\n    this.updateNestedCollectibleState(\n      updatedCollectibles,\n      ALL_COLLECTIBLES_STATE_KEY,\n    );\n  }\n\n  /**\n   * Update collectible favorite status.\n   *\n   * @param address - Hex address of the collectible contract.\n   * @param tokenId - Hex address of the collectible contract.\n   * @param favorite - Collectible new favorite status.\n   */\n  updateCollectibleFavoriteStatus(\n    address: string,\n    tokenId: string,\n    favorite: boolean,\n  ) {\n    const { allCollectibles } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const collectibles = allCollectibles[selectedAddress]?.[chainId] || [];\n    const index: number = collectibles.findIndex(\n      (collectible) =>\n        collectible.address === address && collectible.tokenId === tokenId,\n    );\n\n    if (index === -1) {\n      return;\n    }\n\n    const updatedCollectible: Collectible = {\n      ...collectibles[index],\n      favorite,\n    };\n\n    // Update Collectibles array\n    collectibles[index] = updatedCollectible;\n\n    this.updateNestedCollectibleState(collectibles, ALL_COLLECTIBLES_STATE_KEY);\n  }\n}\n\nexport default CollectiblesController;\n"]}