{"version":3,"file":"AssetsContractController.js","sourceRoot":"","sources":["../../src/assets/AssetsContractController.ts"],"names":[],"mappings":"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","sourcesContent":["import { BN } from 'ethereumjs-util';\nimport Web3 from 'web3';\nimport abiSingleCallBalancesContract from 'single-call-balance-checker-abi';\nimport { BaseController, BaseConfig, BaseState } from '../BaseController';\nimport type { PreferencesState } from '../user/PreferencesController';\nimport { IPFS_DEFAULT_GATEWAY_URL } from '../constants';\nimport { SupportedTokenDetectionNetworks } from '../util';\nimport { NetworkState } from '../network/NetworkController';\nimport { ERC721Standard } from './Standards/CollectibleStandards/ERC721/ERC721Standard';\nimport { ERC1155Standard } from './Standards/CollectibleStandards/ERC1155/ERC1155Standard';\nimport { ERC20Standard } from './Standards/ERC20Standard';\n\n/**\n * Check if token detection is enabled for certain networks\n *\n * @param chainId - ChainID of network\n * @returns Whether the current network supports token detection\n */\nexport const SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID: Record<string, string> = {\n  [SupportedTokenDetectionNetworks.mainnet]:\n    '0xb1f8e55c7f64d203c1400b9d8555d050f94adf39',\n  [SupportedTokenDetectionNetworks.bsc]:\n    '0x2352c63A83f9Fd126af8676146721Fa00924d7e4',\n  [SupportedTokenDetectionNetworks.polygon]:\n    '0x2352c63A83f9Fd126af8676146721Fa00924d7e4',\n  [SupportedTokenDetectionNetworks.avax]:\n    '0xD023D153a0DFa485130ECFdE2FAA7e612EF94818',\n};\n\nexport const MISSING_PROVIDER_ERROR =\n  'AssetsContractController failed to set the provider correctly. A provider must be set for this method to be available';\n\n/**\n * @type AssetsContractConfig\n *\n * Assets Contract controller configuration\n * @property provider - Provider used to create a new web3 instance\n */\nexport interface AssetsContractConfig extends BaseConfig {\n  provider: any;\n  ipfsGateway: string;\n  chainId: string;\n}\n\n/**\n * @type BalanceMap\n *\n * Key value object containing the balance for each tokenAddress\n * @property [tokenAddress] - Address of the token\n */\nexport interface BalanceMap {\n  [tokenAddress: string]: BN;\n}\n\n/**\n * Controller that interacts with contracts on mainnet through web3\n */\nexport class AssetsContractController extends BaseController<\n  AssetsContractConfig,\n  BaseState\n> {\n  private web3: any;\n\n  private erc721Standard?: ERC721Standard;\n\n  private erc1155Standard?: ERC1155Standard;\n\n  private erc20Standard?: ERC20Standard;\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'AssetsContractController';\n\n  /**\n   * Creates a AssetsContractController instance.\n   *\n   * @param options - The controller options.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      onPreferencesStateChange,\n      onNetworkStateChange,\n    }: {\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n    },\n    config?: Partial<AssetsContractConfig>,\n    state?: Partial<BaseState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      provider: undefined,\n      ipfsGateway: IPFS_DEFAULT_GATEWAY_URL,\n      chainId: SupportedTokenDetectionNetworks.mainnet,\n    };\n    this.initialize();\n\n    onPreferencesStateChange(({ ipfsGateway }) => {\n      this.configure({ ipfsGateway });\n    });\n\n    onNetworkStateChange((networkState) => {\n      if (this.config.chainId !== networkState.provider.chainId) {\n        this.configure({\n          chainId: networkState.provider.chainId,\n        });\n      }\n    });\n  }\n\n  /**\n   * Sets a new provider.\n   *\n   * TODO: Replace this wth a method.\n   *\n   * @property provider - Provider used to create a new underlying Web3 instance\n   */\n  set provider(provider: any) {\n    this.web3 = new Web3(provider);\n    this.erc721Standard = new ERC721Standard(this.web3);\n    this.erc1155Standard = new ERC1155Standard(this.web3);\n    this.erc20Standard = new ERC20Standard(this.web3);\n  }\n\n  get provider() {\n    throw new Error('Property only used for setting');\n  }\n\n  /**\n   * Get balance or count for current account on specific asset contract.\n   *\n   * @param address - Asset ERC20 contract address.\n   * @param selectedAddress - Current account public address.\n   * @returns Promise resolving to BN object containing balance for current account on specific asset contract.\n   */\n  async getERC20BalanceOf(\n    address: string,\n    selectedAddress: string,\n  ): Promise<BN> {\n    if (!this.erc20Standard) {\n      throw new Error(MISSING_PROVIDER_ERROR);\n    }\n    return this.erc20Standard.getBalanceOf(address, selectedAddress);\n  }\n\n  /**\n   * Query for the decimals for a given ERC20 asset.\n   *\n   * @param address - ERC20 asset contract address.\n   * @returns Promise resolving to the 'decimals'.\n   */\n  async getERC20TokenDecimals(address: string): Promise<string> {\n    if (this.erc20Standard === undefined) {\n      throw new Error(MISSING_PROVIDER_ERROR);\n    }\n    return await this.erc20Standard.getTokenDecimals(address);\n  }\n\n  /**\n   * Enumerate assets assigned to an owner.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param selectedAddress - Current account public address.\n   * @param index - A collectible counter less than `balanceOf(selectedAddress)`.\n   * @returns Promise resolving to token identifier for the 'index'th asset assigned to 'selectedAddress'.\n   */\n  getERC721CollectibleTokenId(\n    address: string,\n    selectedAddress: string,\n    index: number,\n  ): Promise<string> {\n    if (this.erc721Standard === undefined) {\n      throw new Error(MISSING_PROVIDER_ERROR);\n    }\n    return this.erc721Standard.getCollectibleTokenId(\n      address,\n      selectedAddress,\n      index,\n    );\n  }\n\n  /**\n   * Enumerate assets assigned to an owner.\n   *\n   * @param tokenAddress - ERC721 asset contract address.\n   * @param userAddress - Current account public address.\n   * @param tokenId - ERC721 asset identifier.\n   * @returns Promise resolving to an object containing the token standard and a set of details which depend on which standard the token supports.\n   */\n  async getTokenStandardAndDetails(\n    tokenAddress: string,\n    userAddress?: string,\n    tokenId?: string,\n  ): Promise<{\n    standard: string;\n    tokenURI?: string | undefined;\n    symbol?: string | undefined;\n    name?: string | undefined;\n    decimals?: string | undefined;\n    balance?: BN | undefined;\n  }> {\n    if (\n      this.erc721Standard === undefined ||\n      this.erc1155Standard === undefined ||\n      this.erc20Standard === undefined\n    ) {\n      throw new Error(MISSING_PROVIDER_ERROR);\n    }\n\n    const { ipfsGateway } = this.config;\n\n    // ERC721\n    try {\n      return {\n        ...(await this.erc721Standard.getDetails(\n          tokenAddress,\n          ipfsGateway,\n          tokenId,\n        )),\n      };\n    } catch {\n      // Ignore\n    }\n\n    // ERC1155\n    try {\n      return {\n        ...(await this.erc1155Standard.getDetails(\n          tokenAddress,\n          ipfsGateway,\n          tokenId,\n        )),\n      };\n    } catch {\n      // Ignore\n    }\n\n    // ERC20\n    try {\n      return {\n        ...(await this.erc20Standard.getDetails(tokenAddress, userAddress)),\n      };\n    } catch {\n      // Ignore\n    }\n\n    throw new Error('Unable to determine contract standard');\n  }\n\n  /**\n   * Query for tokenURI for a given ERC721 asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param tokenId - ERC721 asset identifier.\n   * @returns Promise resolving to the 'tokenURI'.\n   */\n  async getERC721TokenURI(address: string, tokenId: string): Promise<string> {\n    if (this.erc721Standard === undefined) {\n      throw new Error(MISSING_PROVIDER_ERROR);\n    }\n    return this.erc721Standard.getTokenURI(address, tokenId);\n  }\n\n  /**\n   * Query for name for a given asset.\n   *\n   * @param address - ERC721 or ERC20 asset contract address.\n   * @returns Promise resolving to the 'name'.\n   */\n  async getERC721AssetName(address: string): Promise<string> {\n    if (this.erc721Standard === undefined) {\n      throw new Error(MISSING_PROVIDER_ERROR);\n    }\n    return this.erc721Standard.getAssetName(address);\n  }\n\n  /**\n   * Query for symbol for a given asset.\n   *\n   * @param address - ERC721 or ERC20 asset contract address.\n   * @returns Promise resolving to the 'symbol'.\n   */\n  async getERC721AssetSymbol(address: string): Promise<string> {\n    if (this.erc721Standard === undefined) {\n      throw new Error(MISSING_PROVIDER_ERROR);\n    }\n    return this.erc721Standard.getAssetSymbol(address);\n  }\n\n  /**\n   * Query for owner for a given ERC721 asset.\n   *\n   * @param address - ERC721 asset contract address.\n   * @param tokenId - ERC721 asset identifier.\n   * @returns Promise resolving to the owner address.\n   */\n  async getERC721OwnerOf(address: string, tokenId: string): Promise<string> {\n    if (this.erc721Standard === undefined) {\n      throw new Error(MISSING_PROVIDER_ERROR);\n    }\n    return this.erc721Standard.getOwnerOf(address, tokenId);\n  }\n\n  /**\n   * Query for tokenURI for a given asset.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @param tokenId - ERC1155 asset identifier.\n   * @returns Promise resolving to the 'tokenURI'.\n   */\n  async getERC1155TokenURI(address: string, tokenId: string): Promise<string> {\n    if (this.erc1155Standard === undefined) {\n      throw new Error(MISSING_PROVIDER_ERROR);\n    }\n    return this.erc1155Standard.getTokenURI(address, tokenId);\n  }\n\n  /**\n   * Query for balance of a given ERC 1155 token.\n   *\n   * @param userAddress - Wallet public address.\n   * @param collectibleAddress - ERC1155 asset contract address.\n   * @param collectibleId - ERC1155 asset identifier.\n   * @returns Promise resolving to the 'balanceOf'.\n   */\n  async getERC1155BalanceOf(\n    userAddress: string,\n    collectibleAddress: string,\n    collectibleId: string,\n  ): Promise<number> {\n    if (this.erc1155Standard === undefined) {\n      throw new Error(MISSING_PROVIDER_ERROR);\n    }\n    return await this.erc1155Standard.getBalanceOf(\n      collectibleAddress,\n      userAddress,\n      collectibleId,\n    );\n  }\n\n  /**\n   * Transfer single ERC1155 token.\n   *\n   * @param collectibleAddress - ERC1155 token address.\n   * @param senderAddress - ERC1155 token sender.\n   * @param recipientAddress - ERC1155 token recipient.\n   * @param collectibleId - ERC1155 token id.\n   * @param qty - Quantity of tokens to be sent.\n   * @returns Promise resolving to the 'transferSingle' ERC1155 token.\n   */\n  async transferSingleERC1155(\n    collectibleAddress: string,\n    senderAddress: string,\n    recipientAddress: string,\n    collectibleId: string,\n    qty: string,\n  ): Promise<void> {\n    if (this.erc1155Standard === undefined) {\n      throw new Error(MISSING_PROVIDER_ERROR);\n    }\n    return await this.erc1155Standard.transferSingle(\n      collectibleAddress,\n      senderAddress,\n      recipientAddress,\n      collectibleId,\n      qty,\n    );\n  }\n\n  /**\n   * Get the token balance for a list of token addresses in a single call. Only non-zero balances\n   * are returned.\n   *\n   * @param selectedAddress - The address to check token balances for.\n   * @param tokensToDetect - The token addresses to detect balances for.\n   * @returns The list of non-zero token balances.\n   */\n  async getBalancesInSingleCall(\n    selectedAddress: string,\n    tokensToDetect: string[],\n  ) {\n    if (!(this.config.chainId in SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID)) {\n      // Only fetch balance if contract address exists\n      return {};\n    }\n    const contractAddress =\n      SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID[this.config.chainId];\n\n    const contract = this.web3.eth\n      .contract(abiSingleCallBalancesContract)\n      .at(contractAddress);\n    return new Promise<BalanceMap>((resolve, reject) => {\n      contract.balances(\n        [selectedAddress],\n        tokensToDetect,\n        (error: Error, result: BN[]) => {\n          /* istanbul ignore if */\n          if (error) {\n            reject(error);\n            return;\n          }\n          const nonZeroBalances: BalanceMap = {};\n          /* istanbul ignore else */\n          if (result.length > 0) {\n            tokensToDetect.forEach((tokenAddress, index) => {\n              const balance: BN = result[index];\n              /* istanbul ignore else */\n              if (String(balance) !== '0') {\n                nonZeroBalances[tokenAddress] = balance;\n              }\n            });\n          }\n          resolve(nonZeroBalances);\n        },\n      );\n    });\n  }\n}\n\nexport default AssetsContractController;\n"]}