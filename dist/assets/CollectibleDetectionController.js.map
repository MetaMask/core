{"version":3,"file":"CollectibleDetectionController.js","sourceRoot":"","sources":["../../src/assets/CollectibleDetectionController.ts"],"names":[],"mappings":"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","sourcesContent":["import { BaseController, BaseConfig, BaseState } from '../BaseController';\nimport type { NetworkState, NetworkType } from '../network/NetworkController';\nimport type { PreferencesState } from '../user/PreferencesController';\nimport { safelyExecute, timeoutFetch, toChecksumHexAddress } from '../util';\nimport { MAINNET } from '../constants';\nimport type {\n  CollectiblesController,\n  CollectiblesState,\n  CollectibleMetadata,\n} from './CollectiblesController';\n\nconst DEFAULT_INTERVAL = 180000;\n\n/**\n * @type ApiCollectible\n *\n * Collectible object coming from OpenSea api\n * @property token_id - The collectible identifier\n * @property num_sales - Number of sales\n * @property background_color - The background color to be displayed with the item\n * @property image_url - URI of an image associated with this collectible\n * @property image_preview_url - URI of a smaller image associated with this collectible\n * @property image_thumbnail_url - URI of a thumbnail image associated with this collectible\n * @property image_original_url - URI of the original image associated with this collectible\n * @property animation_url - URI of a animation associated with this collectible\n * @property animation_original_url - URI of the original animation associated with this collectible\n * @property name - The collectible name\n * @property description - The collectible description\n * @property external_link - External link containing additional information\n * @property assetContract - The collectible contract information object\n * @property creator - The collectible owner information object\n * @property lastSale - When this item was last sold\n */\nexport interface ApiCollectible {\n  token_id: string;\n  num_sales: number | null;\n  background_color: string | null;\n  image_url: string | null;\n  image_preview_url: string | null;\n  image_thumbnail_url: string | null;\n  image_original_url: string | null;\n  animation_url: string | null;\n  animation_original_url: string | null;\n  name: string | null;\n  description: string | null;\n  external_link: string | null;\n  asset_contract: ApiCollectibleContract;\n  creator: ApiCollectibleCreator;\n  last_sale: ApiCollectibleLastSale | null;\n}\n\n/**\n * @type ApiCollectibleContract\n *\n * Collectible contract object coming from OpenSea api\n * @property address - Address of the collectible contract\n * @property asset_contract_type - The collectible type, it could be `semi-fungible` or `non-fungible`\n * @property created_date - Creation date\n * @property collection - Object containing the contract name and URI of an image associated\n * @property schema_name - The schema followed by the contract, it could be `ERC721` or `ERC1155`\n * @property symbol - The collectible contract symbol\n * @property total_supply - Total supply of collectibles\n * @property description - The collectible contract description\n * @property external_link - External link containing additional information\n */\nexport interface ApiCollectibleContract {\n  address: string;\n  asset_contract_type: string | null;\n  created_date: string | null;\n  schema_name: string | null;\n  symbol: string | null;\n  total_supply: string | null;\n  description: string | null;\n  external_link: string | null;\n  collection: {\n    name: string | null;\n    image_url?: string | null;\n  };\n}\n\n/**\n * @type ApiCollectibleLastSale\n *\n * Collectible sale object coming from OpenSea api\n * @property event_timestamp - Object containing a `username`\n * @property total_price - URI of collectible image associated with this owner\n * @property transaction - Object containing transaction_hash and block_hash\n */\nexport interface ApiCollectibleLastSale {\n  event_timestamp: string;\n  total_price: string;\n  transaction: { transaction_hash: string; block_hash: string };\n}\n\n/**\n * @type ApiCollectibleCreator\n *\n * Collectible creator object coming from OpenSea api\n * @property user - Object containing a `username`\n * @property profile_img_url - URI of collectible image associated with this owner\n * @property address - The owner address\n */\nexport interface ApiCollectibleCreator {\n  user: { username: string };\n  profile_img_url: string;\n  address: string;\n}\n\n/**\n * @type CollectibleDetectionConfig\n *\n * CollectibleDetection configuration\n * @property interval - Polling interval used to fetch new token rates\n * @property networkType - Network type ID as per net_version\n * @property selectedAddress - Vault selected address\n * @property tokens - List of tokens associated with the active vault\n */\nexport interface CollectibleDetectionConfig extends BaseConfig {\n  interval: number;\n  networkType: NetworkType;\n  chainId: `0x${string}` | `${number}` | number;\n  selectedAddress: string;\n}\n\n/**\n * Controller that passively polls on a set interval for Collectibles auto detection\n */\nexport class CollectibleDetectionController extends BaseController<\n  CollectibleDetectionConfig,\n  BaseState\n> {\n  private intervalId?: NodeJS.Timeout;\n\n  private getOwnerCollectiblesApi(address: string, offset: number) {\n    return `https://api.opensea.io/api/v1/assets?owner=${address}&offset=${offset}&limit=50`;\n  }\n\n  private async getOwnerCollectibles(address: string) {\n    let response: Response;\n    let collectibles: any = [];\n    const openSeaApiKey = this.getOpenSeaApiKey();\n    try {\n      let offset = 0;\n      let pagingFinish = false;\n      /* istanbul ignore if */\n      do {\n        const api = this.getOwnerCollectiblesApi(address, offset);\n        response = await timeoutFetch(\n          api,\n          openSeaApiKey ? { headers: { 'X-API-KEY': openSeaApiKey } } : {},\n          15000,\n        );\n        const collectiblesArray = await response.json();\n        collectiblesArray.assets?.length !== 0\n          ? (collectibles = [...collectibles, ...collectiblesArray.assets])\n          : (pagingFinish = true);\n        offset += 50;\n      } while (!pagingFinish);\n    } catch (e) {\n      /* istanbul ignore next */\n      return [];\n    }\n    return collectibles;\n  }\n\n  /**\n   * Name of this controller used during composition\n   */\n  name = 'CollectibleDetectionController';\n\n  private getOpenSeaApiKey: () => string | undefined;\n\n  private addCollectible: CollectiblesController['addCollectible'];\n\n  private getCollectiblesState: () => CollectiblesState;\n\n  /**\n   * Creates a CollectibleDetectionController instance.\n   *\n   * @param options - The controller options.\n   * @param options.onCollectiblesStateChange - Allows subscribing to assets controller state changes.\n   * @param options.onPreferencesStateChange - Allows subscribing to preferences controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.getOpenSeaApiKey - Gets the OpenSea API key, if one is set.\n   * @param options.addCollectible - Add a collectible.\n   * @param options.getCollectiblesState - Gets the current state of the Assets controller.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      onPreferencesStateChange,\n      onNetworkStateChange,\n      getOpenSeaApiKey,\n      addCollectible,\n      getCollectiblesState,\n    }: {\n      onCollectiblesStateChange: (\n        listener: (collectiblesState: CollectiblesState) => void,\n      ) => void;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      getOpenSeaApiKey: () => string | undefined;\n      addCollectible: CollectiblesController['addCollectible'];\n      getCollectiblesState: () => CollectiblesState;\n    },\n    config?: Partial<CollectibleDetectionConfig>,\n    state?: Partial<BaseState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      interval: DEFAULT_INTERVAL,\n      networkType: MAINNET,\n      chainId: '1',\n      selectedAddress: '',\n      disabled: true,\n    };\n    this.initialize();\n    this.getCollectiblesState = getCollectiblesState;\n    onPreferencesStateChange(({ selectedAddress, useCollectibleDetection }) => {\n      const {\n        selectedAddress: previouslySelectedAddress,\n        disabled,\n      } = this.config;\n\n      if (\n        selectedAddress !== previouslySelectedAddress ||\n        !useCollectibleDetection !== disabled\n      ) {\n        this.configure({ selectedAddress, disabled: !useCollectibleDetection });\n        this.detectCollectibles();\n      }\n\n      if (!useCollectibleDetection) {\n        this.stop();\n      }\n    });\n\n    onNetworkStateChange(({ provider }) => {\n      this.configure({\n        networkType: provider.type,\n        chainId: provider.chainId as CollectibleDetectionConfig['chainId'],\n      });\n    });\n    this.getOpenSeaApiKey = getOpenSeaApiKey;\n    this.addCollectible = addCollectible;\n  }\n\n  /**\n   * Start polling for the currency rate.\n   */\n  async start() {\n    if (!this.isMainnet() || this.disabled) {\n      return;\n    }\n\n    await this.startPolling();\n  }\n\n  /**\n   * Stop polling for the currency rate.\n   */\n  stop() {\n    this.stopPolling();\n  }\n\n  private stopPolling() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n\n  /**\n   * Starts a new polling interval.\n   *\n   * @param interval - An interval on which to poll.\n   */\n  private async startPolling(interval?: number): Promise<void> {\n    interval && this.configure({ interval }, false, false);\n    this.stopPolling();\n    await this.detectCollectibles();\n    this.intervalId = setInterval(async () => {\n      await this.detectCollectibles();\n    }, this.config.interval);\n  }\n\n  /**\n   * Checks whether network is mainnet or not.\n   *\n   * @returns Whether current network is mainnet.\n   */\n  isMainnet = (): boolean => this.config.networkType === MAINNET;\n\n  /**\n   * Triggers asset ERC721 token auto detection on mainnet. Any newly detected collectibles are\n   * added.\n   */\n  async detectCollectibles() {\n    /* istanbul ignore if */\n    if (!this.isMainnet() || this.disabled) {\n      return;\n    }\n    const { selectedAddress, chainId } = this.config;\n\n    /* istanbul ignore else */\n    if (!selectedAddress) {\n      return;\n    }\n\n    await safelyExecute(async () => {\n      const apiCollectibles = await this.getOwnerCollectibles(selectedAddress);\n      const addCollectiblesPromises = apiCollectibles.map(\n        async (collectible: ApiCollectible) => {\n          const {\n            token_id,\n            num_sales,\n            background_color,\n            image_url,\n            image_preview_url,\n            image_thumbnail_url,\n            image_original_url,\n            animation_url,\n            animation_original_url,\n            name,\n            description,\n            external_link,\n            creator,\n            asset_contract: { address, schema_name },\n            last_sale,\n          } = collectible;\n\n          let ignored;\n          /* istanbul ignore else */\n          const { ignoredCollectibles } = this.getCollectiblesState();\n          if (ignoredCollectibles.length) {\n            ignored = ignoredCollectibles.find((c) => {\n              /* istanbul ignore next */\n              return (\n                c.address === toChecksumHexAddress(address) &&\n                c.tokenId === token_id\n              );\n            });\n          }\n\n          /* istanbul ignore else */\n          if (!ignored) {\n            /* istanbul ignore next */\n            const collectibleMetadata: CollectibleMetadata = Object.assign(\n              {},\n              { name },\n              creator && { creator },\n              description && { description },\n              image_url && { image: image_url },\n              num_sales && { numberOfSales: num_sales },\n              background_color && { backgroundColor: background_color },\n              image_preview_url && { imagePreview: image_preview_url },\n              image_thumbnail_url && { imageThumbnail: image_thumbnail_url },\n              image_original_url && { imageOriginal: image_original_url },\n              animation_url && { animation: animation_url },\n              animation_original_url && {\n                animationOriginal: animation_original_url,\n              },\n              schema_name && { standard: schema_name },\n              external_link && { externalLink: external_link },\n              last_sale && { lastSale: last_sale },\n            );\n            await this.addCollectible(address, token_id, collectibleMetadata, {\n              userAddress: selectedAddress,\n              chainId: chainId as string,\n            });\n          }\n        },\n      );\n      await Promise.all(addCollectiblesPromises);\n    });\n  }\n}\n\nexport default CollectibleDetectionController;\n"]}