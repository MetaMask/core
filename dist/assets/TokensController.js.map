{"version":3,"file":"TokensController.js","sourceRoot":"","sources":["../../src/assets/TokensController.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events';\nimport contractsMap from '@metamask/contract-metadata';\nimport { abiERC721 } from 'metamask-eth-abis';\nimport { v1 as random } from 'uuid';\nimport { Mutex } from 'async-mutex';\nimport { ethers } from 'ethers';\nimport { BaseController, BaseConfig, BaseState } from '../BaseController';\nimport type { PreferencesState } from '../user/PreferencesController';\nimport type { NetworkState, NetworkType } from '../network/NetworkController';\nimport { validateTokenToWatch, toChecksumHexAddress } from '../util';\nimport { MAINNET } from '../constants';\nimport type { Token } from './TokenRatesController';\n\nconst ERC721_INTERFACE_ID = '0x80ac58cd';\n/**\n * @type TokensConfig\n *\n * Tokens controller configuration\n * @property networkType - Network ID as per net_version\n * @property selectedAddress - Vault selected address\n */\nexport interface TokensConfig extends BaseConfig {\n  networkType: NetworkType;\n  selectedAddress: string;\n  chainId: string;\n  provider: any;\n}\n\n/**\n * @type AssetSuggestionResult\n * @property result - Promise resolving to a new suggested asset address\n * @property suggestedAssetMeta - Meta information about this new suggested asset\n */\ninterface AssetSuggestionResult {\n  result: Promise<string>;\n  suggestedAssetMeta: SuggestedAssetMeta;\n}\n\nenum SuggestedAssetStatus {\n  accepted = 'accepted',\n  failed = 'failed',\n  pending = 'pending',\n  rejected = 'rejected',\n}\n\nexport type SuggestedAssetMetaBase = {\n  id: string;\n  time: number;\n  type: string;\n  asset: Token;\n};\n\n/**\n * @type SuggestedAssetMeta\n *\n * Suggested asset by EIP747 meta data\n * @property error - Synthesized error information for failed asset suggestions\n * @property id - Generated UUID associated with this suggested asset\n * @property status - String status of this this suggested asset\n * @property time - Timestamp associated with this this suggested asset\n * @property type - Type type this suggested asset\n * @property asset - Asset suggested object\n */\nexport type SuggestedAssetMeta =\n  | (SuggestedAssetMetaBase & {\n      status: SuggestedAssetStatus.failed;\n      error: Error;\n    })\n  | (SuggestedAssetMetaBase & {\n      status:\n        | SuggestedAssetStatus.accepted\n        | SuggestedAssetStatus.rejected\n        | SuggestedAssetStatus.pending;\n    });\n\n/**\n * @type TokensState\n *\n * Assets controller state\n * @property allTokens - Object containing tokens by network and account\n * @property suggestedAssets - List of pending suggested assets to be added or canceled\n * @property tokens - List of tokens associated with the active network and address pair\n * @property ignoredTokens - List of ignoredTokens associated with the active network and address pair\n * @property allIgnoredTokens - Object containing hidden/ignored tokens by network and account\n */\nexport interface TokensState extends BaseState {\n  allTokens: { [key: string]: { [key: string]: Token[] } };\n  allIgnoredTokens: { [key: string]: { [key: string]: string[] } };\n  ignoredTokens: string[];\n  suggestedAssets: SuggestedAssetMeta[];\n  tokens: Token[];\n}\n\n/**\n * Controller that stores assets and exposes convenience methods\n */\nexport class TokensController extends BaseController<\n  TokensConfig,\n  TokensState\n> {\n  private mutex = new Mutex();\n\n  private ethersProvider: any;\n\n  private failSuggestedAsset(\n    suggestedAssetMeta: SuggestedAssetMeta,\n    error: Error,\n  ) {\n    const failedSuggestedAssetMeta = {\n      ...suggestedAssetMeta,\n      status: SuggestedAssetStatus.failed,\n      error,\n    };\n    this.hub.emit(\n      `${suggestedAssetMeta.id}:finished`,\n      failedSuggestedAssetMeta,\n    );\n  }\n\n  /**\n   * EventEmitter instance used to listen to specific EIP747 events\n   */\n  hub = new EventEmitter();\n\n  /**\n   * Name of this controller used during composition\n   */\n  name = 'TokensController';\n\n  /**\n   * Creates a TokensController instance.\n   *\n   * @param options - The controller options.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.config - Initial options used to configure this controller.\n   * @param options.state - Initial state to set on this controller.\n   */\n  constructor({\n    onPreferencesStateChange,\n    onNetworkStateChange,\n    config,\n    state,\n  }: {\n    onPreferencesStateChange: (\n      listener: (preferencesState: PreferencesState) => void,\n    ) => void;\n    onNetworkStateChange: (\n      listener: (networkState: NetworkState) => void,\n    ) => void;\n    config?: Partial<TokensConfig>;\n    state?: Partial<TokensState>;\n  }) {\n    super(config, state);\n\n    this.defaultConfig = {\n      networkType: MAINNET,\n      selectedAddress: '',\n      chainId: '',\n      provider: undefined,\n      ...config,\n    };\n\n    this.defaultState = {\n      allTokens: {},\n      allIgnoredTokens: {},\n      ignoredTokens: [],\n      suggestedAssets: [],\n      tokens: [],\n      ...state,\n    };\n\n    this.initialize();\n\n    onPreferencesStateChange(({ selectedAddress }) => {\n      const { allTokens, allIgnoredTokens } = this.state;\n      const { chainId } = this.config;\n      this.configure({ selectedAddress });\n      this.update({\n        tokens: allTokens[chainId]?.[selectedAddress] || [],\n        ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] || [],\n      });\n    });\n\n    onNetworkStateChange(({ provider }) => {\n      const { allTokens, allIgnoredTokens } = this.state;\n      const { selectedAddress } = this.config;\n      const { chainId } = provider;\n      this.configure({ chainId });\n      this.ethersProvider = this._instantiateNewEthersProvider();\n      this.update({\n        tokens: allTokens[chainId]?.[selectedAddress] || [],\n        ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] || [],\n      });\n    });\n  }\n\n  _instantiateNewEthersProvider(): any {\n    return new ethers.providers.Web3Provider(this.config?.provider);\n  }\n\n  /**\n   * Adds a token to the stored token list.\n   *\n   * @param address - Hex address of the token contract.\n   * @param symbol - Symbol of the token.\n   * @param decimals - Number of decimals the token uses.\n   * @param image - Image of the token.\n   * @returns Current token list.\n   */\n  async addToken(\n    address: string,\n    symbol: string,\n    decimals: number,\n    image?: string,\n  ): Promise<Token[]> {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      address = toChecksumHexAddress(address);\n      const { tokens, ignoredTokens } = this.state;\n      const isERC721 = await this._detectIsERC721(address);\n      const newEntry: Token = { address, symbol, decimals, image, isERC721 };\n      const previousEntry = tokens.find(\n        (token) => token.address.toLowerCase() === address.toLowerCase(),\n      );\n      if (previousEntry) {\n        const previousIndex = tokens.indexOf(previousEntry);\n        tokens[previousIndex] = newEntry;\n      } else {\n        tokens.push(newEntry);\n      }\n\n      const newIgnoredTokens = ignoredTokens.filter(\n        (tokenAddress) => tokenAddress.toLowerCase() !== address.toLowerCase(),\n      );\n      const { newAllTokens, newAllIgnoredTokens } = this._getNewAllTokensState(\n        tokens,\n        newIgnoredTokens,\n      );\n\n      this.update({\n        allTokens: newAllTokens,\n        tokens,\n        allIgnoredTokens: newAllIgnoredTokens,\n        ignoredTokens: newIgnoredTokens,\n      });\n      return tokens;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Adds a batch of tokens to the stored token list.\n   *\n   * @param tokensToAdd - Array of Tokens to be added or updated.\n   * @returns Current token list.\n   */\n  async addTokens(tokensToAdd: Token[]): Promise<Token[]> {\n    const releaseLock = await this.mutex.acquire();\n    const { tokens, ignoredTokens } = this.state;\n\n    try {\n      tokensToAdd = await Promise.all(\n        tokensToAdd.map(async (token) => {\n          token.isERC721 = await this._detectIsERC721(token.address);\n          return token;\n        }),\n      );\n\n      let newIgnoredTokens = ignoredTokens;\n\n      tokensToAdd.forEach((tokenToAdd) => {\n        const { address, symbol, decimals, image, isERC721 } = tokenToAdd;\n        const checksumAddress = toChecksumHexAddress(address);\n        const newEntry: Token = {\n          address: checksumAddress,\n          symbol,\n          decimals,\n          image,\n          isERC721,\n        };\n        const previousEntry = tokens.find(\n          (token) =>\n            token.address.toLowerCase() === checksumAddress.toLowerCase(),\n        );\n        if (previousEntry) {\n          const previousIndex = tokens.indexOf(previousEntry);\n          tokens[previousIndex] = newEntry;\n        } else {\n          tokens.push(newEntry);\n        }\n\n        newIgnoredTokens = newIgnoredTokens.filter(\n          (tokenAddress) =>\n            tokenAddress.toLowerCase() !== address.toLowerCase(),\n        );\n      });\n\n      const { newAllTokens, newAllIgnoredTokens } = this._getNewAllTokensState(\n        tokens,\n        newIgnoredTokens,\n      );\n\n      this.update({\n        tokens,\n        allTokens: newAllTokens,\n        allIgnoredTokens: newAllIgnoredTokens,\n        ignoredTokens: newIgnoredTokens,\n      });\n\n      return tokens;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Adds isERC721 field to token object. This is called when a user attempts to add tokens that\n   * were previously added which do not yet had isERC721 field.\n   *\n   * @param tokenAddress - The contract address of the token requiring the isERC721 field added.\n   * @returns The new token object with the added isERC721 field.\n   */\n  async updateTokenType(tokenAddress: string) {\n    const isERC721 = await this._detectIsERC721(tokenAddress);\n    const { tokens } = this.state;\n    const tokenIndex = tokens.findIndex((token) => {\n      return token.address.toLowerCase() === tokenAddress.toLowerCase();\n    });\n    tokens[tokenIndex].isERC721 = isERC721;\n    this.update({ tokens });\n    return tokens[tokenIndex];\n  }\n\n  /**\n   * Detects whether or not a token is ERC-721 compatible.\n   *\n   * @param tokenAddress - The token contract address.\n   * @returns A boolean indicating whether the token address passed in supports the EIP-721\n   * interface.\n   */\n  async _detectIsERC721(tokenAddress: string) {\n    const checksumAddress = toChecksumHexAddress(tokenAddress);\n    // if this token is already in our contract metadata map we don't need\n    // to check against the contract\n    if (contractsMap[checksumAddress]?.erc721 === true) {\n      return Promise.resolve(true);\n    } else if (contractsMap[checksumAddress]?.erc20 === true) {\n      return Promise.resolve(false);\n    }\n\n    const tokenContract = await this._createEthersContract(\n      tokenAddress,\n      abiERC721,\n      this.ethersProvider,\n    );\n    try {\n      return await tokenContract.supportsInterface(ERC721_INTERFACE_ID);\n    } catch (error: any) {\n      // currently we see a variety of errors across different networks when\n      // token contracts are not ERC721 compatible. We need to figure out a better\n      // way of differentiating token interface types but for now if we get an error\n      // we have to assume the token is not ERC721 compatible.\n      return false;\n    }\n  }\n\n  async _createEthersContract(\n    tokenAddress: string,\n    abi: string,\n    ethersProvider: any,\n  ): Promise<any> {\n    const tokenContract = await new ethers.Contract(\n      tokenAddress,\n      abi,\n      ethersProvider,\n    );\n    return tokenContract;\n  }\n\n  _generateRandomId(): string {\n    return random();\n  }\n\n  /**\n   * Adds a new suggestedAsset to state. Parameters will be validated according to\n   * asset type being watched. A `<suggestedAssetMeta.id>:pending` hub event will be emitted once added.\n   *\n   * @param asset - The asset to be watched. For now only ERC20 tokens are accepted.\n   * @param type - The asset type.\n   * @returns Object containing a Promise resolving to the suggestedAsset address if accepted.\n   */\n  async watchAsset(asset: Token, type: string): Promise<AssetSuggestionResult> {\n    const suggestedAssetMeta = {\n      asset,\n      id: this._generateRandomId(),\n      status: SuggestedAssetStatus.pending as SuggestedAssetStatus.pending,\n      time: Date.now(),\n      type,\n    };\n    try {\n      switch (type) {\n        case 'ERC20':\n          validateTokenToWatch(asset);\n          break;\n        default:\n          throw new Error(`Asset of type ${type} not supported`);\n      }\n    } catch (error) {\n      this.failSuggestedAsset(suggestedAssetMeta, error);\n      return Promise.reject(error);\n    }\n\n    const result: Promise<string> = new Promise((resolve, reject) => {\n      this.hub.once(\n        `${suggestedAssetMeta.id}:finished`,\n        (meta: SuggestedAssetMeta) => {\n          switch (meta.status) {\n            case SuggestedAssetStatus.accepted:\n              return resolve(meta.asset.address);\n            case SuggestedAssetStatus.rejected:\n              return reject(new Error('User rejected to watch the asset.'));\n            case SuggestedAssetStatus.failed:\n              return reject(new Error(meta.error.message));\n            /* istanbul ignore next */\n            default:\n              return reject(new Error(`Unknown status: ${meta.status}`));\n          }\n        },\n      );\n    });\n\n    const { suggestedAssets } = this.state;\n    suggestedAssets.push(suggestedAssetMeta);\n    this.update({ suggestedAssets: [...suggestedAssets] });\n    this.hub.emit('pendingSuggestedAsset', suggestedAssetMeta);\n    return { result, suggestedAssetMeta };\n  }\n\n  /**\n   * Accepts to watch an asset and updates it's status and deletes the suggestedAsset from state,\n   * adding the asset to corresponding asset state. In this case ERC20 tokens.\n   * A `<suggestedAssetMeta.id>:finished` hub event is fired after accepted or failure.\n   *\n   * @param suggestedAssetID - The ID of the suggestedAsset to accept.\n   */\n  async acceptWatchAsset(suggestedAssetID: string): Promise<void> {\n    const { suggestedAssets } = this.state;\n    const index = suggestedAssets.findIndex(\n      ({ id }) => suggestedAssetID === id,\n    );\n    const suggestedAssetMeta = suggestedAssets[index];\n    try {\n      switch (suggestedAssetMeta.type) {\n        case 'ERC20':\n          const { address, symbol, decimals, image } = suggestedAssetMeta.asset;\n          await this.addToken(address, symbol, decimals, image);\n          suggestedAssetMeta.status = SuggestedAssetStatus.accepted;\n          this.hub.emit(\n            `${suggestedAssetMeta.id}:finished`,\n            suggestedAssetMeta,\n          );\n          break;\n        default:\n          throw new Error(\n            `Asset of type ${suggestedAssetMeta.type} not supported`,\n          );\n      }\n    } catch (error) {\n      this.failSuggestedAsset(suggestedAssetMeta, error);\n    }\n    const newSuggestedAssets = suggestedAssets.filter(\n      ({ id }) => id !== suggestedAssetID,\n    );\n    this.update({ suggestedAssets: [...newSuggestedAssets] });\n  }\n\n  /**\n   * Rejects a watchAsset request based on its ID by setting its status to \"rejected\"\n   * and emitting a `<suggestedAssetMeta.id>:finished` hub event.\n   *\n   * @param suggestedAssetID - The ID of the suggestedAsset to accept.\n   */\n  rejectWatchAsset(suggestedAssetID: string) {\n    const { suggestedAssets } = this.state;\n    const index = suggestedAssets.findIndex(\n      ({ id }) => suggestedAssetID === id,\n    );\n    const suggestedAssetMeta = suggestedAssets[index];\n    if (!suggestedAssetMeta) {\n      return;\n    }\n    suggestedAssetMeta.status = SuggestedAssetStatus.rejected;\n    this.hub.emit(`${suggestedAssetMeta.id}:finished`, suggestedAssetMeta);\n    const newSuggestedAssets = suggestedAssets.filter(\n      ({ id }) => id !== suggestedAssetID,\n    );\n    this.update({ suggestedAssets: [...newSuggestedAssets] });\n  }\n\n  /**\n   * Removes a token from the stored token list and saves it in ignored tokens list.\n   *\n   * @param address - The hex address of the token contract.\n   */\n  removeAndIgnoreToken(address: string) {\n    address = toChecksumHexAddress(address);\n    const { tokens, ignoredTokens } = this.state;\n\n    const alreadyIgnored = ignoredTokens.find(\n      (tokenAddress) => tokenAddress.toLowerCase() === address.toLowerCase(),\n    );\n\n    const newTokens = tokens.filter((token) => {\n      if (token.address.toLowerCase() === address.toLowerCase()) {\n        !alreadyIgnored && ignoredTokens.push(address);\n        return false;\n      }\n      return true;\n    });\n\n    const { newAllTokens, newAllIgnoredTokens } = this._getNewAllTokensState(\n      newTokens,\n      ignoredTokens,\n    );\n\n    this.update({\n      allTokens: newAllTokens,\n      tokens: newTokens,\n      allIgnoredTokens: newAllIgnoredTokens,\n      ignoredTokens,\n    });\n  }\n\n  /**\n   * Takes a new tokens and ignoredTokens array for the current network/account combination\n   * and returns new allTokens and allIgnoredTokens state to update to.\n   *\n   * @param newTokens - The new tokens to set for the current network and selected account.\n   * @param newIgnoredTokens - The new ignored tokens to set for the current network and selected account.\n   * @returns The updated `allTokens` and `allIgnoredTokens` state.\n   */\n  _getNewAllTokensState(newTokens: Token[], newIgnoredTokens: string[]) {\n    const { allTokens, allIgnoredTokens } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const networkTokens = allTokens[chainId];\n    const networkIgnoredTokens = allIgnoredTokens[chainId];\n\n    const newNetworkTokens = {\n      ...networkTokens,\n      ...{ [selectedAddress]: newTokens },\n    };\n    const newIgnoredNetworkTokens = {\n      ...networkIgnoredTokens,\n      ...{ [selectedAddress]: newIgnoredTokens },\n    };\n\n    const newAllTokens = {\n      ...allTokens,\n      ...{ [chainId]: newNetworkTokens },\n    };\n\n    const newAllIgnoredTokens = {\n      ...allIgnoredTokens,\n      ...{ [chainId]: newIgnoredNetworkTokens },\n    };\n    return { newAllTokens, newAllIgnoredTokens };\n  }\n\n  /**\n   * Removes all tokens from the ignored list.\n   */\n  clearIgnoredTokens() {\n    this.update({ ignoredTokens: [], allIgnoredTokens: {} });\n  }\n}\n\nexport default TokensController;\n"]}