{"version":3,"file":"KeyringController.js","sourceRoot":"","sources":["../../src/keyring/KeyringController.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  addHexPrefix,\n  bufferToHex,\n  isValidPrivate,\n  toBuffer,\n} from 'ethereumjs-util';\nimport { stripHexPrefix } from 'ethjs-util';\nimport {\n  normalize as normalizeAddress,\n  signTypedData,\n  signTypedData_v4,\n  signTypedDataLegacy,\n} from 'eth-sig-util';\nimport Wallet, { thirdparty as importers } from 'ethereumjs-wallet';\nimport Keyring from 'eth-keyring-controller';\nimport { Mutex } from 'async-mutex';\nimport {\n  BaseController,\n  BaseConfig,\n  BaseState,\n  Listener,\n} from '../BaseController';\nimport { PreferencesController } from '../user/PreferencesController';\nimport { PersonalMessageParams } from '../message-manager/PersonalMessageManager';\nimport { TypedMessageParams } from '../message-manager/TypedMessageManager';\nimport { toChecksumHexAddress } from '../util';\n\nconst privates = new WeakMap();\n\n/**\n * Available keyring types\n */\nexport enum KeyringTypes {\n  simple = 'Simple Key Pair',\n  hd = 'HD Key Tree',\n}\n\n/**\n * @type KeyringObject\n *\n * Keyring object\n * @property type - Keyring type\n * @property accounts - Associated accounts\n * @function getAccounts - Get associated accounts\n */\nexport interface KeyringObject {\n  type: string;\n  accounts: string[];\n  getAccounts(): string[];\n}\n\n/**\n * @type KeyringState\n *\n * Keyring controller state\n * @property vault - Encrypted string representing keyring data\n * @property keyrings - Group of accounts\n */\nexport interface KeyringState extends BaseState {\n  vault?: string;\n  keyrings: Keyring[];\n}\n\n/**\n * @type KeyringMemState\n *\n * Keyring mem controller state\n * @property isUnlocked - Whether vault is unlocked\n * @property keyringTypes - Account types\n * @property keyrings - Group of accounts\n */\nexport interface KeyringMemState extends BaseState {\n  isUnlocked: boolean;\n  keyringTypes: string[];\n  keyrings: Keyring[];\n}\n\n/**\n * @type KeyringConfig\n *\n * Keyring controller configuration\n * @property encryptor - Keyring encryptor\n */\nexport interface KeyringConfig extends BaseConfig {\n  encryptor?: any;\n}\n\n/**\n * @type Keyring\n *\n * Keyring object to return in fullUpdate\n * @property type - Keyring type\n * @property accounts - Associated accounts\n * @property index - Associated index\n */\nexport interface Keyring {\n  accounts: string[];\n  type: string;\n  index?: number;\n}\n\n/**\n * A strategy for importing an account\n */\nexport enum AccountImportStrategy {\n  privateKey = 'privateKey',\n  json = 'json',\n}\n\n/**\n * The `signTypedMessage` version\n *\n * @see https://docs.metamask.io/guide/signing-data.html\n */\nexport enum SignTypedDataVersion {\n  V1 = 'V1',\n  V3 = 'V3',\n  V4 = 'V4',\n}\n\n/**\n * Controller responsible for establishing and managing user identity\n */\nexport class KeyringController extends BaseController<\n  KeyringConfig,\n  KeyringState\n> {\n  private mutex = new Mutex();\n\n  /**\n   * Name of this controller used during composition\n   */\n  name = 'KeyringController';\n\n  private removeIdentity: PreferencesController['removeIdentity'];\n\n  private syncIdentities: PreferencesController['syncIdentities'];\n\n  private updateIdentities: PreferencesController['updateIdentities'];\n\n  private setSelectedAddress: PreferencesController['setSelectedAddress'];\n\n  /**\n   * Creates a KeyringController instance.\n   *\n   * @param options - The controller options.\n   * @param options.removeIdentity - Remove the identity with the given address.\n   * @param options.syncIdentities - Sync identities with the given list of addresses.\n   * @param options.updateIdentities - Generate an identity for each address given that doesn't already have an identity.\n   * @param options.setSelectedAddress - Set the selected address.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      removeIdentity,\n      syncIdentities,\n      updateIdentities,\n      setSelectedAddress,\n    }: {\n      removeIdentity: PreferencesController['removeIdentity'];\n      syncIdentities: PreferencesController['syncIdentities'];\n      updateIdentities: PreferencesController['updateIdentities'];\n      setSelectedAddress: PreferencesController['setSelectedAddress'];\n    },\n    config?: Partial<KeyringConfig>,\n    state?: Partial<KeyringState>,\n  ) {\n    super(config, state);\n    privates.set(this, {\n      keyring: new Keyring(Object.assign({ initState: state }, config)),\n    });\n\n    this.defaultState = {\n      ...privates.get(this).keyring.store.getState(),\n      keyrings: [],\n    };\n    this.removeIdentity = removeIdentity;\n    this.syncIdentities = syncIdentities;\n    this.updateIdentities = updateIdentities;\n    this.setSelectedAddress = setSelectedAddress;\n    this.initialize();\n    this.fullUpdate();\n  }\n\n  /**\n   * Adds a new account to the default (first) HD seed phrase keyring.\n   *\n   * @returns Promise resolving to current state when the account is added.\n   */\n  async addNewAccount(): Promise<KeyringMemState> {\n    const primaryKeyring = privates\n      .get(this)\n      .keyring.getKeyringsByType('HD Key Tree')[0];\n    /* istanbul ignore if */\n    if (!primaryKeyring) {\n      throw new Error('No HD keyring found');\n    }\n    const oldAccounts = await privates.get(this).keyring.getAccounts();\n    await privates.get(this).keyring.addNewAccount(primaryKeyring);\n    const newAccounts = await privates.get(this).keyring.getAccounts();\n\n    await this.verifySeedPhrase();\n\n    this.updateIdentities(newAccounts);\n    newAccounts.forEach((selectedAddress: string) => {\n      if (!oldAccounts.includes(selectedAddress)) {\n        this.setSelectedAddress(selectedAddress);\n      }\n    });\n    return this.fullUpdate();\n  }\n\n  /**\n   * Adds a new account to the default (first) HD seed phrase keyring without updating identities in preferences.\n   *\n   * @returns Promise resolving to current state when the account is added.\n   */\n  async addNewAccountWithoutUpdate(): Promise<KeyringMemState> {\n    const primaryKeyring = privates\n      .get(this)\n      .keyring.getKeyringsByType('HD Key Tree')[0];\n    /* istanbul ignore if */\n    if (!primaryKeyring) {\n      throw new Error('No HD keyring found');\n    }\n    await privates.get(this).keyring.addNewAccount(primaryKeyring);\n    await this.verifySeedPhrase();\n    return this.fullUpdate();\n  }\n\n  /**\n   * Effectively the same as creating a new keychain then populating it\n   * using the given seed phrase.\n   *\n   * @param password - Password to unlock keychain.\n   * @param seed - Seed phrase to restore keychain.\n   * @returns Promise resolving to th restored keychain object.\n   */\n  async createNewVaultAndRestore(password: string, seed: string) {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      this.updateIdentities([]);\n      const vault = await privates\n        .get(this)\n        .keyring.createNewVaultAndRestore(password, seed);\n      this.updateIdentities(await privates.get(this).keyring.getAccounts());\n      this.fullUpdate();\n      return vault;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Create a new primary keychain and wipe any previous keychains.\n   *\n   * @param password - Password to unlock the new vault.\n   * @returns Newly-created keychain object.\n   */\n  async createNewVaultAndKeychain(password: string) {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      const vault = await privates\n        .get(this)\n        .keyring.createNewVaultAndKeychain(password);\n      this.updateIdentities(await privates.get(this).keyring.getAccounts());\n      this.fullUpdate();\n      return vault;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Returns the status of the vault.\n   *\n   * @returns Boolean returning true if the vault is unlocked.\n   */\n  isUnlocked(): boolean {\n    return privates.get(this).keyring.memStore.getState().isUnlocked;\n  }\n\n  /**\n   * Gets the seed phrase of the HD keyring.\n   *\n   * @param password - Password of the keyring.\n   * @returns Promise resolving to the seed phrase.\n   */\n  exportSeedPhrase(password: string) {\n    if (privates.get(this).keyring.password === password) {\n      return privates.get(this).keyring.keyrings[0].mnemonic;\n    }\n    throw new Error('Invalid password');\n  }\n\n  /**\n   * Gets the private key from the keyring controlling an address.\n   *\n   * @param password - Password of the keyring.\n   * @param address - Address to export.\n   * @returns Promise resolving to the private key for an address.\n   */\n  exportAccount(password: string, address: string): Promise<string> {\n    if (privates.get(this).keyring.password === password) {\n      return privates.get(this).keyring.exportAccount(address);\n    }\n    throw new Error('Invalid password');\n  }\n\n  /**\n   * Returns the public addresses of all accounts for the current keyring.\n   *\n   * @returns A promise resolving to an array of addresses.\n   */\n  getAccounts(): Promise<string[]> {\n    return privates.get(this).keyring.getAccounts();\n  }\n\n  /**\n   * Imports an account with the specified import strategy.\n   *\n   * @param strategy - Import strategy name.\n   * @param args - Array of arguments to pass to the underlying stategy.\n   * @throws Will throw when passed an unrecognized strategy.\n   * @returns Promise resolving to current state when the import is complete.\n   */\n  async importAccountWithStrategy(\n    strategy: AccountImportStrategy,\n    args: any[],\n  ): Promise<KeyringMemState> {\n    let privateKey;\n    switch (strategy) {\n      case 'privateKey':\n        const [importedKey] = args;\n        if (!importedKey) {\n          throw new Error('Cannot import an empty key.');\n        }\n        const prefixed = addHexPrefix(importedKey);\n        /* istanbul ignore if */\n        if (!isValidPrivate(toBuffer(prefixed))) {\n          throw new Error('Cannot import invalid private key.');\n        }\n        privateKey = stripHexPrefix(prefixed);\n        break;\n      case 'json':\n        let wallet;\n        const [input, password] = args;\n        try {\n          wallet = importers.fromEtherWallet(input, password);\n        } catch (e) {\n          wallet = wallet || (await Wallet.fromV3(input, password, true));\n        }\n        privateKey = bufferToHex(wallet.getPrivateKey());\n        break;\n      default:\n        throw new Error(`Unexpected import strategy: '${strategy}'`);\n    }\n    const newKeyring = await privates\n      .get(this)\n      .keyring.addNewKeyring(KeyringTypes.simple, [privateKey]);\n    const accounts = await newKeyring.getAccounts();\n    const allAccounts = await privates.get(this).keyring.getAccounts();\n    this.updateIdentities(allAccounts);\n    this.setSelectedAddress(accounts[0]);\n    return this.fullUpdate();\n  }\n\n  /**\n   * Removes an account from keyring state.\n   *\n   * @param address - Address of the account to remove.\n   * @returns Promise resolving current state when this account removal completes.\n   */\n  async removeAccount(address: string): Promise<KeyringMemState> {\n    this.removeIdentity(address);\n    await privates.get(this).keyring.removeAccount(address);\n    return this.fullUpdate();\n  }\n\n  /**\n   * Deallocates all secrets and locks the wallet.\n   *\n   * @returns Promise resolving to current state.\n   */\n  setLocked(): Promise<KeyringMemState> {\n    return privates.get(this).keyring.setLocked();\n  }\n\n  /**\n   * Signs message by calling down into a specific keyring.\n   *\n   * @param messageParams - PersonalMessageParams object to sign.\n   * @returns Promise resolving to a signed message string.\n   */\n  signMessage(messageParams: PersonalMessageParams) {\n    return privates.get(this).keyring.signMessage(messageParams);\n  }\n\n  /**\n   * Signs personal message by calling down into a specific keyring.\n   *\n   * @param messageParams - PersonalMessageParams object to sign.\n   * @returns Promise resolving to a signed message string.\n   */\n  signPersonalMessage(messageParams: PersonalMessageParams) {\n    return privates.get(this).keyring.signPersonalMessage(messageParams);\n  }\n\n  /**\n   * Signs typed message by calling down into a specific keyring.\n   *\n   * @param messageParams - TypedMessageParams object to sign.\n   * @param version - Compatibility version EIP712.\n   * @throws Will throw when passed an unrecognized version.\n   * @returns Promise resolving to a signed message string or an error if any.\n   */\n  async signTypedMessage(\n    messageParams: TypedMessageParams,\n    version: SignTypedDataVersion,\n  ) {\n    try {\n      const address = normalizeAddress(messageParams.from);\n      const { password } = privates.get(this).keyring;\n      const privateKey = await this.exportAccount(password, address);\n      const privateKeyBuffer = toBuffer(addHexPrefix(privateKey));\n      switch (version) {\n        case SignTypedDataVersion.V1:\n          // signTypedDataLegacy will throw if the data is invalid.\n          return signTypedDataLegacy(privateKeyBuffer, {\n            data: messageParams.data as any,\n          });\n        case SignTypedDataVersion.V3:\n          return signTypedData(privateKeyBuffer, {\n            data: JSON.parse(messageParams.data as string),\n          });\n        case SignTypedDataVersion.V4:\n          return signTypedData_v4(privateKeyBuffer, {\n            data: JSON.parse(messageParams.data as string),\n          });\n        default:\n          throw new Error(`Unexpected signTypedMessage version: '${version}'`);\n      }\n    } catch (error) {\n      throw new Error(`Keyring Controller signTypedMessage: ${error}`);\n    }\n  }\n\n  /**\n   * Signs a transaction by calling down into a specific keyring.\n   *\n   * @param transaction - Transaction object to sign. Must be a `ethereumjs-tx` transaction instance.\n   * @param from - Address to sign from, should be in keychain.\n   * @returns Promise resolving to a signed transaction string.\n   */\n  signTransaction(transaction: unknown, from: string) {\n    return privates.get(this).keyring.signTransaction(transaction, from);\n  }\n\n  /**\n   * Attempts to decrypt the current vault and load its keyrings.\n   *\n   * @param password - Password to unlock the keychain.\n   * @returns Promise resolving to the current state.\n   */\n  async submitPassword(password: string): Promise<KeyringMemState> {\n    await privates.get(this).keyring.submitPassword(password);\n    const accounts = await privates.get(this).keyring.getAccounts();\n    await this.syncIdentities(accounts);\n    return this.fullUpdate();\n  }\n\n  /**\n   * Adds new listener to be notified of state changes.\n   *\n   * @param listener - Callback triggered when state changes.\n   */\n  subscribe(listener: Listener<KeyringState>) {\n    privates.get(this).keyring.store.subscribe(listener);\n  }\n\n  /**\n   * Removes existing listener from receiving state changes.\n   *\n   * @param listener - Callback to remove.\n   * @returns True if a listener is found and unsubscribed.\n   */\n  unsubscribe(listener: Listener<KeyringState>) {\n    return privates.get(this).keyring.store.unsubscribe(listener);\n  }\n\n  /**\n   * Adds new listener to be notified when the wallet is locked.\n   *\n   * @param listener - Callback triggered when wallet is locked.\n   * @returns EventEmitter if listener added.\n   */\n  onLock(listener: () => void) {\n    return privates.get(this).keyring.on('lock', listener);\n  }\n\n  /**\n   * Adds new listener to be notified when the wallet is unlocked.\n   *\n   * @param listener - Callback triggered when wallet is unlocked.\n   * @returns EventEmitter if listener added.\n   */\n  onUnlock(listener: () => void) {\n    return privates.get(this).keyring.on('unlock', listener);\n  }\n\n  /**\n   * Verifies the that the seed phrase restores the current keychain's accounts.\n   *\n   * @returns Whether the verification succeeds.\n   */\n  async verifySeedPhrase(): Promise<string> {\n    const primaryKeyring = privates\n      .get(this)\n      .keyring.getKeyringsByType(KeyringTypes.hd)[0];\n    /* istanbul ignore if */\n    if (!primaryKeyring) {\n      throw new Error('No HD keyring found.');\n    }\n\n    const seedWords = (await primaryKeyring.serialize()).mnemonic;\n    const accounts = await primaryKeyring.getAccounts();\n    /* istanbul ignore if */\n    if (accounts.length === 0) {\n      throw new Error('Cannot verify an empty keyring.');\n    }\n\n    const TestKeyringClass = privates\n      .get(this)\n      .keyring.getKeyringClassForType(KeyringTypes.hd);\n    const testKeyring = new TestKeyringClass({\n      mnemonic: seedWords,\n      numberOfAccounts: accounts.length,\n    });\n    const testAccounts = await testKeyring.getAccounts();\n    /* istanbul ignore if */\n    if (testAccounts.length !== accounts.length) {\n      throw new Error('Seed phrase imported incorrect number of accounts.');\n    }\n\n    testAccounts.forEach((account: string, i: number) => {\n      /* istanbul ignore if */\n      if (account.toLowerCase() !== accounts[i].toLowerCase()) {\n        throw new Error('Seed phrase imported different accounts.');\n      }\n    });\n\n    return seedWords;\n  }\n\n  /**\n   * Update keyrings in state and calls KeyringController fullUpdate method returning current state.\n   *\n   * @returns The current state.\n   */\n  async fullUpdate(): Promise<KeyringMemState> {\n    const keyrings: Keyring[] = await Promise.all<Keyring>(\n      privates.get(this).keyring.keyrings.map(\n        async (keyring: KeyringObject, index: number): Promise<Keyring> => {\n          const keyringAccounts = await keyring.getAccounts();\n          const accounts = Array.isArray(keyringAccounts)\n            ? keyringAccounts.map((address) => toChecksumHexAddress(address))\n            : /* istanbul ignore next */ [];\n          return {\n            accounts,\n            index,\n            type: keyring.type,\n          };\n        },\n      ),\n    );\n    this.update({ keyrings: [...keyrings] });\n    return privates.get(this).keyring.fullUpdate();\n  }\n}\n\nexport default KeyringController;\n"]}