{"version":3,"file":"KeyringController.js","sourceRoot":"","sources":["../../src/keyring/KeyringController.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  addHexPrefix,\n  bufferToHex,\n  isValidPrivate,\n  toBuffer,\n  stripHexPrefix,\n} from 'ethereumjs-util';\nimport {\n  normalize as normalizeAddress,\n  signTypedData,\n  signTypedData_v4,\n  signTypedDataLegacy,\n} from 'eth-sig-util';\nimport Wallet, { thirdparty as importers } from 'ethereumjs-wallet';\nimport Keyring from 'eth-keyring-controller';\nimport { Mutex } from 'async-mutex';\nimport {\n  MetaMaskKeyring as QRKeyring,\n  IKeyringState as IQRKeyringState,\n} from '@keystonehq/metamask-airgapped-keyring';\nimport {\n  BaseController,\n  BaseConfig,\n  BaseState,\n  Listener,\n} from '../BaseController';\nimport { PreferencesController } from '../user/PreferencesController';\nimport { PersonalMessageParams } from '../message-manager/PersonalMessageManager';\nimport { TypedMessageParams } from '../message-manager/TypedMessageManager';\nimport { toChecksumHexAddress } from '../util';\n\n/**\n * Available keyring types\n */\nexport enum KeyringTypes {\n  simple = 'Simple Key Pair',\n  hd = 'HD Key Tree',\n  qr = 'QR Hardware Wallet Device',\n}\n\n/**\n * @type KeyringObject\n *\n * Keyring object\n * @property type - Keyring type\n * @property accounts - Associated accounts\n * @function getAccounts - Get associated accounts\n */\nexport interface KeyringObject {\n  type: string;\n  accounts: string[];\n  getAccounts(): string[];\n}\n\n/**\n * @type KeyringState\n *\n * Keyring controller state\n * @property vault - Encrypted string representing keyring data\n * @property keyrings - Group of accounts\n */\nexport interface KeyringState extends BaseState {\n  vault?: string;\n  keyrings: Keyring[];\n}\n\n/**\n * @type KeyringMemState\n *\n * Keyring mem controller state\n * @property isUnlocked - Whether vault is unlocked\n * @property keyringTypes - Account types\n * @property keyrings - Group of accounts\n */\nexport interface KeyringMemState extends BaseState {\n  isUnlocked: boolean;\n  keyringTypes: string[];\n  keyrings: Keyring[];\n}\n\n/**\n * @type KeyringConfig\n *\n * Keyring controller configuration\n * @property encryptor - Keyring encryptor\n */\nexport interface KeyringConfig extends BaseConfig {\n  encryptor?: any;\n  keyringTypes?: any[];\n}\n\n/**\n * @type Keyring\n *\n * Keyring object to return in fullUpdate\n * @property type - Keyring type\n * @property accounts - Associated accounts\n * @property index - Associated index\n */\nexport interface Keyring {\n  accounts: string[];\n  type: string;\n  index?: number;\n}\n\n/**\n * A strategy for importing an account\n */\nexport enum AccountImportStrategy {\n  privateKey = 'privateKey',\n  json = 'json',\n}\n\n/**\n * The `signTypedMessage` version\n *\n * @see https://docs.metamask.io/guide/signing-data.html\n */\nexport enum SignTypedDataVersion {\n  V1 = 'V1',\n  V3 = 'V3',\n  V4 = 'V4',\n}\n\n/**\n * Controller responsible for establishing and managing user identity\n */\nexport class KeyringController extends BaseController<\n  KeyringConfig,\n  KeyringState\n> {\n  private mutex = new Mutex();\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'KeyringController';\n\n  private removeIdentity: PreferencesController['removeIdentity'];\n\n  private syncIdentities: PreferencesController['syncIdentities'];\n\n  private updateIdentities: PreferencesController['updateIdentities'];\n\n  private setSelectedAddress: PreferencesController['setSelectedAddress'];\n\n  private setAccountLabel?: PreferencesController['setAccountLabel'];\n\n  #keyring: typeof Keyring;\n\n  /**\n   * Creates a KeyringController instance.\n   *\n   * @param options - The controller options.\n   * @param options.removeIdentity - Remove the identity with the given address.\n   * @param options.syncIdentities - Sync identities with the given list of addresses.\n   * @param options.updateIdentities - Generate an identity for each address given that doesn't already have an identity.\n   * @param options.setSelectedAddress - Set the selected address.\n   * @param options.setAccountLabel - Set a new name for account.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      removeIdentity,\n      syncIdentities,\n      updateIdentities,\n      setSelectedAddress,\n      setAccountLabel,\n    }: {\n      removeIdentity: PreferencesController['removeIdentity'];\n      syncIdentities: PreferencesController['syncIdentities'];\n      updateIdentities: PreferencesController['updateIdentities'];\n      setSelectedAddress: PreferencesController['setSelectedAddress'];\n      setAccountLabel?: PreferencesController['setAccountLabel'];\n    },\n    config?: Partial<KeyringConfig>,\n    state?: Partial<KeyringState>,\n  ) {\n    super(config, state);\n    this.#keyring = new Keyring(Object.assign({ initState: state }, config));\n\n    this.defaultState = {\n      ...this.#keyring.store.getState(),\n      keyrings: [],\n    };\n    this.removeIdentity = removeIdentity;\n    this.syncIdentities = syncIdentities;\n    this.updateIdentities = updateIdentities;\n    this.setSelectedAddress = setSelectedAddress;\n    this.setAccountLabel = setAccountLabel;\n    this.initialize();\n    this.fullUpdate();\n  }\n\n  /**\n   * Adds a new account to the default (first) HD seed phrase keyring.\n   *\n   * @returns Promise resolving to current state when the account is added.\n   */\n  async addNewAccount(): Promise<KeyringMemState> {\n    const primaryKeyring = this.#keyring.getKeyringsByType('HD Key Tree')[0];\n    /* istanbul ignore if */\n    if (!primaryKeyring) {\n      throw new Error('No HD keyring found');\n    }\n    const oldAccounts = await this.#keyring.getAccounts();\n    await this.#keyring.addNewAccount(primaryKeyring);\n    const newAccounts = await this.#keyring.getAccounts();\n\n    await this.verifySeedPhrase();\n\n    this.updateIdentities(newAccounts);\n    newAccounts.forEach((selectedAddress: string) => {\n      if (!oldAccounts.includes(selectedAddress)) {\n        this.setSelectedAddress(selectedAddress);\n      }\n    });\n    return this.fullUpdate();\n  }\n\n  /**\n   * Adds a new account to the default (first) HD seed phrase keyring without updating identities in preferences.\n   *\n   * @returns Promise resolving to current state when the account is added.\n   */\n  async addNewAccountWithoutUpdate(): Promise<KeyringMemState> {\n    const primaryKeyring = this.#keyring.getKeyringsByType('HD Key Tree')[0];\n    /* istanbul ignore if */\n    if (!primaryKeyring) {\n      throw new Error('No HD keyring found');\n    }\n    await this.#keyring.addNewAccount(primaryKeyring);\n    await this.verifySeedPhrase();\n    return this.fullUpdate();\n  }\n\n  /**\n   * Effectively the same as creating a new keychain then populating it\n   * using the given seed phrase.\n   *\n   * @param password - Password to unlock keychain.\n   * @param seed - A BIP39-compliant seed phrase,\n   * either as a string or an array of UTF-8 bytes that represent the string.\n   * @returns Promise resolving to the restored keychain object.\n   */\n  async createNewVaultAndRestore(password: string, seed: string | number[]) {\n    const releaseLock = await this.mutex.acquire();\n    if (!password || !password.length) {\n      throw new Error('Invalid password');\n    }\n\n    try {\n      this.updateIdentities([]);\n      const vault = await this.#keyring.createNewVaultAndRestore(\n        password,\n        seed,\n      );\n      this.updateIdentities(await this.#keyring.getAccounts());\n      this.fullUpdate();\n      return vault;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Create a new primary keychain and wipe any previous keychains.\n   *\n   * @param password - Password to unlock the new vault.\n   * @returns Newly-created keychain object.\n   */\n  async createNewVaultAndKeychain(password: string) {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      const vault = await this.#keyring.createNewVaultAndKeychain(password);\n      this.updateIdentities(await this.#keyring.getAccounts());\n      this.fullUpdate();\n      return vault;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Returns the status of the vault.\n   *\n   * @returns Boolean returning true if the vault is unlocked.\n   */\n  isUnlocked(): boolean {\n    return this.#keyring.memStore.getState().isUnlocked;\n  }\n\n  /**\n   * Gets the seed phrase of the HD keyring.\n   *\n   * @param password - Password of the keyring.\n   * @returns Promise resolving to the seed phrase.\n   */\n  exportSeedPhrase(password: string) {\n    if (this.#keyring.password === password) {\n      return this.#keyring.keyrings[0].mnemonic;\n    }\n    throw new Error('Invalid password');\n  }\n\n  /**\n   * Gets the private key from the keyring controlling an address.\n   *\n   * @param password - Password of the keyring.\n   * @param address - Address to export.\n   * @returns Promise resolving to the private key for an address.\n   */\n  exportAccount(password: string, address: string): Promise<string> {\n    if (this.#keyring.password === password) {\n      return this.#keyring.exportAccount(address);\n    }\n    throw new Error('Invalid password');\n  }\n\n  /**\n   * Returns the public addresses of all accounts for the current keyring.\n   *\n   * @returns A promise resolving to an array of addresses.\n   */\n  getAccounts(): Promise<string[]> {\n    return this.#keyring.getAccounts();\n  }\n\n  /**\n   * Imports an account with the specified import strategy.\n   *\n   * @param strategy - Import strategy name.\n   * @param args - Array of arguments to pass to the underlying stategy.\n   * @throws Will throw when passed an unrecognized strategy.\n   * @returns Promise resolving to current state when the import is complete.\n   */\n  async importAccountWithStrategy(\n    strategy: AccountImportStrategy,\n    args: any[],\n  ): Promise<KeyringMemState> {\n    let privateKey;\n    switch (strategy) {\n      case 'privateKey':\n        const [importedKey] = args;\n        if (!importedKey) {\n          throw new Error('Cannot import an empty key.');\n        }\n        const prefixed = addHexPrefix(importedKey);\n\n        let bufferedPrivateKey;\n        try {\n          bufferedPrivateKey = toBuffer(prefixed);\n        } catch {\n          throw new Error('Cannot import invalid private key.');\n        }\n\n        /* istanbul ignore if */\n        if (!isValidPrivate(bufferedPrivateKey)) {\n          throw new Error('Cannot import invalid private key.');\n        }\n\n        privateKey = stripHexPrefix(prefixed);\n        break;\n      case 'json':\n        let wallet;\n        const [input, password] = args;\n        try {\n          wallet = importers.fromEtherWallet(input, password);\n        } catch (e) {\n          wallet = wallet || (await Wallet.fromV3(input, password, true));\n        }\n        privateKey = bufferToHex(wallet.getPrivateKey());\n        break;\n      default:\n        throw new Error(`Unexpected import strategy: '${strategy}'`);\n    }\n    const newKeyring = await this.#keyring.addNewKeyring(KeyringTypes.simple, [\n      privateKey,\n    ]);\n    const accounts = await newKeyring.getAccounts();\n    const allAccounts = await this.#keyring.getAccounts();\n    this.updateIdentities(allAccounts);\n    this.setSelectedAddress(accounts[0]);\n    return this.fullUpdate();\n  }\n\n  /**\n   * Removes an account from keyring state.\n   *\n   * @param address - Address of the account to remove.\n   * @returns Promise resolving current state when this account removal completes.\n   */\n  async removeAccount(address: string): Promise<KeyringMemState> {\n    this.removeIdentity(address);\n    await this.#keyring.removeAccount(address);\n    return this.fullUpdate();\n  }\n\n  /**\n   * Deallocates all secrets and locks the wallet.\n   *\n   * @returns Promise resolving to current state.\n   */\n  setLocked(): Promise<KeyringMemState> {\n    return this.#keyring.setLocked();\n  }\n\n  /**\n   * Signs message by calling down into a specific keyring.\n   *\n   * @param messageParams - PersonalMessageParams object to sign.\n   * @returns Promise resolving to a signed message string.\n   */\n  signMessage(messageParams: PersonalMessageParams) {\n    return this.#keyring.signMessage(messageParams);\n  }\n\n  /**\n   * Signs personal message by calling down into a specific keyring.\n   *\n   * @param messageParams - PersonalMessageParams object to sign.\n   * @returns Promise resolving to a signed message string.\n   */\n  signPersonalMessage(messageParams: PersonalMessageParams) {\n    return this.#keyring.signPersonalMessage(messageParams);\n  }\n\n  /**\n   * Signs typed message by calling down into a specific keyring.\n   *\n   * @param messageParams - TypedMessageParams object to sign.\n   * @param version - Compatibility version EIP712.\n   * @throws Will throw when passed an unrecognized version.\n   * @returns Promise resolving to a signed message string or an error if any.\n   */\n  async signTypedMessage(\n    messageParams: TypedMessageParams,\n    version: SignTypedDataVersion,\n  ) {\n    try {\n      const address = normalizeAddress(messageParams.from);\n      const qrKeyring = await this.getOrAddQRKeyring();\n      const qrAccounts = await qrKeyring.getAccounts();\n      if (\n        qrAccounts.findIndex(\n          (qrAddress: string) =>\n            qrAddress.toLowerCase() === address.toLowerCase(),\n        ) !== -1\n      ) {\n        const messageParamsClone = { ...messageParams };\n        if (\n          version !== SignTypedDataVersion.V1 &&\n          typeof messageParamsClone.data === 'string'\n        ) {\n          messageParamsClone.data = JSON.parse(messageParamsClone.data);\n        }\n        return this.#keyring.signTypedMessage(messageParamsClone, { version });\n      }\n\n      const { password } = this.#keyring;\n      const privateKey = await this.exportAccount(password, address);\n      const privateKeyBuffer = toBuffer(addHexPrefix(privateKey));\n      switch (version) {\n        case SignTypedDataVersion.V1:\n          // signTypedDataLegacy will throw if the data is invalid.\n          return signTypedDataLegacy(privateKeyBuffer, {\n            data: messageParams.data as any,\n          });\n        case SignTypedDataVersion.V3:\n          return signTypedData(privateKeyBuffer, {\n            data: JSON.parse(messageParams.data as string),\n          });\n        case SignTypedDataVersion.V4:\n          return signTypedData_v4(privateKeyBuffer, {\n            data: JSON.parse(messageParams.data as string),\n          });\n        default:\n          throw new Error(`Unexpected signTypedMessage version: '${version}'`);\n      }\n    } catch (error) {\n      throw new Error(`Keyring Controller signTypedMessage: ${error}`);\n    }\n  }\n\n  /**\n   * Signs a transaction by calling down into a specific keyring.\n   *\n   * @param transaction - Transaction object to sign. Must be a `ethereumjs-tx` transaction instance.\n   * @param from - Address to sign from, should be in keychain.\n   * @returns Promise resolving to a signed transaction string.\n   */\n  signTransaction(transaction: unknown, from: string) {\n    return this.#keyring.signTransaction(transaction, from);\n  }\n\n  /**\n   * Attempts to decrypt the current vault and load its keyrings.\n   *\n   * @param password - Password to unlock the keychain.\n   * @returns Promise resolving to the current state.\n   */\n  async submitPassword(password: string): Promise<KeyringMemState> {\n    await this.#keyring.submitPassword(password);\n    const accounts = await this.#keyring.getAccounts();\n    await this.syncIdentities(accounts);\n    return this.fullUpdate();\n  }\n\n  /**\n   * Adds new listener to be notified of state changes.\n   *\n   * @param listener - Callback triggered when state changes.\n   */\n  override subscribe(listener: Listener<KeyringState>) {\n    this.#keyring.store.subscribe(listener);\n  }\n\n  /**\n   * Removes existing listener from receiving state changes.\n   *\n   * @param listener - Callback to remove.\n   * @returns True if a listener is found and unsubscribed.\n   */\n  override unsubscribe(listener: Listener<KeyringState>) {\n    return this.#keyring.store.unsubscribe(listener);\n  }\n\n  /**\n   * Adds new listener to be notified when the wallet is locked.\n   *\n   * @param listener - Callback triggered when wallet is locked.\n   * @returns EventEmitter if listener added.\n   */\n  onLock(listener: () => void) {\n    return this.#keyring.on('lock', listener);\n  }\n\n  /**\n   * Adds new listener to be notified when the wallet is unlocked.\n   *\n   * @param listener - Callback triggered when wallet is unlocked.\n   * @returns EventEmitter if listener added.\n   */\n  onUnlock(listener: () => void) {\n    return this.#keyring.on('unlock', listener);\n  }\n\n  /**\n   * Verifies the that the seed phrase restores the current keychain's accounts.\n   *\n   * @returns Whether the verification succeeds.\n   */\n  async verifySeedPhrase(): Promise<string> {\n    const primaryKeyring = this.#keyring.getKeyringsByType(KeyringTypes.hd)[0];\n    /* istanbul ignore if */\n    if (!primaryKeyring) {\n      throw new Error('No HD keyring found.');\n    }\n\n    const seedWords = (await primaryKeyring.serialize()).mnemonic;\n    const accounts = await primaryKeyring.getAccounts();\n    /* istanbul ignore if */\n    if (accounts.length === 0) {\n      throw new Error('Cannot verify an empty keyring.');\n    }\n\n    const TestKeyringClass = this.#keyring.getKeyringClassForType(\n      KeyringTypes.hd,\n    );\n    const testKeyring = new TestKeyringClass({\n      mnemonic: seedWords,\n      numberOfAccounts: accounts.length,\n    });\n    const testAccounts = await testKeyring.getAccounts();\n    /* istanbul ignore if */\n    if (testAccounts.length !== accounts.length) {\n      throw new Error('Seed phrase imported incorrect number of accounts.');\n    }\n\n    testAccounts.forEach((account: string, i: number) => {\n      /* istanbul ignore if */\n      if (account.toLowerCase() !== accounts[i].toLowerCase()) {\n        throw new Error('Seed phrase imported different accounts.');\n      }\n    });\n\n    return seedWords;\n  }\n\n  /**\n   * Update keyrings in state and calls KeyringController fullUpdate method returning current state.\n   *\n   * @returns The current state.\n   */\n  async fullUpdate(): Promise<KeyringMemState> {\n    const keyrings: Keyring[] = await Promise.all<Keyring>(\n      this.#keyring.keyrings.map(\n        async (keyring: KeyringObject, index: number): Promise<Keyring> => {\n          const keyringAccounts = await keyring.getAccounts();\n          const accounts = Array.isArray(keyringAccounts)\n            ? keyringAccounts.map((address) => toChecksumHexAddress(address))\n            : /* istanbul ignore next */ [];\n          return {\n            accounts,\n            index,\n            type: keyring.type,\n          };\n        },\n      ),\n    );\n    this.update({ keyrings: [...keyrings] });\n    return this.#keyring.fullUpdate();\n  }\n\n  // QR Hardware related methods\n\n  /**\n   * Add qr hardware keyring.\n   *\n   * @returns The added keyring\n   */\n  private async addQRKeyring(): Promise<QRKeyring> {\n    const keyring = await this.#keyring.addNewKeyring(KeyringTypes.qr);\n    await this.fullUpdate();\n    return keyring;\n  }\n\n  /**\n   * Get qr hardware keyring.\n   *\n   * @returns The added keyring\n   */\n  async getOrAddQRKeyring(): Promise<QRKeyring> {\n    const keyring = this.#keyring.getKeyringsByType(KeyringTypes.qr)[0];\n    return keyring || (await this.addQRKeyring());\n  }\n\n  async restoreQRKeyring(serialized: any): Promise<void> {\n    (await this.getOrAddQRKeyring()).deserialize(serialized);\n    this.updateIdentities(await this.#keyring.getAccounts());\n    await this.fullUpdate();\n  }\n\n  async resetQRKeyringState(): Promise<void> {\n    (await this.getOrAddQRKeyring()).resetStore();\n  }\n\n  async getQRKeyringState(): Promise<IQRKeyringState> {\n    return (await this.getOrAddQRKeyring()).getMemStore();\n  }\n\n  async submitQRCryptoHDKey(cryptoHDKey: string): Promise<void> {\n    (await this.getOrAddQRKeyring()).submitCryptoHDKey(cryptoHDKey);\n  }\n\n  async submitQRCryptoAccount(cryptoAccount: string): Promise<void> {\n    (await this.getOrAddQRKeyring()).submitCryptoAccount(cryptoAccount);\n  }\n\n  async submitQRSignature(\n    requestId: string,\n    ethSignature: string,\n  ): Promise<void> {\n    (await this.getOrAddQRKeyring()).submitSignature(requestId, ethSignature);\n  }\n\n  async cancelQRSignRequest(): Promise<void> {\n    (await this.getOrAddQRKeyring()).cancelSignRequest();\n  }\n\n  async connectQRHardware(\n    page: number,\n  ): Promise<{ balance: string; address: string; index: number }[]> {\n    try {\n      const keyring = await this.getOrAddQRKeyring();\n      let accounts;\n      switch (page) {\n        case -1:\n          accounts = await keyring.getPreviousPage();\n          break;\n        case 1:\n          accounts = await keyring.getNextPage();\n          break;\n        default:\n          accounts = await keyring.getFirstPage();\n      }\n      return accounts.map((account: any) => {\n        return {\n          ...account,\n          balance: '0x0',\n        };\n      });\n    } catch (e) {\n      throw new Error(`Unspecified error when connect QR Hardware, ${e}`);\n    }\n  }\n\n  async unlockQRHardwareWalletAccount(index: number): Promise<void> {\n    const keyring = await this.getOrAddQRKeyring();\n\n    keyring.setAccountToUnlock(index);\n    const oldAccounts = await this.#keyring.getAccounts();\n    await this.#keyring.addNewAccount(keyring);\n    const newAccounts = await this.#keyring.getAccounts();\n    this.updateIdentities(newAccounts);\n    newAccounts.forEach((address: string) => {\n      if (!oldAccounts.includes(address)) {\n        if (this.setAccountLabel) {\n          this.setAccountLabel(address, `${keyring.getName()} ${index}`);\n        }\n        this.setSelectedAddress(address);\n      }\n    });\n    await this.#keyring.persistAllKeyrings();\n    await this.fullUpdate();\n  }\n\n  async getAccountKeyringType(account: string): Promise<KeyringTypes> {\n    return (await this.#keyring.getKeyringForAccount(account)).type;\n  }\n\n  async forgetQRDevice(): Promise<void> {\n    const keyring = await this.getOrAddQRKeyring();\n    keyring.forgetDevice();\n    const accounts = (await this.#keyring.getAccounts()) as string[];\n    accounts.forEach((account) => {\n      this.setSelectedAddress(account);\n    });\n    await this.#keyring.persistAllKeyrings();\n    await this.fullUpdate();\n  }\n}\n\nexport default KeyringController;\n"]}