{"version":3,"file":"BaseControllerV2.js","sourceRoot":"","sources":["../src/BaseControllerV2.ts"],"names":[],"mappings":";;;AAAA,iCAA0D;AAW1D,qBAAa,EAAE,CAAC;AAgGhB;;GAEG;AACH,MAAa,cAAc;IA+BzB;;;;;;;;;OASG;IACH,YAAY,EACV,SAAS,EACT,QAAQ,EACR,IAAI,EACJ,KAAK,GAMN;QACC,IAAI,CAAC,eAAe,GAAG,SAAS,CAAC;QACjC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,aAAa,GAAG,KAAK,CAAC;QAC3B,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QAEzB,IAAI,CAAC,eAAe,CAAC,qBAAqB,CACxC,GAAG,IAAI,WAAW,EAClB,GAAG,EAAE,CAAC,IAAI,CAAC,KAAK,CACjB,CAAC;IACJ,CAAC;IAED;;;;OAIG;IACH,IAAI,KAAK;QACP,OAAO,IAAI,CAAC,aAAa,CAAC;IAC5B,CAAC;IAED,IAAI,KAAK,CAAC,CAAC;QACT,MAAM,IAAI,KAAK,CACb,2EAA2E,CAC5E,CAAC;IACJ,CAAC;IAED;;;;;;;;OAQG;IACO,MAAM,CACd,QAA+D;QAE/D,MAAM,CAAC,SAAS,EAAE,OAAO,CAAC,GAAG,0BAAkB,CAC7C,IAAI,CAAC,aAAa,EAClB,QAAQ,CACT,CAAC;QACF,IAAI,CAAC,aAAa,GAAG,SAA0B,CAAC;QAChD,IAAI,CAAC,eAAe,CAAC,OAAO,CAC1B,GAAG,IAAI,CAAC,IAAI,cAAoC,EAChD,SAAc,EACd,OAAO,CACR,CAAC;IACJ,CAAC;IAED;;;;;;;;OAQG;IACO,OAAO;QACf,IAAI,CAAC,eAAe,CAAC,uBAAuB,CAC1C,GAAG,IAAI,CAAC,IAAI,cAAoC,CACjD,CAAC;IACJ,CAAC;CACF;AApHD,wCAoHC;AAED;;;;;;;;;;GAUG;AACH,SAAgB,kBAAkB,CAChC,KAAoB,EACpB,QAA0B;IAE1B,OAAO,uBAAuB,CAAC,KAAK,EAAE,QAAQ,EAAE,WAAW,CAAC,CAAC;AAC/D,CAAC;AALD,gDAKC;AAED;;;;;;GAMG;AACH,SAAgB,kBAAkB,CAChC,KAAoB,EACpB,QAA0B;IAE1B,OAAO,uBAAuB,CAAC,KAAK,EAAE,QAAQ,EAAE,SAAS,CAAC,CAAC;AAC7D,CAAC;AALD,gDAKC;AAED,SAAS,uBAAuB,CAC9B,KAAoB,EACpB,QAA0B,EAC1B,gBAAyC;IAEzC,OAAO,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,CAAC,cAAc,EAAE,GAAG,EAAE,EAAE;QACvD,MAAM,gBAAgB,GAAG,QAAQ,CAAC,GAAc,CAAC,CAAC,gBAAgB,CAAC,CAAC;QACpE,MAAM,aAAa,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC;QACjC,IAAI,OAAO,gBAAgB,KAAK,UAAU,EAAE;YAC1C,cAAc,CAAC,GAAa,CAAC,GAAG,gBAAgB,CAAC,aAAa,CAAC,CAAC;SACjE;aAAM,IAAI,gBAAgB,EAAE;YAC3B,cAAc,CAAC,GAAa,CAAC,GAAG,aAAa,CAAC;SAC/C;QACD,OAAO,cAAc,CAAC;IACxB,CAAC,EAAE,EAAsC,CAAC,CAAC;AAC7C,CAAC","sourcesContent":["import { enablePatches, produceWithPatches } from 'immer';\n\n// Imported separately because only the type is used\n// eslint-disable-next-line no-duplicate-imports\nimport type { Draft, Patch } from 'immer';\n\nimport type {\n  RestrictedControllerMessenger,\n  Namespaced,\n} from './ControllerMessenger';\n\nenablePatches();\n\n/**\n * A state change listener.\n *\n * This function will get called for each state change, and is given a copy of\n * the new state along with a set of patches describing the changes since the\n * last update.\n *\n * @param state - The new controller state\n * @param patches - A list of patches describing any changes (see here for more\n *   information: https://immerjs.github.io/immer/docs/patches)\n */\nexport type Listener<T> = (state: T, patches: Patch[]) => void;\n\ntype primitive = null | boolean | number | string;\n\ntype DefinitelyNotJsonable = ((...args: any[]) => any) | undefined;\n\n// Credit to https://github.com/grant-dennison for this type\n// Source: https://github.com/Microsoft/TypeScript/issues/1897#issuecomment-710744173\nexport type IsJsonable<T> =\n  // Check if there are any non-jsonable types represented in the union\n  // Note: use of tuples in this first condition side-steps distributive conditional types\n  // (see https://github.com/microsoft/TypeScript/issues/29368#issuecomment-453529532)\n  [Extract<T, DefinitelyNotJsonable>] extends [never]\n    ? // Non-jsonable type union was found empty\n      T extends primitive\n      ? // Primitive is acceptable\n        T\n      : // Otherwise check if array\n      T extends (infer U)[]\n      ? // Arrays are special; just check array element type\n        IsJsonable<U>[]\n      : // Otherwise check if object\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      T extends object\n      ? // It's an object\n        {\n          // Iterate over keys in object case\n          [P in keyof T]: P extends string\n            ? // Recursive call for children\n              IsJsonable<T[P]>\n            : // Exclude non-string keys\n              never;\n        }\n      : // Otherwise any other non-object no bueno\n        never\n    : // Otherwise non-jsonable type union was found not empty\n      never;\n\n/**\n * An function to derive state.\n *\n * This function will accept one piece of the controller state (one property),\n * and will return some derivation of that state.\n *\n * @param value - A piece of controller state\n * @returns Something derived from controller state\n */\nexport type StateDeriver<T> = (value: IsJsonable<T>) => IsJsonable<Json>;\n\n/**\n * State metadata.\n *\n * This metadata describes which parts of state should be persisted, and how to\n * get an anonymized representation of the state.\n */\nexport type StateMetadata<T> = {\n  [P in keyof T]: StatePropertyMetadata<T[P]>;\n};\n\n/**\n * Metadata for a single state property\n *\n * @property persist - Indicates whether this property should be persisted\n *   (`true` for persistent, `false` for transient), or is set to a function\n *   that derives the persistent state from the state.\n * @property anonymous - Indicates whether this property is already anonymous,\n *   (`true` for anonymous, `false` if it has potential to be personally\n *   identifiable), or is set to a function that returns an anonymized\n *   representation of this state.\n */\nexport interface StatePropertyMetadata<T> {\n  persist: boolean | StateDeriver<T>;\n  anonymous: boolean | StateDeriver<T>;\n}\n\nexport type Json =\n  | null\n  | boolean\n  | number\n  | string\n  | Json[]\n  | { [prop: string]: Json };\n\n/**\n * Controller class that provides state management, subscriptions, and state metadata\n */\nexport class BaseController<\n  N extends string,\n  S extends Record<string, unknown>\n> {\n  private internalState: IsJsonable<S>;\n\n  protected messagingSystem: RestrictedControllerMessenger<\n    N,\n    any,\n    any,\n    string,\n    string\n  >;\n\n  /**\n   * The name of the controller.\n   *\n   * This is used by the ComposableController to construct a composed application state.\n   */\n  public readonly name: N;\n\n  public readonly metadata: StateMetadata<S>;\n\n  /**\n   * The existence of the `subscribe` property is how the ComposableController detects whether a\n   * controller extends the old BaseController or the new one. We set it to `never` here to ensure\n   * this property is never used for new BaseController-based controllers, to ensure the\n   * ComposableController never mistakes them for an older style controller.\n   */\n  public readonly subscribe: never;\n\n  /**\n   * Creates a BaseController instance.\n   *\n   * @param options\n   * @param options.messenger - Controller messaging system\n   * @param options.metadata - State metadata, describing how to \"anonymize\" the state, and which\n   *   parts should be persisted.\n   * @param options.name - The name of the controller, used as a namespace for events and actions\n   * @param options.state - Initial controller state\n   */\n  constructor({\n    messenger,\n    metadata,\n    name,\n    state,\n  }: {\n    messenger: RestrictedControllerMessenger<N, any, any, string, string>;\n    metadata: StateMetadata<S>;\n    name: N;\n    state: IsJsonable<S>;\n  }) {\n    this.messagingSystem = messenger;\n    this.name = name;\n    this.internalState = state;\n    this.metadata = metadata;\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:getState`,\n      () => this.state,\n    );\n  }\n\n  /**\n   * Retrieves current controller state\n   *\n   * @returns - Current state\n   */\n  get state() {\n    return this.internalState;\n  }\n\n  set state(_) {\n    throw new Error(\n      `Controller state cannot be directly mutated; use 'update' method instead.`,\n    );\n  }\n\n  /**\n   * Updates controller state. Accepts a callback that is passed a draft copy\n   * of the controller state. If a value is returned, it is set as the new\n   * state. Otherwise, any changes made within that callback to the draft are\n   * applied to the controller state.\n   *\n   * @param callback - Callback for updating state, passed a draft state\n   *   object. Return a new state object or mutate the draft to update state.\n   */\n  protected update(\n    callback: (state: Draft<IsJsonable<S>>) => void | IsJsonable<S>,\n  ) {\n    const [nextState, patches] = produceWithPatches(\n      this.internalState,\n      callback,\n    );\n    this.internalState = nextState as IsJsonable<S>;\n    this.messagingSystem.publish(\n      `${this.name}:stateChange` as Namespaced<N, any>,\n      nextState as S,\n      patches,\n    );\n  }\n\n  /**\n   * Prepares the controller for garbage collection. This should be extended\n   * by any subclasses to clean up any additional connections or events.\n   *\n   * The only cleanup performed here is to remove listeners. While technically\n   * this is not required to ensure this instance is garbage collected, it at\n   * least ensures this instance won't be responsible for preventing the\n   * listeners from being garbage collected.\n   */\n  protected destroy() {\n    this.messagingSystem.clearEventSubscriptions(\n      `${this.name}:stateChange` as Namespaced<N, any>,\n    );\n  }\n}\n\n/**\n * Returns an anonymized representation of the controller state.\n *\n * By \"anonymized\" we mean that it should not contain any information that could be personally\n * identifiable.\n *\n * @param state - The controller state\n * @param metadata - The controller state metadata, which describes how to derive the\n *   anonymized state\n * @returns The anonymized controller state\n */\nexport function getAnonymizedState<S extends Record<string, unknown>>(\n  state: IsJsonable<S>,\n  metadata: StateMetadata<S>,\n): IsJsonable<Record<string, Json>> {\n  return deriveStateFromMetadata(state, metadata, 'anonymous');\n}\n\n/**\n * Returns the subset of state that should be persisted\n *\n * @param state - The controller state\n * @param metadata - The controller state metadata, which describes which pieces of state should be persisted\n * @returns The subset of controller state that should be persisted\n */\nexport function getPersistentState<S extends Record<string, unknown>>(\n  state: IsJsonable<S>,\n  metadata: StateMetadata<S>,\n): IsJsonable<Record<string, Json>> {\n  return deriveStateFromMetadata(state, metadata, 'persist');\n}\n\nfunction deriveStateFromMetadata<S extends Record<string, unknown>>(\n  state: IsJsonable<S>,\n  metadata: StateMetadata<S>,\n  metadataProperty: 'anonymous' | 'persist',\n): IsJsonable<Record<string, Json>> {\n  return Object.keys(state).reduce((persistedState, key) => {\n    const propertyMetadata = metadata[key as keyof S][metadataProperty];\n    const stateProperty = state[key];\n    if (typeof propertyMetadata === 'function') {\n      persistedState[key as string] = propertyMetadata(stateProperty);\n    } else if (propertyMetadata) {\n      persistedState[key as string] = stateProperty;\n    }\n    return persistedState;\n  }, {} as IsJsonable<Record<string, Json>>);\n}\n"]}