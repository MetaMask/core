{"version":3,"sources":["../src/BaseControllerV1.ts"],"names":[],"mappings":";AA4CO,IAAM,mBAAN,MAAkE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAsCvE,YAAY,SAAqB,CAAC,GAAG,QAAoB,CAAC,GAAG;AAlC7D;AAAA;AAAA;AAAA,yBAAmB,CAAC;AAKpB;AAAA;AAAA;AAAA,wBAAkB,CAAC;AAKnB;AAAA;AAAA;AAAA,oBAAW;AAKX;AAAA;AAAA;AAAA,gBAAO;AAMP,SAAQ,iBAAoB,KAAK;AAEjC,SAAQ,gBAAmB,KAAK;AAEhC,SAAiB,oBAAmC,CAAC;AAUnD,SAAK,eAAe;AACpB,SAAK,gBAAgB;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASU,aAAa;AACrB,SAAK,gBAAgB,KAAK;AAC1B,SAAK,iBAAiB,KAAK;AAC3B,SAAK,UAAU,KAAK,aAAa;AACjC,SAAK,OAAO,KAAK,YAAY;AAC7B,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,IAAI,SAAS;AACX,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,IAAI,QAAQ;AACV,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,UAAU,QAAoB,YAAY,OAAO,aAAa,MAAM;AAClE,QAAI,YAAY;AACd,WAAK,iBAAiB,YACjB,SACD,OAAO,OAAO,KAAK,gBAAgB,MAAM;AAE7C,iBAAW,OAAO,OAAO,KAAK,KAAK,cAAc,GAAkB;AACjE,cAAM,QAAQ,KAAK,eAAe,GAAG;AACrC,YAAI,UAAU,QAAW;AACvB,UAAC,KAAsB,GAAG,IAAI;AAAA,QAChC;AAAA,MACF;AAAA,IACF,OAAO;AACL,iBAAW,OAAO,OAAO,KAAK,MAAM,GAAkB;AAEpD,YAAI,KAAK,eAAe,GAAG,MAAM,QAAW;AAC1C,gBAAM,QAAS,OAAa,GAAG;AAC/B,eAAK,eAAe,GAAG,IAAI;AAC3B,UAAC,KAAsB,GAAG,IAAI;AAAA,QAChC;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,SAAS;AACP,QAAI,KAAK,UAAU;AACjB;AAAA,IACF;AAEA,SAAK,kBAAkB,QAAQ,CAAC,aAAa;AAC3C,eAAS,KAAK,aAAa;AAAA,IAC7B,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,UAAU,UAAuB;AAC/B,SAAK,kBAAkB,KAAK,QAAQ;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,YAAY,UAAuB;AACjC,UAAM,QAAQ,KAAK,kBAAkB,UAAU,CAAC,OAAO,aAAa,EAAE;AACtE,YAAQ,MAAM,KAAK,kBAAkB,OAAO,OAAO,CAAC;AACpD,WAAO,QAAQ;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,OAAO,OAAmB,YAAY,OAAO;AAC3C,SAAK,gBAAgB,YACjB,OAAO,OAAO,CAAC,GAAG,KAAU,IAC5B,OAAO,OAAO,CAAC,GAAG,KAAK,eAAe,KAAK;AAC/C,SAAK,OAAO;AAAA,EACd;AACF;AAEA,IAAO,2BAAQ","sourcesContent":["/**\n * State change callbacks\n */\n// TODO: Either fix this lint violation or explain why it's necessary to ignore.\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport type Listener<T> = (state: T) => void;\n\n/**\n * @type BaseConfig\n *\n * Base controller configuration\n * @property disabled - Determines if this controller is enabled\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface BaseConfig {\n  disabled?: boolean;\n}\n\n/**\n * @type BaseState\n *\n * Base state representation\n * @property name - Unique name for this controller\n */\n// This interface was created before this ESLint rule was added.\n// Convert to a `type` in a future major version.\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface BaseState {\n  name?: string;\n}\n\n/**\n * @deprecated This class has been renamed to BaseControllerV1 and is no longer recommended for use for controllers. Please use BaseController (formerly BaseControllerV2) instead.\n *\n * Controller class that provides configuration, state management, and subscriptions.\n *\n * The core purpose of every controller is to maintain an internal data object\n * called \"state\". Each controller is responsible for its own state, and all global wallet state\n * is tracked in a controller as state.\n */\n// TODO: Either fix this lint violation or explain why it's necessary to ignore.\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class BaseControllerV1<C extends BaseConfig, S extends BaseState> {\n  /**\n   * Default options used to configure this controller\n   */\n  defaultConfig: C = {} as never;\n\n  /**\n   * Default state set on this controller\n   */\n  defaultState: S = {} as never;\n\n  /**\n   * Determines if listeners are notified of state changes\n   */\n  disabled = false;\n\n  /**\n   * Name of this controller used during composition\n   */\n  name = 'BaseController';\n\n  private readonly initialConfig: Partial<C>;\n\n  private readonly initialState: Partial<S>;\n\n  private internalConfig: C = this.defaultConfig;\n\n  private internalState: S = this.defaultState;\n\n  private readonly internalListeners: Listener<S>[] = [];\n\n  /**\n   * Creates a BaseControllerV1 instance. Both initial state and initial\n   * configuration options are merged with defaults upon initialization.\n   *\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(config: Partial<C> = {}, state: Partial<S> = {}) {\n    this.initialState = state;\n    this.initialConfig = config;\n  }\n\n  /**\n   * Enables the controller. This sets each config option as a member\n   * variable on this instance and triggers any defined setters. This\n   * also sets initial state and triggers any listeners.\n   *\n   * @returns This controller instance.\n   */\n  protected initialize() {\n    this.internalState = this.defaultState;\n    this.internalConfig = this.defaultConfig;\n    this.configure(this.initialConfig);\n    this.update(this.initialState);\n    return this;\n  }\n\n  /**\n   * Retrieves current controller configuration options.\n   *\n   * @returns The current configuration.\n   */\n  get config() {\n    return this.internalConfig;\n  }\n\n  /**\n   * Retrieves current controller state.\n   *\n   * @returns The current state.\n   */\n  get state() {\n    return this.internalState;\n  }\n\n  /**\n   * Updates controller configuration.\n   *\n   * @param config - New configuration options.\n   * @param overwrite - Overwrite config instead of merging.\n   * @param fullUpdate - Boolean that defines if the update is partial or not.\n   */\n  configure(config: Partial<C>, overwrite = false, fullUpdate = true) {\n    if (fullUpdate) {\n      this.internalConfig = overwrite\n        ? (config as C)\n        : Object.assign(this.internalConfig, config);\n\n      for (const key of Object.keys(this.internalConfig) as (keyof C)[]) {\n        const value = this.internalConfig[key];\n        if (value !== undefined) {\n          (this as unknown as C)[key] = value;\n        }\n      }\n    } else {\n      for (const key of Object.keys(config) as (keyof C)[]) {\n        /* istanbul ignore else */\n        if (this.internalConfig[key] !== undefined) {\n          const value = (config as C)[key];\n          this.internalConfig[key] = value;\n          (this as unknown as C)[key] = value;\n        }\n      }\n    }\n  }\n\n  /**\n   * Notifies all subscribed listeners of current state.\n   */\n  notify() {\n    if (this.disabled) {\n      return;\n    }\n\n    this.internalListeners.forEach((listener) => {\n      listener(this.internalState);\n    });\n  }\n\n  /**\n   * Adds new listener to be notified of state changes.\n   *\n   * @param listener - The callback triggered when state changes.\n   */\n  subscribe(listener: Listener<S>) {\n    this.internalListeners.push(listener);\n  }\n\n  /**\n   * Removes existing listener from receiving state changes.\n   *\n   * @param listener - The callback to remove.\n   * @returns `true` if a listener is found and unsubscribed.\n   */\n  unsubscribe(listener: Listener<S>) {\n    const index = this.internalListeners.findIndex((cb) => listener === cb);\n    index > -1 && this.internalListeners.splice(index, 1);\n    return index > -1;\n  }\n\n  /**\n   * Updates controller state.\n   *\n   * @param state - The new state.\n   * @param overwrite - Overwrite state instead of merging.\n   */\n  update(state: Partial<S>, overwrite = false) {\n    this.internalState = overwrite\n      ? Object.assign({}, state as S)\n      : Object.assign({}, this.internalState, state);\n    this.notify();\n  }\n}\n\nexport default BaseControllerV1;\n"]}