{"version":3,"sources":["../src/transforms/remove-fenced-code.ts"],"names":["DirectiveTerminus","DirectiveCommand"],"mappings":"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","sourcesContent":["import { hasProperty } from '@metamask/utils';\n\n/**\n * Two sets of feature labels, where:\n * - `active` is the set of labels that are active for the current build.\n * - `all` is the set of all labels that are declared in the codebase.\n *\n * For `ONLY_INCLUDE_IF` fences, the code fence removal transform will\n * include the fenced code if any of the specified labels are active. See\n * {@link removeFencedCode} for details.\n */\nexport type FeatureLabels = {\n  active: ReadonlySet<string>;\n  all: ReadonlySet<string>;\n};\n\nenum DirectiveTerminus {\n  BEGIN = 'BEGIN',\n  END = 'END',\n}\n\nexport enum DirectiveCommand {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ONLY_INCLUDE_IF = 'ONLY_INCLUDE_IF',\n}\n\n// Matches lines starting with \"///:\", and any preceding whitespace, except\n// newlines. We except newlines to avoid eating blank lines preceding a fenced\n// line.\n// Double-negative RegEx credit: https://stackoverflow.com/a/3469155\nconst linesWithFenceRegex = /^[^\\S\\r\\n]*\\/\\/\\/:.*$/gmu;\n\n// Matches the first \"///:\" in a string, and any preceding whitespace\nconst fenceSentinelRegex = /^\\s*\\/\\/\\/:/u;\n\n// Breaks a fence directive into its constituent components.\n// At this stage of parsing, we are looking for one of:\n// - TERMINUS:COMMAND(PARAMS)\n// - TERMINUS:COMMAND\nconst directiveParsingRegex =\n  /^([A-Z]+):([A-Z_]+)(?:\\(((?:\\w[-\\w]*,)*\\w[-\\w]*)\\))?$/u;\n\n/**\n * Removes fenced code from the given JavaScript source string. \"Fenced code\"\n * includes the entire fence lines, including their trailing newlines, and the\n * lines that they surround.\n *\n * A valid fence consists of two well-formed fence lines, separated by one or\n * more lines that should be excluded. The first line must contain a `BEGIN`\n * directive, and the second most contain an `END` directive. Both directives\n * must specify the same command.\n *\n * Here's an example of a valid fence:\n *\n * ```javascript\n *   ///: BEGIN:ONLY_INCLUDE_IF(build-flask)\n *   console.log('I am Flask.');\n *   ///: END:ONLY_INCLUDE_IF\n * ```\n *\n * For details, please see the documentation.\n *\n * @param filePath - The path to the file being transformed.\n * @param fileContent - The contents of the file being transformed.\n * @param featureLabels - FeatureLabels that are currently active.\n * @returns A tuple of the post-transform file contents and a boolean indicating\n * whether they were modified.\n */\nexport function removeFencedCode(\n  filePath: string,\n  fileContent: string,\n  featureLabels: FeatureLabels,\n): [string, boolean] {\n  // Do not modify the file if we detect an inline sourcemap. For reasons\n  // yet to be determined, the transform receives every file twice while in\n  // watch mode, the second after Babel has transpiled the file. Babel adds\n  // inline source maps to the file, something we will never do in our own\n  // source files, so we use the existence of inline source maps to determine\n  // whether we should ignore the file.\n  if (/^\\/\\/# sourceMappingURL=/gmu.test(fileContent)) {\n    return [fileContent, false];\n  }\n\n  // If we didn't match any lines, return the unmodified file contents.\n  const matchedLines = [...fileContent.matchAll(linesWithFenceRegex)];\n\n  if (matchedLines.length === 0) {\n    return [fileContent, false];\n  }\n\n  // Parse fence lines\n  const parsedDirectives = matchedLines.map((matchArray) => {\n    const line = matchArray[0];\n\n    /* istanbul ignore next: should be impossible */\n    if (\n      matchArray.index === undefined ||\n      !line ||\n      !fenceSentinelRegex.test(line)\n    ) {\n      throw new Error(\n        getInvalidFenceLineMessage(\n          filePath,\n          line ?? '',\n          `Fence sentinel may only appear at the start of a line, optionally preceded by whitespace.`,\n        ),\n      );\n    }\n\n    // Store the start and end indices of each line\n    // Increment the end index by 1 to including the trailing newline when\n    // performing string operations.\n    const indices: [number, number] = [\n      matchArray.index,\n      matchArray.index + line.length + 1,\n    ];\n\n    const lineWithoutSentinel = line.replace(fenceSentinelRegex, '');\n    if (!/^ \\w\\w+/u.test(lineWithoutSentinel)) {\n      throw new Error(\n        getInvalidFenceLineMessage(\n          filePath,\n          line,\n          `Fence sentinel must be followed by a single space and an alphabetical string of two or more characters.`,\n        ),\n      );\n    }\n\n    const directiveMatches = lineWithoutSentinel\n      .trim()\n      .match(directiveParsingRegex);\n\n    if (!directiveMatches) {\n      throw new Error(\n        getInvalidFenceLineMessage(\n          filePath,\n          line,\n          `Failed to parse fence directive.`,\n        ),\n      );\n    }\n\n    // The first element of a RegEx match array is the input.\n    // Typecast: If there's a match, the expected elements must exist.\n    const [, terminus, command, parameters] = directiveMatches as [\n      string,\n      string,\n      string,\n      string,\n    ];\n\n    if (!isValidTerminus(terminus)) {\n      throw new Error(\n        getInvalidFenceLineMessage(\n          filePath,\n          line,\n          `Line contains invalid directive terminus \"${terminus}\".`,\n        ),\n      );\n    }\n\n    if (!isValidCommand(command)) {\n      throw new Error(\n        getInvalidFenceLineMessage(\n          filePath,\n          line,\n          `Line contains invalid directive command \"${command}\".`,\n        ),\n      );\n    }\n\n    if (terminus === DirectiveTerminus.BEGIN) {\n      if (!parameters) {\n        throw new Error(\n          getInvalidParamsMessage(filePath, `No parameters specified.`),\n        );\n      }\n\n      return {\n        command,\n        indices,\n        line,\n        parameters: parameters.split(','),\n        terminus,\n      };\n    }\n    return { command, indices, line, terminus };\n  });\n\n  if (parsedDirectives.length % 2 !== 0) {\n    throw new Error(\n      getInvalidFenceStructureMessage(\n        filePath,\n        `A valid fence consists of two fence lines, but the file contains an uneven number, \"${parsedDirectives.length}\", of fence lines.`,\n      ),\n    );\n  }\n\n  // The below for-loop iterates over the parsed fence directives and performs\n  // the following work:\n  // - Ensures that the array of parsed directives consists of valid directive\n  //   pairs, as specified in the documentation.\n  // - For each directive pair, determines whether their fenced lines should be\n  //   removed for the current build, and if so, stores the indices we will use\n  //   to splice the file content string.\n\n  const splicingIndices: number[] = [];\n  let shouldSplice = false;\n  let currentCommand: string;\n\n  parsedDirectives.forEach((directive, i) => {\n    const { line, indices, terminus, command } = directive;\n\n    if (i % 2 === 0) {\n      if (terminus !== DirectiveTerminus.BEGIN) {\n        throw new Error(\n          getInvalidFencePairMessage(\n            filePath,\n            line,\n            `The first directive of a pair must be a \"BEGIN\" directive.`,\n          ),\n        );\n      }\n\n      const { parameters } = directive;\n      currentCommand = command;\n      validateCommand(command, parameters, filePath, featureLabels);\n\n      const blockIsActive = parameters.some((param) =>\n        featureLabels.active.has(param),\n      );\n\n      if (blockIsActive) {\n        shouldSplice = false;\n      } else {\n        shouldSplice = true;\n\n        // Add start index of BEGIN directive line to splicing indices\n        splicingIndices.push(indices[0]);\n      }\n    } else {\n      if (terminus !== DirectiveTerminus.END) {\n        throw new Error(\n          getInvalidFencePairMessage(\n            filePath,\n            line,\n            `The second directive of a pair must be an \"END\" directive.`,\n          ),\n        );\n      }\n\n      /* istanbul ignore next: impossible until there's more than one command */\n      if (command !== currentCommand) {\n        throw new Error(\n          getInvalidFencePairMessage(\n            filePath,\n            line,\n            `Expected \"END\" directive to have command \"${currentCommand}\" but found \"${command}\".`,\n          ),\n        );\n      }\n\n      // Forbid empty fences\n      const { line: previousLine, indices: previousIndices } =\n        // We're only in this case if i > 0, so this will always be defined.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        parsedDirectives[i - 1]!;\n      if (fileContent.substring(previousIndices[1], indices[0]).trim() === '') {\n        throw new Error(\n          `Empty fence found in file \"${filePath}\":\\n${previousLine}\\n${line}\\n`,\n        );\n      }\n\n      if (shouldSplice) {\n        // Add end index of END directive line to splicing indices\n        splicingIndices.push(indices[1]);\n      }\n    }\n  });\n\n  // This indicates that the present build type should include all fenced code,\n  // and so we just returned the unmodified file contents.\n  if (splicingIndices.length === 0) {\n    return [fileContent, false];\n  }\n\n  /* istanbul ignore next: should be impossible */\n  if (splicingIndices.length % 2 !== 0) {\n    throw new Error(\n      `Internal error while transforming file \"${filePath}\":\\nCollected an uneven number of splicing indices: \"${splicingIndices.length}\"`,\n    );\n  }\n\n  return [multiSplice(fileContent, splicingIndices), true];\n}\n\n/**\n * Returns a copy of the given string, without the character ranges specified\n * by the splicing indices array.\n *\n * The splicing indices must be a non-empty, even-length array of non-negative\n * integers, specifying the character ranges to remove from the given string, as\n * follows:\n *\n * `[ start, end, start, end, start, end, ... ]`\n *\n * Throws if the array is not an even-length array of non-negative integers.\n *\n * @param toSplice - The string to splice.\n * @param splicingIndices - Indices to splice at.\n * @returns The spliced string.\n */\nexport function multiSplice(\n  toSplice: string,\n  splicingIndices: number[],\n): string {\n  if (splicingIndices.length === 0 || splicingIndices.length % 2 !== 0) {\n    throw new Error('Expected non-empty, even-length array.');\n  }\n  if (splicingIndices.some((index) => !Number.isInteger(index) || index < 0)) {\n    throw new Error('Expected array of non-negative integers.');\n  }\n\n  const retainedSubstrings = [];\n\n  // Get the first part to be included\n  // The substring() call returns an empty string if splicingIndices[0] is 0,\n  // which is exactly what we want in that case.\n  retainedSubstrings.push(toSplice.substring(0, splicingIndices[0]));\n\n  // This loop gets us all parts of the string that should be retained, except\n  // the first and the last.\n  // It iterates over all \"end\" indices of the array except the last one, and\n  // pushes the substring between each \"end\" index and the next \"begin\" index\n  // to the array of retained substrings.\n  if (splicingIndices.length > 2) {\n    // Note the boundary index of \"splicingIndices.length - 1\". This loop must\n    // not iterate over the last element of the array, which is handled outside\n    // of this loop.\n    for (let i = 1; i < splicingIndices.length - 1; i += 2) {\n      retainedSubstrings.push(\n        // splicingIndices[i] refers to an element between the first and last\n        // elements of the array, and will always be defined.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        toSplice.substring(splicingIndices[i]!, splicingIndices[i + 1]),\n      );\n    }\n  }\n\n  // Get the last part to be included\n  retainedSubstrings.push(\n    // The last element of a non-empty array will always be defined.\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    toSplice.substring(splicingIndices[splicingIndices.length - 1]!),\n  );\n  return retainedSubstrings.join('');\n}\n\n/**\n * Gets an invalid fence line error message.\n *\n * @param filePath - The path to the file that caused the error.\n * @param line - The contents of the line with the error.\n * @param details - An explanation of the error.\n * @returns The error message.\n */\nfunction getInvalidFenceLineMessage(\n  filePath: string,\n  line: string,\n  details: string,\n) {\n  return `Invalid fence line in file \"${filePath}\": \"${line}\":\\n${details}`;\n}\n\n/**\n * Gets an invalid fence structure error message.\n *\n * @param filePath - The path to the file that caused the error.\n * @param details - An explanation of the error.\n * @returns The error message.\n */\nfunction getInvalidFenceStructureMessage(filePath: string, details: string) {\n  return `Invalid fence structure in file \"${filePath}\":\\n${details}`;\n}\n\n/**\n * Gets an invalid fence pair error message.\n *\n * @param filePath - The path to the file that caused the error.\n * @param line - The contents of the line with the error.\n * @param details - An explanation of the error.\n * @returns The error message.\n */\nfunction getInvalidFencePairMessage(\n  filePath: string,\n  line: string,\n  details: string,\n) {\n  return `Invalid fence pair in file \"${filePath}\" due to line \"${line}\":\\n${details}`;\n}\n\n/**\n * Gets an invalid command params error message.\n *\n * @param filePath - The path to the file that caused the error.\n * @param details - An explanation of the error.\n * @param command - The command of the directive with the invalid parameters, if known.\n * @returns The error message.\n */\nfunction getInvalidParamsMessage(\n  filePath: string,\n  details: string,\n  command?: string,\n) {\n  return `Invalid code fence parameters in file \"${filePath}\"${\n    command ? `for command \"${command}\"` : ''\n  }:\\n${details}`;\n}\n\n/**\n * Checks whether the given terminus string is valid, i.e. one of `BEGIN` or `END`.\n *\n * @param terminus - The terminus string to validate.\n * @returns Whether the string is a valid terminus string.\n */\nfunction isValidTerminus(terminus: string): terminus is DirectiveTerminus {\n  return hasProperty(DirectiveTerminus, terminus);\n}\n\n/**\n * Checks whether the given command string is valid.\n *\n * @param command - The command string to validate.\n * @returns Whether the string is a valid command string.\n */\nfunction isValidCommand(command: string): command is DirectiveCommand {\n  return hasProperty(DirectiveCommand, command);\n}\n\n/**\n * Validates the specified command. Throws if validation fails.\n *\n * @param command - The command to validate.\n * @param params - The parameters of the command.\n * @param filePath - The path of the current file.\n * @param featureLabels - The possible feature labels.\n */\nexport function validateCommand(\n  command: unknown,\n  params: string[],\n  filePath: string,\n  featureLabels: FeatureLabels,\n): asserts command is DirectiveCommand {\n  switch (command) {\n    case DirectiveCommand.ONLY_INCLUDE_IF:\n      if (!params || params.length === 0) {\n        throw new Error(\n          getInvalidParamsMessage(\n            filePath,\n            `No parameters specified.`,\n            DirectiveCommand.ONLY_INCLUDE_IF,\n          ),\n        );\n      }\n\n      for (const param of params) {\n        if (!featureLabels.all.has(param)) {\n          throw new Error(\n            getInvalidParamsMessage(\n              filePath,\n              `\"${param}\" is not a declared build feature.`,\n              DirectiveCommand.ONLY_INCLUDE_IF,\n            ),\n          );\n        }\n      }\n      break;\n\n    default:\n      throw new Error(`Unrecognized command \"${String(command)}\".`);\n  }\n}\n"]}