{"version":3,"file":"ERC1155Standard.js","sourceRoot":"","sources":["../../../../src/Standards/NftStandards/ERC1155/ERC1155Standard.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,mEAAyD;AACzD,wDAAoD;AAGpD,iEAMoC;AACpC,oDAA+E;AAE/E,MAAa,eAAe;IAG1B,YAAY,QAAsB;QAIlC;;;;;WAKG;QACH,yCAAoC,GAAG,CACrC,OAAe,EACG,EAAE;YACpB,OAAO,IAAI,CAAC,yBAAyB,CACnC,OAAO,EACP,oDAAiC,CAClC,CAAC;QACJ,CAAC,CAAA,CAAC;QAEF;;;;;WAKG;QACH,2CAAsC,GAAG,CACvC,OAAe,EACG,EAAE;YACpB,OAAO,IAAI,CAAC,yBAAyB,CACnC,OAAO,EACP,sDAAmC,CACpC,CAAC;QACJ,CAAC,CAAA,CAAC;QAEF;;;;;WAKG;QACH,sCAAiC,GAAG,CAClC,OAAe,EACG,EAAE;YACpB,OAAO,IAAI,CAAC,yBAAyB,CAAC,OAAO,EAAE,uCAAoB,CAAC,CAAC;QACvE,CAAC,CAAA,CAAC;QAEF;;;;;;WAMG;QACH,gBAAW,GAAG,CAAO,OAAe,EAAE,OAAe,EAAmB,EAAE;YACxE,MAAM,QAAQ,GAAG,IAAI,oBAAQ,CAAC,OAAO,EAAE,8BAAU,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;YAClE,OAAO,QAAQ,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;QAC/B,CAAC,CAAA,CAAC;QAEF;;;;;;;WAOG;QACH,iBAAY,GAAG,CACb,eAAuB,EACvB,OAAe,EACf,OAAe,EACF,EAAE;YACf,MAAM,QAAQ,GAAG,IAAI,oBAAQ,CAAC,eAAe,EAAE,8BAAU,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;YAC1E,MAAM,OAAO,GAAG,MAAM,QAAQ,CAAC,SAAS,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;YAC3D,OAAO,IAAA,gCAAmB,EAAC,OAAO,CAAC,CAAC;QACtC,CAAC,CAAA,CAAC;QAEF;;;;;;;;;;;WAWG;QACH,mBAAc,GAAG,CACf,QAAgB,EAChB,IAAY,EACZ,EAAU,EACV,EAAU,EACV,KAAa,EACE,EAAE;YACjB,MAAM,QAAQ,GAAG,IAAI,oBAAQ,CAAC,QAAQ,EAAE,8BAAU,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;YACnE,OAAO,IAAI,OAAO,CAAO,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;gBAC3C,QAAQ,CAAC,cAAc,CACrB,QAAQ,EACR,IAAI,EACJ,EAAE,EACF,EAAE,EACF,KAAK,EACL,CAAC,KAAY,EAAE,MAAY,EAAE,EAAE;oBAC7B,wBAAwB;oBACxB,IAAI,KAAK,EAAE;wBACT,MAAM,CAAC,KAAK,CAAC,CAAC;wBACd,OAAO;qBACR;oBACD,OAAO,CAAC,MAAM,CAAC,CAAC;gBAClB,CAAC,CACF,CAAC;YACJ,CAAC,CAAC,CAAC;QACL,CAAC,CAAA,CAAC;QAEF;;;;;;WAMG;QACK,8BAAyB,GAAG,CAClC,OAAe,EACf,WAAmB,EACD,EAAE;YACpB,MAAM,QAAQ,GAAG,IAAI,oBAAQ,CAAC,OAAO,EAAE,8BAAU,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;YAClE,OAAO,QAAQ,CAAC,iBAAiB,CAAC,WAAW,CAAC,CAAC;QACjD,CAAC,CAAA,CAAC;QAEF;;;;;;;WAOG;QACH,eAAU,GAAG,CACX,OAAe,EACf,WAAmB,EACnB,OAAgB,EAKf,EAAE;YACH,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,iCAAiC,CAAC,OAAO,CAAC,CAAC;YAExE,IAAI,CAAC,SAAS,EAAE;gBACd,MAAM,IAAI,KAAK,CAAC,qCAAqC,CAAC,CAAC;aACxD;YACD,IAAI,QAAQ,EAAE,KAAK,CAAC;YAEpB,IAAI,OAAO,EAAE;gBACX,QAAQ,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;gBACpD,IAAI,QAAQ,CAAC,UAAU,CAAC,SAAS,CAAC,EAAE;oBAClC,QAAQ,GAAG,IAAA,gCAAmB,EAAC,WAAW,EAAE,QAAQ,EAAE,IAAI,CAAC,CAAC;iBAC7D;gBAED,IAAI;oBACF,MAAM,QAAQ,GAAG,MAAM,IAAA,+BAAY,EAAC,QAAQ,CAAC,CAAC;oBAC9C,MAAM,MAAM,GAAG,MAAM,QAAQ,CAAC,IAAI,EAAE,CAAC;oBACrC,KAAK,GAAG,MAAM,aAAN,MAAM,uBAAN,MAAM,CAAE,KAAK,CAAC;oBACtB,IAAI,KAAK,aAAL,KAAK,uBAAL,KAAK,CAAE,UAAU,CAAC,SAAS,CAAC,EAAE;wBAChC,KAAK,GAAG,IAAA,gCAAmB,EAAC,WAAW,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;qBACvD;iBACF;gBAAC,WAAM;oBACN,SAAS;iBACV;aACF;YAED,sDAAsD;YACtD,OAAO;gBACL,QAAQ,EAAE,0BAAO;gBACjB,QAAQ;gBACR,KAAK;aACN,CAAC;QACJ,CAAC,CAAA,CAAC;QAjLA,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;IAC3B,CAAC;CAiLF;AAtLD,0CAsLC","sourcesContent":["import { abiERC1155 } from '@metamask/metamask-eth-abis';\nimport { Contract } from '@ethersproject/contracts';\nimport { BN } from 'ethereumjs-util';\nimport { Web3Provider } from '@ethersproject/providers';\nimport {\n  ERC1155,\n  ERC1155_INTERFACE_ID,\n  ERC1155_METADATA_URI_INTERFACE_ID,\n  ERC1155_TOKEN_RECEIVER_INTERFACE_ID,\n  timeoutFetch,\n} from '@metamask/controller-utils';\nimport { getFormattedIpfsUrl, ethersBigNumberToBN } from '../../../assetsUtil';\n\nexport class ERC1155Standard {\n  private provider: Web3Provider;\n\n  constructor(provider: Web3Provider) {\n    this.provider = provider;\n  }\n\n  /**\n   * Query if contract implements ERC1155 URI Metadata interface.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC1155 URI Metadata interface.\n   */\n  contractSupportsURIMetadataInterface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(\n      address,\n      ERC1155_METADATA_URI_INTERFACE_ID,\n    );\n  };\n\n  /**\n   * Query if contract implements ERC1155 Token Receiver interface.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @returns Promise resolving to whether the contract implements ERC1155 Token Receiver interface.\n   */\n  contractSupportsTokenReceiverInterface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(\n      address,\n      ERC1155_TOKEN_RECEIVER_INTERFACE_ID,\n    );\n  };\n\n  /**\n   * Query if contract implements ERC1155 interface.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @returns Promise resolving to whether the contract implements the base ERC1155 interface.\n   */\n  contractSupportsBase1155Interface = async (\n    address: string,\n  ): Promise<boolean> => {\n    return this.contractSupportsInterface(address, ERC1155_INTERFACE_ID);\n  };\n\n  /**\n   * Query for tokenURI for a given asset.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @param tokenId - ERC1155 asset identifier.\n   * @returns Promise resolving to the 'tokenURI'.\n   */\n  getTokenURI = async (address: string, tokenId: string): Promise<string> => {\n    const contract = new Contract(address, abiERC1155, this.provider);\n    return contract.uri(tokenId);\n  };\n\n  /**\n   * Query for balance of a given ERC1155 token.\n   *\n   * @param contractAddress - ERC1155 asset contract address.\n   * @param address - Wallet public address.\n   * @param tokenId - ERC1155 asset identifier.\n   * @returns Promise resolving to the 'balanceOf'.\n   */\n  getBalanceOf = async (\n    contractAddress: string,\n    address: string,\n    tokenId: string,\n  ): Promise<BN> => {\n    const contract = new Contract(contractAddress, abiERC1155, this.provider);\n    const balance = await contract.balanceOf(address, tokenId);\n    return ethersBigNumberToBN(balance);\n  };\n\n  /**\n   * Transfer single ERC1155 token.\n   * When minting/creating tokens, the from arg MUST be set to 0x0 (i.e. zero address).\n   * When burning/destroying tokens, the to arg MUST be set to 0x0 (i.e. zero address).\n   *\n   * @param operator - ERC1155 token address.\n   * @param from - ERC1155 token holder.\n   * @param to - ERC1155 token recipient.\n   * @param id - ERC1155 token id.\n   * @param value - Number of tokens to be sent.\n   * @returns Promise resolving to the 'transferSingle'.\n   */\n  transferSingle = async (\n    operator: string,\n    from: string,\n    to: string,\n    id: string,\n    value: string,\n  ): Promise<void> => {\n    const contract = new Contract(operator, abiERC1155, this.provider);\n    return new Promise<void>((resolve, reject) => {\n      contract.transferSingle(\n        operator,\n        from,\n        to,\n        id,\n        value,\n        (error: Error, result: void) => {\n          /* istanbul ignore if */\n          if (error) {\n            reject(error);\n            return;\n          }\n          resolve(result);\n        },\n      );\n    });\n  };\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - ERC1155 asset contract address.\n   * @param interfaceId - Interface identifier.\n   * @returns Promise resolving to whether the contract implements `interfaceID`.\n   */\n  private contractSupportsInterface = async (\n    address: string,\n    interfaceId: string,\n  ): Promise<boolean> => {\n    const contract = new Contract(address, abiERC1155, this.provider);\n    return contract.supportsInterface(interfaceId);\n  };\n\n  /**\n   * Query if a contract implements an interface.\n   *\n   * @param address - Asset contract address.\n   * @param ipfsGateway - The user's preferred IPFS gateway.\n   * @param tokenId - tokenId of a given token in the contract.\n   * @returns Promise resolving an object containing the standard, tokenURI, symbol and name of the given contract/tokenId pair.\n   */\n  getDetails = async (\n    address: string,\n    ipfsGateway: string,\n    tokenId?: string,\n  ): Promise<{\n    standard: string;\n    tokenURI: string | undefined;\n    image: string | undefined;\n  }> => {\n    const isERC1155 = await this.contractSupportsBase1155Interface(address);\n\n    if (!isERC1155) {\n      throw new Error(\"This isn't a valid ERC1155 contract\");\n    }\n    let tokenURI, image;\n\n    if (tokenId) {\n      tokenURI = await this.getTokenURI(address, tokenId);\n      if (tokenURI.startsWith('ipfs://')) {\n        tokenURI = getFormattedIpfsUrl(ipfsGateway, tokenURI, true);\n      }\n\n      try {\n        const response = await timeoutFetch(tokenURI);\n        const object = await response.json();\n        image = object?.image;\n        if (image?.startsWith('ipfs://')) {\n          image = getFormattedIpfsUrl(ipfsGateway, image, true);\n        }\n      } catch {\n        // ignore\n      }\n    }\n\n    // TODO consider querying to the metadata to get name.\n    return {\n      standard: ERC1155,\n      tokenURI,\n      image,\n    };\n  };\n}\n"]}