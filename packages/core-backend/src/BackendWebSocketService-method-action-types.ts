/**
 * This file is auto generated by `scripts/generate-method-action-types.ts`.
 * Do not edit manually.
 */

import type { BackendWebSocketService } from './BackendWebSocketService';

/**
 * Establishes WebSocket connection with smart reconnection behavior
 *
 * Connection Requirements (all must be true):
 * 1. Feature enabled (isEnabled() = true)
 * 2. Wallet unlocked (checked by getBearerToken)
 * 3. User signed in (checked by getBearerToken)
 *
 * Platform code should call this when app opens/foregrounds.
 * Automatically called on KeyringController:unlock event.
 *
 * @returns Promise that resolves when connection is established
 */
export type BackendWebSocketServiceConnectAction = {
  type: `BackendWebSocketService:connect`;
  handler: BackendWebSocketService['connect'];
};

/**
 * Closes WebSocket connection
 */
export type BackendWebSocketServiceDisconnectAction = {
  type: `BackendWebSocketService:disconnect`;
  handler: BackendWebSocketService['disconnect'];
};

/**
 * Forces a WebSocket reconnection to clean up subscription state
 *
 * This method is useful when subscription state may be out of sync and needs to be reset.
 * It performs a controlled disconnect-then-reconnect sequence:
 * - Disconnects cleanly to trigger subscription cleanup
 * - Schedules reconnection with exponential backoff to prevent rapid loops
 * - All subscriptions will be cleaned up automatically on disconnect
 *
 * Use cases:
 * - Recovering from subscription/unsubscription issues
 * - Cleaning up orphaned subscriptions
 * - Forcing a fresh subscription state
 *
 * @returns Promise that resolves when disconnection is complete (reconnection is scheduled)
 */
export type BackendWebSocketServiceForceReconnectionAction = {
  type: `BackendWebSocketService:forceReconnection`;
  handler: BackendWebSocketService['forceReconnection'];
};

/**
 * Sends a message through the WebSocket (fire-and-forget, no response expected)
 *
 * This is a low-level method for sending messages without waiting for a response.
 * Most consumers should use `sendRequest()` instead, which handles request-response
 * correlation and provides proper error handling with timeouts.
 *
 * Use this method only when:
 * - You don't need a response from the server
 * - You're implementing custom message protocols
 * - You need fine-grained control over message timing
 *
 * @param message - The message to send
 * @throws Error if WebSocket is not connected or send fails
 *
 * @see sendRequest for request-response pattern with automatic correlation
 */
export type BackendWebSocketServiceSendMessageAction = {
  type: `BackendWebSocketService:sendMessage`;
  handler: BackendWebSocketService['sendMessage'];
};

/**
 * Sends a request and waits for a correlated response (recommended for most use cases)
 *
 * This is the recommended high-level method for request-response communication.
 * It automatically handles:
 * - Request ID generation and correlation
 * - Response matching with timeout protection
 * - Automatic reconnection on timeout
 * - Proper cleanup of pending requests
 *
 * @param message - The request message (can include optional requestId for testing)
 * @returns Promise that resolves with the response data
 * @throws Error if WebSocket is not connected, request times out, or response indicates failure
 *
 * @see sendMessage for fire-and-forget messaging without response handling
 */
export type BackendWebSocketServiceSendRequestAction = {
  type: `BackendWebSocketService:sendRequest`;
  handler: BackendWebSocketService['sendRequest'];
};

/**
 * Gets current connection information
 *
 * @returns Current connection status and details
 */
export type BackendWebSocketServiceGetConnectionInfoAction = {
  type: `BackendWebSocketService:getConnectionInfo`;
  handler: BackendWebSocketService['getConnectionInfo'];
};

/**
 * Gets all subscription information for a specific channel
 *
 * @param channel - The channel name to look up
 * @returns Array of subscription details for all subscriptions containing the channel
 */
export type BackendWebSocketServiceGetSubscriptionsByChannelAction = {
  type: `BackendWebSocketService:getSubscriptionsByChannel`;
  handler: BackendWebSocketService['getSubscriptionsByChannel'];
};

/**
 * Checks if a channel has a subscription
 *
 * @param channel - The channel name to check
 * @returns True if the channel has a subscription, false otherwise
 */
export type BackendWebSocketServiceChannelHasSubscriptionAction = {
  type: `BackendWebSocketService:channelHasSubscription`;
  handler: BackendWebSocketService['channelHasSubscription'];
};

/**
 * Finds all subscriptions that have channels starting with the specified prefix
 *
 * @param channelPrefix - The channel prefix to search for (e.g., "account-activity.v1")
 * @returns Array of subscription info for matching subscriptions
 */
export type BackendWebSocketServiceFindSubscriptionsByChannelPrefixAction = {
  type: `BackendWebSocketService:findSubscriptionsByChannelPrefix`;
  handler: BackendWebSocketService['findSubscriptionsByChannelPrefix'];
};

/**
 * Register a callback for specific channels (local callback only, no server subscription)
 *
 * **Key Difference from `subscribe()`:**
 * - `addChannelCallback()`: Registers a local callback without creating a server-side subscription.
 * The callback triggers on ANY message matching the channel name, regardless of subscriptionId.
 * Useful for system-wide notifications or when you don't control the subscription lifecycle.
 *
 * - `subscribe()`: Creates a proper server-side subscription with a subscriptionId.
 * The callback only triggers for messages with the matching subscriptionId.
 * Includes proper lifecycle management (unsubscribe, automatic cleanup on disconnect).
 *
 * **When to use `addChannelCallback()`:**
 * - Listening to system-wide notifications (e.g., 'system-notifications.v1')
 * - Monitoring channels where subscriptions are managed elsewhere
 * - Debug/logging scenarios where you want to observe all channel messages
 *
 * **When to use `subscribe()` instead:**
 * - Creating new subscriptions that need server-side registration
 * - When you need proper cleanup via unsubscribe
 * - Most application use cases (recommended approach)
 *
 * @param options - Channel callback configuration
 * @param options.channelName - Channel name to match exactly
 * @param options.callback - Function to call when channel matches
 *
 * @example
 * ```typescript
 * // Listen to system notifications (no server subscription needed)
 * webSocketService.addChannelCallback({
 * channelName: 'system-notifications.v1',
 * callback: (notification) => {
 * console.log('System notification:', notification.data);
 * }
 * });
 *
 * // For account-specific subscriptions, use subscribe() instead:
 * // const sub = await webSocketService.subscribe({
 * //   channels: ['account-activity.v1.eip155:0:0x1234...'],
 * //   callback: (notification) => { ... }
 * // });
 * ```
 *
 * @see subscribe for creating proper server-side subscriptions with lifecycle management
 */
export type BackendWebSocketServiceAddChannelCallbackAction = {
  type: `BackendWebSocketService:addChannelCallback`;
  handler: BackendWebSocketService['addChannelCallback'];
};

/**
 * Remove a channel callback
 *
 * @param channelName - The channel name returned from addChannelCallback
 * @returns True if callback was found and removed, false otherwise
 */
export type BackendWebSocketServiceRemoveChannelCallbackAction = {
  type: `BackendWebSocketService:removeChannelCallback`;
  handler: BackendWebSocketService['removeChannelCallback'];
};

/**
 * Get all registered channel callbacks (for debugging)
 *
 * @returns Array of all registered channel callbacks
 */
export type BackendWebSocketServiceGetChannelCallbacksAction = {
  type: `BackendWebSocketService:getChannelCallbacks`;
  handler: BackendWebSocketService['getChannelCallbacks'];
};

/**
 * Create and manage a subscription with server-side registration (recommended for most use cases)
 *
 * This is the recommended subscription API for high-level services. It creates a proper
 * server-side subscription and routes notifications based on subscriptionId.
 *
 * **Key Features:**
 * - Creates server-side subscription with unique subscriptionId
 * - Callback triggered only for messages with matching subscriptionId
 * - Automatic lifecycle management (cleanup on disconnect)
 * - Includes unsubscribe method for proper cleanup
 * - Request-response pattern with error handling
 *
 * **When to use `subscribe()`:**
 * - Creating new subscriptions (account activity, price updates, etc.)
 * - When you need proper cleanup/unsubscribe functionality
 * - Most application use cases
 *
 * **When to use `addChannelCallback()` instead:**
 * - System-wide notifications without server-side subscription
 * - Observing channels managed elsewhere
 * - Debug/logging scenarios
 *
 * @param options - Subscription configuration
 * @param options.channels - Array of channel names to subscribe to
 * @param options.callback - Callback function for handling notifications
 * @param options.requestId - Optional request ID for testing (will generate UUID if not provided)
 * @param options.channelType - Channel type identifier
 * @returns Subscription object with unsubscribe method
 *
 * @example
 * ```typescript
 * // AccountActivityService usage
 * const subscription = await webSocketService.subscribe({
 * channels: ['account-activity.v1.eip155:0:0x1234...'],
 * callback: (notification) => {
 * this.handleAccountActivity(notification.data);
 * }
 * });
 *
 * // Later, clean up
 * await subscription.unsubscribe();
 * ```
 *
 * @see addChannelCallback for local callbacks without server-side subscription
 */
export type BackendWebSocketServiceSubscribeAction = {
  type: `BackendWebSocketService:subscribe`;
  handler: BackendWebSocketService['subscribe'];
};

/**
 * Union of all BackendWebSocketService action types.
 */
export type BackendWebSocketServiceMethodActions =
  | BackendWebSocketServiceConnectAction
  | BackendWebSocketServiceDisconnectAction
  | BackendWebSocketServiceForceReconnectionAction
  | BackendWebSocketServiceSendMessageAction
  | BackendWebSocketServiceSendRequestAction
  | BackendWebSocketServiceGetConnectionInfoAction
  | BackendWebSocketServiceGetSubscriptionsByChannelAction
  | BackendWebSocketServiceChannelHasSubscriptionAction
  | BackendWebSocketServiceFindSubscriptionsByChannelPrefixAction
  | BackendWebSocketServiceAddChannelCallbackAction
  | BackendWebSocketServiceRemoveChannelCallbackAction
  | BackendWebSocketServiceGetChannelCallbacksAction
  | BackendWebSocketServiceSubscribeAction;
