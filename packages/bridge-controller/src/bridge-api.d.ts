/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["HealthController_serviceMetadata"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["HealthController_check"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/metrics": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["MonitoringController_getPrometheusMetrics"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/getQuote": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Gets Bridge Quotes
         * @description Returns Bridge quotes from across all aggregators
         */
        get: operations["AggregatorController_getQuoteV2"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/getQuoteStream": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Gets Bridge Quotes via SSE Stream
         * @description Returns Bridge quotes as Server-Sent Events, streaming quotes as they arrive from aggregators
         */
        get: operations["AggregatorController_getQuoteStreamV2"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/getQuoteStream": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Gets Bridge Quotes via SSE Stream
         * @description Returns Bridge quotes as Server-Sent Events, streaming quotes as they arrive from aggregators
         */
        get: operations["AggregatorController_getQuoteStream"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/getQuote": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Gets Bridge Quotes
         * @description Returns Bridge quotes from across all aggregators
         */
        get: operations["AggregatorController_getQuote"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/getTxStatus": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Gets Bridge Status
         * @description Returns a Bridge's status for a given and whether it was successful or not, or is pending completion
         */
        get: operations["AggregatorController_getTxStatusV2"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/getTxStatus": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Gets Bridge Status
         * @description Returns a Bridge's status for a given and whether it was successful or not, or is pending completion
         */
        get: operations["AggregatorController_getTxStatus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/getAllFeatureFlags": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a list of all the Launch Darkly Flags
         * @description Useful for debugging and informational purposes. Retruns a JSON of all the Bridge Launch Darkly Flags
         */
        get: operations["AggregatorController_getAllFeatureFlags"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/providerCheck": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["AggregatorController_providerCheck"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/addresses": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["AggregatorController_getContractAddresses"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/aggregators": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["AggregatorController_getAggregatorsSupportingLifecycle"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/aggregators/all": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["AggregatorController_getAllSupportedCombinations"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/submitOrder": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Submit Intent Order
         * @description Submit a signed intent order to an aggregator (e.g., CowSwap)
         */
        post: operations["AggregatorController_submitOrder"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/getOrderStatus": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Order Status
         * @description Get the status of a submitted intent order
         */
        get: operations["AggregatorController_getOrderStatus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/getTokens": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns a list of all Bridge Tokens
         * @description Returns a list of all the supported Bridge Tokens
         */
        get: operations["TokensController_getTokens"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/getTokens/popular": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Returns a list of all Bridge Tokens
         * @description Returns a list of all the supported Bridge Tokens
         */
        post: operations["TokensController_getPopularTokens"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/getTokens/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Returns a list of all Bridge Tokens
         * @description Returns a list of all the supported Bridge Tokens
         */
        post: operations["TokensController_searchTokens"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/decode/{action}/{srcChainId}/{txHash}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Decodes a MetaBridge Transaction
         * @description Useful for debugging and informational purposes. Decodes a Bridge transaction and what was submitted on chain
         */
        get: operations["DecoderController_decode"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/relay/quote": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get a quote from Relay API
         * @description Proxies a quote request to the Relay API to safeguard the API key. Accepts all parameters needed for the Relay quote request.
         */
        post: operations["RelayProxyController_proxyRelayQuote"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/featureFlags": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["SwapsController_getFeatureFlags"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/networks/{chainId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["SwapsController_getNetworkConfig"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/networks/{chainId}/tokens": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["SwapsController_getTokens"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/networks/{chainId}/token": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["SwapsController_getToken"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/networks/{chainId}/topAssets": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["SwapsController_getTopAssets"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/networks/{chainId}/aggregators": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["SwapsController_getSupportedAggregators"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/networks/{chainId}/aggregatorMetadata": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["SwapsController_getAggregatorMetadata"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/networks/{chainId}/unsupportedTokens": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["SwapsController_getUnsupportedTokens"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/networks/{chainId}/blockedTokens": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["SwapsController_getBlockedTokens"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        TokenDto: {
            chainId: number;
            assetId: string;
            name: string;
            symbol: string;
            address: string;
            decimals: number;
            iconUrl?: string;
            coingeckoId?: string;
            aggregators: string[];
            occurrences?: number;
            fee?: number;
            metadata?: Record<string, never>;
            price?: string;
        };
        ProtocolDto: {
            name: string;
            displayName?: string;
            icon?: string;
        };
        StepDto: {
            /** @enum {string} */
            action: "send" | "swap" | "bridge" | "wrap" | "getBridgeStatus" | "refuel" | "gaslessSwap" | "intentSwap" | "gaslessBridge";
            /** @enum {number} */
            srcChainId: 20000000000001 | 1 | 10 | 56 | 137 | 143 | 324 | 1329 | 8453 | 42161 | 43114 | 59144 | 1151111081099710 | 728126428;
            /** @enum {number} */
            destChainId?: 20000000000001 | 1 | 10 | 56 | 137 | 143 | 324 | 1329 | 8453 | 42161 | 43114 | 59144 | 1151111081099710 | 728126428;
            srcAsset: components["schemas"]["TokenDto"];
            destAsset: components["schemas"]["TokenDto"];
            srcAmount: string;
            destAmount: string;
            protocol: components["schemas"]["ProtocolDto"];
        };
        BridgePriceDataDto: {
            totalFromAmountUsd: string;
            totalToAmountUsd: string;
            priceImpact: string;
            totalFeeAmountUsd?: string;
        };
        CrossChainQuoteDto: {
            requestId: string;
            bridgeId: string;
            srcChainId: number;
            srcAsset: components["schemas"]["TokenDto"];
            srcTokenAmount: string;
            destChainId: number;
            destAsset: components["schemas"]["TokenDto"];
            destTokenAmount: string;
            minDestTokenAmount: string;
            feeData: Record<string, never>;
            aggregator: string;
            /** @description To be deprecated. */
            bridges: string[];
            /** @description Should be identical to bridges. Bridges field is to be deprecated. */
            protocols: string[];
            steps: components["schemas"]["StepDto"][];
            refuel?: components["schemas"]["StepDto"];
            priceData: components["schemas"]["BridgePriceDataDto"];
            gasIncluded?: boolean;
            gasIncluded7702?: boolean;
            /** @description On solana we sometimes use the auto slippage so we need to get it from provider, however not all return it. */
            slippage?: number;
            gasSponsored?: boolean;
            /** @description Optional for backwards compatibility */
            aggregatorType?: string;
            walletAddress?: string;
            destWalletAddress?: string;
        };
        QuoteResponseDto: {
            quote: components["schemas"]["CrossChainQuoteDto"];
            approval?: Record<string, never>;
            trade: Record<string, never>;
            estimatedProcessingTimeInSeconds: number;
        };
        StatusDto: {
            chainId: number;
            txHash?: string | null;
            amount?: string | null;
            token?: components["schemas"]["TokenDto"];
        };
        StatusResponseDto: {
            status: string;
            srcChain: components["schemas"]["StatusDto"];
            destChain?: components["schemas"]["StatusDto"];
            bridge?: string;
            isExpectedToken?: boolean;
            isUnrecognizedRouterAddress?: boolean;
            refuel?: components["schemas"]["StatusResponseDto"];
        };
        SubmitIntentOrderRequestDto: {
            /**
             * @description The chain where the order executes
             * @enum {number}
             */
            srcChainId: 20000000000001 | 1 | 10 | 56 | 137 | 143 | 324 | 1329 | 8453 | 42161 | 43114 | 59144 | 1151111081099710 | 728126428;
            /** @description The quote/request ID from getQuote response */
            quoteId: string;
            /** @description User's EIP-712 signature of the order */
            signature: string;
            /** @description The order data from quote.intent.order */
            order: Record<string, never>;
            /** @description The user's wallet address */
            userAddress: string;
            /**
             * @description Which aggregator to use (e.g., COWSWAP)
             * @enum {string}
             */
            aggregatorId: "lifi" | "socket" | "squid" | "jupiter" | "kyberswap" | "wrapped_native" | "1inch" | "0x" | "openocean" | "pmm" | "rango" | "airswap" | "debridge" | "okx" | "cowswap" | "bridgers" | "xoswap" | "relay" | "across" | "relay_native" | "stargate" | "mayan";
        };
        DefaultAssetIdDto: Record<string, never>;
        PopularTokensRequestDto: {
            /**
             * @description Array of chain IDs in CAIP-2 format
             * @example [
             *       "eip155:1",
             *       "eip155:137"
             *     ]
             */
            chainIds: string[];
            /**
             * @description Array of default asset IDs in CAIP-19 format to ensure inclusion in the response
             * @example [
             *       {
             *         "assetId": "eip155:1/erc20:0xa0b86a33e6441b8c4c8c0e1234567890abcdef123",
             *         "name": "USD Coin",
             *         "symbol": "USDC",
             *         "decimals": 18
             *       }
             *     ]
             */
            includeAssets?: components["schemas"]["DefaultAssetIdDto"][];
        };
        SearchRequestDto: {
            /**
             * @description Array of chain IDs in CAIP-2 format
             * @example [
             *       "eip155:1",
             *       "eip155:137"
             *     ]
             */
            chainIds: string[];
            /**
             * @description Search query string
             * @example USDC
             */
            query: string;
            /**
             * @description Cursor for pagination
             * @example MA==
             */
            after?: string;
            /**
             * @description Array of default asset IDs in CAIP-19 format to ensure inclusion in the response
             * @example [
             *       {
             *         "assetId": "eip155:1/erc20:0xa0b86a33e6441b8c4c8c0e1234567890abcdef123",
             *         "name": "USD Coin",
             *         "symbol": "USDC",
             *         "decimals": 18
             *       }
             *     ]
             */
            includeAssets?: components["schemas"]["DefaultAssetIdDto"][];
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    HealthController_serviceMetadata: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    HealthController_check: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    MonitoringController_getPrometheusMetrics: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    AggregatorController_getQuoteV2: {
        parameters: {
            query: {
                srcTokenAmount: string;
                slippage?: number;
                aggIds?: string[];
                bridgeIds?: string[];
                insufficientBal?: boolean;
                /** @description Custom fee rate in basis points (0-10000 bps) */
                fee?: number;
                resetApproval?: boolean;
                refuel?: boolean;
                gasIncluded?: boolean;
                gasIncluded7702?: boolean;
                clientId?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successfully retrieved quotes */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["QuoteResponseDto"][];
                };
            };
        };
    };
    AggregatorController_getQuoteStreamV2: {
        parameters: {
            query: {
                srcTokenAmount: string;
                slippage?: number;
                aggIds?: string[];
                bridgeIds?: string[];
                insufficientBal?: boolean;
                /** @description Custom fee rate in basis points (0-10000 bps) */
                fee?: number;
                resetApproval?: boolean;
                refuel?: boolean;
                gasIncluded?: boolean;
                gasIncluded7702?: boolean;
                clientId?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description SSE stream of quotes. Each event contains a QuoteResponseDto. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/event-stream": {
                        data?: components["schemas"]["QuoteResponseDto"];
                        /** @example quote */
                        type?: string;
                        /** @example 1234567890-0 */
                        id?: string;
                    };
                };
            };
        };
    };
    AggregatorController_getQuoteStream: {
        parameters: {
            query: {
                walletAddress: string;
                destWalletAddress?: string;
                srcChainId: number;
                destChainId: number;
                srcTokenAddress: string;
                destTokenAddress: string;
                srcTokenAmount: string;
                slippage?: number;
                aggIds?: string[];
                bridgeIds?: string[];
                insufficientBal?: boolean;
                /** @description Custom fee rate in basis points (0-10000 bps) */
                fee?: number;
                noFee?: boolean;
                resetApproval?: boolean;
                refuel?: boolean;
                gasIncluded?: boolean;
                gasIncluded7702?: boolean;
                clientId?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description SSE stream of quotes. Each event contains a QuoteResponseDto. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "text/event-stream": {
                        data?: components["schemas"]["QuoteResponseDto"];
                        /** @example quote */
                        type?: string;
                        /** @example 1234567890-0 */
                        id?: string;
                    };
                };
            };
        };
    };
    AggregatorController_getQuote: {
        parameters: {
            query: {
                walletAddress: string;
                destWalletAddress?: string;
                srcChainId: number;
                destChainId: number;
                srcTokenAddress: string;
                destTokenAddress: string;
                srcTokenAmount: string;
                slippage?: number;
                aggIds?: string[];
                bridgeIds?: string[];
                insufficientBal?: boolean;
                /** @description Custom fee rate in basis points (0-10000 bps) */
                fee?: number;
                noFee?: boolean;
                resetApproval?: boolean;
                refuel?: boolean;
                gasIncluded?: boolean;
                gasIncluded7702?: boolean;
                clientId?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successfully retrieved quotes */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["QuoteResponseDto"][];
                };
            };
        };
    };
    AggregatorController_getTxStatusV2: {
        parameters: {
            query: {
                bridgeId: string;
                srcTxHash: string;
                requestId?: string;
                refuel: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successfully retrieved transaction status */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StatusResponseDto"];
                };
            };
        };
    };
    AggregatorController_getTxStatus: {
        parameters: {
            query: {
                bridgeId: string;
                srcTxHash: string;
                requestId?: string;
                srcChainId: number;
                destChainId: number;
                refuel: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successfully retrieved transaction status */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StatusResponseDto"];
                };
            };
        };
    };
    AggregatorController_getAllFeatureFlags: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    AggregatorController_providerCheck: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    AggregatorController_getContractAddresses: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    AggregatorController_getAggregatorsSupportingLifecycle: {
        parameters: {
            query: {
                /** @description The chain ID to check lifecycle support for */
                chainId: 20000000000001 | 1 | 10 | 56 | 137 | 143 | 324 | 1329 | 8453 | 42161 | 43114 | 59144 | 1151111081099710 | 728126428;
                /** @description The operation type to check lifecycle support for */
                operation: "send" | "swap" | "bridge" | "wrap" | "getBridgeStatus" | "refuel" | "gaslessSwap" | "intentSwap" | "gaslessBridge";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    AggregatorController_getAllSupportedCombinations: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    AggregatorController_submitOrder: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SubmitIntentOrderRequestDto"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    AggregatorController_getOrderStatus: {
        parameters: {
            query: {
                /** @description The order ID returned from submitOrder */
                orderId: string;
                /** @description The chain where the order was submitted */
                srcChainId: 20000000000001 | 1 | 10 | 56 | 137 | 143 | 324 | 1329 | 8453 | 42161 | 43114 | 59144 | 1151111081099710 | 728126428;
                /** @description Which aggregator to query (e.g., COWSWAP) */
                aggregatorId: "lifi" | "socket" | "squid" | "jupiter" | "kyberswap" | "wrapped_native" | "1inch" | "0x" | "openocean" | "pmm" | "rango" | "airswap" | "debridge" | "okx" | "cowswap" | "bridgers" | "xoswap" | "relay" | "across" | "relay_native" | "stargate" | "mayan";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TokensController_getTokens: {
        parameters: {
            query: {
                chainId: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TokensController_getPopularTokens: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["PopularTokensRequestDto"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    TokensController_searchTokens: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SearchRequestDto"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    DecoderController_decode: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                srcChainId: number;
                txHash: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    RelayProxyController_proxyRelayQuote: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successfully retrieved quote from Relay */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": Record<string, never>;
                };
            };
            /** @description Invalid request parameters */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error or Relay API error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    SwapsController_getFeatureFlags: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    SwapsController_getNetworkConfig: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    SwapsController_getTokens: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                chainId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    SwapsController_getToken: {
        parameters: {
            query: {
                address: string;
            };
            header?: never;
            path: {
                chainId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    SwapsController_getTopAssets: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                chainId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    SwapsController_getSupportedAggregators: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                chainId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    SwapsController_getAggregatorMetadata: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                chainId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    SwapsController_getUnsupportedTokens: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                chainId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    SwapsController_getBlockedTokens: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                chainId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
}
