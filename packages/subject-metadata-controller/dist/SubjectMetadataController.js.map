{"version":3,"file":"SubjectMetadataController.js","sourceRoot":"","sources":["../src/SubjectMetadataController.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Patch } from 'immer';\nimport { Json } from '@metamask/types';\nimport {\n  BaseControllerV2,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport type {\n  GenericPermissionController,\n  PermissionSubjectMetadata,\n  HasPermissions,\n} from '@metamask/permission-controller';\n\nconst controllerName = 'SubjectMetadataController';\n\ntype SubjectOrigin = string;\n\n/**\n * The different kinds of subjects that MetaMask may interact with, including\n * third parties and itself (e.g., when the background communicated with the UI).\n */\nexport enum SubjectType {\n  Extension = 'extension',\n  Internal = 'internal',\n  Unknown = 'unknown',\n  Website = 'website',\n  Snap = 'snap',\n}\n\nexport type SubjectMetadata = PermissionSubjectMetadata & {\n  [key: string]: Json;\n  // TODO:TS4.4 make optional\n  name: string | null;\n  subjectType: SubjectType | null;\n  extensionId: string | null;\n  iconUrl: string | null;\n};\n\ntype SubjectMetadataToAdd = PermissionSubjectMetadata & {\n  name?: string | null;\n  subjectType?: SubjectType | null;\n  extensionId?: string | null;\n  iconUrl?: string | null;\n} & Record<string, Json>;\n\nexport type SubjectMetadataControllerState = {\n  subjectMetadata: Record<SubjectOrigin, SubjectMetadata>;\n};\n\nconst stateMetadata = {\n  subjectMetadata: { persist: true, anonymous: false },\n};\n\nconst defaultState: SubjectMetadataControllerState = {\n  subjectMetadata: {},\n};\n\nexport type GetSubjectMetadataState = {\n  type: `${typeof controllerName}:getState`;\n  handler: () => SubjectMetadataControllerState;\n};\n\nexport type GetSubjectMetadata = {\n  type: `${typeof controllerName}:getSubjectMetadata`;\n  handler: (origin: SubjectOrigin) => SubjectMetadata | undefined;\n};\n\nexport type SubjectMetadataControllerActions =\n  | GetSubjectMetadataState\n  | GetSubjectMetadata;\n\nexport type SubjectMetadataStateChange = {\n  type: `${typeof controllerName}:stateChange`;\n  payload: [SubjectMetadataControllerState, Patch[]];\n};\n\nexport type SubjectMetadataControllerEvents = SubjectMetadataStateChange;\n\ntype AllowedActions = HasPermissions;\n\nexport type SubjectMetadataControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  SubjectMetadataControllerActions | AllowedActions,\n  SubjectMetadataControllerEvents,\n  AllowedActions['type'],\n  never\n>;\n\ntype SubjectMetadataControllerOptions = {\n  messenger: SubjectMetadataControllerMessenger;\n  subjectCacheLimit: number;\n  state?: Partial<SubjectMetadataControllerState>;\n};\n\n/**\n * A controller for storing metadata associated with permission subjects. More\n * or less, a cache.\n */\nexport class SubjectMetadataController extends BaseControllerV2<\n  typeof controllerName,\n  SubjectMetadataControllerState,\n  SubjectMetadataControllerMessenger\n> {\n  private subjectCacheLimit: number;\n\n  private subjectsWithoutPermissionsEncounteredSinceStartup: Set<string>;\n\n  private subjectHasPermissions: GenericPermissionController['hasPermissions'];\n\n  constructor({\n    messenger,\n    subjectCacheLimit,\n    state = {},\n  }: SubjectMetadataControllerOptions) {\n    if (!Number.isInteger(subjectCacheLimit) || subjectCacheLimit < 1) {\n      throw new Error(\n        `subjectCacheLimit must be a positive integer. Received: \"${subjectCacheLimit}\"`,\n      );\n    }\n\n    const hasPermissions = (origin: string) => {\n      return messenger.call('PermissionController:hasPermissions', origin);\n    };\n\n    super({\n      name: controllerName,\n      metadata: stateMetadata,\n      messenger,\n      state: {\n        ...SubjectMetadataController.getTrimmedState(state, hasPermissions),\n      },\n    });\n\n    this.subjectHasPermissions = hasPermissions;\n    this.subjectCacheLimit = subjectCacheLimit;\n    this.subjectsWithoutPermissionsEncounteredSinceStartup = new Set();\n\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:getSubjectMetadata`,\n      this.getSubjectMetadata.bind(this),\n    );\n  }\n\n  /**\n   * Clears the state of this controller. Also resets the cache of subjects\n   * encountered since startup, so as to not prematurely reach the cache limit.\n   */\n  clearState(): void {\n    this.subjectsWithoutPermissionsEncounteredSinceStartup.clear();\n    this.update((_draftState) => {\n      return { ...defaultState };\n    });\n  }\n\n  /**\n   * Stores domain metadata for the given origin (subject). Deletes metadata for\n   * subjects without permissions in a FIFO manner once more than\n   * {@link SubjectMetadataController.subjectCacheLimit} distinct origins have\n   * been added since boot.\n   *\n   * In order to prevent a degraded user experience,\n   * metadata is never deleted for subjects with permissions, since metadata\n   * cannot yet be requested on demand.\n   *\n   * @param metadata - The subject metadata to store.\n   */\n  addSubjectMetadata(metadata: SubjectMetadataToAdd): void {\n    const { origin } = metadata;\n    const newMetadata: SubjectMetadata = {\n      ...metadata,\n      extensionId: metadata.extensionId || null,\n      iconUrl: metadata.iconUrl || null,\n      name: metadata.name || null,\n      subjectType: metadata.subjectType || null,\n    };\n\n    let originToForget: string | null = null;\n    // We only delete the oldest encountered subject from the cache, again to\n    // ensure that the user's experience isn't degraded by missing icons etc.\n    if (\n      this.subjectsWithoutPermissionsEncounteredSinceStartup.size >=\n      this.subjectCacheLimit\n    ) {\n      const cachedOrigin =\n        this.subjectsWithoutPermissionsEncounteredSinceStartup\n          .values()\n          .next().value;\n\n      this.subjectsWithoutPermissionsEncounteredSinceStartup.delete(\n        cachedOrigin,\n      );\n\n      if (!this.subjectHasPermissions(cachedOrigin)) {\n        originToForget = cachedOrigin;\n      }\n    }\n\n    this.subjectsWithoutPermissionsEncounteredSinceStartup.add(origin);\n\n    this.update((draftState) => {\n      // Typecast: ts(2589)\n      draftState.subjectMetadata[origin] = newMetadata as any;\n      if (typeof originToForget === 'string') {\n        delete draftState.subjectMetadata[originToForget];\n      }\n    });\n  }\n\n  /**\n   * Gets the subject metadata for the given origin, if any.\n   *\n   * @param origin - The origin for which to get the subject metadata.\n   * @returns The subject metadata, if any, or `undefined` otherwise.\n   */\n  getSubjectMetadata(origin: SubjectOrigin): SubjectMetadata | undefined {\n    return this.state.subjectMetadata[origin];\n  }\n\n  /**\n   * Deletes all subjects without permissions from the controller's state.\n   */\n  trimMetadataState(): void {\n    this.update((draftState) => {\n      return SubjectMetadataController.getTrimmedState(\n        // Typecast: ts(2589)\n        draftState as any,\n        this.subjectHasPermissions,\n      );\n    });\n  }\n\n  /**\n   * Returns a new state object that only includes subjects with permissions.\n   * This method is static because we want to call it in the constructor, before\n   * the controller's state is initialized.\n   *\n   * @param state - The state object to trim.\n   * @param hasPermissions - A function that returns a boolean indicating\n   * whether a particular subject (identified by its origin) has any\n   * permissions.\n   * @returns The new state object. If the specified `state` object has no\n   * subject metadata, the returned object will be equivalent to the default\n   * state of this controller.\n   */\n  private static getTrimmedState(\n    state: Partial<SubjectMetadataControllerState>,\n    hasPermissions: SubjectMetadataController['subjectHasPermissions'],\n  ): SubjectMetadataControllerState {\n    const { subjectMetadata = {} } = state;\n\n    return {\n      subjectMetadata: Object.keys(subjectMetadata).reduce<\n        Record<SubjectOrigin, SubjectMetadata>\n      >((newSubjectMetadata, origin) => {\n        if (hasPermissions(origin)) {\n          newSubjectMetadata[origin] = subjectMetadata[origin];\n        }\n        return newSubjectMetadata;\n      }, {}),\n    };\n  }\n}\n"]}