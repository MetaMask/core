{"version":3,"sources":["../src/utils/validation.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Struct, StructError } from '@metamask/superstruct';\nimport {\n  assert,\n  boolean,\n  define,\n  enums,\n  func,\n  number,\n  object,\n  optional,\n  refine,\n  string,\n} from '@metamask/superstruct';\nimport { TransactionType } from '@metamask/transaction-controller';\nimport { isStrictHexString } from '@metamask/utils';\n\nimport { EMPTY_BYTES } from '../constants';\nimport type {\n  PrepareUserOperationResponse,\n  SignUserOperationResponse,\n  UpdateUserOperationResponse,\n} from '../types';\nimport type {\n  AddUserOperationOptions,\n  AddUserOperationRequest,\n} from '../UserOperationController';\n\n/**\n * Validate a request to add a user operation.\n * @param request - The request to validate.\n */\nexport function validateAddUserOperationRequest(\n  request: AddUserOperationRequest,\n) {\n  const Hex = defineHex();\n  const HexOrEmptyBytes = defineHexOrEmptyBytes();\n\n  const ValidRequest = object({\n    data: optional(HexOrEmptyBytes),\n    from: Hex,\n    maxFeePerGas: optional(Hex),\n    maxPriorityFeePerGas: optional(Hex),\n    to: optional(Hex),\n    value: optional(Hex),\n  });\n\n  validate(request, ValidRequest, 'Invalid request to add user operation');\n}\n\n/**\n * Validate the options when adding a user operation.\n * @param options - The options to validate.\n */\nexport function validateAddUserOperationOptions(\n  options: AddUserOperationOptions,\n) {\n  const ValidOptions = object({\n    networkClientId: string(),\n    origin: string(),\n    requireApproval: optional(boolean()),\n    smartContractAccount: optional(\n      object({\n        prepareUserOperation: func(),\n        updateUserOperation: func(),\n        signUserOperation: func(),\n      }),\n    ),\n    swaps: optional(\n      object({\n        approvalTxId: optional(string()),\n        destinationTokenAddress: optional(string()),\n        destinationTokenDecimals: optional(number()),\n        destinationTokenSymbol: optional(string()),\n        estimatedBaseFee: optional(string()),\n        sourceTokenSymbol: optional(string()),\n        swapMetaData: optional(object()),\n        swapTokenValue: optional(string()),\n        destinationTokenAmount: optional(string()),\n        sourceTokenAddress: optional(string()),\n        sourceTokenAmount: optional(string()),\n        sourceTokenDecimals: optional(number()),\n        swapAndSendRecipient: optional(string()),\n      }),\n    ),\n    type: optional(enums(Object.values(TransactionType))),\n  });\n\n  validate(options, ValidOptions, 'Invalid options to add user operation');\n}\n\n/**\n * Validate the response from a smart contract account when preparing the user operation.\n * @param response - The response to validate.\n */\nexport function validatePrepareUserOperationResponse(\n  response: PrepareUserOperationResponse,\n) {\n  const Hex = defineHex();\n  const HexOrEmptyBytes = defineHexOrEmptyBytes();\n\n  const ValidResponse = refine(\n    object({\n      bundler: string(),\n      callData: Hex,\n      dummyPaymasterAndData: optional(HexOrEmptyBytes),\n      dummySignature: optional(HexOrEmptyBytes),\n      gas: optional(\n        object({\n          callGasLimit: Hex,\n          preVerificationGas: Hex,\n          verificationGasLimit: Hex,\n        }),\n      ),\n      initCode: optional(HexOrEmptyBytes),\n      nonce: Hex,\n      sender: Hex,\n    }),\n    'ValidPrepareUserOperationResponse',\n    ({ gas, dummySignature }) => {\n      if (!gas && (!dummySignature || dummySignature === EMPTY_BYTES)) {\n        return 'Must specify dummySignature if not specifying gas';\n      }\n\n      /* istanbul ignore next */\n      return true;\n    },\n  );\n\n  validate(\n    response,\n    ValidResponse,\n    'Invalid response when preparing user operation',\n  );\n}\n\n/**\n * Validate the response from a smart contract account when updating the user operation.\n * @param response - The response to validate.\n */\nexport function validateUpdateUserOperationResponse(\n  response: UpdateUserOperationResponse,\n) {\n  const ValidResponse = optional(\n    object({\n      paymasterAndData: optional(defineHexOrEmptyBytes()),\n      callGasLimit: optional(defineHexOrEmptyBytes()),\n      preVerificationGas: optional(defineHexOrEmptyBytes()),\n      verificationGasLimit: optional(defineHexOrEmptyBytes()),\n    }),\n  );\n\n  validate(\n    response,\n    ValidResponse,\n    'Invalid response when updating user operation',\n  );\n}\n\n/**\n * Validate the response from a smart contract account when signing the user operation.\n * @param response - The response to validate.\n */\nexport function validateSignUserOperationResponse(\n  response: SignUserOperationResponse,\n) {\n  const Hex = defineHex();\n\n  const ValidResponse = object({\n    signature: Hex,\n  });\n\n  validate(\n    response,\n    ValidResponse,\n    'Invalid response when signing user operation',\n  );\n}\n\n/**\n * Validate data against a struct.\n * @param data - The data to validate.\n * @param struct - The struct to validate against.\n * @param message - The message to throw if validation fails.\n */\n// TODO: Either fix this lint violation or explain why it's necessary to ignore.\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction validate<T>(data: unknown, struct: Struct<T>, message: string) {\n  try {\n    assert(data, struct, message);\n  } catch (error) {\n    const causes = (error as StructError)\n      .failures()\n      .map((failure) => {\n        if (!failure.path.length) {\n          return failure.message;\n        }\n\n        return `${failure.path.join('.')} - ${failure.message}`;\n      })\n      .join('\\n');\n\n    const finalMessage = `${message}\\n${causes}`;\n\n    throw new Error(finalMessage);\n  }\n}\n\n/**\n * Define the Hex type used by superstruct.\n * @returns The Hex superstruct type.\n */\nfunction defineHex() {\n  return define<string>('Hexadecimal String', (value) =>\n    isStrictHexString(value),\n  );\n}\n\n/**\n * Define the HexOrEmptyBytes type used by superstruct.\n * @returns The HexOrEmptyBytes superstruct type.\n */\nfunction defineHexOrEmptyBytes() {\n  return define<string>(\n    'Hexadecimal String or 0x',\n    (value) => isStrictHexString(value) || value === EMPTY_BYTES,\n  );\n}\n"]}