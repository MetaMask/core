import type {
  AccountGroupId,
  Bip44Account,
  MultichainAccountWalletId,
  MultichainAccountWallet as MultichainAccountWalletDefinition,
  MultichainAccountWalletStatus,
} from '@metamask/account-api';
import {
  AccountWalletType,
  getGroupIndexFromMultichainAccountGroupId,
  isMultichainAccountGroupId,
  toDefaultAccountGroupId,
  toMultichainAccountWalletId,
} from '@metamask/account-api';
import { AccountCreationType } from '@metamask/keyring-api';
import type { EntropySourceId, KeyringAccount } from '@metamask/keyring-api';
import { assert } from '@metamask/utils';
import { Mutex } from 'async-mutex';

import type { Logger } from './logger';
import {
  createModuleLogger,
  ERROR_PREFIX,
  projectLogger as log,
  WARNING_PREFIX,
} from './logger';
import type { GroupState } from './MultichainAccountGroup';
import { MultichainAccountGroup } from './MultichainAccountGroup';
import type { ServiceState, StateKeys } from './MultichainAccountService';
import type { Bip44AccountProvider } from './providers';
import { EvmAccountProvider } from './providers/EvmAccountProvider';
import type { MultichainAccountServiceMessenger } from './types';
import { createSentryError } from './utils';

/**
 * The context for a provider discovery.
 */
type AccountProviderDiscoveryContext<
  Account extends Bip44Account<KeyringAccount>,
> = {
  provider: Bip44AccountProvider<Account>;
  stopped: boolean;
  groupIndex: number;
  accounts: Account[];
};

export type WalletState = ServiceState[StateKeys['entropySource']];

// type alias to make clear this state is generated by discovery
type DiscoveredGroupsState = WalletState;

/**
 * A multichain account wallet that holds multiple multichain accounts (one multichain account per
 * group index).
 */
export class MultichainAccountWallet<
  Account extends Bip44Account<KeyringAccount>,
> implements MultichainAccountWalletDefinition<Account>
{
  readonly #lock = new Mutex();

  readonly #id: MultichainAccountWalletId;

  readonly #providers: Bip44AccountProvider<Account>[];

  readonly #entropySource: EntropySourceId;

  readonly #accountGroups: Map<number, MultichainAccountGroup<Account>>;

  readonly #messenger: MultichainAccountServiceMessenger;

  readonly #log: Logger;

  #initialized = false;

  #status: MultichainAccountWalletStatus;

  constructor({
    providers,
    entropySource,
    messenger,
  }: {
    providers: Bip44AccountProvider<Account>[];
    entropySource: EntropySourceId;
    messenger: MultichainAccountServiceMessenger;
  }) {
    this.#id = toMultichainAccountWalletId(entropySource);
    this.#providers = providers;
    this.#entropySource = entropySource;
    this.#messenger = messenger;
    this.#accountGroups = new Map();

    this.#log = createModuleLogger(log, `[${this.#id}]`);

    // Initial synchronization (don't emit events during initialization).
    this.#status = 'uninitialized';
  }

  /**
   * Initialize the wallet and construct the internal representation of multichain account groups.
   *
   * @param walletState - The wallet state.
   */
  init(walletState: WalletState): void {
    this.#log('Initializing wallet state...');
    for (const [groupIndexString, groupState] of Object.entries(walletState)) {
      // Have to convert to number because the state keys become strings when we construct the state object in the service
      const groupIndex = Number(groupIndexString);
      const group = new MultichainAccountGroup({
        groupIndex,
        wallet: this,
        providers: this.#providers,
        messenger: this.#messenger,
      });

      this.#log(`Creating new group for index ${groupIndex}...`);

      group.init(groupState);

      this.#accountGroups.set(groupIndex, group);
    }
    if (!this.#initialized) {
      this.#initialized = true;
      this.#status = 'ready';
    }

    this.#log('Finished initializing wallet state...');
  }

  /**
   * Gets the multichain account wallet ID.
   *
   * @returns The multichain account wallet ID.
   */
  get id(): MultichainAccountWalletId {
    return this.#id;
  }

  /**
   * Gets the multichain account wallet type, which is always {@link AccountWalletType.Entropy}.
   *
   * @returns The multichain account wallet type.
   */
  get type(): AccountWalletType.Entropy {
    return AccountWalletType.Entropy;
  }

  /**
   * Gets the multichain account wallet entropy source.
   *
   * @returns The multichain account wallet entropy source.
   */
  get entropySource(): EntropySourceId {
    return this.#entropySource;
  }

  /**
   * Gets the multichain account wallet current status.
   *
   * @returns The multichain account wallet current status.
   */
  get status(): MultichainAccountWalletStatus {
    return this.#status;
  }

  /**
   * Set the wallet status and run the associated operation callback.
   *
   * @param status - Wallet status associated with this operation.
   * @param operation - Operation to run.
   * @returns The operation's result.
   * @throws {Error} If the wallet is already running a mutable operation.
   */
  async #withLock<Return>(
    status: MultichainAccountWalletStatus,
    operation: () => Promise<Return>,
  ): Promise<Return> {
    const release = await this.#lock.acquire();
    try {
      this.#log(`Locking wallet with status "${status}"...`);
      this.#status = status;
      this.#messenger.publish(
        'MultichainAccountService:walletStatusChange',
        this.id,
        this.#status,
      );
      return await operation();
    } finally {
      this.#status = 'ready';
      this.#messenger.publish(
        'MultichainAccountService:walletStatusChange',
        this.id,
        this.#status,
      );
      release();
      this.#log(`Releasing wallet lock (was "${status}")`);
    }
  }

  /**
   * Create accounts for a given provider and group index range.
   *
   * @param provider - The provider to create accounts for.
   * @param from - The starting group index (inclusive).
   * @param to - The ending group index (inclusive).
   * @returns The created accounts.
   */
  async #createAccountsRangeForProvider(
    provider: Bip44AccountProvider<Account>,
    from: number,
    to: number,
  ): Promise<Bip44Account<Account>[]> {
    const isBatching = to > from;

    try {
      return await provider.createAccounts({
        type: AccountCreationType.Bip44DeriveIndexRange,
        entropySource: this.#entropySource,
        range: {
          from,
          to,
        },
      });
    } catch (error) {
      const modeDescription = isBatching
        ? 'some accounts (batch)'
        : 'some accounts';
      const rangeDescription = isBatching
        ? `from group index ${from} to ${to}`
        : `for group index ${to}`;

      const errorMessage = `Unable to create ${modeDescription} ${rangeDescription} with provider "${provider.getName()}". Error: ${(error as Error).message}`;
      console.warn(errorMessage);
      this.#log(`${ERROR_PREFIX} ${errorMessage}:`, error);

      const sentryError = createSentryError(
        `Unable to create ${modeDescription} with provider "${provider.getName()}"`,
        error as Error,
        {
          range: {
            from,
            to,
          },
          provider: provider.getName(),
          isBatching,
        },
      );
      this.#messenger.captureException?.(sentryError);
      throw error;
    }
  }

  /**
   * Create or update a multichain account group state for a given group index and group state.
   *
   * @param groupIndex The group's index.
   * @param groupState The group's state to create or update the group with.
   * @returns The created or updated multichain account group.
   */
  #createOrUpdateMultichainAccountGroup(
    groupIndex: number,
    groupState: GroupState,
  ): [MultichainAccountGroup<Account>, boolean] {
    let group = this.#accountGroups.get(groupIndex);
    if (group) {
      // NOTE: This will publish an update event automatically.
      group.update(groupState);

      this.#log(`Group updated: [${group.id}]`);

      return [group, false];
    }

    group = new MultichainAccountGroup({
      wallet: this,
      providers: this.#providers,
      groupIndex,
      messenger: this.#messenger,
    });
    group.init(groupState);

    this.#accountGroups.set(groupIndex, group);

    this.#log(`New group created: [${group.id}]`);

    if (this.#initialized) {
      this.#messenger.publish(
        'MultichainAccountService:multichainAccountGroupCreated',
        group,
      );
    }

    return [group, true];
  }

  /**
   * Internal method to create a range of multichain account groups.
   *
   * IMPORTANT: This method assumes the caller has already acquired the wallet lock.
   *
   * @param fromGroupIndex - The starting group index (inclusive).
   * @param toGroupIndex - The ending group index (inclusive).
   * @param options - Options to configure the account creation.
   * @param options.waitForAllProvidersToFinishCreatingAccounts - Whether to wait for all
   * account providers to finish creating their accounts before returning. If `false`, only
   * the EVM provider will be awaited, while all other providers will create their accounts
   * in the background. Defaults to `false`.
   * @returns Array of created multichain account groups.
   */
  async #createMultichainAccountGroupsRange(
    fromGroupIndex: number,
    toGroupIndex: number,
    options: {
      waitForAllProvidersToFinishCreatingAccounts?: boolean;
    },
  ): Promise<MultichainAccountGroup<Account>[]> {
    const nextGroupIndex = this.getNextGroupIndex();
    const groups: MultichainAccountGroup<Account>[] = [];

    // Get existing groups (fromGroupIndex to nextGroupIndex-1).
    for (
      let i = fromGroupIndex;
      i < Math.min(nextGroupIndex, toGroupIndex + 1);
      i++
    ) {
      const group = this.getMultichainAccountGroup(i);
      if (group) {
        groups.push(group);
      }
    }

    // Create new groups (max(nextGroupIndex, fromGroupIndex) to toGroupIndex).
    const from = Math.max(nextGroupIndex, fromGroupIndex);
    const to = toGroupIndex;
    if (from <= to) {
      this.#log(`Creating groups from index ${from} to ${to}...`);

      const [evmProvider, ...otherProviders] = this.#providers;
      assert(
        evmProvider instanceof EvmAccountProvider,
        'EVM account provider must be first',
      );

      // Create EVM accounts for all new groups using range.
      const evmProviderName = evmProvider.getName();
      const evmAccounts = await this.#createAccountsRangeForProvider(
        evmProvider,
        from,
        to,
      );

      // Map EVM accounts to group indices.
      const evmGroupStateByGroupIndex = new Map<number, GroupState>();
      evmAccounts.forEach((account) => {
        const { groupIndex } = account.options.entropy;
        evmGroupStateByGroupIndex.set(groupIndex, {
          [evmProviderName]: [account.id],
        });
      });

      // Execute creation of non-EVM accounts in parallel, but sequentially after EVM accounts since they depend on the group creation that happens after we get the EVM accounts (because of the need to update the group state with the non-EVM accounts once they are created).
      const createNonEvmAccounts = async (
        provider: Bip44AccountProvider<Account>,
        groupStateByGroupIndex: Map<number, GroupState>,
      ): Promise<void> => {
        const nonEvmProviderName = provider.getName();
        const nonEvmAccounts = await this.#createAccountsRangeForProvider(
          provider,
          from,
          to,
        );

        // Map non-EVM accounts to group indices.
        nonEvmAccounts.forEach((account) => {
          const { groupIndex } = account.options.entropy;

          let groupState = groupStateByGroupIndex.get(groupIndex);
          if (!groupState) {
            groupState = {
              [nonEvmProviderName]: [],
            };
            groupStateByGroupIndex.set(groupIndex, groupState);
          }

          if (!groupState[nonEvmProviderName]) {
            groupState[nonEvmProviderName] = [];
          }

          groupState[nonEvmProviderName].push(account.id);
        });
      };

      // Finalize group states with accounts from other providers, then create groups
      // and update states with the associated accounts.
      const createOrUpdateMultichainAccountGroupsFrom = async (
        allGroupStateByGroupIndex: Map<number, GroupState>,
      ): Promise<void> => {
        for (let groupIndex = from; groupIndex <= to; groupIndex++) {
          const groupState = allGroupStateByGroupIndex.get(groupIndex);

          if (groupState) {
            const [group, created] = this.#createOrUpdateMultichainAccountGroup(
              groupIndex,
              groupState,
            );

            if (created) {
              groups.push(group);
            }
          } else {
            this.#log(
              `${WARNING_PREFIX} Failed to create new group for group index: ${groupIndex} because no accounts were created for it`,
            );
          }
        }
      };

      if (options.waitForAllProvidersToFinishCreatingAccounts) {
        // We re-use existing mapping and will extend it with non-EVM accounts.
        const groupStateByGroupIndex = evmGroupStateByGroupIndex;

        // We continue updating the group states with non-EVM accounts now.
        await Promise.all(
          otherProviders.map((provider) =>
            createNonEvmAccounts(provider, groupStateByGroupIndex),
          ),
        );

        // We can finalize the group creation and updates now that we have all accounts from all providers.
        await createOrUpdateMultichainAccountGroupsFrom(groupStateByGroupIndex);
      } else {
        // We can finalize with the EVM accounts for now, since the non-EVM accounts are going to get
        // created in the background.
        await createOrUpdateMultichainAccountGroupsFrom(
          evmGroupStateByGroupIndex,
        );

        // We can use a new mapping now, since EVM should have been created by now.
        const groupStateByGroupIndex = new Map<number, GroupState>();

        // We create the non-EVM accounts in the background, and update the groups as the accounts are created.
        // eslint-disable-next-line no-void
        void Promise.allSettled(
          otherProviders.map((provider) =>
            createNonEvmAccounts(provider, groupStateByGroupIndex),
          ),
        ).then(async (results) => {
          // In background mode, we still want to log if there are failures, but we don't want to throw since some
          // accounts might have been created "partially".
          const failures = results.filter(
            (result): result is PromiseRejectedResult =>
              result.status === 'rejected',
          );
          if (failures.length) {
            // We warn there's failures on some providers and thus misalignment, but we still create the group
            const errorMessage = failures.reduce(
              (message, failure) => `${message}\n- ${failure.reason.message}`,
              `Unable to create some accounts in the background. Providers threw the following errors:\n`,
            );

            console.warn(errorMessage);
            this.#log(`${WARNING_PREFIX} ${errorMessage}`);
          }

          // If some providers succeeded, we still want to update the groups accordingly.
          if (results.length !== failures.length) {
            // We re-finalize everything to update the groups with the accounts from the non-EVM providers as they come in.
            return await createOrUpdateMultichainAccountGroupsFrom(
              groupStateByGroupIndex,
            );
          }
          return undefined;
        });
      }
    }

    return groups;
  }

  /**
   * Gets multichain account for a given ID.
   * The default group ID will default to the multichain account with index 0.
   *
   * @param id - Account group ID.
   * @returns Account group.
   */
  getAccountGroup(
    id: AccountGroupId,
  ): MultichainAccountGroup<Account> | undefined {
    // We consider the "default case" to be mapped to index 0.
    if (id === toDefaultAccountGroupId(this.id)) {
      return this.#accountGroups.get(0);
    }

    // If it is not a valid ID, we cannot extract the group index
    // from it, so we fail fast.
    if (!isMultichainAccountGroupId(id)) {
      return undefined;
    }

    const groupIndex = getGroupIndexFromMultichainAccountGroupId(id);
    return this.#accountGroups.get(groupIndex);
  }

  /**
   * Gets all multichain accounts. Similar to {@link MultichainAccountWallet.getMultichainAccountGroups}.
   *
   * @returns The multichain accounts.
   */
  getAccountGroups(): MultichainAccountGroup<Account>[] {
    return this.getMultichainAccountGroups();
  }

  /**
   * Gets multichain account group for a given index.
   *
   * @param groupIndex - Multichain account index.
   * @returns The multichain account associated with the given index.
   */
  getMultichainAccountGroup(
    groupIndex: number,
  ): MultichainAccountGroup<Account> | undefined {
    return this.#accountGroups.get(groupIndex);
  }

  /**
   * Gets all multichain account groups.
   *
   * @returns The multichain accounts.
   */
  getMultichainAccountGroups(): MultichainAccountGroup<Account>[] {
    return Array.from(this.#accountGroups.values()); // TODO: Prevent copy here.
  }

  /**
   * Gets next group index for this wallet.
   *
   * @returns The next group index of this wallet.
   */
  getNextGroupIndex(): number {
    // We do not check for gaps.
    return (
      Math.max(
        -1, // So it will default to 0 if no groups.
        ...this.#accountGroups.keys(),
      ) + 1
    );
  }

  /**
   * Creates a multichain account group for a given group index.
   *
   * NOTE: This operation WILL lock the wallet's mutex.
   *
   * @param groupIndex - The group index to use.
   * @param options - Options to configure the account creation.
   * @param options.waitForAllProvidersToFinishCreatingAccounts - Whether to wait for all
   * account providers to finish creating their accounts before returning. If `false`, only
   * the EVM provider will be awaited, while all other providers will create their accounts
   * in the background. Defaults to `false`.
   * @throws If groupIndex is greater than the next available group index.
   * @throws If any of the account providers fails to create their accounts and
   * the `waitForAllProvidersToFinishCreatingAccounts` option is set to `true`. If `false`,
   * errors from non-EVM providers will be logged but ignored, and only errors from the
   * EVM provider will be thrown.
   * @returns The multichain account group for this group index.
   */
  async createMultichainAccountGroup(
    groupIndex: number,
    options: {
      waitForAllProvidersToFinishCreatingAccounts?: boolean;
    } = { waitForAllProvidersToFinishCreatingAccounts: false },
  ): Promise<MultichainAccountGroup<Account>> {
    return await this.#withLock('in-progress:create-accounts', async () => {
      const nextGroupIndex = this.getNextGroupIndex();

      // Validate that we can only create the next available group or an existing one.
      if (groupIndex > nextGroupIndex) {
        throw new Error(
          `You cannot use a group index that is higher than the next available one: expected <=${nextGroupIndex}, got ${groupIndex}`,
        );
      }

      // If the group already exists, return it.
      const existingGroup = this.getMultichainAccountGroup(groupIndex);
      if (existingGroup) {
        this.#log(
          `Trying to re-create existing group: [${existingGroup.id}] (idempotent)`,
        );
        return existingGroup;
      }

      // Create the group using the private range method.
      const groups = await this.#createMultichainAccountGroupsRange(
        groupIndex,
        groupIndex,
        options,
      );

      const group = groups[0];
      assert(group, `Expected group at index ${groupIndex} to exist`);
      return group;
    });
  }

  /**
   * Creates multiple multichain account groups up to maxGroupIndex.
   *
   * NOTE: This operation WILL lock the wallet's mutex.
   *
   * @param maxGroupIndex - The maximum group index to create (creates 0 to maxGroupIndex inclusive).
   * @param options - Options to configure the account creation.
   * @param options.waitForAllProvidersToFinishCreatingAccounts - Whether to wait for all
   * account providers to finish creating their accounts before returning. Defaults to false.
   * @throws If maxGroupIndex is less than 0 or if account creation fails.
   * @returns Array of created multichain account groups.
   */
  async createMultichainAccountGroups(
    maxGroupIndex: number,
    options: {
      waitForAllProvidersToFinishCreatingAccounts?: boolean;
    } = { waitForAllProvidersToFinishCreatingAccounts: false },
  ): Promise<MultichainAccountGroup<Account>[]> {
    return await this.#withLock('in-progress:create-accounts', async () => {
      if (maxGroupIndex < 0) {
        throw new Error('maxGroupIndex must be >= 0');
      }

      // Create groups from 0 to maxGroupIndex using the private range method.
      return this.#createMultichainAccountGroupsRange(
        0,
        maxGroupIndex,
        options,
      );
    });
  }

  /**
   * Creates the next multichain account group.
   *
   * @throws If any of the account providers fails to create their accounts.
   * @returns The multichain account group for the next group index available.
   */
  async createNextMultichainAccountGroup(): Promise<
    MultichainAccountGroup<Account>
  > {
    return this.createMultichainAccountGroup(this.getNextGroupIndex(), {
      waitForAllProvidersToFinishCreatingAccounts: true,
    });
  }

  /**
   * Align all multichain account groups.
   *
   * NOTE: This operation WILL NOT lock the wallet's mutex.
   */
  async #alignAccounts(): Promise<void> {
    const groups = this.getMultichainAccountGroups();
    await Promise.all(groups.map((group) => group.alignAccounts()));
  }

  /**
   * Align all accounts from each existing multichain account groups.
   *
   * NOTE: This operation WILL lock the wallet's mutex.
   */
  async alignAccounts(): Promise<void> {
    await this.#withLock('in-progress:alignment', async () => {
      await this.#alignAccounts();
    });
  }

  /**
   * Align a specific multichain account group.
   *
   * NOTE: This operation WILL lock the wallet's mutex.
   *
   * @param groupIndex - The group index to align.
   */
  async alignAccountsOf(groupIndex: number): Promise<void> {
    await this.#withLock('in-progress:alignment', async () => {
      const group = this.getMultichainAccountGroup(groupIndex);
      if (group) {
        await group.alignAccounts();
      }
    });
  }

  /**
   * Discover and create accounts for all providers.
   *
   * NOTE: This operation WILL lock the wallet's mutex.
   *
   * @returns The discovered accounts for each provider.
   */
  async discoverAccounts(): Promise<Account[]> {
    return this.#withLock('in-progress:discovery', async () => {
      // Start with the next available group index (so we can resume the discovery
      // from there).
      let maxGroupIndex = this.getNextGroupIndex();
      const discoveredGroupsState: DiscoveredGroupsState = {};

      const addDiscoveryResultToState = (
        result: Account[],
        providerName: string,
        groupIndex: number,
      ) => {
        const accountIds = result.map((account) => account.id);
        discoveredGroupsState[groupIndex] ??= {};
        discoveredGroupsState[groupIndex][providerName] = accountIds;
      };

      // One serialized loop per provider; all run concurrently
      const runProviderDiscovery = async (
        context: AccountProviderDiscoveryContext<Account>,
      ): Promise<void> => {
        const providerName = context.provider.getName();
        const message = (stepName: string, groupIndex: number) =>
          `[${providerName}] Discovery ${stepName} for group index: ${groupIndex}`;

        while (!context.stopped) {
          // Fast‑forward to current high‑water mark
          const targetGroupIndex = Math.max(context.groupIndex, maxGroupIndex);

          log(message('started', targetGroupIndex));

          let accounts: Account[] = [];
          try {
            accounts = await context.provider.discoverAccounts({
              entropySource: this.#entropySource,
              groupIndex: targetGroupIndex,
            });
          } catch (error) {
            context.stopped = true;
            console.error(error);
            log(
              message(
                `failed (with: "${(error as Error).message}")`,
                targetGroupIndex,
              ),
              error,
            );
            const sentryError = createSentryError(
              'Unable to discover accounts',
              error as Error,
              {
                provider: providerName,
                groupIndex: targetGroupIndex,
              },
            );
            this.#messenger.captureException?.(sentryError);
            break;
          }

          if (!accounts.length) {
            log(
              message('stopped (no accounts got discovered)', targetGroupIndex),
            );
            context.stopped = true;
            break;
          }

          log(message('**succeeded**', targetGroupIndex));

          context.accounts = context.accounts.concat(accounts);

          addDiscoveryResultToState(accounts, providerName, targetGroupIndex);

          const nextGroupIndex = targetGroupIndex + 1;
          context.groupIndex = nextGroupIndex;

          if (nextGroupIndex > maxGroupIndex) {
            maxGroupIndex = nextGroupIndex;
          }
        }
      };

      const providerContexts: AccountProviderDiscoveryContext<Account>[] =
        this.#providers.map((provider) => ({
          provider,
          stopped: false,
          groupIndex: maxGroupIndex,
          accounts: [],
        }));

      // Start discovery for each providers.
      await Promise.all(providerContexts.map(runProviderDiscovery));

      // Create discovered groups
      for (const [groupIndexString, groupState] of Object.entries(
        discoveredGroupsState,
      )) {
        const groupIndex = Number(groupIndexString);
        const group = new MultichainAccountGroup({
          wallet: this,
          providers: this.#providers,
          groupIndex,
          messenger: this.#messenger,
        });
        group.init(groupState);
        this.#accountGroups.set(groupIndex, group);
      }

      // Align missing accounts from group. This is required to create missing account from non-discovered
      // indexes for some providers.
      await this.#alignAccounts();

      return providerContexts.flatMap((context) => context.accounts);
    });
  }
}
