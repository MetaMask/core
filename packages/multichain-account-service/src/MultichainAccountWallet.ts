import type {
  AccountGroupId,
  Bip44Account,
  MultichainAccountWalletId,
  MultichainAccountWallet as MultichainAccountWalletDefinition,
  MultichainAccountWalletStatus,
} from '@metamask/account-api';
import {
  AccountWalletType,
  getGroupIndexFromMultichainAccountGroupId,
  isMultichainAccountGroupId,
  toDefaultAccountGroupId,
  toMultichainAccountWalletId,
} from '@metamask/account-api';
import type { EntropySourceId, KeyringAccount } from '@metamask/keyring-api';
import { assert } from '@metamask/utils';
import { Mutex } from 'async-mutex';

import type { Logger } from './logger';
import {
  createModuleLogger,
  ERROR_PREFIX,
  projectLogger as log,
  WARNING_PREFIX,
} from './logger';
import {
  type GroupState,
  MultichainAccountGroup,
} from './MultichainAccountGroup';
import type { ServiceState, StateKeys } from './MultichainAccountService';
import { type Bip44AccountProvider, EvmAccountProvider } from './providers';
import type { MultichainAccountServiceMessenger } from './types';
import { createSentryError } from './utils';

/**
 * The context for a provider discovery.
 */
type AccountProviderDiscoveryContext<
  Account extends Bip44Account<KeyringAccount>,
> = {
  provider: Bip44AccountProvider<Account>;
  stopped: boolean;
  groupIndex: number;
  accounts: Account[];
};

export type WalletState = ServiceState[StateKeys['entropySource']];

// type alias to make clear this state is generated by discovery
type DiscoveredGroupsState = WalletState;

/**
 * A multichain account wallet that holds multiple multichain accounts (one multichain account per
 * group index).
 */
export class MultichainAccountWallet<
  Account extends Bip44Account<KeyringAccount>,
> implements MultichainAccountWalletDefinition<Account>
{
  readonly #lock = new Mutex();

  readonly #id: MultichainAccountWalletId;

  readonly #providers: Bip44AccountProvider<Account>[];

  readonly #entropySource: EntropySourceId;

  readonly #accountGroups: Map<number, MultichainAccountGroup<Account>>;

  readonly #messenger: MultichainAccountServiceMessenger;

  readonly #log: Logger;

  #initialized = false;

  #status: MultichainAccountWalletStatus;

  constructor({
    providers,
    entropySource,
    messenger,
  }: {
    providers: Bip44AccountProvider<Account>[];
    entropySource: EntropySourceId;
    messenger: MultichainAccountServiceMessenger;
  }) {
    this.#id = toMultichainAccountWalletId(entropySource);
    this.#providers = providers;
    this.#entropySource = entropySource;
    this.#messenger = messenger;
    this.#accountGroups = new Map();

    this.#log = createModuleLogger(log, `[${this.#id}]`);

    // Initial synchronization (don't emit events during initialization).
    this.#status = 'uninitialized';
  }

  /**
   * Initialize the wallet and construct the internal representation of multichain account groups.
   *
   * @param walletState - The wallet state.
   */
  init(walletState: WalletState): void {
    this.#log('Initializing wallet state...');
    for (const [groupIndexString, groupState] of Object.entries(walletState)) {
      // Have to convert to number because the state keys become strings when we construct the state object in the service
      const groupIndex = Number(groupIndexString);
      const group = new MultichainAccountGroup({
        groupIndex,
        wallet: this,
        providers: this.#providers,
        messenger: this.#messenger,
      });

      this.#log(`Creating new group for index ${groupIndex}...`);

      group.init(groupState);

      this.#accountGroups.set(groupIndex, group);
    }
    if (!this.#initialized) {
      this.#initialized = true;
      this.#status = 'ready';
    }

    this.#log('Finished initializing wallet state...');
  }

  /**
   * Gets the multichain account wallet ID.
   *
   * @returns The multichain account wallet ID.
   */
  get id(): MultichainAccountWalletId {
    return this.#id;
  }

  /**
   * Gets the multichain account wallet type, which is always {@link AccountWalletType.Entropy}.
   *
   * @returns The multichain account wallet type.
   */
  get type(): AccountWalletType.Entropy {
    return AccountWalletType.Entropy;
  }

  /**
   * Gets the multichain account wallet entropy source.
   *
   * @returns The multichain account wallet entropy source.
   */
  get entropySource(): EntropySourceId {
    return this.#entropySource;
  }

  /**
   * Gets the multichain account wallet current status.
   *
   * @returns The multichain account wallet current status.
   */
  get status(): MultichainAccountWalletStatus {
    return this.#status;
  }

  /**
   * Set the wallet status and run the associated operation callback.
   *
   * @param status - Wallet status associated with this operation.
   * @param operation - Operation to run.
   * @returns The operation's result.
   * @throws {Error} If the wallet is already running a mutable operation.
   */
  async #withLock<Return>(
    status: MultichainAccountWalletStatus,
    operation: () => Promise<Return>,
  ): Promise<Return> {
    const release = await this.#lock.acquire();
    try {
      this.#log(`Locking wallet with status "${status}"...`);
      this.#status = status;
      this.#messenger.publish(
        'MultichainAccountService:walletStatusChange',
        this.id,
        this.#status,
      );
      return await operation();
    } finally {
      this.#status = 'ready';
      this.#messenger.publish(
        'MultichainAccountService:walletStatusChange',
        this.id,
        this.#status,
      );
      release();
      this.#log(`Releasing wallet lock (was "${status}")`);
    }
  }

  /**
   * Create accounts with non‑EVM providers. Optional throttling is managed by each provider internally.
   * When awaitAll is true, waits for all providers and throws if any failed.
   * When false, starts work in background and logs errors without throwing.
   *
   * @param options - Method options.
   * @param options.groupIndex - The group index to create accounts for.
   * @param options.providers - The non‑EVM account providers.
   * @param options.awaitAll - Whether to wait for all providers to finish.
   * @param options.group - The group object pertaining to the group index to create accounts for.
   * @throws If awaitAll is true and any provider fails to create accounts.
   * @returns A promise that resolves when done (if awaitAll is true) or immediately (if false).
   */
  async #createNonEvmAccounts({
    groupIndex,
    providers,
    awaitAll,
    group,
  }: {
    groupIndex: number;
    providers: Bip44AccountProvider<Account>[];
    awaitAll: boolean;
    group: MultichainAccountGroup<Account>;
  }): Promise<void> {
    if (awaitAll) {
      const tasks = providers.map((provider) =>
        provider
          .createAccounts({
            entropySource: this.#entropySource,
            groupIndex,
          })
          .catch((error) => {
            const sentryError = createSentryError(
              `Unable to create account with provider "${provider.getName()}"`,
              error,
              {
                groupIndex,
                provider: provider.getName(),
              },
            );
            this.#messenger.captureException?.(sentryError);
            throw error;
          }),
      );

      const results = await Promise.allSettled(tasks);

      const providerFailures = results.reduce((acc, result, idx) => {
        let newAcc = acc;
        if (result.status === 'rejected') {
          newAcc += `\n- ${providers[idx].getName()}: ${result.reason.message}`;
        }
        return newAcc;
      }, '');

      if (providerFailures.length) {
        // We warn there's failures on some providers and thus misalignment, but we still create the group
        const message = `Unable to create some accounts for group index: ${groupIndex}. Providers threw the following errors:${providerFailures}`;
        console.warn(message);
        this.#log(`${WARNING_PREFIX} ${message}`);
      }

      // No need to fetch the accounts list from the AccountsController since we already have the account IDs to be used in the controller
      const groupState = results.reduce<GroupState>((state, result, idx) => {
        if (result.status === 'fulfilled') {
          state[providers[idx].getName()] = result.value.map(
            (account) => account.id,
          );
        }
        return state;
      }, {});

      group.update(groupState);
    } else {
      // Create account with other providers in the background
      providers.forEach((provider) => {
        provider
          .createAccounts({
            entropySource: this.#entropySource,
            groupIndex,
          })
          .then((accounts) => {
            const accountIds = accounts.map((account) => account.id);
            group.update({ [provider.getName()]: accountIds });
            return group;
          })
          .catch((error) => {
            // Log errors from background providers but don't fail the operation
            const errorMessage = `Unable to create some accounts for group index: ${groupIndex} with provider "${provider.getName()}". Error: ${(error as Error).message}`;
            console.warn(errorMessage);
            this.#log(`${WARNING_PREFIX} ${errorMessage}:`, error);
            const sentryError = createSentryError(
              `Unable to create account with provider "${provider.getName()}"`,
              error,
              {
                groupIndex,
                provider: provider.getName(),
              },
            );
            this.#messenger.captureException?.(sentryError);
          });
      });
    }
  }

  /**
   * Gets multichain account for a given ID.
   * The default group ID will default to the multichain account with index 0.
   *
   * @param id - Account group ID.
   * @returns Account group.
   */
  getAccountGroup(
    id: AccountGroupId,
  ): MultichainAccountGroup<Account> | undefined {
    // We consider the "default case" to be mapped to index 0.
    if (id === toDefaultAccountGroupId(this.id)) {
      return this.#accountGroups.get(0);
    }

    // If it is not a valid ID, we cannot extract the group index
    // from it, so we fail fast.
    if (!isMultichainAccountGroupId(id)) {
      return undefined;
    }

    const groupIndex = getGroupIndexFromMultichainAccountGroupId(id);
    return this.#accountGroups.get(groupIndex);
  }

  /**
   * Gets all multichain accounts. Similar to {@link MultichainAccountWallet.getMultichainAccountGroups}.
   *
   * @returns The multichain accounts.
   */
  getAccountGroups(): MultichainAccountGroup<Account>[] {
    return this.getMultichainAccountGroups();
  }

  /**
   * Gets multichain account group for a given index.
   *
   * @param groupIndex - Multichain account index.
   * @returns The multichain account associated with the given index.
   */
  getMultichainAccountGroup(
    groupIndex: number,
  ): MultichainAccountGroup<Account> | undefined {
    return this.#accountGroups.get(groupIndex);
  }

  /**
   * Gets all multichain account groups.
   *
   * @returns The multichain accounts.
   */
  getMultichainAccountGroups(): MultichainAccountGroup<Account>[] {
    return Array.from(this.#accountGroups.values()); // TODO: Prevent copy here.
  }

  /**
   * Gets next group index for this wallet.
   *
   * @returns The next group index of this wallet.
   */
  getNextGroupIndex(): number {
    // We do not check for gaps.
    return (
      Math.max(
        -1, // So it will default to 0 if no groups.
        ...this.#accountGroups.keys(),
      ) + 1
    );
  }

  /**
   * Creates a multichain account group for a given group index.
   *
   * NOTE: This operation WILL lock the wallet's mutex.
   *
   * @param groupIndex - The group index to use.
   * @param options - Options to configure the account creation.
   * @param options.waitForAllProvidersToFinishCreatingAccounts - Whether to wait for all
   * account providers to finish creating their accounts before returning. If `false`, only
   * the EVM provider will be awaited, while all other providers will create their accounts
   * in the background. Defaults to `false`.
   * @throws If any of the account providers fails to create their accounts and
   * the `waitForAllProvidersToFinishCreatingAccounts` option is set to `true`. If `false`,
   * errors from non-EVM providers will be logged but ignored, and only errors from the
   * EVM provider will be thrown.
   * @returns The multichain account group for this group index.
   */
  async createMultichainAccountGroup(
    groupIndex: number,
    options: {
      waitForAllProvidersToFinishCreatingAccounts?: boolean;
    } = { waitForAllProvidersToFinishCreatingAccounts: false },
  ): Promise<MultichainAccountGroup<Account>> {
    return await this.#withLock('in-progress:create-accounts', async () => {
      const nextGroupIndex = this.getNextGroupIndex();
      if (groupIndex > nextGroupIndex) {
        throw new Error(
          `You cannot use a group index that is higher than the next available one: expected <=${nextGroupIndex}, got ${groupIndex}`,
        );
      }

      let group = this.getMultichainAccountGroup(groupIndex);

      if (group) {
        this.#log(
          `Trying to re-create existing group: [${group.id}] (idempotent)`,
        );
        return group;
      }

      this.#log(`Creating new group for index ${groupIndex}...`);

      // Extract the EVM provider from the list of providers.
      // We always await EVM account creation first.
      const [evmProvider, ...otherProviders] = this.#providers;
      assert(
        evmProvider instanceof EvmAccountProvider,
        'EVM account provider must be first',
      );

      const evmAccounts = await evmProvider
        .createAccounts({
          entropySource: this.#entropySource,
          groupIndex,
        })
        .then((accounts) => accounts.map((account) => account.id))
        .catch((error) => {
          const errorMessage = `Unable to create some accounts for group index: ${groupIndex} with provider "${evmProvider.getName()}". Error: ${(error as Error).message}`;
          console.warn(errorMessage);
          this.#log(`${ERROR_PREFIX} ${errorMessage}:`, error);
          const sentryError = createSentryError(
            `Unable to create account with provider "${evmProvider.getName()}"`,
            error as Error,
            {
              groupIndex,
              provider: evmProvider.getName(),
            },
          );
          this.#messenger.captureException?.(sentryError);
          throw error;
        });

      group = new MultichainAccountGroup({
        wallet: this,
        providers: this.#providers,
        groupIndex,
        messenger: this.#messenger,
      });

      group.init({ [evmProvider.getName()]: evmAccounts });

      // We then create accounts with other providers (some being throttled if configured).
      // Depending on the options, we either await all providers or run them in background.
      if (options?.waitForAllProvidersToFinishCreatingAccounts) {
        await this.#createNonEvmAccounts({
          groupIndex,
          providers: otherProviders,
          awaitAll: true,
          group,
        });
      } else {
        // eslint-disable-next-line no-void
        void this.#createNonEvmAccounts({
          groupIndex,
          providers: otherProviders,
          awaitAll: false,
          group,
        });
      }

      // Register the account(s) to our internal map.
      this.#accountGroups.set(groupIndex, group);

      this.#log(`New group created: [${group.id}]`);

      if (this.#initialized) {
        this.#messenger.publish(
          'MultichainAccountService:multichainAccountGroupCreated',
          group,
        );
      }

      return group;
    });
  }

  /**
   * Creates the next multichain account group.
   *
   * @throws If any of the account providers fails to create their accounts.
   * @returns The multichain account group for the next group index available.
   */
  async createNextMultichainAccountGroup(): Promise<
    MultichainAccountGroup<Account>
  > {
    return this.createMultichainAccountGroup(this.getNextGroupIndex(), {
      waitForAllProvidersToFinishCreatingAccounts: true,
    });
  }

  /**
   * Align all multichain account groups.
   *
   * NOTE: This operation WILL NOT lock the wallet's mutex.
   */
  async #alignAccounts(): Promise<void> {
    const groups = this.getMultichainAccountGroups();
    await Promise.all(groups.map((group) => group.alignAccounts()));
  }

  /**
   * Align all accounts from each existing multichain account groups.
   *
   * NOTE: This operation WILL lock the wallet's mutex.
   */
  async alignAccounts(): Promise<void> {
    await this.#withLock('in-progress:alignment', async () => {
      await this.#alignAccounts();
    });
  }

  /**
   * Align a specific multichain account group.
   *
   * NOTE: This operation WILL lock the wallet's mutex.
   *
   * @param groupIndex - The group index to align.
   */
  async alignAccountsOf(groupIndex: number): Promise<void> {
    await this.#withLock('in-progress:alignment', async () => {
      const group = this.getMultichainAccountGroup(groupIndex);
      if (group) {
        await group.alignAccounts();
      }
    });
  }

  /**
   * Discover and create accounts for all providers.
   *
   * NOTE: This operation WILL lock the wallet's mutex.
   *
   * @returns The discovered accounts for each provider.
   */
  async discoverAccounts(): Promise<Account[]> {
    return this.#withLock('in-progress:discovery', async () => {
      // Start with the next available group index (so we can resume the discovery
      // from there).
      let maxGroupIndex = this.getNextGroupIndex();
      const discoveredGroupsState: DiscoveredGroupsState = {};

      const addDiscoveryResultToState = (
        result: Account[],
        providerName: string,
        groupIndex: number,
      ) => {
        const accountIds = result.map((account) => account.id);
        discoveredGroupsState[groupIndex] ??= {};
        discoveredGroupsState[groupIndex][providerName] = accountIds;
      };

      // One serialized loop per provider; all run concurrently
      const runProviderDiscovery = async (
        context: AccountProviderDiscoveryContext<Account>,
      ): Promise<void> => {
        const providerName = context.provider.getName();
        const message = (stepName: string, groupIndex: number) =>
          `[${providerName}] Discovery ${stepName} for group index: ${groupIndex}`;

        while (!context.stopped) {
          // Fast‑forward to current high‑water mark
          const targetGroupIndex = Math.max(context.groupIndex, maxGroupIndex);

          log(message('started', targetGroupIndex));

          let accounts: Account[] = [];
          try {
            accounts = await context.provider.discoverAccounts({
              entropySource: this.#entropySource,
              groupIndex: targetGroupIndex,
            });
          } catch (error) {
            context.stopped = true;
            console.error(error);
            log(
              message(
                `failed (with: "${(error as Error).message}")`,
                targetGroupIndex,
              ),
              error,
            );
            const sentryError = createSentryError(
              'Unable to discover accounts',
              error as Error,
              {
                provider: providerName,
                groupIndex: targetGroupIndex,
              },
            );
            this.#messenger.captureException?.(sentryError);
            break;
          }

          if (!accounts.length) {
            log(
              message('stopped (no accounts got discovered)', targetGroupIndex),
            );
            context.stopped = true;
            break;
          }

          log(message('**succeeded**', targetGroupIndex));

          context.accounts = context.accounts.concat(accounts);

          addDiscoveryResultToState(accounts, providerName, targetGroupIndex);

          const nextGroupIndex = targetGroupIndex + 1;
          context.groupIndex = nextGroupIndex;

          if (nextGroupIndex > maxGroupIndex) {
            maxGroupIndex = nextGroupIndex;
          }
        }
      };

      const providerContexts: AccountProviderDiscoveryContext<Account>[] =
        this.#providers.map((provider) => ({
          provider,
          stopped: false,
          groupIndex: maxGroupIndex,
          accounts: [],
        }));

      // Start discovery for each providers.
      await Promise.all(providerContexts.map(runProviderDiscovery));

      // Create discovered groups
      for (const [groupIndexString, groupState] of Object.entries(
        discoveredGroupsState,
      )) {
        const groupIndex = Number(groupIndexString);
        const group = new MultichainAccountGroup({
          wallet: this,
          providers: this.#providers,
          groupIndex,
          messenger: this.#messenger,
        });
        group.init(groupState);
        this.#accountGroups.set(groupIndex, group);
      }

      // Align missing accounts from group. This is required to create missing account from non-discovered
      // indexes for some providers.
      await this.#alignAccounts();

      return providerContexts.flatMap((context) => context.accounts);
    });
  }
}
