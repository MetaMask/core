import type {
  AccountGroupId,
  Bip44Account,
  MultichainAccountWalletId,
  MultichainAccountWallet as MultichainAccountWalletDefinition,
  MultichainAccountWalletStatus,
} from '@metamask/account-api';
import {
  AccountWalletType,
  getGroupIndexFromMultichainAccountGroupId,
  isMultichainAccountGroupId,
  toDefaultAccountGroupId,
  toMultichainAccountWalletId,
} from '@metamask/account-api';
import type { EntropySourceId, KeyringAccount } from '@metamask/keyring-api';
import { assert } from '@metamask/utils';
import { Mutex } from 'async-mutex';

import type { Logger } from './logger';
import {
  createModuleLogger,
  ERROR_PREFIX,
  projectLogger as log,
  WARNING_PREFIX,
} from './logger';
import {
  type GroupState,
  MultichainAccountGroup,
} from './MultichainAccountGroup';
import type { ServiceState, StateKeys } from './MultichainAccountService';
import { type BaseBip44AccountProvider, EvmAccountProvider } from './providers';
import type { MultichainAccountServiceMessenger } from './types';

/**
 * The context for a provider discovery.
 */
type AccountProviderDiscoveryContext<
  Account extends Bip44Account<KeyringAccount>,
> = {
  provider: BaseBip44AccountProvider;
  stopped: boolean;
  groupIndex: number;
  accounts: Account[];
};

export type WalletState = ServiceState[StateKeys['entropySource']];

// type alias to make clear this state is generated by discovery
type DiscoveredGroupsState = WalletState;

/**
 * A multichain account wallet that holds multiple multichain accounts (one multichain account per
 * group index).
 */
export class MultichainAccountWallet<
  Account extends Bip44Account<KeyringAccount>,
> implements MultichainAccountWalletDefinition<Account>
{
  readonly #lock = new Mutex();

  readonly #id: MultichainAccountWalletId;

  readonly #providers: BaseBip44AccountProvider[];

  readonly #entropySource: EntropySourceId;

  readonly #accountGroups: Map<number, MultichainAccountGroup<Account>>;

  readonly #messenger: MultichainAccountServiceMessenger;

  readonly #log: Logger;

  #initialized = false;

  #status: MultichainAccountWalletStatus;

  constructor({
    providers,
    entropySource,
    messenger,
  }: {
    providers: BaseBip44AccountProvider[];
    entropySource: EntropySourceId;
    messenger: MultichainAccountServiceMessenger;
  }) {
    this.#id = toMultichainAccountWalletId(entropySource);
    this.#providers = providers;
    this.#entropySource = entropySource;
    this.#messenger = messenger;
    this.#accountGroups = new Map();

    this.#log = createModuleLogger(log, `[${this.#id}]`);

    // Initial synchronization (don't emit events during initialization).
    this.#status = 'uninitialized';
  }

  /**
   * Initialize the wallet and construct the internal representation of multichain account groups.
   *
   * @param walletState - The wallet state.
   */
  init(walletState: WalletState) {
    this.#log('Initializing wallet state...');
    for (const [groupIndex, groupState] of Object.entries(walletState)) {
      // Have to convert to number because the state keys become strings when we construct the state object in the service
      const indexAsNumber = Number(groupIndex);
      const group = new MultichainAccountGroup({
        groupIndex: indexAsNumber,
        wallet: this,
        providers: this.#providers,
        messenger: this.#messenger,
      });

      this.#log(`Creating new group for index ${indexAsNumber}...`);

      group.init(groupState);

      this.#accountGroups.set(indexAsNumber, group);
    }
    if (!this.#initialized) {
      this.#initialized = true;
      this.#status = 'ready';
    }

    this.#log('Finished initializing wallet state...');
  }

  /**
   * Gets the multichain account wallet ID.
   *
   * @returns The multichain account wallet ID.
   */
  get id(): MultichainAccountWalletId {
    return this.#id;
  }

  /**
   * Gets the multichain account wallet type, which is always {@link AccountWalletType.Entropy}.
   *
   * @returns The multichain account wallet type.
   */
  get type(): AccountWalletType.Entropy {
    return AccountWalletType.Entropy;
  }

  /**
   * Gets the multichain account wallet entropy source.
   *
   * @returns The multichain account wallet entropy source.
   */
  get entropySource(): EntropySourceId {
    return this.#entropySource;
  }

  /**
   * Gets the multichain account wallet current status.
   *
   * @returns The multichain account wallet current status.
   */
  get status(): MultichainAccountWalletStatus {
    return this.#status;
  }

  /**
   * Set the wallet status and run the associated operation callback.
   *
   * @param status - Wallet status associated with this operation.
   * @param operation - Operation to run.
   * @returns The operation's result.
   * @throws {Error} If the wallet is already running a mutable operation.
   */
  async #withLock<Return>(
    status: MultichainAccountWalletStatus,
    operation: () => Promise<Return>,
  ) {
    const release = await this.#lock.acquire();
    try {
      this.#log(`Locking wallet with status "${status}"...`);
      this.#status = status;
      this.#messenger.publish(
        'MultichainAccountService:walletStatusChange',
        this.id,
        this.#status,
      );
      return await operation();
    } finally {
      this.#status = 'ready';
      this.#messenger.publish(
        'MultichainAccountService:walletStatusChange',
        this.id,
        this.#status,
      );
      release();
      this.#log(`Releasing wallet lock (was "${status}")`);
    }
  }

  /**
   * Gets multichain account for a given ID.
   * The default group ID will default to the multichain account with index 0.
   *
   * @param id - Account group ID.
   * @returns Account group.
   */
  getAccountGroup(
    id: AccountGroupId,
  ): MultichainAccountGroup<Account> | undefined {
    // We consider the "default case" to be mapped to index 0.
    if (id === toDefaultAccountGroupId(this.id)) {
      return this.#accountGroups.get(0);
    }

    // If it is not a valid ID, we cannot extract the group index
    // from it, so we fail fast.
    if (!isMultichainAccountGroupId(id)) {
      return undefined;
    }

    const groupIndex = getGroupIndexFromMultichainAccountGroupId(id);
    return this.#accountGroups.get(groupIndex);
  }

  /**
   * Gets all multichain accounts. Similar to {@link MultichainAccountWallet.getMultichainAccountGroups}.
   *
   * @returns The multichain accounts.
   */
  getAccountGroups(): MultichainAccountGroup<Account>[] {
    return this.getMultichainAccountGroups();
  }

  /**
   * Gets multichain account group for a given index.
   *
   * @param groupIndex - Multichain account index.
   * @returns The multichain account associated with the given index.
   */
  getMultichainAccountGroup(
    groupIndex: number,
  ): MultichainAccountGroup<Account> | undefined {
    return this.#accountGroups.get(groupIndex);
  }

  /**
   * Gets all multichain account groups.
   *
   * @returns The multichain accounts.
   */
  getMultichainAccountGroups(): MultichainAccountGroup<Account>[] {
    return Array.from(this.#accountGroups.values()); // TODO: Prevent copy here.
  }

  /**
   * Gets next group index for this wallet.
   *
   * @returns The next group index of this wallet.
   */
  getNextGroupIndex(): number {
    // We do not check for gaps.
    return (
      Math.max(
        -1, // So it will default to 0 if no groups.
        ...this.#accountGroups.keys(),
      ) + 1
    );
  }

  /**
   * Creates a multichain account group for a given group index.
   *
   * NOTE: This operation WILL lock the wallet's mutex.
   *
   * @param groupIndex - The group index to use.
   * @param options - Options to configure the account creation.
   * @param options.waitForAllProvidersToFinishCreatingAccounts - Whether to wait for all
   * account providers to finish creating their accounts before returning. If `false`, only
   * the EVM provider will be awaited, while all other providers will create their accounts
   * in the background. Defaults to `false`.
   * @throws If any of the account providers fails to create their accounts and
   * the `waitForAllProvidersToFinishCreatingAccounts` option is set to `true`. If `false`,
   * errors from non-EVM providers will be logged but ignored, and only errors from the
   * EVM provider will be thrown.
   * @returns The multichain account group for this group index.
   */
  async createMultichainAccountGroup(
    groupIndex: number,
    options: {
      waitForAllProvidersToFinishCreatingAccounts?: boolean;
    } = { waitForAllProvidersToFinishCreatingAccounts: false },
  ): Promise<MultichainAccountGroup<Account>> {
    return await this.#withLock('in-progress:create-accounts', async () => {
      const nextGroupIndex = this.getNextGroupIndex();
      if (groupIndex > nextGroupIndex) {
        throw new Error(
          `You cannot use a group index that is higher than the next available one: expected <=${nextGroupIndex}, got ${groupIndex}`,
        );
      }

      let group = this.getMultichainAccountGroup(groupIndex);

      if (group) {
        this.#log(
          `Trying to re-create existing group: [${group.id}] (idempotent)`,
        );
        return group;
      }

      this.#log(`Creating new group for index ${groupIndex}...`);

      if (options?.waitForAllProvidersToFinishCreatingAccounts) {
        // Create account with all providers and await them.
        const results = await Promise.allSettled(
          this.#providers.map((provider) =>
            provider.createAccounts({
              entropySource: this.#entropySource,
              groupIndex,
            }),
          ),
        );

        let failureCount = 0;

        const providerFailures = results.reduce((acc, result, idx) => {
          if (result.status === 'rejected') {
            failureCount += 1;
            acc += `\n- ${this.#providers[idx].getName()}: ${result.reason.message}`;
          }
          return acc;
        }, '');

        const everyProviderFailed = failureCount === this.#providers.length;

        if (everyProviderFailed) {
          // We throw an error if there's a failure on every provider
          throw new Error(
            `Unable to create multichain account group for index: ${groupIndex} due to provider failures:${providerFailures}`,
          );
        } else if (providerFailures) {
          // We warn there's failures on some providers and thus misalignment, but we still create the group
          const message = `Unable to create some accounts for group index: ${groupIndex}. Providers threw the following errors:${providerFailures}`;
          console.warn(message);
          this.#log(`${WARNING_PREFIX} ${message}`);
        }

        group = new MultichainAccountGroup({
          wallet: this,
          providers: this.#providers,
          groupIndex,
          messenger: this.#messenger,
        });

        // No need to fetch the accounts list from the AccountsController since we already have the account IDs to be used in the controller
        const groupState = results.reduce<GroupState>((state, result, idx) => {
          if (result.status === 'fulfilled') {
            state[this.#providers[idx].getName()] = result.value.map(
              (account) => account.id,
            );
          }
          return state;
        }, {});

        group.init(groupState);
      } else {
        // Extract the EVM provider from the list of providers.
        // We will only await the EVM provider to create its accounts, while
        // all other providers will be started in the background.
        const [evmProvider, ...otherProviders] = this.#providers;
        assert(
          evmProvider instanceof EvmAccountProvider,
          'EVM account provider must be first',
        );

        // Create the group here because the EVM provider will not fail.
        // There isn't a failure scenario here since this function is only used by createNextMultichainAccountGroup (no throw on gap error).
        // We have to deterministically create the group here because otherwise we can't set the group in state.
        group = new MultichainAccountGroup({
          wallet: this,
          providers: this.#providers,
          groupIndex,
          messenger: this.#messenger,
        });

        evmProvider
          .createAccounts({
            entropySource: this.#entropySource,
            groupIndex,
          })
          .then((account) => {
            group?.init({ [evmProvider.getName()]: [account[0].id] });
            return group;
          })
          .catch((error) => {
            const errorMessage = `Unable to create some accounts for group index: ${groupIndex} with provider "${evmProvider.getName()}". Error: ${(error as Error).message}`;
            console.warn(errorMessage);
            this.#log(`${ERROR_PREFIX} ${errorMessage}:`, error);
          });

        // Create account with other providers in the background
        otherProviders.forEach((provider) => {
          provider
            .createAccounts({
              entropySource: this.#entropySource,
              groupIndex,
            })
            .then((accounts) => {
              const accountIds = accounts.map((account) => account.id);
              group?.init({ [provider.getName()]: accountIds });
              return group;
            })
            .catch((error) => {
              // Log errors from background providers but don't fail the operation
              const errorMessage = `Unable to create some accounts for group index: ${groupIndex} with provider "${provider.getName()}". Error: ${(error as Error).message}`;
              console.warn(errorMessage);
              this.#log(`${WARNING_PREFIX} ${errorMessage}:`, error);
            });
        });
      }

      // Register the account(s) to our internal map.
      this.#accountGroups.set(groupIndex, group);

      this.#log(`New group created: [${group.id}]`);

      if (this.#initialized) {
        this.#messenger.publish(
          'MultichainAccountService:multichainAccountGroupCreated',
          group,
        );
      }

      return group;
    });
  }

  /**
   * Creates the next multichain account group.
   *
   * @throws If any of the account providers fails to create their accounts.
   * @returns The multichain account group for the next group index available.
   */
  async createNextMultichainAccountGroup(): Promise<
    MultichainAccountGroup<Account>
  > {
    return this.createMultichainAccountGroup(this.getNextGroupIndex(), {
      waitForAllProvidersToFinishCreatingAccounts: true,
    });
  }

  /**
   * Align all multichain account groups.
   *
   * NOTE: This operation WILL NOT lock the wallet's mutex.
   */
  async #alignAccounts(): Promise<void> {
    const groups = this.getMultichainAccountGroups();
    await Promise.all(groups.map((group) => group.alignAccounts()));
  }

  /**
   * Align all accounts from each existing multichain account groups.
   *
   * NOTE: This operation WILL lock the wallet's mutex.
   */
  async alignAccounts(): Promise<void> {
    await this.#withLock('in-progress:alignment', async () => {
      await this.#alignAccounts();
    });
  }

  /**
   * Align a specific multichain account group.
   *
   * NOTE: This operation WILL lock the wallet's mutex.
   *
   * @param groupIndex - The group index to align.
   */
  async alignAccountsOf(groupIndex: number): Promise<void> {
    await this.#withLock('in-progress:alignment', async () => {
      const group = this.getMultichainAccountGroup(groupIndex);
      if (group) {
        await group.alignAccounts();
      }
    });
  }

  /**
   * Discover and create accounts for all providers.
   *
   * NOTE: This operation WILL lock the wallet's mutex.
   *
   * @returns The discovered accounts for each provider.
   */
  async discoverAccounts(): Promise<Account[]> {
    return this.#withLock('in-progress:discovery', async () => {
      // Start with the next available group index (so we can resume the discovery
      // from there).
      let maxGroupIndex = this.getNextGroupIndex();
      const discoveredGroupsState: DiscoveredGroupsState = {};

      const addDiscoveryResultToState = (
        result: Account[],
        providerName: string,
        groupIndex: number,
      ) => {
        const accountIds = result.map((account) => account.id);
        discoveredGroupsState[groupIndex] ??= {};
        discoveredGroupsState[groupIndex][providerName] = accountIds;
      };

      // One serialized loop per provider; all run concurrently
      const runProviderDiscovery = async (
        context: AccountProviderDiscoveryContext<Account>,
      ) => {
        const providerName = context.provider.getName();
        const message = (stepName: string, groupIndex: number) =>
          `[${providerName}] Discovery ${stepName} for group index: ${groupIndex}`;

        while (!context.stopped) {
          // Fast‑forward to current high‑water mark
          const targetGroupIndex = Math.max(context.groupIndex, maxGroupIndex);

          log(message('started', targetGroupIndex));

          let accounts: Account[] = [];
          try {
            accounts = (await context.provider.discoverAccounts({
              entropySource: this.#entropySource,
              groupIndex: targetGroupIndex,
            })) as Account[];
          } catch (error) {
            context.stopped = true;
            console.error(error);
            log(
              message(
                `failed (with: "${(error as Error).message}")`,
                targetGroupIndex,
              ),
              error,
            );
            break;
          }

          if (!accounts.length) {
            log(
              message('stopped (no accounts got discovered)', targetGroupIndex),
            );
            context.stopped = true;
            break;
          }

          log(message('**succeeded**', targetGroupIndex));

          context.accounts = context.accounts.concat(accounts);

          addDiscoveryResultToState(accounts, providerName, targetGroupIndex);

          const nextGroupIndex = targetGroupIndex + 1;
          context.groupIndex = nextGroupIndex;

          if (nextGroupIndex > maxGroupIndex) {
            maxGroupIndex = nextGroupIndex;
          }
        }
      };

      const providerContexts: AccountProviderDiscoveryContext<Account>[] =
        this.#providers.map((provider) => ({
          provider,
          stopped: false,
          groupIndex: maxGroupIndex,
          accounts: [],
        }));

      // Start discovery for each providers.
      await Promise.all(providerContexts.map(runProviderDiscovery));

      // Create discovered groups
      for (const [groupIndex, groupState] of Object.entries(
        discoveredGroupsState,
      )) {
        const indexAsNumber = Number(groupIndex);
        const group = new MultichainAccountGroup({
          wallet: this,
          providers: this.#providers,
          groupIndex: indexAsNumber,
          messenger: this.#messenger,
        });
        group.init(groupState);
        this.#accountGroups.set(indexAsNumber, group);
      }

      // Align missing accounts from group. This is required to create missing account from non-discovered
      // indexes for some providers.
      await this.#alignAccounts();

      return providerContexts.flatMap((context) => context.accounts);
    });
  }
}
