{"version":3,"sources":["../src/helpers/EtherscanRemoteTransactionSource.ts"],"names":[],"mappings":"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","sourcesContent":["import { BNToHex } from '@metamask/controller-utils';\nimport type { Hex } from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\nimport BN from 'bn.js';\nimport { v1 as random } from 'uuid';\n\nimport { ETHERSCAN_SUPPORTED_NETWORKS } from '../constants';\nimport { incomingTransactionsLogger as log } from '../logger';\nimport type {\n  RemoteTransactionSource,\n  RemoteTransactionSourceRequest,\n  TransactionMeta,\n} from '../types';\nimport { TransactionStatus, TransactionType } from '../types';\nimport {\n  fetchEtherscanTokenTransactions,\n  fetchEtherscanTransactions,\n} from '../utils/etherscan';\nimport type {\n  EtherscanTokenTransactionMeta,\n  EtherscanTransactionMeta,\n  EtherscanTransactionMetaBase,\n  EtherscanTransactionRequest,\n  EtherscanTransactionResponse,\n} from '../utils/etherscan';\n\nconst ETHERSCAN_RATE_LIMIT_INTERVAL = 5000;\n/**\n * A RemoteTransactionSource that fetches transaction data from Etherscan.\n */\nexport class EtherscanRemoteTransactionSource\n  implements RemoteTransactionSource\n{\n  #includeTokenTransfers: boolean;\n\n  #isTokenRequestPending: boolean;\n\n  #mutex = new Mutex();\n\n  constructor({\n    includeTokenTransfers,\n  }: { includeTokenTransfers?: boolean } = {}) {\n    this.#includeTokenTransfers = includeTokenTransfers ?? true;\n    this.#isTokenRequestPending = false;\n  }\n\n  isSupportedNetwork(chainId: Hex): boolean {\n    return Object.keys(ETHERSCAN_SUPPORTED_NETWORKS).includes(chainId);\n  }\n\n  getLastBlockVariations(): string[] {\n    return [this.#isTokenRequestPending ? 'token' : 'normal'];\n  }\n\n  async fetchTransactions(\n    request: RemoteTransactionSourceRequest,\n  ): Promise<TransactionMeta[]> {\n    const releaseLock = await this.#mutex.acquire();\n    const acquiredTime = Date.now();\n\n    const etherscanRequest: EtherscanTransactionRequest = {\n      ...request,\n      chainId: request.currentChainId,\n    };\n\n    try {\n      const transactions = this.#isTokenRequestPending\n        ? await this.#fetchTokenTransactions(request, etherscanRequest)\n        : await this.#fetchNormalTransactions(request, etherscanRequest);\n\n      if (this.#includeTokenTransfers) {\n        this.#isTokenRequestPending = !this.#isTokenRequestPending;\n      }\n\n      return transactions;\n    } finally {\n      this.#releaseLockAfterInterval(acquiredTime, releaseLock);\n    }\n  }\n\n  #releaseLockAfterInterval(acquireTime: number, releaseLock: () => void) {\n    const elapsedTime = Date.now() - acquireTime;\n    const remainingTime = Math.max(\n      0,\n      ETHERSCAN_RATE_LIMIT_INTERVAL - elapsedTime,\n    );\n    // Wait for the remaining time if it hasn't been 5 seconds yet\n    if (remainingTime > 0) {\n      setTimeout(releaseLock, remainingTime);\n    } else {\n      releaseLock();\n    }\n  }\n\n  #fetchNormalTransactions = async (\n    request: RemoteTransactionSourceRequest,\n    etherscanRequest: EtherscanTransactionRequest,\n  ) => {\n    const { currentChainId } = request;\n\n    const etherscanTransactions = await fetchEtherscanTransactions(\n      etherscanRequest,\n    );\n\n    return this.#getResponseTransactions(etherscanTransactions).map((tx) =>\n      this.#normalizeTransaction(tx, currentChainId),\n    );\n  };\n\n  #fetchTokenTransactions = async (\n    request: RemoteTransactionSourceRequest,\n    etherscanRequest: EtherscanTransactionRequest,\n  ) => {\n    const { currentChainId } = request;\n\n    const etherscanTransactions = await fetchEtherscanTokenTransactions(\n      etherscanRequest,\n    );\n\n    return this.#getResponseTransactions(etherscanTransactions).map((tx) =>\n      this.#normalizeTokenTransaction(tx, currentChainId),\n    );\n  };\n\n  // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  #getResponseTransactions<T extends EtherscanTransactionMetaBase>(\n    response: EtherscanTransactionResponse<T>,\n  ): T[] {\n    let result = response.result as T[];\n\n    if (response.status === '0') {\n      result = [];\n\n      if (response.result.length) {\n        log('Ignored Etherscan request error', {\n          message: response.result,\n          type: this.#isTokenRequestPending ? 'token' : 'normal',\n        });\n      }\n    }\n\n    return result;\n  }\n\n  #normalizeTransaction(\n    txMeta: EtherscanTransactionMeta,\n    currentChainId: Hex,\n  ): TransactionMeta {\n    const base = this.#normalizeTransactionBase(txMeta, currentChainId);\n\n    return {\n      ...base,\n      txParams: {\n        ...base.txParams,\n        data: txMeta.input,\n      },\n      ...(txMeta.isError === '0'\n        ? { status: TransactionStatus.confirmed }\n        : {\n            error: new Error('Transaction failed'),\n            status: TransactionStatus.failed,\n          }),\n    };\n  }\n\n  #normalizeTokenTransaction(\n    txMeta: EtherscanTokenTransactionMeta,\n    currentChainId: Hex,\n  ): TransactionMeta {\n    const base = this.#normalizeTransactionBase(txMeta, currentChainId);\n\n    return {\n      ...base,\n      isTransfer: true,\n      transferInformation: {\n        contractAddress: txMeta.contractAddress,\n        decimals: Number(txMeta.tokenDecimal),\n        symbol: txMeta.tokenSymbol,\n      },\n    };\n  }\n\n  #normalizeTransactionBase(\n    txMeta: EtherscanTransactionMetaBase,\n    currentChainId: Hex,\n  ): TransactionMeta {\n    const time = parseInt(txMeta.timeStamp, 10) * 1000;\n\n    return {\n      blockNumber: txMeta.blockNumber,\n      chainId: currentChainId,\n      hash: txMeta.hash,\n      id: random({ msecs: time }),\n      status: TransactionStatus.confirmed,\n      time,\n      txParams: {\n        chainId: currentChainId,\n        from: txMeta.from,\n        gas: BNToHex(new BN(txMeta.gas)),\n        gasPrice: BNToHex(new BN(txMeta.gasPrice)),\n        gasUsed: BNToHex(new BN(txMeta.gasUsed)),\n        nonce: BNToHex(new BN(txMeta.nonce)),\n        to: txMeta.to,\n        value: BNToHex(new BN(txMeta.value)),\n      },\n      type: TransactionType.incoming,\n      verifiedOnBlockchain: false,\n    };\n  }\n}\n"]}