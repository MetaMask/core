import {
  AUTH_LOGIN_ENDPOINT,
  AUTH_NONCE_ENDPOINT,
  OIDC_CLIENT_ID,
  OIDC_GRANT_TYPE,
  OIDC_TOKENS_ENDPOINT,
} from '../constants';

export type NonceResponse = {
  nonce: string;
};
/**
 * Retrieves a nonce from the authentication API based on the provided public key.
 *
 * @param publicKey - The public key used to identify the user.
 * @returns A promise that resolves to the nonce if successful, or null if the request fails.
 */
export async function getNonce(publicKey: string): Promise<string | null> {
  const nonceUrl = new URL(AUTH_NONCE_ENDPOINT);
  nonceUrl.searchParams.set('identifier', publicKey);

  try {
    const nonceResponse = await fetch(nonceUrl.toString());
    if (!nonceResponse.ok) {
      return null;
    }

    const nonceJson: NonceResponse = await nonceResponse.json();
    return nonceJson?.nonce ?? null;
  } catch (e) {
    console.error('authentication-controller/services: unable to get nonce', e);
    return null;
  }
}

export type LoginResponse = {
  token: string;
  expires_in: string;
  /**
   * Contains anonymous information about the logged in profile.
   *
   * @property identifier_id - a deterministic unique identifier on the method used to sign in
   * @property profile_id - a unique id for a given profile
   * @property metametrics_id - an anonymous server id
   */
  profile: {
    identifier_id: string;
    profile_id: string;
  };
};
/**
 * Authenticates a user by sending a login request to the server.
 *
 * @param rawMessage - The raw message to be signed.
 * @param signature - The signature generated by the user.
 * @param clientMetaMetricsId - The client's metametrics ID.
 * @returns A promise that resolves to the login response if successful, or null if there was an error.
 */
export async function login(
  rawMessage: string,
  signature: string,
  clientMetaMetricsId: string,
): Promise<LoginResponse | null> {
  try {
    const response = await fetch(AUTH_LOGIN_ENDPOINT, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        signature,
        raw_message: rawMessage,
        metametrics: {
          metametrics_id: clientMetaMetricsId,
          agent: 'extension',
        },
      }),
    });

    if (!response.ok) {
      return null;
    }

    const loginResponse: LoginResponse = await response.json();
    return loginResponse ?? null;
  } catch (e) {
    console.error('authentication-controller/services: unable to login', e);
    return null;
  }
}

export type OAuthTokenResponse = {
  access_token: string;
  expires_in: number;
};

/**
 * Retrieves an access token from the server using a JWT token.
 *
 * @param jwtToken - The JWT token used for authentication.
 * @returns A promise that resolves to the access token if successful, or null if an error occurs.
 */
export async function getAccessToken(jwtToken: string): Promise<string | null> {
  const headers = new Headers({
    'Content-Type': 'application/x-www-form-urlencoded',
  });

  const urlEncodedBody = new URLSearchParams();
  urlEncodedBody.append('grant_type', OIDC_GRANT_TYPE);
  urlEncodedBody.append('client_id', OIDC_CLIENT_ID);
  urlEncodedBody.append('assertion', jwtToken);

  try {
    const response = await fetch(OIDC_TOKENS_ENDPOINT, {
      method: 'POST',
      headers,
      body: urlEncodedBody.toString(),
    });

    if (!response.ok) {
      return null;
    }

    const accessTokenResponse: OAuthTokenResponse = await response.json();
    return accessTokenResponse?.access_token ?? null;
  } catch (e) {
    console.error(
      'authentication-controller/services: unable to get access token',
      e,
    );
    return null;
  }
}

/**
 * Creates a login raw message using the provided nonce and public key.
 *
 * @param nonce - The nonce to be included in the login raw message.
 * @param publicKey - The public key to be included in the login raw message.
 * @returns The login raw message in the format "metamask:{nonce}:{publicKey}".
 */
export function createLoginRawMessage(
  nonce: string,
  publicKey: string,
): `metamask:${string}:${string}` {
  return `metamask:${nonce}:${publicKey}` as const;
}
