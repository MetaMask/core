{"version":3,"sources":["../src/SubjectMetadataController.ts"],"sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport type { Json } from '@metamask/utils';\n\nimport type {\n  GenericPermissionController,\n  HasPermissions,\n  PermissionSubjectMetadata,\n} from './PermissionController';\n\nconst controllerName = 'SubjectMetadataController';\n\ntype SubjectOrigin = string;\n\n/**\n * The different kinds of subjects that MetaMask may interact with, including\n * third parties and itself (e.g., when the background communicated with the UI).\n */\nexport enum SubjectType {\n  Extension = 'extension',\n  Internal = 'internal',\n  Unknown = 'unknown',\n  Website = 'website',\n  Snap = 'snap',\n}\n\nexport type SubjectMetadata = PermissionSubjectMetadata & {\n  [key: string]: Json;\n  name: string | null;\n  subjectType: SubjectType | null;\n  extensionId: string | null;\n  iconUrl: string | null;\n};\n\ntype SubjectMetadataToAdd = PermissionSubjectMetadata & {\n  name?: string | null;\n  subjectType?: SubjectType | null;\n  extensionId?: string | null;\n  iconUrl?: string | null;\n} & Record<string, Json>;\n\nexport type SubjectMetadataControllerState = {\n  subjectMetadata: Record<SubjectOrigin, SubjectMetadata>;\n};\n\nconst stateMetadata = {\n  subjectMetadata: { persist: true, anonymous: false },\n};\n\nconst defaultState: SubjectMetadataControllerState = {\n  subjectMetadata: {},\n};\n\nexport type GetSubjectMetadataState = ControllerGetStateAction<\n  typeof controllerName,\n  SubjectMetadataControllerState\n>;\n\nexport type GetSubjectMetadata = {\n  type: `${typeof controllerName}:getSubjectMetadata`;\n  handler: (origin: SubjectOrigin) => SubjectMetadata | undefined;\n};\n\nexport type AddSubjectMetadata = {\n  type: `${typeof controllerName}:addSubjectMetadata`;\n  handler: (metadata: SubjectMetadataToAdd) => void;\n};\n\nexport type SubjectMetadataControllerActions =\n  | GetSubjectMetadataState\n  | GetSubjectMetadata\n  | AddSubjectMetadata;\n\nexport type SubjectMetadataStateChange = ControllerStateChangeEvent<\n  typeof controllerName,\n  SubjectMetadataControllerState\n>;\n\nexport type SubjectMetadataControllerEvents = SubjectMetadataStateChange;\n\ntype AllowedActions = HasPermissions;\n\nexport type SubjectMetadataControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  SubjectMetadataControllerActions | AllowedActions,\n  SubjectMetadataControllerEvents,\n  AllowedActions['type'],\n  never\n>;\n\ntype SubjectMetadataControllerOptions = {\n  messenger: SubjectMetadataControllerMessenger;\n  subjectCacheLimit: number;\n  state?: Partial<SubjectMetadataControllerState>;\n};\n\n/**\n * A controller for storing metadata associated with permission subjects. More\n * or less, a cache.\n */\nexport class SubjectMetadataController extends BaseController<\n  typeof controllerName,\n  SubjectMetadataControllerState,\n  SubjectMetadataControllerMessenger\n> {\n  private readonly subjectCacheLimit: number;\n\n  private readonly subjectsWithoutPermissionsEncounteredSinceStartup: Set<string>;\n\n  private readonly subjectHasPermissions: GenericPermissionController['hasPermissions'];\n\n  constructor({\n    messenger,\n    subjectCacheLimit,\n    state = {},\n  }: SubjectMetadataControllerOptions) {\n    if (!Number.isInteger(subjectCacheLimit) || subjectCacheLimit < 1) {\n      throw new Error(\n        `subjectCacheLimit must be a positive integer. Received: \"${subjectCacheLimit}\"`,\n      );\n    }\n\n    const hasPermissions = (origin: string) => {\n      return messenger.call('PermissionController:hasPermissions', origin);\n    };\n\n    super({\n      name: controllerName,\n      metadata: stateMetadata,\n      messenger,\n      state: {\n        ...SubjectMetadataController.getTrimmedState(state, hasPermissions),\n      },\n    });\n\n    this.subjectHasPermissions = hasPermissions;\n    this.subjectCacheLimit = subjectCacheLimit;\n    this.subjectsWithoutPermissionsEncounteredSinceStartup = new Set();\n\n    this.messagingSystem.registerActionHandler(\n      // ESLint is confused by the string literal type.\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      `${this.name}:getSubjectMetadata`,\n      this.getSubjectMetadata.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      // ESLint is confused by the string literal type.\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      `${this.name}:addSubjectMetadata`,\n      this.addSubjectMetadata.bind(this),\n    );\n  }\n\n  /**\n   * Clears the state of this controller. Also resets the cache of subjects\n   * encountered since startup, so as to not prematurely reach the cache limit.\n   */\n  clearState(): void {\n    this.subjectsWithoutPermissionsEncounteredSinceStartup.clear();\n    this.update((_draftState) => {\n      return { ...defaultState };\n    });\n  }\n\n  /**\n   * Stores domain metadata for the given origin (subject). Deletes metadata for\n   * subjects without permissions in a FIFO manner once more than\n   * {@link SubjectMetadataController.subjectCacheLimit} distinct origins have\n   * been added since boot.\n   *\n   * In order to prevent a degraded user experience,\n   * metadata is never deleted for subjects with permissions, since metadata\n   * cannot yet be requested on demand.\n   *\n   * @param metadata - The subject metadata to store.\n   */\n  addSubjectMetadata(metadata: SubjectMetadataToAdd): void {\n    const { origin } = metadata;\n    const newMetadata: SubjectMetadata = {\n      ...metadata,\n      extensionId: metadata.extensionId || null,\n      iconUrl: metadata.iconUrl || null,\n      name: metadata.name || null,\n      subjectType: metadata.subjectType || null,\n    };\n\n    let originToForget: string | null = null;\n    // We only delete the oldest encountered subject from the cache, again to\n    // ensure that the user's experience isn't degraded by missing icons etc.\n    if (\n      this.subjectsWithoutPermissionsEncounteredSinceStartup.size >=\n      this.subjectCacheLimit\n    ) {\n      const cachedOrigin =\n        this.subjectsWithoutPermissionsEncounteredSinceStartup\n          .values()\n          .next().value;\n\n      this.subjectsWithoutPermissionsEncounteredSinceStartup.delete(\n        cachedOrigin,\n      );\n\n      if (!this.subjectHasPermissions(cachedOrigin)) {\n        originToForget = cachedOrigin;\n      }\n    }\n\n    this.subjectsWithoutPermissionsEncounteredSinceStartup.add(origin);\n\n    this.update((draftState) => {\n      draftState.subjectMetadata[origin] = newMetadata;\n      if (typeof originToForget === 'string') {\n        delete draftState.subjectMetadata[originToForget];\n      }\n    });\n  }\n\n  /**\n   * Gets the subject metadata for the given origin, if any.\n   *\n   * @param origin - The origin for which to get the subject metadata.\n   * @returns The subject metadata, if any, or `undefined` otherwise.\n   */\n  getSubjectMetadata(origin: SubjectOrigin): SubjectMetadata | undefined {\n    return this.state.subjectMetadata[origin];\n  }\n\n  /**\n   * Deletes all subjects without permissions from the controller's state.\n   */\n  trimMetadataState(): void {\n    this.update((draftState) => {\n      // @ts-expect-error ts(2589)\n      return SubjectMetadataController.getTrimmedState(\n        draftState,\n        this.subjectHasPermissions,\n      );\n    });\n  }\n\n  /**\n   * Returns a new state object that only includes subjects with permissions.\n   * This method is static because we want to call it in the constructor, before\n   * the controller's state is initialized.\n   *\n   * @param state - The state object to trim.\n   * @param hasPermissions - A function that returns a boolean indicating\n   * whether a particular subject (identified by its origin) has any\n   * permissions.\n   * @returns The new state object. If the specified `state` object has no\n   * subject metadata, the returned object will be equivalent to the default\n   * state of this controller.\n   */\n  private static getTrimmedState(\n    state: Partial<SubjectMetadataControllerState>,\n    hasPermissions: SubjectMetadataController['subjectHasPermissions'],\n  ): SubjectMetadataControllerState {\n    const { subjectMetadata = {} } = state;\n\n    return {\n      subjectMetadata: Object.keys(subjectMetadata).reduce<\n        Record<SubjectOrigin, SubjectMetadata>\n      >((newSubjectMetadata, origin) => {\n        if (hasPermissions(origin)) {\n          newSubjectMetadata[origin] = subjectMetadata[origin];\n        }\n        return newSubjectMetadata;\n      }, {}),\n    };\n  }\n}\n"],"mappings":"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","names":["SubjectType"]}