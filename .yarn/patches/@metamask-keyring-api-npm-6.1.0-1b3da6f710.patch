diff --git a/dist/superstruct.d.ts b/dist/superstruct.d.ts
index b81329da445b729dc26533adb51443f14e58e5dc..2857b6d3d4c9070d7c557bd15f7c1b9bc41c9951 100644
--- a/dist/superstruct.d.ts
+++ b/dist/superstruct.d.ts
@@ -1,6 +1,6 @@
 import type { Infer } from 'superstruct';
 import { Struct } from 'superstruct';
-import type { ObjectSchema, OmitBy, Optionalize, PickBy, Simplify } from 'superstruct/dist/utils';
+import type { ObjectSchema, OmitBy, Optionalize, PickBy, Simplify } from 'superstruct';
 declare const ExactOptionalSymbol: unique symbol;
 export declare type ExactOptionalTag = {
     type: typeof ExactOptionalSymbol;
diff --git a/dist/superstruct.js.map b/dist/superstruct.js.map
index 746668d2b1959fedd9150a9faf35ea30e30b5a7a..aaf130b761f57ade6c49f009f1f5c825186e858a 100644
--- a/dist/superstruct.js.map
+++ b/dist/superstruct.js.map
@@ -1 +1 @@
-{"version":3,"file":"superstruct.js","sourceRoot":"","sources":["../src/superstruct.ts"],"names":[],"mappings":";;;AACA,6CAAiE;AAkDjE;;;;;;GAMG;AACH,SAAgB,MAAM,CACpB,MAAc;IAEd,OAAO,IAAA,oBAAQ,EAAC,MAAM,CAAQ,CAAC;AACjC,CAAC;AAJD,wBAIC;AAED;;;;;GAKG;AACH,SAAS,WAAW,CAAC,GAAY;IAC/B,MAAM,QAAQ,GAAW,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IACvD,MAAM,MAAM,GAA4B,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IAE1E,OAAO,QAAQ,IAAI,MAAM,CAAC;AAC5B,CAAC;AAED;;;;;;;;;;;;GAYG;AACH,SAAgB,aAAa,CAC3B,MAA4B;IAE5B,OAAO,IAAI,oBAAM,CAAC;QAChB,GAAG,MAAM;QAET,SAAS,EAAE,CAAC,KAAK,EAAE,GAAG,EAAE,EAAE,CACxB,CAAC,WAAW,CAAC,GAAG,CAAC,IAAI,MAAM,CAAC,SAAS,CAAC,KAAK,EAAE,GAAG,CAAC;QAEnD,OAAO,EAAE,CAAC,KAAK,EAAE,GAAG,EAAE,EAAE,CACtB,CAAC,WAAW,CAAC,GAAG,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,KAAa,EAAE,GAAG,CAAC;KAC1D,CAAC,CAAC;AACL,CAAC;AAZD,sCAYC;AAED;;;;;;;;;;;;GAYG;AACH,SAAgB,aAAa,CAC3B,IAAY,EACZ,OAAe;IAEf,OAAO,IAAA,oBAAM,EACX,IAAI,EACJ,CAAC,KAAc,EAAW,EAAE,CAC1B,OAAO,KAAK,KAAK,QAAQ,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CACnD,CAAC;AACJ,CAAC;AATD,sCASC;AAED;;;;;GAKG;AACU,QAAA,SAAS,GAAG,IAAA,oBAAM,EAAS,KAAK,EAAE,CAAC,KAAc,EAAE,EAAE;IAChE,IAAI,GAAG,CAAC;IAER,IAAI;QACF,GAAG,GAAG,IAAI,GAAG,CAAC,KAAe,CAAC,CAAC;KAChC;IAAC,OAAO,CAAC,EAAE;QACV,OAAO,KAAK,CAAC;KACd;IAED,OAAO,GAAG,CAAC,QAAQ,KAAK,OAAO,IAAI,GAAG,CAAC,QAAQ,KAAK,QAAQ,CAAC;AAC/D,CAAC,CAAC,CAAC","sourcesContent":["import type { Infer, Context } from 'superstruct';\nimport { Struct, define, object as stObject } from 'superstruct';\nimport type {\n  ObjectSchema,\n  OmitBy,\n  Optionalize,\n  PickBy,\n  Simplify,\n} from 'superstruct/dist/utils';\n\ndeclare const ExactOptionalSymbol: unique symbol;\n\nexport type ExactOptionalTag = {\n  type: typeof ExactOptionalSymbol;\n};\n\n/**\n * Exclude type `Type` from the properties of `Obj`.\n *\n * ```ts\n * type Foo = { a: string | null; b: number };\n * type Bar = ExcludeType<Foo, null>;\n * // Bar = { a: string, b: number }\n * ```\n */\nexport type ExcludeType<Obj, Type> = {\n  [K in keyof Obj]: Exclude<Obj[K], Type>;\n};\n\n/**\n * Make optional all properties that have the `ExactOptionalTag` type.\n *\n * ```ts\n * type Foo = { a: string | ExactOptionalTag; b: number};\n * type Bar = ExactOptionalize<Foo>;\n * // Bar = { a?: string; b: number}\n * ```\n */\nexport type ExactOptionalize<Schema extends object> = OmitBy<\n  Schema,\n  ExactOptionalTag\n> &\n  Partial<ExcludeType<PickBy<Schema, ExactOptionalTag>, ExactOptionalTag>>;\n\n/**\n * Infer a type from an superstruct object schema.\n */\nexport type ObjectType<Schema extends ObjectSchema> = Simplify<\n  ExactOptionalize<Optionalize<{ [K in keyof Schema]: Infer<Schema[K]> }>>\n>;\n\n/**\n * Change the return type of a superstruct object struct to support exact\n * optional properties.\n *\n * @param schema - The object schema.\n * @returns A struct representing an object with a known set of properties.\n */\nexport function object<Schema extends ObjectSchema>(\n  schema: Schema,\n): Struct<ObjectType<Schema>, Schema> {\n  return stObject(schema) as any;\n}\n\n/**\n * Check if the current property is present in its parent object.\n *\n * @param ctx - The context to check.\n * @returns `true` if the property is present, `false` otherwise.\n */\nfunction hasOptional(ctx: Context): boolean {\n  const property: string = ctx.path[ctx.path.length - 1];\n  const parent: Record<string, unknown> = ctx.branch[ctx.branch.length - 2];\n\n  return property in parent;\n}\n\n/**\n * Augment a struct to allow exact-optional values. Exact-optional values can\n * be omitted but cannot be `undefined`.\n *\n * ```ts\n * const foo = object({ bar: exactOptional(string()) });\n * type Foo = Infer<typeof foo>;\n * // Foo = { bar?: string }\n * ```\n *\n * @param struct - The struct to augment.\n * @returns The augmented struct.\n */\nexport function exactOptional<Type, Schema>(\n  struct: Struct<Type, Schema>,\n): Struct<Type | ExactOptionalTag, Schema> {\n  return new Struct({\n    ...struct,\n\n    validator: (value, ctx) =>\n      !hasOptional(ctx) || struct.validator(value, ctx),\n\n    refiner: (value, ctx) =>\n      !hasOptional(ctx) || struct.refiner(value as Type, ctx),\n  });\n}\n\n/**\n * Defines a new string-struct matching a regular expression.\n *\n * Example:\n *\n * ```ts\n * const EthAddressStruct = definePattern('EthAddress', /^0x[0-9a-f]{40}$/iu);\n * ```\n *\n * @param name - Type name.\n * @param pattern - Regular expression to match.\n * @returns A new string-struct that matches the given pattern.\n */\nexport function definePattern(\n  name: string,\n  pattern: RegExp,\n): Struct<string, null> {\n  return define<string>(\n    name,\n    (value: unknown): boolean =>\n      typeof value === 'string' && pattern.test(value),\n  );\n}\n\n/**\n * Validates if a given value is a valid URL.\n *\n * @param value - The value to be validated.\n * @returns A boolean indicating if the value is a valid URL.\n */\nexport const UrlStruct = define<string>('Url', (value: unknown) => {\n  let url;\n\n  try {\n    url = new URL(value as string);\n  } catch (_) {\n    return false;\n  }\n\n  return url.protocol === 'http:' || url.protocol === 'https:';\n});\n"]}
\ No newline at end of file
+{"version":3,"file":"superstruct.js","sourceRoot":"","sources":["../src/superstruct.ts"],"names":[],"mappings":";;;AACA,6CAAiE;AAkDjE;;;;;;GAMG;AACH,SAAgB,MAAM,CACpB,MAAc;IAEd,OAAO,IAAA,oBAAQ,EAAC,MAAM,CAAQ,CAAC;AACjC,CAAC;AAJD,wBAIC;AAED;;;;;GAKG;AACH,SAAS,WAAW,CAAC,GAAY;IAC/B,MAAM,QAAQ,GAAW,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IACvD,MAAM,MAAM,GAA4B,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IAE1E,OAAO,QAAQ,IAAI,MAAM,CAAC;AAC5B,CAAC;AAED;;;;;;;;;;;;GAYG;AACH,SAAgB,aAAa,CAC3B,MAA4B;IAE5B,OAAO,IAAI,oBAAM,CAAC;QAChB,GAAG,MAAM;QAET,SAAS,EAAE,CAAC,KAAK,EAAE,GAAG,EAAE,EAAE,CACxB,CAAC,WAAW,CAAC,GAAG,CAAC,IAAI,MAAM,CAAC,SAAS,CAAC,KAAK,EAAE,GAAG,CAAC;QAEnD,OAAO,EAAE,CAAC,KAAK,EAAE,GAAG,EAAE,EAAE,CACtB,CAAC,WAAW,CAAC,GAAG,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,KAAa,EAAE,GAAG,CAAC;KAC1D,CAAC,CAAC;AACL,CAAC;AAZD,sCAYC;AAED;;;;;;;;;;;;GAYG;AACH,SAAgB,aAAa,CAC3B,IAAY,EACZ,OAAe;IAEf,OAAO,IAAA,oBAAM,EACX,IAAI,EACJ,CAAC,KAAc,EAAW,EAAE,CAC1B,OAAO,KAAK,KAAK,QAAQ,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CACnD,CAAC;AACJ,CAAC;AATD,sCASC;AAED;;;;;GAKG;AACU,QAAA,SAAS,GAAG,IAAA,oBAAM,EAAS,KAAK,EAAE,CAAC,KAAc,EAAE,EAAE;IAChE,IAAI,GAAG,CAAC;IAER,IAAI;QACF,GAAG,GAAG,IAAI,GAAG,CAAC,KAAe,CAAC,CAAC;KAChC;IAAC,OAAO,CAAC,EAAE;QACV,OAAO,KAAK,CAAC;KACd;IAED,OAAO,GAAG,CAAC,QAAQ,KAAK,OAAO,IAAI,GAAG,CAAC,QAAQ,KAAK,QAAQ,CAAC;AAC/D,CAAC,CAAC,CAAC","sourcesContent":["import type { Infer, Context } from 'superstruct';\nimport { Struct, define, object as stObject } from 'superstruct';\nimport type {\n  ObjectSchema,\n  OmitBy,\n  Optionalize,\n  PickBy,\n  Simplify,\n} from 'superstruct';\n\ndeclare const ExactOptionalSymbol: unique symbol;\n\nexport type ExactOptionalTag = {\n  type: typeof ExactOptionalSymbol;\n};\n\n/**\n * Exclude type `Type` from the properties of `Obj`.\n *\n * ```ts\n * type Foo = { a: string | null; b: number };\n * type Bar = ExcludeType<Foo, null>;\n * // Bar = { a: string, b: number }\n * ```\n */\nexport type ExcludeType<Obj, Type> = {\n  [K in keyof Obj]: Exclude<Obj[K], Type>;\n};\n\n/**\n * Make optional all properties that have the `ExactOptionalTag` type.\n *\n * ```ts\n * type Foo = { a: string | ExactOptionalTag; b: number};\n * type Bar = ExactOptionalize<Foo>;\n * // Bar = { a?: string; b: number}\n * ```\n */\nexport type ExactOptionalize<Schema extends object> = OmitBy<\n  Schema,\n  ExactOptionalTag\n> &\n  Partial<ExcludeType<PickBy<Schema, ExactOptionalTag>, ExactOptionalTag>>;\n\n/**\n * Infer a type from an superstruct object schema.\n */\nexport type ObjectType<Schema extends ObjectSchema> = Simplify<\n  ExactOptionalize<Optionalize<{ [K in keyof Schema]: Infer<Schema[K]> }>>\n>;\n\n/**\n * Change the return type of a superstruct object struct to support exact\n * optional properties.\n *\n * @param schema - The object schema.\n * @returns A struct representing an object with a known set of properties.\n */\nexport function object<Schema extends ObjectSchema>(\n  schema: Schema,\n): Struct<ObjectType<Schema>, Schema> {\n  return stObject(schema) as any;\n}\n\n/**\n * Check if the current property is present in its parent object.\n *\n * @param ctx - The context to check.\n * @returns `true` if the property is present, `false` otherwise.\n */\nfunction hasOptional(ctx: Context): boolean {\n  const property: string = ctx.path[ctx.path.length - 1];\n  const parent: Record<string, unknown> = ctx.branch[ctx.branch.length - 2];\n\n  return property in parent;\n}\n\n/**\n * Augment a struct to allow exact-optional values. Exact-optional values can\n * be omitted but cannot be `undefined`.\n *\n * ```ts\n * const foo = object({ bar: exactOptional(string()) });\n * type Foo = Infer<typeof foo>;\n * // Foo = { bar?: string }\n * ```\n *\n * @param struct - The struct to augment.\n * @returns The augmented struct.\n */\nexport function exactOptional<Type, Schema>(\n  struct: Struct<Type, Schema>,\n): Struct<Type | ExactOptionalTag, Schema> {\n  return new Struct({\n    ...struct,\n\n    validator: (value, ctx) =>\n      !hasOptional(ctx) || struct.validator(value, ctx),\n\n    refiner: (value, ctx) =>\n      !hasOptional(ctx) || struct.refiner(value as Type, ctx),\n  });\n}\n\n/**\n * Defines a new string-struct matching a regular expression.\n *\n * Example:\n *\n * ```ts\n * const EthAddressStruct = definePattern('EthAddress', /^0x[0-9a-f]{40}$/iu);\n * ```\n *\n * @param name - Type name.\n * @param pattern - Regular expression to match.\n * @returns A new string-struct that matches the given pattern.\n */\nexport function definePattern(\n  name: string,\n  pattern: RegExp,\n): Struct<string, null> {\n  return define<string>(\n    name,\n    (value: unknown): boolean =>\n      typeof value === 'string' && pattern.test(value),\n  );\n}\n\n/**\n * Validates if a given value is a valid URL.\n *\n * @param value - The value to be validated.\n * @returns A boolean indicating if the value is a valid URL.\n */\nexport const UrlStruct = define<string>('Url', (value: unknown) => {\n  let url;\n\n  try {\n    url = new URL(value as string);\n  } catch (_) {\n    return false;\n  }\n\n  return url.protocol === 'http:' || url.protocol === 'https:';\n});\n"]}
\ No newline at end of file
