diff --git a/dist/chunk-2LBN5T56.js.map b/dist/chunk-2LBN5T56.js.map
index 99c2b450d36f7c800c2ed82784b30384e0ace616..efcb2d6787d9547511f94717b32f467a28413d70 100644
--- a/dist/chunk-2LBN5T56.js.map
+++ b/dist/chunk-2LBN5T56.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../src/cronjob.ts"],"names":[],"mappings":";AAAA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,OACK;AACP,SAAS,uBAAuB;AAEhC,SAAS,OAAO,QAAQ,QAAQ,UAAU,QAAQ,cAAc;AAEzD,IAAM,0BAA0B,OAAO;AAAA,EAC5C,SAAS,SAAS,oBAAoB;AAAA,EACtC,IAAI,SAAS,eAAe;AAAA,EAC5B,QAAQ,OAAO;AAAA,EACf,QAAQ,SAAS,mBAAmB;AACtC,CAAC;AAIM,IAAM,uBAAuB;AAAA,EAClC,OAAO;AAAA,EACP;AAAA,EACA,CAAC,UAAU;AACT,QAAI;AACF,sBAAgB,KAAK;AACrB,aAAO;AAAA,IACT,QAAQ;AACN,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAUO,SAAS,oBAAoB,YAA6B;AAC/D,QAAM,yBAAyB,OAAO,YAAY,oBAAoB;AACtE,SAAO,gBAAgB,sBAAsB;AAC/C;AAEO,IAAM,6BAA6B,OAAO;AAAA,EAC/C,YAAY;AAAA,EACZ,SAAS;AACX,CAAC;AASM,SAAS,uBAAuB,OAAyB;AAC9D,MAAI;AACF,WAAO,OAAO,0BAA0B;AACxC,WAAO;AAAA,EACT,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAEO,IAAM,kCAAkC;AAAA,EAC7C;AACF;AAQO,SAAS,4BAA4B,OAAyB;AACnE,MAAI;AACF,WAAO,OAAO,+BAA+B;AAC7C,WAAO;AAAA,EACT,QAAQ;AACN,WAAO;AAAA,EACT;AACF","sourcesContent":["import {\n  JsonRpcIdStruct,\n  JsonRpcParamsStruct,\n  JsonRpcVersionStruct,\n} from '@metamask/utils';\nimport { parseExpression } from 'cron-parser';\nimport type { Infer } from 'superstruct';\nimport { array, create, object, optional, refine, string } from 'superstruct';\n\nexport const CronjobRpcRequestStruct = object({\n  jsonrpc: optional(JsonRpcVersionStruct),\n  id: optional(JsonRpcIdStruct),\n  method: string(),\n  params: optional(JsonRpcParamsStruct),\n});\n\nexport type CronjobRpcRequest = Infer<typeof CronjobRpcRequestStruct>;\n\nexport const CronExpressionStruct = refine(\n  string(),\n  'CronExpression',\n  (value) => {\n    try {\n      parseExpression(value);\n      return true;\n    } catch {\n      return false;\n    }\n  },\n);\n\nexport type CronExpression = Infer<typeof CronExpressionStruct>;\n\n/**\n * Parses a cron expression.\n *\n * @param expression - Expression to parse.\n * @returns A CronExpression class instance.\n */\nexport function parseCronExpression(expression: string | object) {\n  const ensureStringExpression = create(expression, CronExpressionStruct);\n  return parseExpression(ensureStringExpression);\n}\n\nexport const CronjobSpecificationStruct = object({\n  expression: CronExpressionStruct,\n  request: CronjobRpcRequestStruct,\n});\nexport type CronjobSpecification = Infer<typeof CronjobSpecificationStruct>;\n\n/**\n * Check if the given value is a {@link CronjobSpecification} object.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid {@link CronjobSpecification} object.\n */\nexport function isCronjobSpecification(value: unknown): boolean {\n  try {\n    create(value, CronjobSpecificationStruct);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport const CronjobSpecificationArrayStruct = array(\n  CronjobSpecificationStruct,\n);\n\n/**\n * Check if the given value is an array of {@link CronjobSpecification} objects.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid array of {@link CronjobSpecification} objects.\n */\nexport function isCronjobSpecificationArray(value: unknown): boolean {\n  try {\n    create(value, CronjobSpecificationArrayStruct);\n    return true;\n  } catch {\n    return false;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"sources":["../src/cronjob.ts"],"names":[],"mappings":";AAAA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,OACK;AACP,SAAS,uBAAuB;AAEhC,SAAS,OAAO,QAAQ,QAAQ,UAAU,QAAQ,cAAc;AAEzD,IAAM,0BAA0B,OAAO;AAAA,EAC5C,SAAS,SAAS,oBAAoB;AAAA,EACtC,IAAI,SAAS,eAAe;AAAA,EAC5B,QAAQ,OAAO;AAAA,EACf,QAAQ,SAAS,mBAAmB;AACtC,CAAC;AAIM,IAAM,uBAAuB;AAAA,EAClC,OAAO;AAAA,EACP;AAAA,EACA,CAAC,UAAU;AACT,QAAI;AACF,sBAAgB,KAAK;AACrB,aAAO;AAAA,IACT,QAAQ;AACN,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAUO,SAAS,oBAAoB,YAA6B;AAC/D,QAAM,yBAAyB,OAAO,YAAY,oBAAoB;AACtE,SAAO,gBAAgB,sBAAsB;AAC/C;AAEO,IAAM,6BAA6B,OAAO;AAAA,EAC/C,YAAY;AAAA,EACZ,SAAS;AACX,CAAC;AASM,SAAS,uBAAuB,OAAyB;AAC9D,MAAI;AACF,WAAO,OAAO,0BAA0B;AACxC,WAAO;AAAA,EACT,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAEO,IAAM,kCAAkC;AAAA,EAC7C;AACF;AAQO,SAAS,4BAA4B,OAAyB;AACnE,MAAI;AACF,WAAO,OAAO,+BAA+B;AAC7C,WAAO;AAAA,EACT,QAAQ;AACN,WAAO;AAAA,EACT;AACF","sourcesContent":["import {\n  JsonRpcIdStruct,\n  JsonRpcParamsStruct,\n  JsonRpcVersionStruct,\n} from '@metamask/utils';\nimport { parseExpression } from 'cron-parser';\nimport type { Infer } from '@metamask/superstruct';\nimport { array, create, object, optional, refine, string } from '@metamask/superstruct';\n\nexport const CronjobRpcRequestStruct = object({\n  jsonrpc: optional(JsonRpcVersionStruct),\n  id: optional(JsonRpcIdStruct),\n  method: string(),\n  params: optional(JsonRpcParamsStruct),\n});\n\nexport type CronjobRpcRequest = Infer<typeof CronjobRpcRequestStruct>;\n\nexport const CronExpressionStruct = refine(\n  string(),\n  'CronExpression',\n  (value) => {\n    try {\n      parseExpression(value);\n      return true;\n    } catch {\n      return false;\n    }\n  },\n);\n\nexport type CronExpression = Infer<typeof CronExpressionStruct>;\n\n/**\n * Parses a cron expression.\n *\n * @param expression - Expression to parse.\n * @returns A CronExpression class instance.\n */\nexport function parseCronExpression(expression: string | object) {\n  const ensureStringExpression = create(expression, CronExpressionStruct);\n  return parseExpression(ensureStringExpression);\n}\n\nexport const CronjobSpecificationStruct = object({\n  expression: CronExpressionStruct,\n  request: CronjobRpcRequestStruct,\n});\nexport type CronjobSpecification = Infer<typeof CronjobSpecificationStruct>;\n\n/**\n * Check if the given value is a {@link CronjobSpecification} object.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid {@link CronjobSpecification} object.\n */\nexport function isCronjobSpecification(value: unknown): boolean {\n  try {\n    create(value, CronjobSpecificationStruct);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport const CronjobSpecificationArrayStruct = array(\n  CronjobSpecificationStruct,\n);\n\n/**\n * Check if the given value is an array of {@link CronjobSpecification} objects.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid array of {@link CronjobSpecification} objects.\n */\nexport function isCronjobSpecificationArray(value: unknown): boolean {\n  try {\n    create(value, CronjobSpecificationArrayStruct);\n    return true;\n  } catch {\n    return false;\n  }\n}\n"]}
\ No newline at end of file
diff --git a/dist/chunk-37VHIRUJ.js.map b/dist/chunk-37VHIRUJ.js.map
index 0307f6d55851cc9ba627142bfc2548e4b416a719..cc92acbd998d37f18246969d0d55557ff5765862 100644
--- a/dist/chunk-37VHIRUJ.js.map
+++ b/dist/chunk-37VHIRUJ.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../src/json-rpc.ts"],"names":[],"mappings":";AAAA,SAAS,mBAAmB;AAM5B;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAEP,SAAS,OAAO,SAAS,QAAQ,UAAU,QAAQ,cAAc;AAEjE,IAAM,uBAAuB;AAAA,EAC3B,OAAO,OAAO,GAAG,kBAAkB,CAAC,UAAU;AAC5C,UAAM,YAAY,MAAM,MAAM,GAAG,EAAE,SAAS;AAC5C,QAAI,YAAY,GAAG;AACjB,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT,CAAC;AACH;AAEO,IAAM,mBAAmB;AAAA,EAC9B,OAAO;AAAA,IACL,OAAO,SAAS,QAAQ,CAAC;AAAA,IACzB,OAAO,SAAS,QAAQ,CAAC;AAAA,IACzB,gBAAgB,SAAS,oBAAoB;AAAA,EAC/C,CAAC;AAAA,EACD;AAAA,EACA,CAAC,UAAU;AACT,UAAM,aAAa;AAAA,MACjB,MAAM,UAAU,QACd,MAAM,UAAU,QACf,MAAM,kBAAkB,MAAM,eAAe,SAAS;AAAA,IAC3D;AAEA,QAAI,YAAY;AACd,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AACF;AAYO,SAAS,mBACd,OAEA,cAC6B;AAC7B;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAEO,IAAM,uBAAuB,OAAO;AAAA,EACzC,gBAAgB,SAAS,oBAAoB;AAC/C,CAAC;AAYM,SAAS,uBACd,OAEA,cACiC;AACjC;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAUA,SAAS,mBAAmB,SAAiB;AAE3C,QAAM,UAAU,QAAQ,QAAQ,wBAAwB,MAAM;AAE9D,QAAM,QAAQ,QAAQ,QAAQ,QAAQ,IAAI;AAC1C,SAAO,OAAO,OAAO,GAAG;AAC1B;AAcA,SAAS,mBAAmB,SAAiB,QAAgB;AAE3D,MAAI,YAAY,OAAO,YAAY,QAAQ;AACzC,WAAO;AAAA,EACT;AAEA,QAAM,QAAQ,mBAAmB,OAAO;AACxC,SAAO,MAAM,KAAK,MAAM;AAC1B;AAUO,SAAS,gBACd,SACA,aACA,QACA;AAEA,MAAI,WAAW,YAAY;AACzB,WAAO;AAAA,EACT;AAGA,MACE,QAAQ,gBAAgB;AAAA,IAAK,CAAC,YAC5B,mBAAmB,SAAS,MAAM;AAAA,EACpC,GACA;AACA,WAAO;AAAA,EACT;AAGA,MAAI,gBAAgB,YAAY,WAAW,QAAQ,OAAO;AACxD,WAAO;AAAA,EACT;AAGA,SAAO,QAAQ,gBAAgB,YAAY,QAAQ,QAAQ,KAAK;AAClE;AAUO,SAAS,uBACd,OACuC;AACvC,MAAI,CAAC,iBAAiB,KAAK,GAAG;AAC5B,QAAI,iBAAiB,KAAK,GAAG;AAC3B,YAAM,IAAI,MAAM,4BAA4B,MAAM,MAAM,OAAO,EAAE;AAAA,IACnE;AAEA,UAAM,IAAI,MAAM,4BAA4B;AAAA,EAC9C;AACF","sourcesContent":["import { SubjectType } from '@metamask/permission-controller';\nimport type {\n  AssertionErrorConstructor,\n  Json,\n  JsonRpcSuccess,\n} from '@metamask/utils';\nimport {\n  assertStruct,\n  isJsonRpcFailure,\n  isJsonRpcSuccess,\n} from '@metamask/utils';\nimport type { Infer } from 'superstruct';\nimport { array, boolean, object, optional, refine, string } from 'superstruct';\n\nconst AllowedOriginsStruct = array(\n  refine(string(), 'Allowed origin', (value) => {\n    const wildcards = value.split('*').length - 1;\n    if (wildcards > 2) {\n      return 'No more than two wildcards (\"*\") are allowed in an origin specifier.';\n    }\n\n    return true;\n  }),\n);\n\nexport const RpcOriginsStruct = refine(\n  object({\n    dapps: optional(boolean()),\n    snaps: optional(boolean()),\n    allowedOrigins: optional(AllowedOriginsStruct),\n  }),\n  'RPC origins',\n  (value) => {\n    const hasOrigins = Boolean(\n      value.snaps === true ||\n        value.dapps === true ||\n        (value.allowedOrigins && value.allowedOrigins.length > 0),\n    );\n\n    if (hasOrigins) {\n      return true;\n    }\n\n    return 'Must specify at least one JSON-RPC origin.';\n  },\n);\n\nexport type RpcOrigins = Infer<typeof RpcOriginsStruct>;\n\n/**\n * Asserts that the given value is a valid {@link RpcOrigins} object.\n *\n * @param value - The value to assert.\n * @param ErrorWrapper - An optional error wrapper to use. Defaults to\n * {@link AssertionError}.\n * @throws If the value is not a valid {@link RpcOrigins} object.\n */\nexport function assertIsRpcOrigins(\n  value: unknown,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper?: AssertionErrorConstructor,\n): asserts value is RpcOrigins {\n  assertStruct(\n    value,\n    RpcOriginsStruct,\n    'Invalid JSON-RPC origins',\n    ErrorWrapper,\n  );\n}\n\nexport const KeyringOriginsStruct = object({\n  allowedOrigins: optional(AllowedOriginsStruct),\n});\n\nexport type KeyringOrigins = Infer<typeof KeyringOriginsStruct>;\n\n/**\n * Assert that the given value is a valid {@link KeyringOrigins} object.\n *\n * @param value - The value to assert.\n * @param ErrorWrapper - An optional error wrapper to use. Defaults to\n * {@link AssertionError}.\n * @throws If the value is not a valid {@link KeyringOrigins} object.\n */\nexport function assertIsKeyringOrigins(\n  value: unknown,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper?: AssertionErrorConstructor,\n): asserts value is KeyringOrigins {\n  assertStruct(\n    value,\n    KeyringOriginsStruct,\n    'Invalid keyring origins',\n    ErrorWrapper,\n  );\n}\n\n/**\n * Create regular expression for matching against an origin while allowing wildcards.\n *\n * The \"*\" symbol is treated as a wildcard and will match 0 or more characters.\n *\n * @param matcher - The string to create the regular expression with.\n * @returns The regular expression.\n */\nfunction createOriginRegExp(matcher: string) {\n  // Escape potential Regex characters\n  const escaped = matcher.replace(/[.*+?^${}()|[\\]\\\\]/gu, '\\\\$&');\n  // Support wildcards\n  const regex = escaped.replace(/\\*/gu, '.*');\n  return RegExp(regex, 'u');\n}\n\n/**\n * Check whether an origin is allowed or not using a matcher string.\n *\n * The matcher string may be a specific origin to match or include wildcards.\n * The \"*\" symbol is treated as a wildcard and will match 0 or more characters.\n * Note: this means that https://*metamask.io matches both https://metamask.io\n * and https://snaps.metamask.io.\n *\n * @param matcher - The matcher string.\n * @param origin - The origin.\n * @returns Whether the origin is allowed.\n */\nfunction checkAllowedOrigin(matcher: string, origin: string) {\n  // If the matcher is a single wildcard or identical to the origin we can return true immediately.\n  if (matcher === '*' || matcher === origin) {\n    return true;\n  }\n\n  const regex = createOriginRegExp(matcher);\n  return regex.test(origin);\n}\n\n/**\n * Check if the given origin is allowed by the given JSON-RPC origins object.\n *\n * @param origins - The JSON-RPC origins object.\n * @param subjectType - The type of the origin.\n * @param origin - The origin to check.\n * @returns Whether the origin is allowed.\n */\nexport function isOriginAllowed(\n  origins: RpcOrigins,\n  subjectType: SubjectType,\n  origin: string,\n) {\n  // The MetaMask client is always allowed.\n  if (origin === 'metamask') {\n    return true;\n  }\n\n  // If the origin is in the `allowedOrigins` list, it is allowed.\n  if (\n    origins.allowedOrigins?.some((matcher) =>\n      checkAllowedOrigin(matcher, origin),\n    )\n  ) {\n    return true;\n  }\n\n  // If the origin is a website and `dapps` is true, it is allowed.\n  if (subjectType === SubjectType.Website && origins.dapps) {\n    return true;\n  }\n\n  // If the origin is a snap and `snaps` is true, it is allowed.\n  return Boolean(subjectType === SubjectType.Snap && origins.snaps);\n}\n\n/**\n * Assert that the given value is a successful JSON-RPC response. If the value\n * is not a success response, an error is thrown. If the value is an JSON-RPC\n * error, the error message is included in the thrown error.\n *\n * @param value - The value to check.\n * @throws If the value is not a JSON-RPC success response.\n */\nexport function assertIsJsonRpcSuccess(\n  value: unknown,\n): asserts value is JsonRpcSuccess<Json> {\n  if (!isJsonRpcSuccess(value)) {\n    if (isJsonRpcFailure(value)) {\n      throw new Error(`JSON-RPC request failed: ${value.error.message}`);\n    }\n\n    throw new Error('Invalid JSON-RPC response.');\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"sources":["../src/json-rpc.ts"],"names":[],"mappings":";AAAA,SAAS,mBAAmB;AAM5B;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAEP,SAAS,OAAO,SAAS,QAAQ,UAAU,QAAQ,cAAc;AAEjE,IAAM,uBAAuB;AAAA,EAC3B,OAAO,OAAO,GAAG,kBAAkB,CAAC,UAAU;AAC5C,UAAM,YAAY,MAAM,MAAM,GAAG,EAAE,SAAS;AAC5C,QAAI,YAAY,GAAG;AACjB,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT,CAAC;AACH;AAEO,IAAM,mBAAmB;AAAA,EAC9B,OAAO;AAAA,IACL,OAAO,SAAS,QAAQ,CAAC;AAAA,IACzB,OAAO,SAAS,QAAQ,CAAC;AAAA,IACzB,gBAAgB,SAAS,oBAAoB;AAAA,EAC/C,CAAC;AAAA,EACD;AAAA,EACA,CAAC,UAAU;AACT,UAAM,aAAa;AAAA,MACjB,MAAM,UAAU,QACd,MAAM,UAAU,QACf,MAAM,kBAAkB,MAAM,eAAe,SAAS;AAAA,IAC3D;AAEA,QAAI,YAAY;AACd,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AACF;AAYO,SAAS,mBACd,OAEA,cAC6B;AAC7B;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAEO,IAAM,uBAAuB,OAAO;AAAA,EACzC,gBAAgB,SAAS,oBAAoB;AAC/C,CAAC;AAYM,SAAS,uBACd,OAEA,cACiC;AACjC;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAUA,SAAS,mBAAmB,SAAiB;AAE3C,QAAM,UAAU,QAAQ,QAAQ,wBAAwB,MAAM;AAE9D,QAAM,QAAQ,QAAQ,QAAQ,QAAQ,IAAI;AAC1C,SAAO,OAAO,OAAO,GAAG;AAC1B;AAcA,SAAS,mBAAmB,SAAiB,QAAgB;AAE3D,MAAI,YAAY,OAAO,YAAY,QAAQ;AACzC,WAAO;AAAA,EACT;AAEA,QAAM,QAAQ,mBAAmB,OAAO;AACxC,SAAO,MAAM,KAAK,MAAM;AAC1B;AAUO,SAAS,gBACd,SACA,aACA,QACA;AAEA,MAAI,WAAW,YAAY;AACzB,WAAO;AAAA,EACT;AAGA,MACE,QAAQ,gBAAgB;AAAA,IAAK,CAAC,YAC5B,mBAAmB,SAAS,MAAM;AAAA,EACpC,GACA;AACA,WAAO;AAAA,EACT;AAGA,MAAI,gBAAgB,YAAY,WAAW,QAAQ,OAAO;AACxD,WAAO;AAAA,EACT;AAGA,SAAO,QAAQ,gBAAgB,YAAY,QAAQ,QAAQ,KAAK;AAClE;AAUO,SAAS,uBACd,OACuC;AACvC,MAAI,CAAC,iBAAiB,KAAK,GAAG;AAC5B,QAAI,iBAAiB,KAAK,GAAG;AAC3B,YAAM,IAAI,MAAM,4BAA4B,MAAM,MAAM,OAAO,EAAE;AAAA,IACnE;AAEA,UAAM,IAAI,MAAM,4BAA4B;AAAA,EAC9C;AACF","sourcesContent":["import { SubjectType } from '@metamask/permission-controller';\nimport type {\n  AssertionErrorConstructor,\n  Json,\n  JsonRpcSuccess,\n} from '@metamask/utils';\nimport {\n  assertStruct,\n  isJsonRpcFailure,\n  isJsonRpcSuccess,\n} from '@metamask/utils';\nimport type { Infer } from '@metamask/superstruct';\nimport { array, boolean, object, optional, refine, string } from '@metamask/superstruct';\n\nconst AllowedOriginsStruct = array(\n  refine(string(), 'Allowed origin', (value) => {\n    const wildcards = value.split('*').length - 1;\n    if (wildcards > 2) {\n      return 'No more than two wildcards (\"*\") are allowed in an origin specifier.';\n    }\n\n    return true;\n  }),\n);\n\nexport const RpcOriginsStruct = refine(\n  object({\n    dapps: optional(boolean()),\n    snaps: optional(boolean()),\n    allowedOrigins: optional(AllowedOriginsStruct),\n  }),\n  'RPC origins',\n  (value) => {\n    const hasOrigins = Boolean(\n      value.snaps === true ||\n        value.dapps === true ||\n        (value.allowedOrigins && value.allowedOrigins.length > 0),\n    );\n\n    if (hasOrigins) {\n      return true;\n    }\n\n    return 'Must specify at least one JSON-RPC origin.';\n  },\n);\n\nexport type RpcOrigins = Infer<typeof RpcOriginsStruct>;\n\n/**\n * Asserts that the given value is a valid {@link RpcOrigins} object.\n *\n * @param value - The value to assert.\n * @param ErrorWrapper - An optional error wrapper to use. Defaults to\n * {@link AssertionError}.\n * @throws If the value is not a valid {@link RpcOrigins} object.\n */\nexport function assertIsRpcOrigins(\n  value: unknown,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper?: AssertionErrorConstructor,\n): asserts value is RpcOrigins {\n  assertStruct(\n    value,\n    RpcOriginsStruct,\n    'Invalid JSON-RPC origins',\n    ErrorWrapper,\n  );\n}\n\nexport const KeyringOriginsStruct = object({\n  allowedOrigins: optional(AllowedOriginsStruct),\n});\n\nexport type KeyringOrigins = Infer<typeof KeyringOriginsStruct>;\n\n/**\n * Assert that the given value is a valid {@link KeyringOrigins} object.\n *\n * @param value - The value to assert.\n * @param ErrorWrapper - An optional error wrapper to use. Defaults to\n * {@link AssertionError}.\n * @throws If the value is not a valid {@link KeyringOrigins} object.\n */\nexport function assertIsKeyringOrigins(\n  value: unknown,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper?: AssertionErrorConstructor,\n): asserts value is KeyringOrigins {\n  assertStruct(\n    value,\n    KeyringOriginsStruct,\n    'Invalid keyring origins',\n    ErrorWrapper,\n  );\n}\n\n/**\n * Create regular expression for matching against an origin while allowing wildcards.\n *\n * The \"*\" symbol is treated as a wildcard and will match 0 or more characters.\n *\n * @param matcher - The string to create the regular expression with.\n * @returns The regular expression.\n */\nfunction createOriginRegExp(matcher: string) {\n  // Escape potential Regex characters\n  const escaped = matcher.replace(/[.*+?^${}()|[\\]\\\\]/gu, '\\\\$&');\n  // Support wildcards\n  const regex = escaped.replace(/\\*/gu, '.*');\n  return RegExp(regex, 'u');\n}\n\n/**\n * Check whether an origin is allowed or not using a matcher string.\n *\n * The matcher string may be a specific origin to match or include wildcards.\n * The \"*\" symbol is treated as a wildcard and will match 0 or more characters.\n * Note: this means that https://*metamask.io matches both https://metamask.io\n * and https://snaps.metamask.io.\n *\n * @param matcher - The matcher string.\n * @param origin - The origin.\n * @returns Whether the origin is allowed.\n */\nfunction checkAllowedOrigin(matcher: string, origin: string) {\n  // If the matcher is a single wildcard or identical to the origin we can return true immediately.\n  if (matcher === '*' || matcher === origin) {\n    return true;\n  }\n\n  const regex = createOriginRegExp(matcher);\n  return regex.test(origin);\n}\n\n/**\n * Check if the given origin is allowed by the given JSON-RPC origins object.\n *\n * @param origins - The JSON-RPC origins object.\n * @param subjectType - The type of the origin.\n * @param origin - The origin to check.\n * @returns Whether the origin is allowed.\n */\nexport function isOriginAllowed(\n  origins: RpcOrigins,\n  subjectType: SubjectType,\n  origin: string,\n) {\n  // The MetaMask client is always allowed.\n  if (origin === 'metamask') {\n    return true;\n  }\n\n  // If the origin is in the `allowedOrigins` list, it is allowed.\n  if (\n    origins.allowedOrigins?.some((matcher) =>\n      checkAllowedOrigin(matcher, origin),\n    )\n  ) {\n    return true;\n  }\n\n  // If the origin is a website and `dapps` is true, it is allowed.\n  if (subjectType === SubjectType.Website && origins.dapps) {\n    return true;\n  }\n\n  // If the origin is a snap and `snaps` is true, it is allowed.\n  return Boolean(subjectType === SubjectType.Snap && origins.snaps);\n}\n\n/**\n * Assert that the given value is a successful JSON-RPC response. If the value\n * is not a success response, an error is thrown. If the value is an JSON-RPC\n * error, the error message is included in the thrown error.\n *\n * @param value - The value to check.\n * @throws If the value is not a JSON-RPC success response.\n */\nexport function assertIsJsonRpcSuccess(\n  value: unknown,\n): asserts value is JsonRpcSuccess<Json> {\n  if (!isJsonRpcSuccess(value)) {\n    if (isJsonRpcFailure(value)) {\n      throw new Error(`JSON-RPC request failed: ${value.error.message}`);\n    }\n\n    throw new Error('Invalid JSON-RPC response.');\n  }\n}\n"]}
\ No newline at end of file
diff --git a/dist/chunk-6LOYTBS3.js.map b/dist/chunk-6LOYTBS3.js.map
index 1dc000f46ea5a9a9d19a5980c8dd35700eeaabed..affde50fa3963a1c1a2236cc4ddf41a74aed7267 100644
--- a/dist/chunk-6LOYTBS3.js.map
+++ b/dist/chunk-6LOYTBS3.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../src/namespace.ts"],"names":[],"mappings":";AAEA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAIA,IAAM,iBACX;AAEK,IAAM,mBACX;AAEK,IAAM,wBAAwB;AAS9B,SAAS,aAAa,SAG3B;AACA,QAAM,QAAQ,eAAe,KAAK,OAAO;AACzC,MAAI,CAAC,OAAO,QAAQ;AAClB,UAAM,IAAI,MAAM,mBAAmB;AAAA,EACrC;AAEA,SAAO;AAAA,IACL,WAAW,MAAM,OAAO;AAAA,IACxB,WAAW,MAAM,OAAO;AAAA,EAC1B;AACF;AASO,SAAS,eAAe,WAI7B;AACA,QAAM,QAAQ,iBAAiB,KAAK,SAAS;AAC7C,MAAI,CAAC,OAAO,QAAQ;AAClB,UAAM,IAAI,MAAM,qBAAqB;AAAA,EACvC;AAEA,SAAO;AAAA,IACL,SAAS,MAAM,OAAO;AAAA,IACtB,SAAS,MAAM,OAAO;AAAA,IACtB,OAAO;AAAA,MACL,WAAW,MAAM,OAAO;AAAA,MACxB,WAAW,MAAM,OAAO;AAAA,IAC1B;AAAA,EACF;AACF;AAMO,IAAM,gBAAgB,KAAK,OAAO,GAAG,GAAG,EAAE;AAE1C,IAAM,sBAAsB;AAAA,EACjC;AAAA,EACA,OAAO,EAAE;AACX;AAKO,IAAM,gBAAgB;AAAA,EAC3B;AAAA,EACA;AACF;AAIO,IAAM,kBAAkB,QAAQ,OAAO,GAAG,gBAAgB;AAE1D,IAAM,uBAAuB,MAAM,eAAe;AAClD,IAAM,uBAAuB,QAAQ,OAAO,GAAG,qBAAqB;AAMpE,IAAM,cAAc,OAAO;AAAA,EAChC,IAAI;AAAA,EACJ,MAAM;AACR,CAAC;AAGM,IAAM,kBAAkB,OAAO;AAAA;AAAA;AAAA;AAAA,EAIpC,QAAQ,MAAM,WAAW;AAAA;AAAA;AAAA;AAAA,EAKzB,SAAS,SAAS,MAAM,aAAa,CAAC;AAAA;AAAA;AAAA;AAAA,EAKtC,QAAQ,SAAS,MAAM,aAAa,CAAC;AACvC,CAAC;AAMM,IAAM,oBAAoB,QAAQ,OAAO,GAAG,mBAAmB;AAS/D,SAAS,cAAc,OAAsC;AAClE,SAAO,GAAG,OAAO,iBAAiB;AACpC;AAQO,SAAS,UAAU,OAAkC;AAC1D,SAAO,GAAG,OAAO,aAAa;AAChC;AAQO,SAAS,YAAY,OAAoC;AAC9D,SAAO,GAAG,OAAO,eAAe;AAClC;AAQO,SAAS,iBAAiB,OAAsC;AACrE,SAAO,GAAG,OAAO,oBAAoB;AACvC;AAQO,SAAS,YAAY,OAAoC;AAC9D,SAAO,GAAG,OAAO,eAAe;AAClC","sourcesContent":["import type { AccountId, ChainId } from '@metamask/snaps-sdk';\nimport type { Infer } from 'superstruct';\nimport {\n  array,\n  define,\n  is,\n  object,\n  optional,\n  pattern,\n  size,\n  string,\n} from 'superstruct';\n\nimport type { InferMatching } from './structs';\n\nexport const CHAIN_ID_REGEX =\n  /^(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-a-zA-Z0-9]{1,32})$/u;\n\nexport const ACCOUNT_ID_REGEX =\n  /^(?<chainId>(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-a-zA-Z0-9]{1,32})):(?<accountAddress>[a-zA-Z0-9]{1,64})$/u;\n\nexport const ACCOUNT_ADDRESS_REGEX = /^(?<accountAddress>[a-zA-Z0-9]{1,64})$/u;\n\n/**\n * Parse a chain ID string to an object containing the namespace and reference.\n * This validates the chain ID before parsing it.\n *\n * @param chainId - The chain ID to validate and parse.\n * @returns The parsed chain ID.\n */\nexport function parseChainId(chainId: ChainId): {\n  namespace: NamespaceId;\n  reference: string;\n} {\n  const match = CHAIN_ID_REGEX.exec(chainId);\n  if (!match?.groups) {\n    throw new Error('Invalid chain ID.');\n  }\n\n  return {\n    namespace: match.groups.namespace,\n    reference: match.groups.reference,\n  };\n}\n\n/**\n * Parse an account ID to an object containing the chain, chain ID and address.\n * This validates the account ID before parsing it.\n *\n * @param accountId - The account ID to validate and parse.\n * @returns The parsed account ID.\n */\nexport function parseAccountId(accountId: AccountId): {\n  chain: { namespace: NamespaceId; reference: string };\n  chainId: ChainId;\n  address: string;\n} {\n  const match = ACCOUNT_ID_REGEX.exec(accountId);\n  if (!match?.groups) {\n    throw new Error('Invalid account ID.');\n  }\n\n  return {\n    address: match.groups.accountAddress,\n    chainId: match.groups.chainId as ChainId,\n    chain: {\n      namespace: match.groups.namespace,\n      reference: match.groups.reference,\n    },\n  };\n}\n\n/**\n * A helper struct for a string with a minimum length of 1 and a maximum length\n * of 40.\n */\nexport const LimitedString = size(string(), 1, 40);\n\nexport const ChainIdStringStruct = define<ChainId>(\n  'Chain ID',\n  string().validator,\n);\n\n/**\n * A CAIP-2 chain ID, i.e., a human-readable namespace and reference.\n */\nexport const ChainIdStruct = pattern<ChainId, null>(\n  ChainIdStringStruct,\n  CHAIN_ID_REGEX,\n);\n\nexport type Caip2ChainId = InferMatching<typeof ChainIdStruct, ChainId>;\n\nexport const AccountIdStruct = pattern(string(), ACCOUNT_ID_REGEX);\n\nexport const AccountIdArrayStruct = array(AccountIdStruct);\nexport const AccountAddressStruct = pattern(string(), ACCOUNT_ADDRESS_REGEX);\nexport type AccountAddress = Infer<typeof AccountAddressStruct>;\n\n/**\n * A chain descriptor.\n */\nexport const ChainStruct = object({\n  id: ChainIdStruct,\n  name: LimitedString,\n});\nexport type Chain = Infer<typeof ChainStruct>;\n\nexport const NamespaceStruct = object({\n  /**\n   * A list of supported chains in the namespace.\n   */\n  chains: array(ChainStruct),\n\n  /**\n   * A list of supported RPC methods on the namespace, that a DApp can call.\n   */\n  methods: optional(array(LimitedString)),\n\n  /**\n   * A list of supported RPC events on the namespace, that a DApp can listen to.\n   */\n  events: optional(array(LimitedString)),\n});\nexport type Namespace = Infer<typeof NamespaceStruct>;\n\n/**\n * A CAIP-2 namespace, i.e., the first part of a chain ID.\n */\nexport const NamespaceIdStruct = pattern(string(), /^[-a-z0-9]{3,8}$/u);\nexport type NamespaceId = Infer<typeof NamespaceIdStruct>;\n\n/**\n * Check if the given value is a CAIP-2 namespace ID.\n *\n * @param value - The value to check.\n * @returns Whether the value is a CAIP-2 namespace ID.\n */\nexport function isNamespaceId(value: unknown): value is NamespaceId {\n  return is(value, NamespaceIdStruct);\n}\n\n/**\n * Check if the given value is a CAIP-2 chain ID.\n *\n * @param value - The value to check.\n * @returns Whether the value is a CAIP-2 chain ID.\n */\nexport function isChainId(value: unknown): value is ChainId {\n  return is(value, ChainIdStruct);\n}\n\n/**\n * Check if the given value is a CAIP-10 account ID.\n *\n * @param value - The value to check.\n * @returns Whether the value is a CAIP-10 account ID.\n */\nexport function isAccountId(value: unknown): value is AccountId {\n  return is(value, AccountIdStruct);\n}\n\n/**\n * Check if the given value is an array of CAIP-10 account IDs.\n *\n * @param value - The value to check.\n * @returns Whether the value is an array of CAIP-10 account IDs.\n */\nexport function isAccountIdArray(value: unknown): value is AccountId[] {\n  return is(value, AccountIdArrayStruct);\n}\n\n/**\n * Check if a value is a {@link Namespace}.\n *\n * @param value - The value to validate.\n * @returns True if the value is a valid {@link Namespace}.\n */\nexport function isNamespace(value: unknown): value is Namespace {\n  return is(value, NamespaceStruct);\n}\n"]}
\ No newline at end of file
+{"version":3,"sources":["../src/namespace.ts"],"names":[],"mappings":";AAEA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAIA,IAAM,iBACX;AAEK,IAAM,mBACX;AAEK,IAAM,wBAAwB;AAS9B,SAAS,aAAa,SAG3B;AACA,QAAM,QAAQ,eAAe,KAAK,OAAO;AACzC,MAAI,CAAC,OAAO,QAAQ;AAClB,UAAM,IAAI,MAAM,mBAAmB;AAAA,EACrC;AAEA,SAAO;AAAA,IACL,WAAW,MAAM,OAAO;AAAA,IACxB,WAAW,MAAM,OAAO;AAAA,EAC1B;AACF;AASO,SAAS,eAAe,WAI7B;AACA,QAAM,QAAQ,iBAAiB,KAAK,SAAS;AAC7C,MAAI,CAAC,OAAO,QAAQ;AAClB,UAAM,IAAI,MAAM,qBAAqB;AAAA,EACvC;AAEA,SAAO;AAAA,IACL,SAAS,MAAM,OAAO;AAAA,IACtB,SAAS,MAAM,OAAO;AAAA,IACtB,OAAO;AAAA,MACL,WAAW,MAAM,OAAO;AAAA,MACxB,WAAW,MAAM,OAAO;AAAA,IAC1B;AAAA,EACF;AACF;AAMO,IAAM,gBAAgB,KAAK,OAAO,GAAG,GAAG,EAAE;AAE1C,IAAM,sBAAsB;AAAA,EACjC;AAAA,EACA,OAAO,EAAE;AACX;AAKO,IAAM,gBAAgB;AAAA,EAC3B;AAAA,EACA;AACF;AAIO,IAAM,kBAAkB,QAAQ,OAAO,GAAG,gBAAgB;AAE1D,IAAM,uBAAuB,MAAM,eAAe;AAClD,IAAM,uBAAuB,QAAQ,OAAO,GAAG,qBAAqB;AAMpE,IAAM,cAAc,OAAO;AAAA,EAChC,IAAI;AAAA,EACJ,MAAM;AACR,CAAC;AAGM,IAAM,kBAAkB,OAAO;AAAA;AAAA;AAAA;AAAA,EAIpC,QAAQ,MAAM,WAAW;AAAA;AAAA;AAAA;AAAA,EAKzB,SAAS,SAAS,MAAM,aAAa,CAAC;AAAA;AAAA;AAAA;AAAA,EAKtC,QAAQ,SAAS,MAAM,aAAa,CAAC;AACvC,CAAC;AAMM,IAAM,oBAAoB,QAAQ,OAAO,GAAG,mBAAmB;AAS/D,SAAS,cAAc,OAAsC;AAClE,SAAO,GAAG,OAAO,iBAAiB;AACpC;AAQO,SAAS,UAAU,OAAkC;AAC1D,SAAO,GAAG,OAAO,aAAa;AAChC;AAQO,SAAS,YAAY,OAAoC;AAC9D,SAAO,GAAG,OAAO,eAAe;AAClC;AAQO,SAAS,iBAAiB,OAAsC;AACrE,SAAO,GAAG,OAAO,oBAAoB;AACvC;AAQO,SAAS,YAAY,OAAoC;AAC9D,SAAO,GAAG,OAAO,eAAe;AAClC","sourcesContent":["import type { AccountId, ChainId } from '@metamask/snaps-sdk';\nimport type { Infer } from '@metamask/superstruct';\nimport {\n  array,\n  define,\n  is,\n  object,\n  optional,\n  pattern,\n  size,\n  string,\n} from '@metamask/superstruct';\n\nimport type { InferMatching } from './structs';\n\nexport const CHAIN_ID_REGEX =\n  /^(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-a-zA-Z0-9]{1,32})$/u;\n\nexport const ACCOUNT_ID_REGEX =\n  /^(?<chainId>(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-a-zA-Z0-9]{1,32})):(?<accountAddress>[a-zA-Z0-9]{1,64})$/u;\n\nexport const ACCOUNT_ADDRESS_REGEX = /^(?<accountAddress>[a-zA-Z0-9]{1,64})$/u;\n\n/**\n * Parse a chain ID string to an object containing the namespace and reference.\n * This validates the chain ID before parsing it.\n *\n * @param chainId - The chain ID to validate and parse.\n * @returns The parsed chain ID.\n */\nexport function parseChainId(chainId: ChainId): {\n  namespace: NamespaceId;\n  reference: string;\n} {\n  const match = CHAIN_ID_REGEX.exec(chainId);\n  if (!match?.groups) {\n    throw new Error('Invalid chain ID.');\n  }\n\n  return {\n    namespace: match.groups.namespace,\n    reference: match.groups.reference,\n  };\n}\n\n/**\n * Parse an account ID to an object containing the chain, chain ID and address.\n * This validates the account ID before parsing it.\n *\n * @param accountId - The account ID to validate and parse.\n * @returns The parsed account ID.\n */\nexport function parseAccountId(accountId: AccountId): {\n  chain: { namespace: NamespaceId; reference: string };\n  chainId: ChainId;\n  address: string;\n} {\n  const match = ACCOUNT_ID_REGEX.exec(accountId);\n  if (!match?.groups) {\n    throw new Error('Invalid account ID.');\n  }\n\n  return {\n    address: match.groups.accountAddress,\n    chainId: match.groups.chainId as ChainId,\n    chain: {\n      namespace: match.groups.namespace,\n      reference: match.groups.reference,\n    },\n  };\n}\n\n/**\n * A helper struct for a string with a minimum length of 1 and a maximum length\n * of 40.\n */\nexport const LimitedString = size(string(), 1, 40);\n\nexport const ChainIdStringStruct = define<ChainId>(\n  'Chain ID',\n  string().validator,\n);\n\n/**\n * A CAIP-2 chain ID, i.e., a human-readable namespace and reference.\n */\nexport const ChainIdStruct = pattern<ChainId, null>(\n  ChainIdStringStruct,\n  CHAIN_ID_REGEX,\n);\n\nexport type Caip2ChainId = InferMatching<typeof ChainIdStruct, ChainId>;\n\nexport const AccountIdStruct = pattern(string(), ACCOUNT_ID_REGEX);\n\nexport const AccountIdArrayStruct = array(AccountIdStruct);\nexport const AccountAddressStruct = pattern(string(), ACCOUNT_ADDRESS_REGEX);\nexport type AccountAddress = Infer<typeof AccountAddressStruct>;\n\n/**\n * A chain descriptor.\n */\nexport const ChainStruct = object({\n  id: ChainIdStruct,\n  name: LimitedString,\n});\nexport type Chain = Infer<typeof ChainStruct>;\n\nexport const NamespaceStruct = object({\n  /**\n   * A list of supported chains in the namespace.\n   */\n  chains: array(ChainStruct),\n\n  /**\n   * A list of supported RPC methods on the namespace, that a DApp can call.\n   */\n  methods: optional(array(LimitedString)),\n\n  /**\n   * A list of supported RPC events on the namespace, that a DApp can listen to.\n   */\n  events: optional(array(LimitedString)),\n});\nexport type Namespace = Infer<typeof NamespaceStruct>;\n\n/**\n * A CAIP-2 namespace, i.e., the first part of a chain ID.\n */\nexport const NamespaceIdStruct = pattern(string(), /^[-a-z0-9]{3,8}$/u);\nexport type NamespaceId = Infer<typeof NamespaceIdStruct>;\n\n/**\n * Check if the given value is a CAIP-2 namespace ID.\n *\n * @param value - The value to check.\n * @returns Whether the value is a CAIP-2 namespace ID.\n */\nexport function isNamespaceId(value: unknown): value is NamespaceId {\n  return is(value, NamespaceIdStruct);\n}\n\n/**\n * Check if the given value is a CAIP-2 chain ID.\n *\n * @param value - The value to check.\n * @returns Whether the value is a CAIP-2 chain ID.\n */\nexport function isChainId(value: unknown): value is ChainId {\n  return is(value, ChainIdStruct);\n}\n\n/**\n * Check if the given value is a CAIP-10 account ID.\n *\n * @param value - The value to check.\n * @returns Whether the value is a CAIP-10 account ID.\n */\nexport function isAccountId(value: unknown): value is AccountId {\n  return is(value, AccountIdStruct);\n}\n\n/**\n * Check if the given value is an array of CAIP-10 account IDs.\n *\n * @param value - The value to check.\n * @returns Whether the value is an array of CAIP-10 account IDs.\n */\nexport function isAccountIdArray(value: unknown): value is AccountId[] {\n  return is(value, AccountIdArrayStruct);\n}\n\n/**\n * Check if a value is a {@link Namespace}.\n *\n * @param value - The value to validate.\n * @returns True if the value is a valid {@link Namespace}.\n */\nexport function isNamespace(value: unknown): value is Namespace {\n  return is(value, NamespaceStruct);\n}\n"]}
\ No newline at end of file
diff --git a/dist/chunk-CMOSYNZR.js.map b/dist/chunk-CMOSYNZR.js.map
index 22b53573f3f36f6188cd83ed9a17139cd433afe6..84c783e8a7d742c9a8225fc33a0201f5a552f115 100644
--- a/dist/chunk-CMOSYNZR.js.map
+++ b/dist/chunk-CMOSYNZR.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../src/types.ts"],"names":["NpmSnapFileNames","SnapIdPrefixes","SnapValidationFailureReason","SNAP_STREAM_NAMES"],"mappings":";AACA,SAAS,cAAc,qBAAqB;AAE5C;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,UAAU;AAAA,OACL;AAQA,IAAK,mBAAL,kBAAKA,sBAAL;AACL,EAAAA,kBAAA,iBAAc;AACd,EAAAA,kBAAA,cAAW;AAFD,SAAAA;AAAA,GAAA;AAKL,IAAM,aAAa;AAAA,EACxB;AAAA,IACE,OAAO;AAAA,IACP;AAAA,EACF;AAAA,EACA;AAAA,EACA;AACF;AAIO,IAAM,2BAA2B,KAAK;AAAA,EAC3C,SAAS;AAAA,EACT,MAAM;AAAA,EACN,MAAM,SAAS,KAAK,OAAO,GAAG,GAAG,QAAQ,CAAC;AAAA,EAC1C,YAAY;AAAA,IACV,OAAO;AAAA,MACL,MAAM,KAAK,OAAO,GAAG,GAAG,QAAQ;AAAA,MAChC,KAAK,KAAK,OAAO,GAAG,GAAG,QAAQ;AAAA,IACjC,CAAC;AAAA,EACH;AACF,CAAC;AAWM,SAAS,qBACd,OAC6B;AAC7B,SAAO,GAAG,OAAO,wBAAwB;AAC3C;AAQO,SAAS,2BACd,OACqC;AACrC;AAAA,IACE;AAAA,IACA;AAAA,IACA,IAAI,gCAA4B;AAAA,EAClC;AACF;AAuCO,IAAK,iBAAL,kBAAKC,oBAAL;AACL,EAAAA,gBAAA,SAAM;AACN,EAAAA,gBAAA,WAAQ;AAFE,SAAAA;AAAA,GAAA;AAUL,IAAK,8BAAL,kBAAKC,iCAAL;AACL,EAAAA,6BAAA,kBAAe;AACf,EAAAA,6BAAA,qBAAkB;AAClB,EAAAA,6BAAA,wBAAqB;AACrB,EAAAA,6BAAA,oBAAiB;AAJP,SAAAA;AAAA,GAAA;AAQL,IAAK,oBAAL,kBAAKC,uBAAL;AACL,EAAAA,mBAAA,cAAW;AACX,EAAAA,mBAAA,aAAU;AAFA,SAAAA;AAAA,GAAA;AAwBL,IAAM,MAAM,CAAC,OAAwB,CAAC,MAC3C,OAAO,MAAM,CAAC,OAAO,GAAG,SAAS,GAAG,CAAC,CAAC,GAAG,OAAO,CAAC,UAAU;AACzD,MAAI;AACF,UAAM,MAAM,IAAI,IAAI,KAAK;AAEzB,UAAM,YAAY,KAAK,IAAI;AAC3B,sBAAkB,KAAK,SAAS;AAChC,WAAO;AAAA,EACT,QAAQ;AACN,WAAO,sBAAsB,MAAM,SAAS,CAAC;AAAA,EAC/C;AACF,CAAC;AASI,SAAS,WACd,KACA,OAAwB,CAAC,GACJ;AACrB,SAAO,GAAG,KAAK,IAAI,IAAI,CAAC;AAC1B;AAGO,IAAM,6BAA6B","sourcesContent":["import type { Json } from '@metamask/utils';\nimport { assertStruct, VersionStruct } from '@metamask/utils';\nimport type { Infer, Struct } from 'superstruct';\nimport {\n  instance,\n  is,\n  object,\n  optional,\n  pattern,\n  refine,\n  size,\n  string,\n  type,\n  union,\n  assert as assertSuperstruct,\n} from 'superstruct';\n\nimport type { SnapCaveatType } from './caveats';\nimport type { SnapFunctionExports, SnapRpcHookArgs } from './handlers';\nimport type { LocalizationFile } from './localization';\nimport type { SnapManifest } from './manifest';\nimport type { VirtualFile } from './virtual-file';\n\nexport enum NpmSnapFileNames {\n  PackageJson = 'package.json',\n  Manifest = 'snap.manifest.json',\n}\n\nexport const NameStruct = size(\n  pattern(\n    string(),\n    /^(?:@[a-z0-9-*~][a-z0-9-*._~]*\\/)?[a-z0-9-~][a-z0-9-._~]*$/u,\n  ),\n  1,\n  214,\n);\n\n// Note we use `type` instead of `object` here, because the latter does not\n// allow unknown keys.\nexport const NpmSnapPackageJsonStruct = type({\n  version: VersionStruct,\n  name: NameStruct,\n  main: optional(size(string(), 1, Infinity)),\n  repository: optional(\n    object({\n      type: size(string(), 1, Infinity),\n      url: size(string(), 1, Infinity),\n    }),\n  ),\n});\n\nexport type NpmSnapPackageJson = Infer<typeof NpmSnapPackageJsonStruct> &\n  Record<string, any>;\n\n/**\n * Check if the given value is a valid {@link NpmSnapPackageJson} object.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid {@link NpmSnapPackageJson} object.\n */\nexport function isNpmSnapPackageJson(\n  value: unknown,\n): value is NpmSnapPackageJson {\n  return is(value, NpmSnapPackageJsonStruct);\n}\n\n/**\n * Asserts that the given value is a valid {@link NpmSnapPackageJson} object.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid {@link NpmSnapPackageJson} object.\n */\nexport function assertIsNpmSnapPackageJson(\n  value: unknown,\n): asserts value is NpmSnapPackageJson {\n  assertStruct(\n    value,\n    NpmSnapPackageJsonStruct,\n    `\"${NpmSnapFileNames.PackageJson}\" is invalid`,\n  );\n}\n\n/**\n * An object for storing parsed but unvalidated Snap file contents.\n */\nexport type UnvalidatedSnapFiles = {\n  manifest?: VirtualFile<Json>;\n  packageJson?: VirtualFile<Json>;\n  sourceCode?: VirtualFile;\n  svgIcon?: VirtualFile;\n  auxiliaryFiles: VirtualFile[];\n  localizationFiles: VirtualFile[];\n};\n\n/**\n * An object for storing the contents of Snap files that have passed JSON\n * Schema validation, or are non-empty if they are strings.\n */\nexport type SnapFiles = {\n  manifest: VirtualFile<SnapManifest>;\n  packageJson: VirtualFile<NpmSnapPackageJson>;\n  sourceCode: VirtualFile;\n  svgIcon?: VirtualFile;\n  auxiliaryFiles: VirtualFile[];\n  localizationFiles: VirtualFile<LocalizationFile>[];\n};\n\n/**\n * A subset of snap files extracted from a fetched snap.\n */\nexport type FetchedSnapFiles = Pick<\n  SnapFiles,\n  'manifest' | 'sourceCode' | 'svgIcon' | 'auxiliaryFiles' | 'localizationFiles'\n>;\n\n/**\n * The possible prefixes for snap ids.\n */\n/* eslint-disable @typescript-eslint/naming-convention */\nexport enum SnapIdPrefixes {\n  npm = 'npm:',\n  local = 'local:',\n}\n/* eslint-enable @typescript-eslint/naming-convention */\n\n/**\n * Snap validation failure reason codes that are programmatically fixable\n * if validation occurs during development.\n */\nexport enum SnapValidationFailureReason {\n  NameMismatch = '\"name\" field mismatch',\n  VersionMismatch = '\"version\" field mismatch',\n  RepositoryMismatch = '\"repository\" field mismatch',\n  ShasumMismatch = '\"shasum\" field mismatch',\n}\n\n/* eslint-disable @typescript-eslint/naming-convention */\nexport enum SNAP_STREAM_NAMES {\n  JSON_RPC = 'jsonRpc',\n  COMMAND = 'command',\n}\n/* eslint-enable @typescript-eslint/naming-convention */\n\n// The snap is the callee\nexport type SnapRpcHook = (options: SnapRpcHookArgs) => Promise<unknown>;\n\ntype ObjectParameters<\n  Type extends Record<string, (...args: any[]) => unknown>,\n> = Parameters<Type[keyof Type]>;\n\nexport type SnapExportsParameters = ObjectParameters<SnapFunctionExports>;\n\ntype UriOptions<Type extends string> = {\n  protocol?: Struct<Type>;\n  hash?: Struct<Type>;\n  port?: Struct<Type>;\n  hostname?: Struct<Type>;\n  pathname?: Struct<Type>;\n  search?: Struct<Type>;\n};\n\nexport const uri = (opts: UriOptions<any> = {}) =>\n  refine(union([string(), instance(URL)]), 'uri', (value) => {\n    try {\n      const url = new URL(value);\n\n      const UrlStruct = type(opts);\n      assertSuperstruct(url, UrlStruct);\n      return true;\n    } catch {\n      return `Expected URL, got \"${value.toString()}\".`;\n    }\n  });\n\n/**\n * Returns whether a given value is a valid URL.\n *\n * @param url - The value to check.\n * @param opts - Optional constraints for url checking.\n * @returns Whether `url` is valid URL or not.\n */\nexport function isValidUrl(\n  url: unknown,\n  opts: UriOptions<any> = {},\n): url is string | URL {\n  return is(url, uri(opts));\n}\n\n// redefining here to avoid circular dependency\nexport const WALLET_SNAP_PERMISSION_KEY = 'wallet_snap';\n\nexport type SnapsPermissionRequest = {\n  [WALLET_SNAP_PERMISSION_KEY]: {\n    caveats: [\n      {\n        type: SnapCaveatType.SnapIds;\n        value: Record<string, Json>;\n      },\n    ];\n  };\n};\n"]}
\ No newline at end of file
+{"version":3,"sources":["../src/types.ts"],"names":["NpmSnapFileNames","SnapIdPrefixes","SnapValidationFailureReason","SNAP_STREAM_NAMES"],"mappings":";AACA,SAAS,cAAc,qBAAqB;AAE5C;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,UAAU;AAAA,OACL;AAQA,IAAK,mBAAL,kBAAKA,sBAAL;AACL,EAAAA,kBAAA,iBAAc;AACd,EAAAA,kBAAA,cAAW;AAFD,SAAAA;AAAA,GAAA;AAKL,IAAM,aAAa;AAAA,EACxB;AAAA,IACE,OAAO;AAAA,IACP;AAAA,EACF;AAAA,EACA;AAAA,EACA;AACF;AAIO,IAAM,2BAA2B,KAAK;AAAA,EAC3C,SAAS;AAAA,EACT,MAAM;AAAA,EACN,MAAM,SAAS,KAAK,OAAO,GAAG,GAAG,QAAQ,CAAC;AAAA,EAC1C,YAAY;AAAA,IACV,OAAO;AAAA,MACL,MAAM,KAAK,OAAO,GAAG,GAAG,QAAQ;AAAA,MAChC,KAAK,KAAK,OAAO,GAAG,GAAG,QAAQ;AAAA,IACjC,CAAC;AAAA,EACH;AACF,CAAC;AAWM,SAAS,qBACd,OAC6B;AAC7B,SAAO,GAAG,OAAO,wBAAwB;AAC3C;AAQO,SAAS,2BACd,OACqC;AACrC;AAAA,IACE;AAAA,IACA;AAAA,IACA,IAAI,gCAA4B;AAAA,EAClC;AACF;AAuCO,IAAK,iBAAL,kBAAKC,oBAAL;AACL,EAAAA,gBAAA,SAAM;AACN,EAAAA,gBAAA,WAAQ;AAFE,SAAAA;AAAA,GAAA;AAUL,IAAK,8BAAL,kBAAKC,iCAAL;AACL,EAAAA,6BAAA,kBAAe;AACf,EAAAA,6BAAA,qBAAkB;AAClB,EAAAA,6BAAA,wBAAqB;AACrB,EAAAA,6BAAA,oBAAiB;AAJP,SAAAA;AAAA,GAAA;AAQL,IAAK,oBAAL,kBAAKC,uBAAL;AACL,EAAAA,mBAAA,cAAW;AACX,EAAAA,mBAAA,aAAU;AAFA,SAAAA;AAAA,GAAA;AAwBL,IAAM,MAAM,CAAC,OAAwB,CAAC,MAC3C,OAAO,MAAM,CAAC,OAAO,GAAG,SAAS,GAAG,CAAC,CAAC,GAAG,OAAO,CAAC,UAAU;AACzD,MAAI;AACF,UAAM,MAAM,IAAI,IAAI,KAAK;AAEzB,UAAM,YAAY,KAAK,IAAI;AAC3B,sBAAkB,KAAK,SAAS;AAChC,WAAO;AAAA,EACT,QAAQ;AACN,WAAO,sBAAsB,MAAM,SAAS,CAAC;AAAA,EAC/C;AACF,CAAC;AASI,SAAS,WACd,KACA,OAAwB,CAAC,GACJ;AACrB,SAAO,GAAG,KAAK,IAAI,IAAI,CAAC;AAC1B;AAGO,IAAM,6BAA6B","sourcesContent":["import type { Json } from '@metamask/utils';\nimport { assertStruct, VersionStruct } from '@metamask/utils';\nimport type { Infer, Struct } from '@metamask/superstruct';\nimport {\n  instance,\n  is,\n  object,\n  optional,\n  pattern,\n  refine,\n  size,\n  string,\n  type,\n  union,\n  assert as assertSuperstruct,\n} from '@metamask/superstruct';\n\nimport type { SnapCaveatType } from './caveats';\nimport type { SnapFunctionExports, SnapRpcHookArgs } from './handlers';\nimport type { LocalizationFile } from './localization';\nimport type { SnapManifest } from './manifest';\nimport type { VirtualFile } from './virtual-file';\n\nexport enum NpmSnapFileNames {\n  PackageJson = 'package.json',\n  Manifest = 'snap.manifest.json',\n}\n\nexport const NameStruct = size(\n  pattern(\n    string(),\n    /^(?:@[a-z0-9-*~][a-z0-9-*._~]*\\/)?[a-z0-9-~][a-z0-9-._~]*$/u,\n  ),\n  1,\n  214,\n);\n\n// Note we use `type` instead of `object` here, because the latter does not\n// allow unknown keys.\nexport const NpmSnapPackageJsonStruct = type({\n  version: VersionStruct,\n  name: NameStruct,\n  main: optional(size(string(), 1, Infinity)),\n  repository: optional(\n    object({\n      type: size(string(), 1, Infinity),\n      url: size(string(), 1, Infinity),\n    }),\n  ),\n});\n\nexport type NpmSnapPackageJson = Infer<typeof NpmSnapPackageJsonStruct> &\n  Record<string, any>;\n\n/**\n * Check if the given value is a valid {@link NpmSnapPackageJson} object.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid {@link NpmSnapPackageJson} object.\n */\nexport function isNpmSnapPackageJson(\n  value: unknown,\n): value is NpmSnapPackageJson {\n  return is(value, NpmSnapPackageJsonStruct);\n}\n\n/**\n * Asserts that the given value is a valid {@link NpmSnapPackageJson} object.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid {@link NpmSnapPackageJson} object.\n */\nexport function assertIsNpmSnapPackageJson(\n  value: unknown,\n): asserts value is NpmSnapPackageJson {\n  assertStruct(\n    value,\n    NpmSnapPackageJsonStruct,\n    `\"${NpmSnapFileNames.PackageJson}\" is invalid`,\n  );\n}\n\n/**\n * An object for storing parsed but unvalidated Snap file contents.\n */\nexport type UnvalidatedSnapFiles = {\n  manifest?: VirtualFile<Json>;\n  packageJson?: VirtualFile<Json>;\n  sourceCode?: VirtualFile;\n  svgIcon?: VirtualFile;\n  auxiliaryFiles: VirtualFile[];\n  localizationFiles: VirtualFile[];\n};\n\n/**\n * An object for storing the contents of Snap files that have passed JSON\n * Schema validation, or are non-empty if they are strings.\n */\nexport type SnapFiles = {\n  manifest: VirtualFile<SnapManifest>;\n  packageJson: VirtualFile<NpmSnapPackageJson>;\n  sourceCode: VirtualFile;\n  svgIcon?: VirtualFile;\n  auxiliaryFiles: VirtualFile[];\n  localizationFiles: VirtualFile<LocalizationFile>[];\n};\n\n/**\n * A subset of snap files extracted from a fetched snap.\n */\nexport type FetchedSnapFiles = Pick<\n  SnapFiles,\n  'manifest' | 'sourceCode' | 'svgIcon' | 'auxiliaryFiles' | 'localizationFiles'\n>;\n\n/**\n * The possible prefixes for snap ids.\n */\n/* eslint-disable @typescript-eslint/naming-convention */\nexport enum SnapIdPrefixes {\n  npm = 'npm:',\n  local = 'local:',\n}\n/* eslint-enable @typescript-eslint/naming-convention */\n\n/**\n * Snap validation failure reason codes that are programmatically fixable\n * if validation occurs during development.\n */\nexport enum SnapValidationFailureReason {\n  NameMismatch = '\"name\" field mismatch',\n  VersionMismatch = '\"version\" field mismatch',\n  RepositoryMismatch = '\"repository\" field mismatch',\n  ShasumMismatch = '\"shasum\" field mismatch',\n}\n\n/* eslint-disable @typescript-eslint/naming-convention */\nexport enum SNAP_STREAM_NAMES {\n  JSON_RPC = 'jsonRpc',\n  COMMAND = 'command',\n}\n/* eslint-enable @typescript-eslint/naming-convention */\n\n// The snap is the callee\nexport type SnapRpcHook = (options: SnapRpcHookArgs) => Promise<unknown>;\n\ntype ObjectParameters<\n  Type extends Record<string, (...args: any[]) => unknown>,\n> = Parameters<Type[keyof Type]>;\n\nexport type SnapExportsParameters = ObjectParameters<SnapFunctionExports>;\n\ntype UriOptions<Type extends string> = {\n  protocol?: Struct<Type>;\n  hash?: Struct<Type>;\n  port?: Struct<Type>;\n  hostname?: Struct<Type>;\n  pathname?: Struct<Type>;\n  search?: Struct<Type>;\n};\n\nexport const uri = (opts: UriOptions<any> = {}) =>\n  refine(union([string(), instance(URL)]), 'uri', (value) => {\n    try {\n      const url = new URL(value);\n\n      const UrlStruct = type(opts);\n      assertSuperstruct(url, UrlStruct);\n      return true;\n    } catch {\n      return `Expected URL, got \"${value.toString()}\".`;\n    }\n  });\n\n/**\n * Returns whether a given value is a valid URL.\n *\n * @param url - The value to check.\n * @param opts - Optional constraints for url checking.\n * @returns Whether `url` is valid URL or not.\n */\nexport function isValidUrl(\n  url: unknown,\n  opts: UriOptions<any> = {},\n): url is string | URL {\n  return is(url, uri(opts));\n}\n\n// redefining here to avoid circular dependency\nexport const WALLET_SNAP_PERMISSION_KEY = 'wallet_snap';\n\nexport type SnapsPermissionRequest = {\n  [WALLET_SNAP_PERMISSION_KEY]: {\n    caveats: [\n      {\n        type: SnapCaveatType.SnapIds;\n        value: Record<string, Json>;\n      },\n    ];\n  };\n};\n"]}
\ No newline at end of file
diff --git a/dist/chunk-EA2FOAEG.mjs.map b/dist/chunk-EA2FOAEG.mjs.map
index 3adeaad438828651cc310b1e083d5d2621ba2dd0..1691a2a3457b49ca2b255df881915dbd86e08d84 100644
--- a/dist/chunk-EA2FOAEG.mjs.map
+++ b/dist/chunk-EA2FOAEG.mjs.map
@@ -1 +1 @@
-{"version":3,"sources":["../src/cronjob.ts"],"sourcesContent":["import {\n  JsonRpcIdStruct,\n  JsonRpcParamsStruct,\n  JsonRpcVersionStruct,\n} from '@metamask/utils';\nimport { parseExpression } from 'cron-parser';\nimport type { Infer } from 'superstruct';\nimport { array, create, object, optional, refine, string } from 'superstruct';\n\nexport const CronjobRpcRequestStruct = object({\n  jsonrpc: optional(JsonRpcVersionStruct),\n  id: optional(JsonRpcIdStruct),\n  method: string(),\n  params: optional(JsonRpcParamsStruct),\n});\n\nexport type CronjobRpcRequest = Infer<typeof CronjobRpcRequestStruct>;\n\nexport const CronExpressionStruct = refine(\n  string(),\n  'CronExpression',\n  (value) => {\n    try {\n      parseExpression(value);\n      return true;\n    } catch {\n      return false;\n    }\n  },\n);\n\nexport type CronExpression = Infer<typeof CronExpressionStruct>;\n\n/**\n * Parses a cron expression.\n *\n * @param expression - Expression to parse.\n * @returns A CronExpression class instance.\n */\nexport function parseCronExpression(expression: string | object) {\n  const ensureStringExpression = create(expression, CronExpressionStruct);\n  return parseExpression(ensureStringExpression);\n}\n\nexport const CronjobSpecificationStruct = object({\n  expression: CronExpressionStruct,\n  request: CronjobRpcRequestStruct,\n});\nexport type CronjobSpecification = Infer<typeof CronjobSpecificationStruct>;\n\n/**\n * Check if the given value is a {@link CronjobSpecification} object.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid {@link CronjobSpecification} object.\n */\nexport function isCronjobSpecification(value: unknown): boolean {\n  try {\n    create(value, CronjobSpecificationStruct);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport const CronjobSpecificationArrayStruct = array(\n  CronjobSpecificationStruct,\n);\n\n/**\n * Check if the given value is an array of {@link CronjobSpecification} objects.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid array of {@link CronjobSpecification} objects.\n */\nexport function isCronjobSpecificationArray(value: unknown): boolean {\n  try {\n    create(value, CronjobSpecificationArrayStruct);\n    return true;\n  } catch {\n    return false;\n  }\n}\n"],"mappings":";AAAA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,OACK;AACP,SAAS,uBAAuB;AAEhC,SAAS,OAAO,QAAQ,QAAQ,UAAU,QAAQ,cAAc;AAEzD,IAAM,0BAA0B,OAAO;AAAA,EAC5C,SAAS,SAAS,oBAAoB;AAAA,EACtC,IAAI,SAAS,eAAe;AAAA,EAC5B,QAAQ,OAAO;AAAA,EACf,QAAQ,SAAS,mBAAmB;AACtC,CAAC;AAIM,IAAM,uBAAuB;AAAA,EAClC,OAAO;AAAA,EACP;AAAA,EACA,CAAC,UAAU;AACT,QAAI;AACF,sBAAgB,KAAK;AACrB,aAAO;AAAA,IACT,QAAQ;AACN,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAUO,SAAS,oBAAoB,YAA6B;AAC/D,QAAM,yBAAyB,OAAO,YAAY,oBAAoB;AACtE,SAAO,gBAAgB,sBAAsB;AAC/C;AAEO,IAAM,6BAA6B,OAAO;AAAA,EAC/C,YAAY;AAAA,EACZ,SAAS;AACX,CAAC;AASM,SAAS,uBAAuB,OAAyB;AAC9D,MAAI;AACF,WAAO,OAAO,0BAA0B;AACxC,WAAO;AAAA,EACT,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAEO,IAAM,kCAAkC;AAAA,EAC7C;AACF;AAQO,SAAS,4BAA4B,OAAyB;AACnE,MAAI;AACF,WAAO,OAAO,+BAA+B;AAC7C,WAAO;AAAA,EACT,QAAQ;AACN,WAAO;AAAA,EACT;AACF;","names":[]}
\ No newline at end of file
+{"version":3,"sources":["../src/cronjob.ts"],"sourcesContent":["import {\n  JsonRpcIdStruct,\n  JsonRpcParamsStruct,\n  JsonRpcVersionStruct,\n} from '@metamask/utils';\nimport { parseExpression } from 'cron-parser';\nimport type { Infer } from '@metamask/superstruct';\nimport { array, create, object, optional, refine, string } from '@metamask/superstruct';\n\nexport const CronjobRpcRequestStruct = object({\n  jsonrpc: optional(JsonRpcVersionStruct),\n  id: optional(JsonRpcIdStruct),\n  method: string(),\n  params: optional(JsonRpcParamsStruct),\n});\n\nexport type CronjobRpcRequest = Infer<typeof CronjobRpcRequestStruct>;\n\nexport const CronExpressionStruct = refine(\n  string(),\n  'CronExpression',\n  (value) => {\n    try {\n      parseExpression(value);\n      return true;\n    } catch {\n      return false;\n    }\n  },\n);\n\nexport type CronExpression = Infer<typeof CronExpressionStruct>;\n\n/**\n * Parses a cron expression.\n *\n * @param expression - Expression to parse.\n * @returns A CronExpression class instance.\n */\nexport function parseCronExpression(expression: string | object) {\n  const ensureStringExpression = create(expression, CronExpressionStruct);\n  return parseExpression(ensureStringExpression);\n}\n\nexport const CronjobSpecificationStruct = object({\n  expression: CronExpressionStruct,\n  request: CronjobRpcRequestStruct,\n});\nexport type CronjobSpecification = Infer<typeof CronjobSpecificationStruct>;\n\n/**\n * Check if the given value is a {@link CronjobSpecification} object.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid {@link CronjobSpecification} object.\n */\nexport function isCronjobSpecification(value: unknown): boolean {\n  try {\n    create(value, CronjobSpecificationStruct);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport const CronjobSpecificationArrayStruct = array(\n  CronjobSpecificationStruct,\n);\n\n/**\n * Check if the given value is an array of {@link CronjobSpecification} objects.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid array of {@link CronjobSpecification} objects.\n */\nexport function isCronjobSpecificationArray(value: unknown): boolean {\n  try {\n    create(value, CronjobSpecificationArrayStruct);\n    return true;\n  } catch {\n    return false;\n  }\n}\n"],"mappings":";AAAA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,OACK;AACP,SAAS,uBAAuB;AAEhC,SAAS,OAAO,QAAQ,QAAQ,UAAU,QAAQ,cAAc;AAEzD,IAAM,0BAA0B,OAAO;AAAA,EAC5C,SAAS,SAAS,oBAAoB;AAAA,EACtC,IAAI,SAAS,eAAe;AAAA,EAC5B,QAAQ,OAAO;AAAA,EACf,QAAQ,SAAS,mBAAmB;AACtC,CAAC;AAIM,IAAM,uBAAuB;AAAA,EAClC,OAAO;AAAA,EACP;AAAA,EACA,CAAC,UAAU;AACT,QAAI;AACF,sBAAgB,KAAK;AACrB,aAAO;AAAA,IACT,QAAQ;AACN,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAUO,SAAS,oBAAoB,YAA6B;AAC/D,QAAM,yBAAyB,OAAO,YAAY,oBAAoB;AACtE,SAAO,gBAAgB,sBAAsB;AAC/C;AAEO,IAAM,6BAA6B,OAAO;AAAA,EAC/C,YAAY;AAAA,EACZ,SAAS;AACX,CAAC;AASM,SAAS,uBAAuB,OAAyB;AAC9D,MAAI;AACF,WAAO,OAAO,0BAA0B;AACxC,WAAO;AAAA,EACT,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAEO,IAAM,kCAAkC;AAAA,EAC7C;AACF;AAQO,SAAS,4BAA4B,OAAyB;AACnE,MAAI;AACF,WAAO,OAAO,+BAA+B;AAC7C,WAAO;AAAA,EACT,QAAQ;AACN,WAAO;AAAA,EACT;AACF;","names":[]}
\ No newline at end of file
diff --git a/dist/chunk-EXEEDJ6N.mjs.map b/dist/chunk-EXEEDJ6N.mjs.map
index b8d03c6d15edaae1badb0358c2b528c4308fc54b..6dc21bd6f368c78e657052012e043221a90602e5 100644
--- a/dist/chunk-EXEEDJ6N.mjs.map
+++ b/dist/chunk-EXEEDJ6N.mjs.map
@@ -1 +1 @@
-{"version":3,"sources":["../src/manifest/validation.ts"],"sourcesContent":["import type { SupportedCurve } from '@metamask/key-tree';\nimport { isValidBIP32PathSegment } from '@metamask/key-tree';\nimport type { EmptyObject, InitialPermissions } from '@metamask/snaps-sdk';\nimport {\n  assertStruct,\n  ChecksumStruct,\n  VersionStruct,\n  isValidSemVerRange,\n  inMilliseconds,\n  Duration,\n} from '@metamask/utils';\nimport type { Describe, Infer, Struct } from 'superstruct';\nimport {\n  array,\n  boolean,\n  create,\n  enums,\n  integer,\n  is,\n  literal,\n  object,\n  optional,\n  refine,\n  record,\n  size,\n  string,\n  type,\n  union,\n  intersection,\n} from 'superstruct';\n\nimport { isEqual } from '../array';\nimport { CronjobSpecificationArrayStruct } from '../cronjob';\nimport { SIP_6_MAGIC_VALUE, STATE_ENCRYPTION_MAGIC_VALUE } from '../entropy';\nimport { KeyringOriginsStruct, RpcOriginsStruct } from '../json-rpc';\nimport { ChainIdStruct } from '../namespace';\nimport { SnapIdStruct } from '../snaps';\nimport { mergeStructs, type InferMatching } from '../structs';\nimport { NameStruct, NpmSnapFileNames, uri } from '../types';\n\n// BIP-43 purposes that cannot be used for entropy derivation. These are in the\n// string form, ending with `'`.\nconst FORBIDDEN_PURPOSES: string[] = [\n  SIP_6_MAGIC_VALUE,\n  STATE_ENCRYPTION_MAGIC_VALUE,\n];\n\nexport const FORBIDDEN_COIN_TYPES: number[] = [60];\nconst FORBIDDEN_PATHS: string[][] = FORBIDDEN_COIN_TYPES.map((coinType) => [\n  'm',\n  \"44'\",\n  `${coinType}'`,\n]);\n\nexport const Bip32PathStruct = refine(\n  array(string()),\n  'BIP-32 path',\n  (path: string[]) => {\n    if (path.length === 0) {\n      return 'Path must be a non-empty BIP-32 derivation path array';\n    }\n\n    if (path[0] !== 'm') {\n      return 'Path must start with \"m\".';\n    }\n\n    if (path.length < 3) {\n      return 'Paths must have a length of at least three.';\n    }\n\n    if (path.slice(1).some((part) => !isValidBIP32PathSegment(part))) {\n      return 'Path must be a valid BIP-32 derivation path array.';\n    }\n\n    if (FORBIDDEN_PURPOSES.includes(path[1])) {\n      return `The purpose \"${path[1]}\" is not allowed for entropy derivation.`;\n    }\n\n    if (\n      FORBIDDEN_PATHS.some((forbiddenPath) =>\n        isEqual(path.slice(0, forbiddenPath.length), forbiddenPath),\n      )\n    ) {\n      return `The path \"${path.join(\n        '/',\n      )}\" is not allowed for entropy derivation.`;\n    }\n\n    return true;\n  },\n);\n\nexport const bip32entropy = <\n  Type extends { path: string[]; curve: string },\n  Schema,\n>(\n  struct: Struct<Type, Schema>,\n) =>\n  refine(struct, 'BIP-32 entropy', (value) => {\n    if (\n      value.curve === 'ed25519' &&\n      value.path.slice(1).some((part) => !part.endsWith(\"'\"))\n    ) {\n      return 'Ed25519 does not support unhardened paths.';\n    }\n\n    return true;\n  });\n\nexport const CurveStruct: Describe<SupportedCurve> = enums([\n  'ed25519',\n  'secp256k1',\n  'ed25519Bip32',\n]);\n\n// Used outside @metamask/snap-utils\nexport const Bip32EntropyStruct = bip32entropy(\n  type({\n    path: Bip32PathStruct,\n    curve: CurveStruct,\n  }),\n);\n\nexport type Bip32Entropy = Infer<typeof Bip32EntropyStruct>;\n\nexport const SnapGetBip32EntropyPermissionsStruct = size(\n  array(Bip32EntropyStruct),\n  1,\n  Infinity,\n);\n\nexport const SemVerRangeStruct = refine(string(), 'SemVer range', (value) => {\n  if (isValidSemVerRange(value)) {\n    return true;\n  }\n  return 'Expected a valid SemVer range.';\n});\n\nexport const SnapIdsStruct = refine(\n  record(SnapIdStruct, object({ version: optional(SemVerRangeStruct) })),\n  'SnapIds',\n  (value) => {\n    if (Object.keys(value).length === 0) {\n      return false;\n    }\n\n    return true;\n  },\n);\n\nexport type SnapIds = Infer<typeof SnapIdsStruct>;\n\nexport const ChainIdsStruct = size(array(ChainIdStruct), 1, Infinity);\n\nexport const LookupMatchersStruct = union([\n  object({\n    tlds: size(array(string()), 1, Infinity),\n  }),\n  object({\n    schemes: size(array(string()), 1, Infinity),\n  }),\n  object({\n    tlds: size(array(string()), 1, Infinity),\n    schemes: size(array(string()), 1, Infinity),\n  }),\n]);\n\nexport const MINIMUM_REQUEST_TIMEOUT = inMilliseconds(5, Duration.Second);\nexport const MAXIMUM_REQUEST_TIMEOUT = inMilliseconds(3, Duration.Minute);\n\nexport const MaxRequestTimeStruct = size(\n  integer(),\n  MINIMUM_REQUEST_TIMEOUT,\n  MAXIMUM_REQUEST_TIMEOUT,\n);\n\n// Utility type to union with for all handler structs\nexport const HandlerCaveatsStruct = object({\n  maxRequestTime: optional(MaxRequestTimeStruct),\n});\n\nexport type HandlerCaveats = Infer<typeof HandlerCaveatsStruct>;\n\nexport const EmptyObjectStruct = object<EmptyObject>({}) as unknown as Struct<\n  EmptyObject,\n  null\n>;\n\n/* eslint-disable @typescript-eslint/naming-convention */\nexport const PermissionsStruct: Describe<InitialPermissions> = type({\n  'endowment:cronjob': optional(\n    mergeStructs(\n      HandlerCaveatsStruct,\n      object({ jobs: CronjobSpecificationArrayStruct }),\n    ),\n  ),\n  'endowment:ethereum-provider': optional(EmptyObjectStruct),\n  'endowment:keyring': optional(\n    mergeStructs(HandlerCaveatsStruct, KeyringOriginsStruct),\n  ),\n  'endowment:lifecycle-hooks': optional(HandlerCaveatsStruct),\n  'endowment:name-lookup': optional(\n    mergeStructs(\n      HandlerCaveatsStruct,\n      object({\n        chains: optional(ChainIdsStruct),\n        matchers: optional(LookupMatchersStruct),\n      }),\n    ),\n  ),\n  'endowment:network-access': optional(EmptyObjectStruct),\n  'endowment:page-home': optional(HandlerCaveatsStruct),\n  'endowment:rpc': optional(\n    mergeStructs(HandlerCaveatsStruct, RpcOriginsStruct),\n  ),\n  'endowment:signature-insight': optional(\n    mergeStructs(\n      HandlerCaveatsStruct,\n      object({\n        allowSignatureOrigin: optional(boolean()),\n      }),\n    ),\n  ),\n  'endowment:transaction-insight': optional(\n    mergeStructs(\n      HandlerCaveatsStruct,\n      object({\n        allowTransactionOrigin: optional(boolean()),\n      }),\n    ),\n  ),\n  'endowment:webassembly': optional(EmptyObjectStruct),\n  snap_dialog: optional(EmptyObjectStruct),\n  snap_manageState: optional(EmptyObjectStruct),\n  snap_manageAccounts: optional(EmptyObjectStruct),\n  snap_notify: optional(EmptyObjectStruct),\n  snap_getBip32Entropy: optional(SnapGetBip32EntropyPermissionsStruct),\n  snap_getBip32PublicKey: optional(SnapGetBip32EntropyPermissionsStruct),\n  snap_getBip44Entropy: optional(\n    size(\n      array(object({ coinType: size(integer(), 0, 2 ** 32 - 1) })),\n      1,\n      Infinity,\n    ),\n  ),\n  snap_getEntropy: optional(EmptyObjectStruct),\n  snap_getLocale: optional(EmptyObjectStruct),\n  wallet_snap: optional(SnapIdsStruct),\n});\n/* eslint-enable @typescript-eslint/naming-convention */\n\nexport type SnapPermissions = InferMatching<\n  typeof PermissionsStruct,\n  InitialPermissions\n>;\n\nexport const SnapAuxilaryFilesStruct = array(string());\n\nexport const InitialConnectionsStruct = record(\n  intersection([string(), uri()]),\n  object({}),\n);\n\nexport type InitialConnections = Infer<typeof InitialConnectionsStruct>;\n\nexport const SnapManifestStruct = object({\n  version: VersionStruct,\n  description: size(string(), 1, 280),\n  proposedName: size(string(), 1, 214),\n  repository: optional(\n    object({\n      type: size(string(), 1, Infinity),\n      url: size(string(), 1, Infinity),\n    }),\n  ),\n  source: object({\n    shasum: ChecksumStruct,\n    location: object({\n      npm: object({\n        filePath: size(string(), 1, Infinity),\n        iconPath: optional(size(string(), 1, Infinity)),\n        packageName: NameStruct,\n        registry: union([\n          literal('https://registry.npmjs.org'),\n          literal('https://registry.npmjs.org/'),\n        ]),\n      }),\n    }),\n    files: optional(SnapAuxilaryFilesStruct),\n    locales: optional(SnapAuxilaryFilesStruct),\n  }),\n  initialConnections: optional(InitialConnectionsStruct),\n  initialPermissions: PermissionsStruct,\n  manifestVersion: literal('0.1'),\n  $schema: optional(string()), // enables JSON-Schema linting in VSC and other IDEs\n});\n\nexport type SnapManifest = Infer<typeof SnapManifestStruct>;\n\n/**\n * Check if the given value is a valid {@link SnapManifest} object.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid {@link SnapManifest} object.\n */\nexport function isSnapManifest(value: unknown): value is SnapManifest {\n  return is(value, SnapManifestStruct);\n}\n\n/**\n * Assert that the given value is a valid {@link SnapManifest} object.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid {@link SnapManifest} object.\n */\nexport function assertIsSnapManifest(\n  value: unknown,\n): asserts value is SnapManifest {\n  assertStruct(\n    value,\n    SnapManifestStruct,\n    `\"${NpmSnapFileNames.Manifest}\" is invalid`,\n  );\n}\n\n/**\n * Creates a {@link SnapManifest} object from JSON.\n *\n * @param value - The value to check.\n * @throws If the value cannot be coerced to a {@link SnapManifest} object.\n * @returns The created {@link SnapManifest} object.\n */\nexport function createSnapManifest(value: unknown): SnapManifest {\n  // TODO: Add a utility to prefix these errors similar to assertStruct\n  return create(value, SnapManifestStruct);\n}\n"],"mappings":"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","names":[]}
\ No newline at end of file
+{"version":3,"sources":["../src/manifest/validation.ts"],"sourcesContent":["import type { SupportedCurve } from '@metamask/key-tree';\nimport { isValidBIP32PathSegment } from '@metamask/key-tree';\nimport type { EmptyObject, InitialPermissions } from '@metamask/snaps-sdk';\nimport {\n  assertStruct,\n  ChecksumStruct,\n  VersionStruct,\n  isValidSemVerRange,\n  inMilliseconds,\n  Duration,\n} from '@metamask/utils';\nimport type { Describe, Infer, Struct } from '@metamask/superstruct';\nimport {\n  array,\n  boolean,\n  create,\n  enums,\n  integer,\n  is,\n  literal,\n  object,\n  optional,\n  refine,\n  record,\n  size,\n  string,\n  type,\n  union,\n  intersection,\n} from '@metamask/superstruct';\n\nimport { isEqual } from '../array';\nimport { CronjobSpecificationArrayStruct } from '../cronjob';\nimport { SIP_6_MAGIC_VALUE, STATE_ENCRYPTION_MAGIC_VALUE } from '../entropy';\nimport { KeyringOriginsStruct, RpcOriginsStruct } from '../json-rpc';\nimport { ChainIdStruct } from '../namespace';\nimport { SnapIdStruct } from '../snaps';\nimport { mergeStructs, type InferMatching } from '../structs';\nimport { NameStruct, NpmSnapFileNames, uri } from '../types';\n\n// BIP-43 purposes that cannot be used for entropy derivation. These are in the\n// string form, ending with `'`.\nconst FORBIDDEN_PURPOSES: string[] = [\n  SIP_6_MAGIC_VALUE,\n  STATE_ENCRYPTION_MAGIC_VALUE,\n];\n\nexport const FORBIDDEN_COIN_TYPES: number[] = [60];\nconst FORBIDDEN_PATHS: string[][] = FORBIDDEN_COIN_TYPES.map((coinType) => [\n  'm',\n  \"44'\",\n  `${coinType}'`,\n]);\n\nexport const Bip32PathStruct = refine(\n  array(string()),\n  'BIP-32 path',\n  (path: string[]) => {\n    if (path.length === 0) {\n      return 'Path must be a non-empty BIP-32 derivation path array';\n    }\n\n    if (path[0] !== 'm') {\n      return 'Path must start with \"m\".';\n    }\n\n    if (path.length < 3) {\n      return 'Paths must have a length of at least three.';\n    }\n\n    if (path.slice(1).some((part) => !isValidBIP32PathSegment(part))) {\n      return 'Path must be a valid BIP-32 derivation path array.';\n    }\n\n    if (FORBIDDEN_PURPOSES.includes(path[1])) {\n      return `The purpose \"${path[1]}\" is not allowed for entropy derivation.`;\n    }\n\n    if (\n      FORBIDDEN_PATHS.some((forbiddenPath) =>\n        isEqual(path.slice(0, forbiddenPath.length), forbiddenPath),\n      )\n    ) {\n      return `The path \"${path.join(\n        '/',\n      )}\" is not allowed for entropy derivation.`;\n    }\n\n    return true;\n  },\n);\n\nexport const bip32entropy = <\n  Type extends { path: string[]; curve: string },\n  Schema,\n>(\n  struct: Struct<Type, Schema>,\n) =>\n  refine(struct, 'BIP-32 entropy', (value) => {\n    if (\n      value.curve === 'ed25519' &&\n      value.path.slice(1).some((part) => !part.endsWith(\"'\"))\n    ) {\n      return 'Ed25519 does not support unhardened paths.';\n    }\n\n    return true;\n  });\n\nexport const CurveStruct: Describe<SupportedCurve> = enums([\n  'ed25519',\n  'secp256k1',\n  'ed25519Bip32',\n]);\n\n// Used outside @metamask/snap-utils\nexport const Bip32EntropyStruct = bip32entropy(\n  type({\n    path: Bip32PathStruct,\n    curve: CurveStruct,\n  }),\n);\n\nexport type Bip32Entropy = Infer<typeof Bip32EntropyStruct>;\n\nexport const SnapGetBip32EntropyPermissionsStruct = size(\n  array(Bip32EntropyStruct),\n  1,\n  Infinity,\n);\n\nexport const SemVerRangeStruct = refine(string(), 'SemVer range', (value) => {\n  if (isValidSemVerRange(value)) {\n    return true;\n  }\n  return 'Expected a valid SemVer range.';\n});\n\nexport const SnapIdsStruct = refine(\n  record(SnapIdStruct, object({ version: optional(SemVerRangeStruct) })),\n  'SnapIds',\n  (value) => {\n    if (Object.keys(value).length === 0) {\n      return false;\n    }\n\n    return true;\n  },\n);\n\nexport type SnapIds = Infer<typeof SnapIdsStruct>;\n\nexport const ChainIdsStruct = size(array(ChainIdStruct), 1, Infinity);\n\nexport const LookupMatchersStruct = union([\n  object({\n    tlds: size(array(string()), 1, Infinity),\n  }),\n  object({\n    schemes: size(array(string()), 1, Infinity),\n  }),\n  object({\n    tlds: size(array(string()), 1, Infinity),\n    schemes: size(array(string()), 1, Infinity),\n  }),\n]);\n\nexport const MINIMUM_REQUEST_TIMEOUT = inMilliseconds(5, Duration.Second);\nexport const MAXIMUM_REQUEST_TIMEOUT = inMilliseconds(3, Duration.Minute);\n\nexport const MaxRequestTimeStruct = size(\n  integer(),\n  MINIMUM_REQUEST_TIMEOUT,\n  MAXIMUM_REQUEST_TIMEOUT,\n);\n\n// Utility type to union with for all handler structs\nexport const HandlerCaveatsStruct = object({\n  maxRequestTime: optional(MaxRequestTimeStruct),\n});\n\nexport type HandlerCaveats = Infer<typeof HandlerCaveatsStruct>;\n\nexport const EmptyObjectStruct = object<EmptyObject>({}) as unknown as Struct<\n  EmptyObject,\n  null\n>;\n\n/* eslint-disable @typescript-eslint/naming-convention */\nexport const PermissionsStruct: Describe<InitialPermissions> = type({\n  'endowment:cronjob': optional(\n    mergeStructs(\n      HandlerCaveatsStruct,\n      object({ jobs: CronjobSpecificationArrayStruct }),\n    ),\n  ),\n  'endowment:ethereum-provider': optional(EmptyObjectStruct),\n  'endowment:keyring': optional(\n    mergeStructs(HandlerCaveatsStruct, KeyringOriginsStruct),\n  ),\n  'endowment:lifecycle-hooks': optional(HandlerCaveatsStruct),\n  'endowment:name-lookup': optional(\n    mergeStructs(\n      HandlerCaveatsStruct,\n      object({\n        chains: optional(ChainIdsStruct),\n        matchers: optional(LookupMatchersStruct),\n      }),\n    ),\n  ),\n  'endowment:network-access': optional(EmptyObjectStruct),\n  'endowment:page-home': optional(HandlerCaveatsStruct),\n  'endowment:rpc': optional(\n    mergeStructs(HandlerCaveatsStruct, RpcOriginsStruct),\n  ),\n  'endowment:signature-insight': optional(\n    mergeStructs(\n      HandlerCaveatsStruct,\n      object({\n        allowSignatureOrigin: optional(boolean()),\n      }),\n    ),\n  ),\n  'endowment:transaction-insight': optional(\n    mergeStructs(\n      HandlerCaveatsStruct,\n      object({\n        allowTransactionOrigin: optional(boolean()),\n      }),\n    ),\n  ),\n  'endowment:webassembly': optional(EmptyObjectStruct),\n  snap_dialog: optional(EmptyObjectStruct),\n  snap_manageState: optional(EmptyObjectStruct),\n  snap_manageAccounts: optional(EmptyObjectStruct),\n  snap_notify: optional(EmptyObjectStruct),\n  snap_getBip32Entropy: optional(SnapGetBip32EntropyPermissionsStruct),\n  snap_getBip32PublicKey: optional(SnapGetBip32EntropyPermissionsStruct),\n  snap_getBip44Entropy: optional(\n    size(\n      array(object({ coinType: size(integer(), 0, 2 ** 32 - 1) })),\n      1,\n      Infinity,\n    ),\n  ),\n  snap_getEntropy: optional(EmptyObjectStruct),\n  snap_getLocale: optional(EmptyObjectStruct),\n  wallet_snap: optional(SnapIdsStruct),\n});\n/* eslint-enable @typescript-eslint/naming-convention */\n\nexport type SnapPermissions = InferMatching<\n  typeof PermissionsStruct,\n  InitialPermissions\n>;\n\nexport const SnapAuxilaryFilesStruct = array(string());\n\nexport const InitialConnectionsStruct = record(\n  intersection([string(), uri()]),\n  object({}),\n);\n\nexport type InitialConnections = Infer<typeof InitialConnectionsStruct>;\n\nexport const SnapManifestStruct = object({\n  version: VersionStruct,\n  description: size(string(), 1, 280),\n  proposedName: size(string(), 1, 214),\n  repository: optional(\n    object({\n      type: size(string(), 1, Infinity),\n      url: size(string(), 1, Infinity),\n    }),\n  ),\n  source: object({\n    shasum: ChecksumStruct,\n    location: object({\n      npm: object({\n        filePath: size(string(), 1, Infinity),\n        iconPath: optional(size(string(), 1, Infinity)),\n        packageName: NameStruct,\n        registry: union([\n          literal('https://registry.npmjs.org'),\n          literal('https://registry.npmjs.org/'),\n        ]),\n      }),\n    }),\n    files: optional(SnapAuxilaryFilesStruct),\n    locales: optional(SnapAuxilaryFilesStruct),\n  }),\n  initialConnections: optional(InitialConnectionsStruct),\n  initialPermissions: PermissionsStruct,\n  manifestVersion: literal('0.1'),\n  $schema: optional(string()), // enables JSON-Schema linting in VSC and other IDEs\n});\n\nexport type SnapManifest = Infer<typeof SnapManifestStruct>;\n\n/**\n * Check if the given value is a valid {@link SnapManifest} object.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid {@link SnapManifest} object.\n */\nexport function isSnapManifest(value: unknown): value is SnapManifest {\n  return is(value, SnapManifestStruct);\n}\n\n/**\n * Assert that the given value is a valid {@link SnapManifest} object.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid {@link SnapManifest} object.\n */\nexport function assertIsSnapManifest(\n  value: unknown,\n): asserts value is SnapManifest {\n  assertStruct(\n    value,\n    SnapManifestStruct,\n    `\"${NpmSnapFileNames.Manifest}\" is invalid`,\n  );\n}\n\n/**\n * Creates a {@link SnapManifest} object from JSON.\n *\n * @param value - The value to check.\n * @throws If the value cannot be coerced to a {@link SnapManifest} object.\n * @returns The created {@link SnapManifest} object.\n */\nexport function createSnapManifest(value: unknown): SnapManifest {\n  // TODO: Add a utility to prefix these errors similar to assertStruct\n  return create(value, SnapManifestStruct);\n}\n"],"mappings":"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","names":[]}
\ No newline at end of file
diff --git a/dist/chunk-EXUEHPZ4.mjs.map b/dist/chunk-EXUEHPZ4.mjs.map
index c5e8ed710eea502b656b5f16aa6033ba3bf36c3b..82a2348db4c0b015ce94fbb14ece4a1baf72797e 100644
--- a/dist/chunk-EXUEHPZ4.mjs.map
+++ b/dist/chunk-EXUEHPZ4.mjs.map
@@ -1 +1 @@
-{"version":3,"sources":["../src/namespace.ts"],"sourcesContent":["import type { AccountId, ChainId } from '@metamask/snaps-sdk';\nimport type { Infer } from 'superstruct';\nimport {\n  array,\n  define,\n  is,\n  object,\n  optional,\n  pattern,\n  size,\n  string,\n} from 'superstruct';\n\nimport type { InferMatching } from './structs';\n\nexport const CHAIN_ID_REGEX =\n  /^(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-a-zA-Z0-9]{1,32})$/u;\n\nexport const ACCOUNT_ID_REGEX =\n  /^(?<chainId>(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-a-zA-Z0-9]{1,32})):(?<accountAddress>[a-zA-Z0-9]{1,64})$/u;\n\nexport const ACCOUNT_ADDRESS_REGEX = /^(?<accountAddress>[a-zA-Z0-9]{1,64})$/u;\n\n/**\n * Parse a chain ID string to an object containing the namespace and reference.\n * This validates the chain ID before parsing it.\n *\n * @param chainId - The chain ID to validate and parse.\n * @returns The parsed chain ID.\n */\nexport function parseChainId(chainId: ChainId): {\n  namespace: NamespaceId;\n  reference: string;\n} {\n  const match = CHAIN_ID_REGEX.exec(chainId);\n  if (!match?.groups) {\n    throw new Error('Invalid chain ID.');\n  }\n\n  return {\n    namespace: match.groups.namespace,\n    reference: match.groups.reference,\n  };\n}\n\n/**\n * Parse an account ID to an object containing the chain, chain ID and address.\n * This validates the account ID before parsing it.\n *\n * @param accountId - The account ID to validate and parse.\n * @returns The parsed account ID.\n */\nexport function parseAccountId(accountId: AccountId): {\n  chain: { namespace: NamespaceId; reference: string };\n  chainId: ChainId;\n  address: string;\n} {\n  const match = ACCOUNT_ID_REGEX.exec(accountId);\n  if (!match?.groups) {\n    throw new Error('Invalid account ID.');\n  }\n\n  return {\n    address: match.groups.accountAddress,\n    chainId: match.groups.chainId as ChainId,\n    chain: {\n      namespace: match.groups.namespace,\n      reference: match.groups.reference,\n    },\n  };\n}\n\n/**\n * A helper struct for a string with a minimum length of 1 and a maximum length\n * of 40.\n */\nexport const LimitedString = size(string(), 1, 40);\n\nexport const ChainIdStringStruct = define<ChainId>(\n  'Chain ID',\n  string().validator,\n);\n\n/**\n * A CAIP-2 chain ID, i.e., a human-readable namespace and reference.\n */\nexport const ChainIdStruct = pattern<ChainId, null>(\n  ChainIdStringStruct,\n  CHAIN_ID_REGEX,\n);\n\nexport type Caip2ChainId = InferMatching<typeof ChainIdStruct, ChainId>;\n\nexport const AccountIdStruct = pattern(string(), ACCOUNT_ID_REGEX);\n\nexport const AccountIdArrayStruct = array(AccountIdStruct);\nexport const AccountAddressStruct = pattern(string(), ACCOUNT_ADDRESS_REGEX);\nexport type AccountAddress = Infer<typeof AccountAddressStruct>;\n\n/**\n * A chain descriptor.\n */\nexport const ChainStruct = object({\n  id: ChainIdStruct,\n  name: LimitedString,\n});\nexport type Chain = Infer<typeof ChainStruct>;\n\nexport const NamespaceStruct = object({\n  /**\n   * A list of supported chains in the namespace.\n   */\n  chains: array(ChainStruct),\n\n  /**\n   * A list of supported RPC methods on the namespace, that a DApp can call.\n   */\n  methods: optional(array(LimitedString)),\n\n  /**\n   * A list of supported RPC events on the namespace, that a DApp can listen to.\n   */\n  events: optional(array(LimitedString)),\n});\nexport type Namespace = Infer<typeof NamespaceStruct>;\n\n/**\n * A CAIP-2 namespace, i.e., the first part of a chain ID.\n */\nexport const NamespaceIdStruct = pattern(string(), /^[-a-z0-9]{3,8}$/u);\nexport type NamespaceId = Infer<typeof NamespaceIdStruct>;\n\n/**\n * Check if the given value is a CAIP-2 namespace ID.\n *\n * @param value - The value to check.\n * @returns Whether the value is a CAIP-2 namespace ID.\n */\nexport function isNamespaceId(value: unknown): value is NamespaceId {\n  return is(value, NamespaceIdStruct);\n}\n\n/**\n * Check if the given value is a CAIP-2 chain ID.\n *\n * @param value - The value to check.\n * @returns Whether the value is a CAIP-2 chain ID.\n */\nexport function isChainId(value: unknown): value is ChainId {\n  return is(value, ChainIdStruct);\n}\n\n/**\n * Check if the given value is a CAIP-10 account ID.\n *\n * @param value - The value to check.\n * @returns Whether the value is a CAIP-10 account ID.\n */\nexport function isAccountId(value: unknown): value is AccountId {\n  return is(value, AccountIdStruct);\n}\n\n/**\n * Check if the given value is an array of CAIP-10 account IDs.\n *\n * @param value - The value to check.\n * @returns Whether the value is an array of CAIP-10 account IDs.\n */\nexport function isAccountIdArray(value: unknown): value is AccountId[] {\n  return is(value, AccountIdArrayStruct);\n}\n\n/**\n * Check if a value is a {@link Namespace}.\n *\n * @param value - The value to validate.\n * @returns True if the value is a valid {@link Namespace}.\n */\nexport function isNamespace(value: unknown): value is Namespace {\n  return is(value, NamespaceStruct);\n}\n"],"mappings":";AAEA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAIA,IAAM,iBACX;AAEK,IAAM,mBACX;AAEK,IAAM,wBAAwB;AAS9B,SAAS,aAAa,SAG3B;AACA,QAAM,QAAQ,eAAe,KAAK,OAAO;AACzC,MAAI,CAAC,OAAO,QAAQ;AAClB,UAAM,IAAI,MAAM,mBAAmB;AAAA,EACrC;AAEA,SAAO;AAAA,IACL,WAAW,MAAM,OAAO;AAAA,IACxB,WAAW,MAAM,OAAO;AAAA,EAC1B;AACF;AASO,SAAS,eAAe,WAI7B;AACA,QAAM,QAAQ,iBAAiB,KAAK,SAAS;AAC7C,MAAI,CAAC,OAAO,QAAQ;AAClB,UAAM,IAAI,MAAM,qBAAqB;AAAA,EACvC;AAEA,SAAO;AAAA,IACL,SAAS,MAAM,OAAO;AAAA,IACtB,SAAS,MAAM,OAAO;AAAA,IACtB,OAAO;AAAA,MACL,WAAW,MAAM,OAAO;AAAA,MACxB,WAAW,MAAM,OAAO;AAAA,IAC1B;AAAA,EACF;AACF;AAMO,IAAM,gBAAgB,KAAK,OAAO,GAAG,GAAG,EAAE;AAE1C,IAAM,sBAAsB;AAAA,EACjC;AAAA,EACA,OAAO,EAAE;AACX;AAKO,IAAM,gBAAgB;AAAA,EAC3B;AAAA,EACA;AACF;AAIO,IAAM,kBAAkB,QAAQ,OAAO,GAAG,gBAAgB;AAE1D,IAAM,uBAAuB,MAAM,eAAe;AAClD,IAAM,uBAAuB,QAAQ,OAAO,GAAG,qBAAqB;AAMpE,IAAM,cAAc,OAAO;AAAA,EAChC,IAAI;AAAA,EACJ,MAAM;AACR,CAAC;AAGM,IAAM,kBAAkB,OAAO;AAAA;AAAA;AAAA;AAAA,EAIpC,QAAQ,MAAM,WAAW;AAAA;AAAA;AAAA;AAAA,EAKzB,SAAS,SAAS,MAAM,aAAa,CAAC;AAAA;AAAA;AAAA;AAAA,EAKtC,QAAQ,SAAS,MAAM,aAAa,CAAC;AACvC,CAAC;AAMM,IAAM,oBAAoB,QAAQ,OAAO,GAAG,mBAAmB;AAS/D,SAAS,cAAc,OAAsC;AAClE,SAAO,GAAG,OAAO,iBAAiB;AACpC;AAQO,SAAS,UAAU,OAAkC;AAC1D,SAAO,GAAG,OAAO,aAAa;AAChC;AAQO,SAAS,YAAY,OAAoC;AAC9D,SAAO,GAAG,OAAO,eAAe;AAClC;AAQO,SAAS,iBAAiB,OAAsC;AACrE,SAAO,GAAG,OAAO,oBAAoB;AACvC;AAQO,SAAS,YAAY,OAAoC;AAC9D,SAAO,GAAG,OAAO,eAAe;AAClC;","names":[]}
\ No newline at end of file
+{"version":3,"sources":["../src/namespace.ts"],"sourcesContent":["import type { AccountId, ChainId } from '@metamask/snaps-sdk';\nimport type { Infer } from '@metamask/superstruct';\nimport {\n  array,\n  define,\n  is,\n  object,\n  optional,\n  pattern,\n  size,\n  string,\n} from '@metamask/superstruct';\n\nimport type { InferMatching } from './structs';\n\nexport const CHAIN_ID_REGEX =\n  /^(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-a-zA-Z0-9]{1,32})$/u;\n\nexport const ACCOUNT_ID_REGEX =\n  /^(?<chainId>(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-a-zA-Z0-9]{1,32})):(?<accountAddress>[a-zA-Z0-9]{1,64})$/u;\n\nexport const ACCOUNT_ADDRESS_REGEX = /^(?<accountAddress>[a-zA-Z0-9]{1,64})$/u;\n\n/**\n * Parse a chain ID string to an object containing the namespace and reference.\n * This validates the chain ID before parsing it.\n *\n * @param chainId - The chain ID to validate and parse.\n * @returns The parsed chain ID.\n */\nexport function parseChainId(chainId: ChainId): {\n  namespace: NamespaceId;\n  reference: string;\n} {\n  const match = CHAIN_ID_REGEX.exec(chainId);\n  if (!match?.groups) {\n    throw new Error('Invalid chain ID.');\n  }\n\n  return {\n    namespace: match.groups.namespace,\n    reference: match.groups.reference,\n  };\n}\n\n/**\n * Parse an account ID to an object containing the chain, chain ID and address.\n * This validates the account ID before parsing it.\n *\n * @param accountId - The account ID to validate and parse.\n * @returns The parsed account ID.\n */\nexport function parseAccountId(accountId: AccountId): {\n  chain: { namespace: NamespaceId; reference: string };\n  chainId: ChainId;\n  address: string;\n} {\n  const match = ACCOUNT_ID_REGEX.exec(accountId);\n  if (!match?.groups) {\n    throw new Error('Invalid account ID.');\n  }\n\n  return {\n    address: match.groups.accountAddress,\n    chainId: match.groups.chainId as ChainId,\n    chain: {\n      namespace: match.groups.namespace,\n      reference: match.groups.reference,\n    },\n  };\n}\n\n/**\n * A helper struct for a string with a minimum length of 1 and a maximum length\n * of 40.\n */\nexport const LimitedString = size(string(), 1, 40);\n\nexport const ChainIdStringStruct = define<ChainId>(\n  'Chain ID',\n  string().validator,\n);\n\n/**\n * A CAIP-2 chain ID, i.e., a human-readable namespace and reference.\n */\nexport const ChainIdStruct = pattern<ChainId, null>(\n  ChainIdStringStruct,\n  CHAIN_ID_REGEX,\n);\n\nexport type Caip2ChainId = InferMatching<typeof ChainIdStruct, ChainId>;\n\nexport const AccountIdStruct = pattern(string(), ACCOUNT_ID_REGEX);\n\nexport const AccountIdArrayStruct = array(AccountIdStruct);\nexport const AccountAddressStruct = pattern(string(), ACCOUNT_ADDRESS_REGEX);\nexport type AccountAddress = Infer<typeof AccountAddressStruct>;\n\n/**\n * A chain descriptor.\n */\nexport const ChainStruct = object({\n  id: ChainIdStruct,\n  name: LimitedString,\n});\nexport type Chain = Infer<typeof ChainStruct>;\n\nexport const NamespaceStruct = object({\n  /**\n   * A list of supported chains in the namespace.\n   */\n  chains: array(ChainStruct),\n\n  /**\n   * A list of supported RPC methods on the namespace, that a DApp can call.\n   */\n  methods: optional(array(LimitedString)),\n\n  /**\n   * A list of supported RPC events on the namespace, that a DApp can listen to.\n   */\n  events: optional(array(LimitedString)),\n});\nexport type Namespace = Infer<typeof NamespaceStruct>;\n\n/**\n * A CAIP-2 namespace, i.e., the first part of a chain ID.\n */\nexport const NamespaceIdStruct = pattern(string(), /^[-a-z0-9]{3,8}$/u);\nexport type NamespaceId = Infer<typeof NamespaceIdStruct>;\n\n/**\n * Check if the given value is a CAIP-2 namespace ID.\n *\n * @param value - The value to check.\n * @returns Whether the value is a CAIP-2 namespace ID.\n */\nexport function isNamespaceId(value: unknown): value is NamespaceId {\n  return is(value, NamespaceIdStruct);\n}\n\n/**\n * Check if the given value is a CAIP-2 chain ID.\n *\n * @param value - The value to check.\n * @returns Whether the value is a CAIP-2 chain ID.\n */\nexport function isChainId(value: unknown): value is ChainId {\n  return is(value, ChainIdStruct);\n}\n\n/**\n * Check if the given value is a CAIP-10 account ID.\n *\n * @param value - The value to check.\n * @returns Whether the value is a CAIP-10 account ID.\n */\nexport function isAccountId(value: unknown): value is AccountId {\n  return is(value, AccountIdStruct);\n}\n\n/**\n * Check if the given value is an array of CAIP-10 account IDs.\n *\n * @param value - The value to check.\n * @returns Whether the value is an array of CAIP-10 account IDs.\n */\nexport function isAccountIdArray(value: unknown): value is AccountId[] {\n  return is(value, AccountIdArrayStruct);\n}\n\n/**\n * Check if a value is a {@link Namespace}.\n *\n * @param value - The value to validate.\n * @returns True if the value is a valid {@link Namespace}.\n */\nexport function isNamespace(value: unknown): value is Namespace {\n  return is(value, NamespaceStruct);\n}\n"],"mappings":";AAEA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAIA,IAAM,iBACX;AAEK,IAAM,mBACX;AAEK,IAAM,wBAAwB;AAS9B,SAAS,aAAa,SAG3B;AACA,QAAM,QAAQ,eAAe,KAAK,OAAO;AACzC,MAAI,CAAC,OAAO,QAAQ;AAClB,UAAM,IAAI,MAAM,mBAAmB;AAAA,EACrC;AAEA,SAAO;AAAA,IACL,WAAW,MAAM,OAAO;AAAA,IACxB,WAAW,MAAM,OAAO;AAAA,EAC1B;AACF;AASO,SAAS,eAAe,WAI7B;AACA,QAAM,QAAQ,iBAAiB,KAAK,SAAS;AAC7C,MAAI,CAAC,OAAO,QAAQ;AAClB,UAAM,IAAI,MAAM,qBAAqB;AAAA,EACvC;AAEA,SAAO;AAAA,IACL,SAAS,MAAM,OAAO;AAAA,IACtB,SAAS,MAAM,OAAO;AAAA,IACtB,OAAO;AAAA,MACL,WAAW,MAAM,OAAO;AAAA,MACxB,WAAW,MAAM,OAAO;AAAA,IAC1B;AAAA,EACF;AACF;AAMO,IAAM,gBAAgB,KAAK,OAAO,GAAG,GAAG,EAAE;AAE1C,IAAM,sBAAsB;AAAA,EACjC;AAAA,EACA,OAAO,EAAE;AACX;AAKO,IAAM,gBAAgB;AAAA,EAC3B;AAAA,EACA;AACF;AAIO,IAAM,kBAAkB,QAAQ,OAAO,GAAG,gBAAgB;AAE1D,IAAM,uBAAuB,MAAM,eAAe;AAClD,IAAM,uBAAuB,QAAQ,OAAO,GAAG,qBAAqB;AAMpE,IAAM,cAAc,OAAO;AAAA,EAChC,IAAI;AAAA,EACJ,MAAM;AACR,CAAC;AAGM,IAAM,kBAAkB,OAAO;AAAA;AAAA;AAAA;AAAA,EAIpC,QAAQ,MAAM,WAAW;AAAA;AAAA;AAAA;AAAA,EAKzB,SAAS,SAAS,MAAM,aAAa,CAAC;AAAA;AAAA;AAAA;AAAA,EAKtC,QAAQ,SAAS,MAAM,aAAa,CAAC;AACvC,CAAC;AAMM,IAAM,oBAAoB,QAAQ,OAAO,GAAG,mBAAmB;AAS/D,SAAS,cAAc,OAAsC;AAClE,SAAO,GAAG,OAAO,iBAAiB;AACpC;AAQO,SAAS,UAAU,OAAkC;AAC1D,SAAO,GAAG,OAAO,aAAa;AAChC;AAQO,SAAS,YAAY,OAAoC;AAC9D,SAAO,GAAG,OAAO,eAAe;AAClC;AAQO,SAAS,iBAAiB,OAAsC;AACrE,SAAO,GAAG,OAAO,oBAAoB;AACvC;AAQO,SAAS,YAAY,OAAoC;AAC9D,SAAO,GAAG,OAAO,eAAe;AAClC;","names":[]}
\ No newline at end of file
diff --git a/dist/chunk-HEXZ4DFV.js.map b/dist/chunk-HEXZ4DFV.js.map
index e6afcd73012f02f53fb24de0d5776a240c98e82b..37583b7ac1951b880ac7c349b6dce71162345946 100644
--- a/dist/chunk-HEXZ4DFV.js.map
+++ b/dist/chunk-HEXZ4DFV.js.map
@@ -1 +1,11 @@
-{"version":3,"sources":["../src/structs.ts"],"names":[],"mappings":"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","sourcesContent":["import { union } from '@metamask/snaps-sdk';\nimport type { NonEmptyArray } from '@metamask/utils';\nimport { assert, isObject } from '@metamask/utils';\nimport { bold, green, red } from 'chalk';\nimport type { Failure } from 'superstruct';\nimport {\n  is,\n  validate,\n  type as superstructType,\n  Struct,\n  StructError,\n  create,\n  assign,\n} from 'superstruct';\nimport type {\n  AnyStruct,\n  Assign,\n  ObjectSchema,\n  ObjectType,\n} from 'superstruct/dist/utils';\n\nimport { indent } from './strings';\n\n/**\n * Infer a struct type, only if it matches the specified type. This is useful\n * for defining types and structs that are related to each other in separate\n * files.\n *\n * @example\n * ```typescript\n * // In file A\n * export type GetFileArgs = {\n *   path: string;\n *   encoding?: EnumToUnion<AuxiliaryFileEncoding>;\n * };\n *\n * // In file B\n * export const GetFileArgsStruct = object(...);\n *\n * // If the type and struct are in the same file, this will return the type.\n * // Otherwise, it will return `never`.\n * export type GetFileArgs =\n *   InferMatching<typeof GetFileArgsStruct, GetFileArgs>;\n * ```\n */\nexport type InferMatching<\n  StructType extends Struct<any, any>,\n  Type,\n> = StructType['TYPE'] extends Type ? Type : never;\n\n/**\n * Colorize a value with a color function. This is useful for colorizing values\n * in error messages. If colorization is disabled, the original value is\n * returned.\n *\n * @param value - The value to colorize.\n * @param colorFunction - The color function to use.\n * @param enabled - Whether to colorize the value.\n * @returns The colorized value, or the original value if colorization is\n * disabled.\n */\nfunction color(\n  value: string,\n  colorFunction: (value: string) => string,\n  enabled: boolean,\n) {\n  if (enabled) {\n    return colorFunction(value);\n  }\n\n  return value;\n}\n\n/**\n * Define a struct, and also define the name of the struct as the given name.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n *\n * @param name - The name of the struct.\n * @param struct - The struct.\n * @returns The struct.\n */\nexport function named<Type, Schema>(\n  name: string,\n  struct: Struct<Type, Schema>,\n) {\n  return new Struct({\n    ...struct,\n    type: name,\n  });\n}\n\nexport class SnapsStructError<Type, Schema> extends StructError {\n  constructor(\n    struct: Struct<Type, Schema>,\n    prefix: string,\n    suffix: string,\n    failure: StructError,\n    failures: () => Generator<Failure>,\n    colorize = true,\n  ) {\n    super(failure, failures);\n\n    this.name = 'SnapsStructError';\n    this.message = `${prefix}.\\n\\n${getStructErrorMessage(\n      struct,\n      [...failures()],\n      colorize,\n    )}${suffix ? `\\n\\n${suffix}` : ''}`;\n  }\n}\n\ntype GetErrorOptions<Type, Schema> = {\n  struct: Struct<Type, Schema>;\n  prefix: string;\n  suffix?: string;\n  error: StructError;\n  colorize?: boolean;\n};\n\n/**\n * Converts an array to a generator function that yields the items in the\n * array.\n *\n * @param array - The array.\n * @returns A generator function.\n * @yields The items in the array.\n */\nexport function* arrayToGenerator<Type>(\n  array: Type[],\n): Generator<Type, void, undefined> {\n  for (const item of array) {\n    yield item;\n  }\n}\n\n/**\n * Returns a `SnapsStructError` with the given prefix and suffix.\n *\n * @param options - The options.\n * @param options.struct - The struct that caused the error.\n * @param options.prefix - The prefix to add to the error message.\n * @param options.suffix - The suffix to add to the error message. Defaults to\n * an empty string.\n * @param options.error - The `superstruct` error to wrap.\n * @param options.colorize - Whether to colorize the value. Defaults to `true`.\n * @returns The `SnapsStructError`.\n */\nexport function getError<Type, Schema>({\n  struct,\n  prefix,\n  suffix = '',\n  error,\n  colorize,\n}: GetErrorOptions<Type, Schema>) {\n  return new SnapsStructError(\n    struct,\n    prefix,\n    suffix,\n    error,\n    () => arrayToGenerator(error.failures()),\n    colorize,\n  );\n}\n\n/**\n * A wrapper of `superstruct`'s `create` function that throws a\n * `SnapsStructError` instead of a `StructError`. This is useful for improving\n * the error messages returned by `superstruct`.\n *\n * @param value - The value to validate.\n * @param struct - The `superstruct` struct to validate the value against.\n * @param prefix - The prefix to add to the error message.\n * @param suffix - The suffix to add to the error message. Defaults to an empty\n * string.\n * @returns The validated value.\n */\nexport function createFromStruct<Type, Schema>(\n  value: unknown,\n  struct: Struct<Type, Schema>,\n  prefix: string,\n  suffix = '',\n) {\n  try {\n    return create(value, struct);\n  } catch (error) {\n    if (error instanceof StructError) {\n      throw getError({ struct, prefix, suffix, error });\n    }\n\n    throw error;\n  }\n}\n\n/**\n * Get a struct from a failure path.\n *\n * @param struct - The struct.\n * @param path - The failure path.\n * @returns The struct at the failure path.\n */\nexport function getStructFromPath<Type, Schema>(\n  struct: Struct<Type, Schema>,\n  path: string[],\n) {\n  return path.reduce<AnyStruct>((result, key) => {\n    if (isObject(struct.schema) && struct.schema[key]) {\n      return struct.schema[key] as AnyStruct;\n    }\n\n    return result;\n  }, struct);\n}\n\n/**\n * Get the union struct names from a struct.\n *\n * @param struct - The struct.\n * @param colorize - Whether to colorize the value. Defaults to `true`.\n * @returns The union struct names, or `null` if the struct is not a union\n * struct.\n */\nexport function getUnionStructNames<Type, Schema>(\n  struct: Struct<Type, Schema>,\n  colorize = true,\n) {\n  if (Array.isArray(struct.schema)) {\n    return struct.schema.map(({ type }) => color(type, green, colorize));\n  }\n\n  return null;\n}\n\n/**\n * Get an error prefix from a `superstruct` failure. This is useful for\n * formatting the error message returned by `superstruct`.\n *\n * @param failure - The `superstruct` failure.\n * @param colorize - Whether to colorize the value. Defaults to `true`.\n * @returns The error prefix.\n */\nexport function getStructErrorPrefix(failure: Failure, colorize = true) {\n  if (failure.type === 'never' || failure.path.length === 0) {\n    return '';\n  }\n\n  return `At path: ${color(failure.path.join('.'), bold, colorize)}  `;\n}\n\n/**\n * Get a string describing the failure. This is similar to the `message`\n * property of `superstruct`'s `Failure` type, but formats the value in a more\n * readable way.\n *\n * @param struct - The struct that caused the failure.\n * @param failure - The `superstruct` failure.\n * @param colorize - Whether to colorize the value. Defaults to `true`.\n * @returns A string describing the failure.\n */\nexport function getStructFailureMessage<Type, Schema>(\n  struct: Struct<Type, Schema>,\n  failure: Failure,\n  colorize = true,\n) {\n  const received = color(JSON.stringify(failure.value), red, colorize);\n  const prefix = getStructErrorPrefix(failure, colorize);\n\n  if (failure.type === 'union') {\n    const childStruct = getStructFromPath(struct, failure.path);\n    const unionNames = getUnionStructNames(childStruct, colorize);\n\n    if (unionNames) {\n      return `${prefix}Expected the value to be one of: ${unionNames.join(\n        ', ',\n      )}, but received: ${received}.`;\n    }\n\n    return `${prefix}${failure.message}.`;\n  }\n\n  if (failure.type === 'literal') {\n    // Superstruct's failure does not provide information about which literal\n    // value was expected, so we need to parse the message to get the literal.\n    const message = failure.message\n      .replace(\n        /the literal `(.+)`,/u,\n        `the value to be \\`${color('$1', green, colorize)}\\`,`,\n      )\n      .replace(\n        /, but received: (.+)/u,\n        `, but received: ${color('$1', red, colorize)}`,\n      );\n\n    return `${prefix}${message}.`;\n  }\n\n  if (failure.type === 'never') {\n    return `Unknown key: ${color(\n      failure.path.join('.'),\n      bold,\n      colorize,\n    )}, received: ${received}.`;\n  }\n\n  if (failure.refinement === 'size') {\n    const message = failure.message\n      .replace(\n        /length between `(\\d+)` and `(\\d+)`/u,\n        `length between ${color('$1', green, colorize)} and ${color(\n          '$2',\n          green,\n          colorize,\n        )},`,\n      )\n      .replace(/length of `(\\d+)`/u, `length of ${color('$1', red, colorize)}`)\n      .replace(/a array/u, 'an array');\n\n    return `${prefix}${message}.`;\n  }\n\n  return `${prefix}Expected a value of type ${color(\n    failure.type,\n    green,\n    colorize,\n  )}, but received: ${received}.`;\n}\n\n/**\n * Get a string describing the errors. This formats all the errors in a\n * human-readable way.\n *\n * @param struct - The struct that caused the failures.\n * @param failures - The `superstruct` failures.\n * @param colorize - Whether to colorize the value. Defaults to `true`.\n * @returns A string describing the errors.\n */\nexport function getStructErrorMessage<Type, Schema>(\n  struct: Struct<Type, Schema>,\n  failures: Failure[],\n  colorize = true,\n) {\n  const formattedFailures = failures.map((failure) =>\n    indent(` ${getStructFailureMessage(struct, failure, colorize)}`),\n  );\n\n  return formattedFailures.join('\\n');\n}\n\n/**\n * Validate a union struct, and throw readable errors if the value does not\n * satisfy the struct. This is useful for improving the error messages returned\n * by `superstruct`.\n *\n * @param value - The value to validate.\n * @param struct - The `superstruct` union struct to validate the value against.\n * This struct must be a union of object structs, and must have at least one\n * shared key to validate against.\n * @param structKey - The key to validate against. This key must be present in\n * all the object structs in the union struct, and is expected to be a literal\n * value.\n * @param coerce - Whether to coerce the value to satisfy the struct. Defaults\n * to `false`.\n * @returns The validated value.\n * @throws If the value does not satisfy the struct.\n * @example\n * const struct = union([\n *   object({ type: literal('a'), value: string() }),\n *   object({ type: literal('b'), value: number() }),\n *   object({ type: literal('c'), value: boolean() }),\n *   // ...\n * ]);\n *\n * // At path: type  Expected the value to be one of: \"a\", \"b\", \"c\", but received: \"d\".\n * validateUnion({ type: 'd', value: 'foo' }, struct, 'type');\n *\n * // At path: value  Expected a value of type string, but received: 42.\n * validateUnion({ type: 'a', value: 42 }, struct, 'value');\n */\nexport function validateUnion<Type, Schema extends readonly Struct<any, any>[]>(\n  value: unknown,\n  struct: Struct<Type, Schema>,\n  structKey: keyof Type,\n  coerce = false,\n) {\n  assert(\n    struct.schema,\n    'Expected a struct with a schema. Make sure to use `union` from `@metamask/snaps-sdk`.',\n  );\n  assert(struct.schema.length > 0, 'Expected a non-empty array of structs.');\n\n  const keyUnion = struct.schema.map(\n    (innerStruct) => innerStruct.schema[structKey],\n    // This is guaranteed to be a non-empty array by the assertion above. We\n    // need to cast it since `superstruct` requires a non-empty array of structs\n    // for the `union` struct.\n  ) as NonEmptyArray<Struct>;\n\n  const key = superstructType({\n    [structKey]: union(keyUnion),\n  });\n\n  const [keyError] = validate(value, key, { coerce });\n  if (keyError) {\n    throw new Error(\n      getStructFailureMessage(key, keyError.failures()[0], false),\n    );\n  }\n\n  // At this point it's guaranteed that the value is an object, so we can safely\n  // cast it to a Record.\n  const objectValue = value as Record<PropertyKey, unknown>;\n  const objectStructs = struct.schema.filter((innerStruct) =>\n    is(objectValue[structKey], innerStruct.schema[structKey]),\n  );\n\n  assert(objectStructs.length > 0, 'Expected a struct to match the value.');\n\n  // We need to validate the value against all the object structs that match the\n  // struct key, and return the first validated value.\n  const validationResults = objectStructs.map((objectStruct) =>\n    validate(objectValue, objectStruct, { coerce }),\n  );\n\n  const validatedValue = validationResults.find(([error]) => !error);\n  if (validatedValue) {\n    return validatedValue[1];\n  }\n\n  assert(validationResults[0][0], 'Expected at least one error.');\n\n  // If there is no validated value, we need to find the error with the least\n  // number of failures (with the assumption that it's the most specific error).\n  const validationError = validationResults.reduce((error, [innerError]) => {\n    assert(innerError, 'Expected an error.');\n    if (innerError.failures().length < error.failures().length) {\n      return innerError;\n    }\n\n    return error;\n  }, validationResults[0][0]);\n\n  throw new Error(\n    getStructFailureMessage(struct, validationError.failures()[0], false),\n  );\n}\n\n/**\n * Create a value with the coercion logic of a union struct, and throw readable\n * errors if the value does not satisfy the struct. This is useful for improving\n * the error messages returned by `superstruct`.\n *\n * @param value - The value to validate.\n * @param struct - The `superstruct` union struct to validate the value against.\n * This struct must be a union of object structs, and must have at least one\n * shared key to validate against.\n * @param structKey - The key to validate against. This key must be present in\n * all the object structs in the union struct, and is expected to be a literal\n * value.\n * @returns The validated value.\n * @throws If the value does not satisfy the struct.\n * @see validateUnion\n */\nexport function createUnion<Type, Schema extends readonly Struct<any, any>[]>(\n  value: unknown,\n  struct: Struct<Type, Schema>,\n  structKey: keyof Type,\n) {\n  return validateUnion(value, struct, structKey, true);\n}\n\n// These types are copied from Superstruct, to mirror `assign`.\nexport function mergeStructs<\n  ObjectA extends ObjectSchema,\n  ObjectB extends ObjectSchema,\n>(\n  A: Struct<ObjectType<ObjectA>, ObjectA>,\n  B: Struct<ObjectType<ObjectB>, ObjectB>,\n): Struct<ObjectType<Assign<ObjectA, ObjectB>>, Assign<ObjectA, ObjectB>>;\nexport function mergeStructs<\n  ObjectA extends ObjectSchema,\n  ObjectB extends ObjectSchema,\n  ObjectC extends ObjectSchema,\n>(\n  A: Struct<ObjectType<ObjectA>, ObjectA>,\n  B: Struct<ObjectType<ObjectB>, ObjectB>,\n  C: Struct<ObjectType<ObjectC>, ObjectC>,\n): Struct<\n  ObjectType<Assign<Assign<ObjectA, ObjectB>, ObjectC>>,\n  Assign<Assign<ObjectA, ObjectB>, ObjectC>\n>;\nexport function mergeStructs<\n  ObjectA extends ObjectSchema,\n  ObjectB extends ObjectSchema,\n  ObjectC extends ObjectSchema,\n  ObjectD extends ObjectSchema,\n>(\n  A: Struct<ObjectType<ObjectA>, ObjectA>,\n  B: Struct<ObjectType<ObjectB>, ObjectB>,\n  C: Struct<ObjectType<ObjectC>, ObjectC>,\n  D: Struct<ObjectType<ObjectD>, ObjectD>,\n): Struct<\n  ObjectType<Assign<Assign<Assign<ObjectA, ObjectB>, ObjectC>, ObjectD>>,\n  Assign<Assign<Assign<ObjectA, ObjectB>, ObjectC>, ObjectD>\n>;\nexport function mergeStructs<\n  ObjectA extends ObjectSchema,\n  ObjectB extends ObjectSchema,\n  ObjectC extends ObjectSchema,\n  ObjectD extends ObjectSchema,\n  ObjectE extends ObjectSchema,\n>(\n  A: Struct<ObjectType<ObjectA>, ObjectA>,\n  B: Struct<ObjectType<ObjectB>, ObjectB>,\n  C: Struct<ObjectType<ObjectC>, ObjectC>,\n  D: Struct<ObjectType<ObjectD>, ObjectD>,\n  E: Struct<ObjectType<ObjectE>, ObjectE>,\n): Struct<\n  ObjectType<\n    Assign<Assign<Assign<Assign<ObjectA, ObjectB>, ObjectC>, ObjectD>, ObjectE>\n  >,\n  Assign<Assign<Assign<Assign<ObjectA, ObjectB>, ObjectC>, ObjectD>, ObjectE>\n>;\n\n/**\n * Merge multiple structs into one, using superstruct `assign`.\n *\n * Differently from plain `assign`, this function also copies over refinements from each struct.\n *\n * @param structs - The `superstruct` structs to merge.\n * @returns The merged struct.\n */\nexport function mergeStructs(...structs: Struct<any>[]): Struct<any> {\n  const mergedStruct = (assign as (...structs: Struct<any>[]) => Struct)(\n    ...structs,\n  );\n  return new Struct({\n    ...mergedStruct,\n    *refiner(value, ctx) {\n      for (const struct of structs) {\n        yield* struct.refiner(value, ctx);\n      }\n    },\n  });\n}\n"]}
\ No newline at end of file
+{
+    "version": 3,
+    "sources": [
+        "../src/structs.ts"
+    ],
+    "names": [],
+    "mappings": "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",
+    "sourcesContent": [
+        "import { union } from '@metamask/snaps-sdk';\nimport type { NonEmptyArray } from '@metamask/utils';\nimport { assert, isObject } from '@metamask/utils';\nimport { bold, green, red } from 'chalk';\nimport type { Failure } from '@metamask/superstruct';\nimport {\n  is,\n  validate,\n  type as superstructType,\n  Struct,\n  StructError,\n  create,\n  assign,\n} from '@metamask/superstruct';\nimport type {\n  AnyStruct,\n  Assign,\n  ObjectSchema,\n  ObjectType,\n} from '@metamask/superstruct';\n\nimport { indent } from './strings';\n\n/**\n * Infer a struct type, only if it matches the specified type. This is useful\n * for defining types and structs that are related to each other in separate\n * files.\n *\n * @example\n * ```typescript\n * // In file A\n * export type GetFileArgs = {\n *   path: string;\n *   encoding?: EnumToUnion<AuxiliaryFileEncoding>;\n * };\n *\n * // In file B\n * export const GetFileArgsStruct = object(...);\n *\n * // If the type and struct are in the same file, this will return the type.\n * // Otherwise, it will return `never`.\n * export type GetFileArgs =\n *   InferMatching<typeof GetFileArgsStruct, GetFileArgs>;\n * ```\n */\nexport type InferMatching<\n  StructType extends Struct<any, any>,\n  Type,\n> = StructType['TYPE'] extends Type ? Type : never;\n\n/**\n * Colorize a value with a color function. This is useful for colorizing values\n * in error messages. If colorization is disabled, the original value is\n * returned.\n *\n * @param value - The value to colorize.\n * @param colorFunction - The color function to use.\n * @param enabled - Whether to colorize the value.\n * @returns The colorized value, or the original value if colorization is\n * disabled.\n */\nfunction color(\n  value: string,\n  colorFunction: (value: string) => string,\n  enabled: boolean,\n) {\n  if (enabled) {\n    return colorFunction(value);\n  }\n\n  return value;\n}\n\n/**\n * Define a struct, and also define the name of the struct as the given name.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n *\n * @param name - The name of the struct.\n * @param struct - The struct.\n * @returns The struct.\n */\nexport function named<Type, Schema>(\n  name: string,\n  struct: Struct<Type, Schema>,\n) {\n  return new Struct({\n    ...struct,\n    type: name,\n  });\n}\n\nexport class SnapsStructError<Type, Schema> extends StructError {\n  constructor(\n    struct: Struct<Type, Schema>,\n    prefix: string,\n    suffix: string,\n    failure: StructError,\n    failures: () => Generator<Failure>,\n    colorize = true,\n  ) {\n    super(failure, failures);\n\n    this.name = 'SnapsStructError';\n    this.message = `${prefix}.\\n\\n${getStructErrorMessage(\n      struct,\n      [...failures()],\n      colorize,\n    )}${suffix ? `\\n\\n${suffix}` : ''}`;\n  }\n}\n\ntype GetErrorOptions<Type, Schema> = {\n  struct: Struct<Type, Schema>;\n  prefix: string;\n  suffix?: string;\n  error: StructError;\n  colorize?: boolean;\n};\n\n/**\n * Converts an array to a generator function that yields the items in the\n * array.\n *\n * @param array - The array.\n * @returns A generator function.\n * @yields The items in the array.\n */\nexport function* arrayToGenerator<Type>(\n  array: Type[],\n): Generator<Type, void, undefined> {\n  for (const item of array) {\n    yield item;\n  }\n}\n\n/**\n * Returns a `SnapsStructError` with the given prefix and suffix.\n *\n * @param options - The options.\n * @param options.struct - The struct that caused the error.\n * @param options.prefix - The prefix to add to the error message.\n * @param options.suffix - The suffix to add to the error message. Defaults to\n * an empty string.\n * @param options.error - The `superstruct` error to wrap.\n * @param options.colorize - Whether to colorize the value. Defaults to `true`.\n * @returns The `SnapsStructError`.\n */\nexport function getError<Type, Schema>({\n  struct,\n  prefix,\n  suffix = '',\n  error,\n  colorize,\n}: GetErrorOptions<Type, Schema>) {\n  return new SnapsStructError(\n    struct,\n    prefix,\n    suffix,\n    error,\n    () => arrayToGenerator(error.failures()),\n    colorize,\n  );\n}\n\n/**\n * A wrapper of `superstruct`'s `create` function that throws a\n * `SnapsStructError` instead of a `StructError`. This is useful for improving\n * the error messages returned by `superstruct`.\n *\n * @param value - The value to validate.\n * @param struct - The `superstruct` struct to validate the value against.\n * @param prefix - The prefix to add to the error message.\n * @param suffix - The suffix to add to the error message. Defaults to an empty\n * string.\n * @returns The validated value.\n */\nexport function createFromStruct<Type, Schema>(\n  value: unknown,\n  struct: Struct<Type, Schema>,\n  prefix: string,\n  suffix = '',\n) {\n  try {\n    return create(value, struct);\n  } catch (error) {\n    if (error instanceof StructError) {\n      throw getError({ struct, prefix, suffix, error });\n    }\n\n    throw error;\n  }\n}\n\n/**\n * Get a struct from a failure path.\n *\n * @param struct - The struct.\n * @param path - The failure path.\n * @returns The struct at the failure path.\n */\nexport function getStructFromPath<Type, Schema>(\n  struct: Struct<Type, Schema>,\n  path: string[],\n) {\n  return path.reduce<AnyStruct>((result, key) => {\n    if (isObject(struct.schema) && struct.schema[key]) {\n      return struct.schema[key] as AnyStruct;\n    }\n\n    return result;\n  }, struct);\n}\n\n/**\n * Get the union struct names from a struct.\n *\n * @param struct - The struct.\n * @param colorize - Whether to colorize the value. Defaults to `true`.\n * @returns The union struct names, or `null` if the struct is not a union\n * struct.\n */\nexport function getUnionStructNames<Type, Schema>(\n  struct: Struct<Type, Schema>,\n  colorize = true,\n) {\n  if (Array.isArray(struct.schema)) {\n    return struct.schema.map(({ type }) => color(type, green, colorize));\n  }\n\n  return null;\n}\n\n/**\n * Get an error prefix from a `superstruct` failure. This is useful for\n * formatting the error message returned by `superstruct`.\n *\n * @param failure - The `superstruct` failure.\n * @param colorize - Whether to colorize the value. Defaults to `true`.\n * @returns The error prefix.\n */\nexport function getStructErrorPrefix(failure: Failure, colorize = true) {\n  if (failure.type === 'never' || failure.path.length === 0) {\n    return '';\n  }\n\n  return `At path: ${color(failure.path.join('.'), bold, colorize)}  `;\n}\n\n/**\n * Get a string describing the failure. This is similar to the `message`\n * property of `superstruct`'s `Failure` type, but formats the value in a more\n * readable way.\n *\n * @param struct - The struct that caused the failure.\n * @param failure - The `superstruct` failure.\n * @param colorize - Whether to colorize the value. Defaults to `true`.\n * @returns A string describing the failure.\n */\nexport function getStructFailureMessage<Type, Schema>(\n  struct: Struct<Type, Schema>,\n  failure: Failure,\n  colorize = true,\n) {\n  const received = color(JSON.stringify(failure.value), red, colorize);\n  const prefix = getStructErrorPrefix(failure, colorize);\n\n  if (failure.type === 'union') {\n    const childStruct = getStructFromPath(struct, failure.path);\n    const unionNames = getUnionStructNames(childStruct, colorize);\n\n    if (unionNames) {\n      return `${prefix}Expected the value to be one of: ${unionNames.join(\n        ', ',\n      )}, but received: ${received}.`;\n    }\n\n    return `${prefix}${failure.message}.`;\n  }\n\n  if (failure.type === 'literal') {\n    // Superstruct's failure does not provide information about which literal\n    // value was expected, so we need to parse the message to get the literal.\n    const message = failure.message\n      .replace(\n        /the literal `(.+)`,/u,\n        `the value to be \\`${color('$1', green, colorize)}\\`,`,\n      )\n      .replace(\n        /, but received: (.+)/u,\n        `, but received: ${color('$1', red, colorize)}`,\n      );\n\n    return `${prefix}${message}.`;\n  }\n\n  if (failure.type === 'never') {\n    return `Unknown key: ${color(\n      failure.path.join('.'),\n      bold,\n      colorize,\n    )}, received: ${received}.`;\n  }\n\n  if (failure.refinement === 'size') {\n    const message = failure.message\n      .replace(\n        /length between `(\\d+)` and `(\\d+)`/u,\n        `length between ${color('$1', green, colorize)} and ${color(\n          '$2',\n          green,\n          colorize,\n        )},`,\n      )\n      .replace(/length of `(\\d+)`/u, `length of ${color('$1', red, colorize)}`)\n      .replace(/a array/u, 'an array');\n\n    return `${prefix}${message}.`;\n  }\n\n  return `${prefix}Expected a value of type ${color(\n    failure.type,\n    green,\n    colorize,\n  )}, but received: ${received}.`;\n}\n\n/**\n * Get a string describing the errors. This formats all the errors in a\n * human-readable way.\n *\n * @param struct - The struct that caused the failures.\n * @param failures - The `superstruct` failures.\n * @param colorize - Whether to colorize the value. Defaults to `true`.\n * @returns A string describing the errors.\n */\nexport function getStructErrorMessage<Type, Schema>(\n  struct: Struct<Type, Schema>,\n  failures: Failure[],\n  colorize = true,\n) {\n  const formattedFailures = failures.map((failure) =>\n    indent(` ${getStructFailureMessage(struct, failure, colorize)}`),\n  );\n\n  return formattedFailures.join('\\n');\n}\n\n/**\n * Validate a union struct, and throw readable errors if the value does not\n * satisfy the struct. This is useful for improving the error messages returned\n * by `superstruct`.\n *\n * @param value - The value to validate.\n * @param struct - The `superstruct` union struct to validate the value against.\n * This struct must be a union of object structs, and must have at least one\n * shared key to validate against.\n * @param structKey - The key to validate against. This key must be present in\n * all the object structs in the union struct, and is expected to be a literal\n * value.\n * @param coerce - Whether to coerce the value to satisfy the struct. Defaults\n * to `false`.\n * @returns The validated value.\n * @throws If the value does not satisfy the struct.\n * @example\n * const struct = union([\n *   object({ type: literal('a'), value: string() }),\n *   object({ type: literal('b'), value: number() }),\n *   object({ type: literal('c'), value: boolean() }),\n *   // ...\n * ]);\n *\n * // At path: type  Expected the value to be one of: \"a\", \"b\", \"c\", but received: \"d\".\n * validateUnion({ type: 'd', value: 'foo' }, struct, 'type');\n *\n * // At path: value  Expected a value of type string, but received: 42.\n * validateUnion({ type: 'a', value: 42 }, struct, 'value');\n */\nexport function validateUnion<Type, Schema extends readonly Struct<any, any>[]>(\n  value: unknown,\n  struct: Struct<Type, Schema>,\n  structKey: keyof Type,\n  coerce = false,\n) {\n  assert(\n    struct.schema,\n    'Expected a struct with a schema. Make sure to use `union` from `@metamask/snaps-sdk`.',\n  );\n  assert(struct.schema.length > 0, 'Expected a non-empty array of structs.');\n\n  const keyUnion = struct.schema.map(\n    (innerStruct) => innerStruct.schema[structKey],\n    // This is guaranteed to be a non-empty array by the assertion above. We\n    // need to cast it since `superstruct` requires a non-empty array of structs\n    // for the `union` struct.\n  ) as NonEmptyArray<Struct>;\n\n  const key = superstructType({\n    [structKey]: union(keyUnion),\n  });\n\n  const [keyError] = validate(value, key, { coerce });\n  if (keyError) {\n    throw new Error(\n      getStructFailureMessage(key, keyError.failures()[0], false),\n    );\n  }\n\n  // At this point it's guaranteed that the value is an object, so we can safely\n  // cast it to a Record.\n  const objectValue = value as Record<PropertyKey, unknown>;\n  const objectStructs = struct.schema.filter((innerStruct) =>\n    is(objectValue[structKey], innerStruct.schema[structKey]),\n  );\n\n  assert(objectStructs.length > 0, 'Expected a struct to match the value.');\n\n  // We need to validate the value against all the object structs that match the\n  // struct key, and return the first validated value.\n  const validationResults = objectStructs.map((objectStruct) =>\n    validate(objectValue, objectStruct, { coerce }),\n  );\n\n  const validatedValue = validationResults.find(([error]) => !error);\n  if (validatedValue) {\n    return validatedValue[1];\n  }\n\n  assert(validationResults[0][0], 'Expected at least one error.');\n\n  // If there is no validated value, we need to find the error with the least\n  // number of failures (with the assumption that it's the most specific error).\n  const validationError = validationResults.reduce((error, [innerError]) => {\n    assert(innerError, 'Expected an error.');\n    if (innerError.failures().length < error.failures().length) {\n      return innerError;\n    }\n\n    return error;\n  }, validationResults[0][0]);\n\n  throw new Error(\n    getStructFailureMessage(struct, validationError.failures()[0], false),\n  );\n}\n\n/**\n * Create a value with the coercion logic of a union struct, and throw readable\n * errors if the value does not satisfy the struct. This is useful for improving\n * the error messages returned by `superstruct`.\n *\n * @param value - The value to validate.\n * @param struct - The `superstruct` union struct to validate the value against.\n * This struct must be a union of object structs, and must have at least one\n * shared key to validate against.\n * @param structKey - The key to validate against. This key must be present in\n * all the object structs in the union struct, and is expected to be a literal\n * value.\n * @returns The validated value.\n * @throws If the value does not satisfy the struct.\n * @see validateUnion\n */\nexport function createUnion<Type, Schema extends readonly Struct<any, any>[]>(\n  value: unknown,\n  struct: Struct<Type, Schema>,\n  structKey: keyof Type,\n) {\n  return validateUnion(value, struct, structKey, true);\n}\n\n// These types are copied from Superstruct, to mirror `assign`.\nexport function mergeStructs<\n  ObjectA extends ObjectSchema,\n  ObjectB extends ObjectSchema,\n>(\n  A: Struct<ObjectType<ObjectA>, ObjectA>,\n  B: Struct<ObjectType<ObjectB>, ObjectB>,\n): Struct<ObjectType<Assign<ObjectA, ObjectB>>, Assign<ObjectA, ObjectB>>;\nexport function mergeStructs<\n  ObjectA extends ObjectSchema,\n  ObjectB extends ObjectSchema,\n  ObjectC extends ObjectSchema,\n>(\n  A: Struct<ObjectType<ObjectA>, ObjectA>,\n  B: Struct<ObjectType<ObjectB>, ObjectB>,\n  C: Struct<ObjectType<ObjectC>, ObjectC>,\n): Struct<\n  ObjectType<Assign<Assign<ObjectA, ObjectB>, ObjectC>>,\n  Assign<Assign<ObjectA, ObjectB>, ObjectC>\n>;\nexport function mergeStructs<\n  ObjectA extends ObjectSchema,\n  ObjectB extends ObjectSchema,\n  ObjectC extends ObjectSchema,\n  ObjectD extends ObjectSchema,\n>(\n  A: Struct<ObjectType<ObjectA>, ObjectA>,\n  B: Struct<ObjectType<ObjectB>, ObjectB>,\n  C: Struct<ObjectType<ObjectC>, ObjectC>,\n  D: Struct<ObjectType<ObjectD>, ObjectD>,\n): Struct<\n  ObjectType<Assign<Assign<Assign<ObjectA, ObjectB>, ObjectC>, ObjectD>>,\n  Assign<Assign<Assign<ObjectA, ObjectB>, ObjectC>, ObjectD>\n>;\nexport function mergeStructs<\n  ObjectA extends ObjectSchema,\n  ObjectB extends ObjectSchema,\n  ObjectC extends ObjectSchema,\n  ObjectD extends ObjectSchema,\n  ObjectE extends ObjectSchema,\n>(\n  A: Struct<ObjectType<ObjectA>, ObjectA>,\n  B: Struct<ObjectType<ObjectB>, ObjectB>,\n  C: Struct<ObjectType<ObjectC>, ObjectC>,\n  D: Struct<ObjectType<ObjectD>, ObjectD>,\n  E: Struct<ObjectType<ObjectE>, ObjectE>,\n): Struct<\n  ObjectType<\n    Assign<Assign<Assign<Assign<ObjectA, ObjectB>, ObjectC>, ObjectD>, ObjectE>\n  >,\n  Assign<Assign<Assign<Assign<ObjectA, ObjectB>, ObjectC>, ObjectD>, ObjectE>\n>;\n\n/**\n * Merge multiple structs into one, using superstruct `assign`.\n *\n * Differently from plain `assign`, this function also copies over refinements from each struct.\n *\n * @param structs - The `superstruct` structs to merge.\n * @returns The merged struct.\n */\nexport function mergeStructs(...structs: Struct<any>[]): Struct<any> {\n  const mergedStruct = (assign as (...structs: Struct<any>[]) => Struct)(\n    ...structs,\n  );\n  return new Struct({\n    ...mergedStruct,\n    *refiner(value, ctx) {\n      for (const struct of structs) {\n        yield* struct.refiner(value, ctx);\n      }\n    },\n  });\n}\n"
+    ]
+}
\ No newline at end of file
diff --git a/dist/chunk-I4TRH6VO.mjs.map b/dist/chunk-I4TRH6VO.mjs.map
index 5d7641083396d9fa2a352e4a62afa213975e00a1..64ca8fe5a65a041316a740aba0cc9adbf0db2895 100644
--- a/dist/chunk-I4TRH6VO.mjs.map
+++ b/dist/chunk-I4TRH6VO.mjs.map
@@ -1 +1 @@
-{"version":3,"sources":["../src/handlers.ts"],"sourcesContent":["import type {\n  OnCronjobHandler,\n  OnHomePageHandler,\n  OnInstallHandler,\n  OnKeyringRequestHandler,\n  OnNameLookupHandler,\n  OnRpcRequestHandler,\n  OnSignatureHandler,\n  OnTransactionHandler,\n  OnUpdateHandler,\n  OnUserInputHandler,\n} from '@metamask/snaps-sdk';\nimport { ComponentOrElementStruct, SeverityLevel } from '@metamask/snaps-sdk';\nimport {\n  assign,\n  literal,\n  nullable,\n  object,\n  optional,\n  string,\n  array,\n  size,\n  union,\n} from 'superstruct';\n\nimport type { SnapHandler } from './handler-types';\nimport { HandlerType } from './handler-types';\n\nexport type SnapRpcHookArgs = {\n  origin: string;\n  handler: HandlerType;\n  request: Record<string, unknown>;\n};\n\nexport const SNAP_EXPORTS = {\n  [HandlerType.OnRpcRequest]: {\n    type: HandlerType.OnRpcRequest,\n    required: true,\n    validator: (snapExport: unknown): snapExport is OnRpcRequestHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n  [HandlerType.OnTransaction]: {\n    type: HandlerType.OnTransaction,\n    required: true,\n    validator: (snapExport: unknown): snapExport is OnTransactionHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n  [HandlerType.OnCronjob]: {\n    type: HandlerType.OnCronjob,\n    required: true,\n    validator: (snapExport: unknown): snapExport is OnCronjobHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n  [HandlerType.OnNameLookup]: {\n    type: HandlerType.OnNameLookup,\n    required: true,\n    validator: (snapExport: unknown): snapExport is OnNameLookupHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n  [HandlerType.OnInstall]: {\n    type: HandlerType.OnInstall,\n    required: false,\n    validator: (snapExport: unknown): snapExport is OnInstallHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n  [HandlerType.OnUpdate]: {\n    type: HandlerType.OnUpdate,\n    required: false,\n    validator: (snapExport: unknown): snapExport is OnUpdateHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n  [HandlerType.OnKeyringRequest]: {\n    type: HandlerType.OnKeyringRequest,\n    required: true,\n    validator: (snapExport: unknown): snapExport is OnKeyringRequestHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n  [HandlerType.OnHomePage]: {\n    type: HandlerType.OnHomePage,\n    required: true,\n    validator: (snapExport: unknown): snapExport is OnHomePageHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n  [HandlerType.OnSignature]: {\n    type: HandlerType.OnSignature,\n    required: true,\n    validator: (snapExport: unknown): snapExport is OnSignatureHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n  [HandlerType.OnUserInput]: {\n    type: HandlerType.OnUserInput,\n    required: false,\n    validator: (snapExport: unknown): snapExport is OnUserInputHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n} as const;\n\nexport const OnTransactionSeverityResponseStruct = object({\n  severity: optional(literal(SeverityLevel.Critical)),\n});\n\nexport const OnTransactionResponseWithIdStruct = assign(\n  OnTransactionSeverityResponseStruct,\n  object({\n    id: string(),\n  }),\n);\n\nexport const OnTransactionResponseWithContentStruct = assign(\n  OnTransactionSeverityResponseStruct,\n  object({\n    content: ComponentOrElementStruct,\n  }),\n);\n\nexport const OnTransactionResponseStruct = nullable(\n  union([\n    OnTransactionResponseWithContentStruct,\n    OnTransactionResponseWithIdStruct,\n  ]),\n);\n\nexport const OnSignatureResponseStruct = OnTransactionResponseStruct;\n\nexport const OnHomePageResponseWithContentStruct = object({\n  content: ComponentOrElementStruct,\n});\n\nexport const OnHomePageResponseWithIdStruct = object({\n  id: string(),\n});\n\nexport const OnHomePageResponseStruct = union([\n  OnHomePageResponseWithContentStruct,\n  OnHomePageResponseWithIdStruct,\n]);\n\nexport const AddressResolutionStruct = object({\n  protocol: string(),\n  resolvedDomain: string(),\n});\n\nexport const DomainResolutionStruct = object({\n  protocol: string(),\n  resolvedAddress: string(),\n  domainName: string(),\n});\n\nexport const AddressResolutionResponseStruct = object({\n  resolvedDomains: size(array(AddressResolutionStruct), 1, Infinity),\n});\n\nexport const DomainResolutionResponseStruct = object({\n  resolvedAddresses: size(array(DomainResolutionStruct), 1, Infinity),\n});\n\nexport const OnNameLookupResponseStruct = nullable(\n  union([AddressResolutionResponseStruct, DomainResolutionResponseStruct]),\n);\n\n/**\n * Utility type for getting the handler function type from a handler type.\n */\nexport type HandlerFunction<Type extends SnapHandler> =\n  Type['validator'] extends (snapExport: unknown) => snapExport is infer Handler\n    ? Handler\n    : never;\n\n/**\n * All the function-based handlers that a snap can implement.\n */\nexport type SnapFunctionExports = {\n  [Key in keyof typeof SNAP_EXPORTS]?: HandlerFunction<\n    (typeof SNAP_EXPORTS)[Key]\n  >;\n};\n\n/**\n * All handlers that a snap can implement.\n */\nexport type SnapExports = SnapFunctionExports;\n"],"mappings":"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","names":[]}
\ No newline at end of file
+{"version":3,"sources":["../src/handlers.ts"],"sourcesContent":["import type {\n  OnCronjobHandler,\n  OnHomePageHandler,\n  OnInstallHandler,\n  OnKeyringRequestHandler,\n  OnNameLookupHandler,\n  OnRpcRequestHandler,\n  OnSignatureHandler,\n  OnTransactionHandler,\n  OnUpdateHandler,\n  OnUserInputHandler,\n} from '@metamask/snaps-sdk';\nimport { ComponentOrElementStruct, SeverityLevel } from '@metamask/snaps-sdk';\nimport {\n  assign,\n  literal,\n  nullable,\n  object,\n  optional,\n  string,\n  array,\n  size,\n  union,\n} from '@metamask/superstruct';\n\nimport type { SnapHandler } from './handler-types';\nimport { HandlerType } from './handler-types';\n\nexport type SnapRpcHookArgs = {\n  origin: string;\n  handler: HandlerType;\n  request: Record<string, unknown>;\n};\n\nexport const SNAP_EXPORTS = {\n  [HandlerType.OnRpcRequest]: {\n    type: HandlerType.OnRpcRequest,\n    required: true,\n    validator: (snapExport: unknown): snapExport is OnRpcRequestHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n  [HandlerType.OnTransaction]: {\n    type: HandlerType.OnTransaction,\n    required: true,\n    validator: (snapExport: unknown): snapExport is OnTransactionHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n  [HandlerType.OnCronjob]: {\n    type: HandlerType.OnCronjob,\n    required: true,\n    validator: (snapExport: unknown): snapExport is OnCronjobHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n  [HandlerType.OnNameLookup]: {\n    type: HandlerType.OnNameLookup,\n    required: true,\n    validator: (snapExport: unknown): snapExport is OnNameLookupHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n  [HandlerType.OnInstall]: {\n    type: HandlerType.OnInstall,\n    required: false,\n    validator: (snapExport: unknown): snapExport is OnInstallHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n  [HandlerType.OnUpdate]: {\n    type: HandlerType.OnUpdate,\n    required: false,\n    validator: (snapExport: unknown): snapExport is OnUpdateHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n  [HandlerType.OnKeyringRequest]: {\n    type: HandlerType.OnKeyringRequest,\n    required: true,\n    validator: (snapExport: unknown): snapExport is OnKeyringRequestHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n  [HandlerType.OnHomePage]: {\n    type: HandlerType.OnHomePage,\n    required: true,\n    validator: (snapExport: unknown): snapExport is OnHomePageHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n  [HandlerType.OnSignature]: {\n    type: HandlerType.OnSignature,\n    required: true,\n    validator: (snapExport: unknown): snapExport is OnSignatureHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n  [HandlerType.OnUserInput]: {\n    type: HandlerType.OnUserInput,\n    required: false,\n    validator: (snapExport: unknown): snapExport is OnUserInputHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n} as const;\n\nexport const OnTransactionSeverityResponseStruct = object({\n  severity: optional(literal(SeverityLevel.Critical)),\n});\n\nexport const OnTransactionResponseWithIdStruct = assign(\n  OnTransactionSeverityResponseStruct,\n  object({\n    id: string(),\n  }),\n);\n\nexport const OnTransactionResponseWithContentStruct = assign(\n  OnTransactionSeverityResponseStruct,\n  object({\n    content: ComponentOrElementStruct,\n  }),\n);\n\nexport const OnTransactionResponseStruct = nullable(\n  union([\n    OnTransactionResponseWithContentStruct,\n    OnTransactionResponseWithIdStruct,\n  ]),\n);\n\nexport const OnSignatureResponseStruct = OnTransactionResponseStruct;\n\nexport const OnHomePageResponseWithContentStruct = object({\n  content: ComponentOrElementStruct,\n});\n\nexport const OnHomePageResponseWithIdStruct = object({\n  id: string(),\n});\n\nexport const OnHomePageResponseStruct = union([\n  OnHomePageResponseWithContentStruct,\n  OnHomePageResponseWithIdStruct,\n]);\n\nexport const AddressResolutionStruct = object({\n  protocol: string(),\n  resolvedDomain: string(),\n});\n\nexport const DomainResolutionStruct = object({\n  protocol: string(),\n  resolvedAddress: string(),\n  domainName: string(),\n});\n\nexport const AddressResolutionResponseStruct = object({\n  resolvedDomains: size(array(AddressResolutionStruct), 1, Infinity),\n});\n\nexport const DomainResolutionResponseStruct = object({\n  resolvedAddresses: size(array(DomainResolutionStruct), 1, Infinity),\n});\n\nexport const OnNameLookupResponseStruct = nullable(\n  union([AddressResolutionResponseStruct, DomainResolutionResponseStruct]),\n);\n\n/**\n * Utility type for getting the handler function type from a handler type.\n */\nexport type HandlerFunction<Type extends SnapHandler> =\n  Type['validator'] extends (snapExport: unknown) => snapExport is infer Handler\n    ? Handler\n    : never;\n\n/**\n * All the function-based handlers that a snap can implement.\n */\nexport type SnapFunctionExports = {\n  [Key in keyof typeof SNAP_EXPORTS]?: HandlerFunction<\n    (typeof SNAP_EXPORTS)[Key]\n  >;\n};\n\n/**\n * All handlers that a snap can implement.\n */\nexport type SnapExports = SnapFunctionExports;\n"],"mappings":"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","names":[]}
\ No newline at end of file
diff --git a/dist/chunk-IPOE62V4.js.map b/dist/chunk-IPOE62V4.js.map
index ae0c17642528a2a26f624224291b4ef320640d4b..4453253634d79c30fea46a29340454f16f71c2ee 100644
--- a/dist/chunk-IPOE62V4.js.map
+++ b/dist/chunk-IPOE62V4.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../src/versions.ts"],"names":[],"mappings":";AACA,SAAS,0BAA0B;AACnC,SAAS,iBAAiB,2BAA2B;AACrD,SAAS,gBAAgB;AAElB,IAAM,iCAAiC;AAYvC,SAAS,iBACd,UACA,cACsB;AACtB,QAAM,6BAA6B;AAAA,IACjC;AAAA,IACA;AAAA,EACF;AAGA,MAAI,4BAA4B;AAC9B,WAAO;AAAA,EACT;AAGA,SAAO,oBAAoB,UAAU,cAAc;AAAA,IACjD,mBAAmB;AAAA,EACrB,CAAC;AACH;AASO,SAAS,oBACd,SAC2E;AAC3E,MAAI,YAAY,UAAa,YAAY,UAAU;AACjD,WAAO,CAAC,QAAW,8BAA8B;AAAA,EACnD;AACA,SAAO,SAAS,SAAS,kBAAkB;AAC7C","sourcesContent":["import type { Json, SemVerVersion, SemVerRange } from '@metamask/utils';\nimport { VersionRangeStruct } from '@metamask/utils';\nimport { maxSatisfying as maxSatisfyingSemver } from 'semver';\nimport { validate } from 'superstruct';\n\nexport const DEFAULT_REQUESTED_SNAP_VERSION = '*' as SemVerRange;\n\n/**\n * Return the highest version in the list that satisfies the range, or `null` if\n * none of them do. For the satisfaction check, pre-release versions will only\n * be checked if no satisfactory non-prerelease version is found first.\n *\n * @param versions - The list of version to check.\n * @param versionRange - The SemVer version range to check against.\n * @returns The highest version in the list that satisfies the range,\n * or `null` if none of them do.\n */\nexport function getTargetVersion(\n  versions: SemVerVersion[],\n  versionRange: SemVerRange,\n): SemVerVersion | null {\n  const maxSatisfyingNonPreRelease = maxSatisfyingSemver(\n    versions,\n    versionRange,\n  );\n\n  // By default don't use pre-release versions\n  if (maxSatisfyingNonPreRelease) {\n    return maxSatisfyingNonPreRelease;\n  }\n\n  // If no satisfying release version is found by default, try pre-release versions\n  return maxSatisfyingSemver(versions, versionRange, {\n    includePrerelease: true,\n  });\n}\n\n/**\n * Parse a version received by some subject attempting to access a snap.\n *\n * @param version - The received version value.\n * @returns `*` if the version is `undefined` or `latest\", otherwise returns\n * the specified version.\n */\nexport function resolveVersionRange(\n  version?: Json,\n): [error: undefined, range: SemVerRange] | [error: Error, range: undefined] {\n  if (version === undefined || version === 'latest') {\n    return [undefined, DEFAULT_REQUESTED_SNAP_VERSION];\n  }\n  return validate(version, VersionRangeStruct);\n}\n"]}
\ No newline at end of file
+{"version":3,"sources":["../src/versions.ts"],"names":[],"mappings":";AACA,SAAS,0BAA0B;AACnC,SAAS,iBAAiB,2BAA2B;AACrD,SAAS,gBAAgB;AAElB,IAAM,iCAAiC;AAYvC,SAAS,iBACd,UACA,cACsB;AACtB,QAAM,6BAA6B;AAAA,IACjC;AAAA,IACA;AAAA,EACF;AAGA,MAAI,4BAA4B;AAC9B,WAAO;AAAA,EACT;AAGA,SAAO,oBAAoB,UAAU,cAAc;AAAA,IACjD,mBAAmB;AAAA,EACrB,CAAC;AACH;AASO,SAAS,oBACd,SAC2E;AAC3E,MAAI,YAAY,UAAa,YAAY,UAAU;AACjD,WAAO,CAAC,QAAW,8BAA8B;AAAA,EACnD;AACA,SAAO,SAAS,SAAS,kBAAkB;AAC7C","sourcesContent":["import type { Json, SemVerVersion, SemVerRange } from '@metamask/utils';\nimport { VersionRangeStruct } from '@metamask/utils';\nimport { maxSatisfying as maxSatisfyingSemver } from 'semver';\nimport { validate } from '@metamask/superstruct';\n\nexport const DEFAULT_REQUESTED_SNAP_VERSION = '*' as SemVerRange;\n\n/**\n * Return the highest version in the list that satisfies the range, or `null` if\n * none of them do. For the satisfaction check, pre-release versions will only\n * be checked if no satisfactory non-prerelease version is found first.\n *\n * @param versions - The list of version to check.\n * @param versionRange - The SemVer version range to check against.\n * @returns The highest version in the list that satisfies the range,\n * or `null` if none of them do.\n */\nexport function getTargetVersion(\n  versions: SemVerVersion[],\n  versionRange: SemVerRange,\n): SemVerVersion | null {\n  const maxSatisfyingNonPreRelease = maxSatisfyingSemver(\n    versions,\n    versionRange,\n  );\n\n  // By default don't use pre-release versions\n  if (maxSatisfyingNonPreRelease) {\n    return maxSatisfyingNonPreRelease;\n  }\n\n  // If no satisfying release version is found by default, try pre-release versions\n  return maxSatisfyingSemver(versions, versionRange, {\n    includePrerelease: true,\n  });\n}\n\n/**\n * Parse a version received by some subject attempting to access a snap.\n *\n * @param version - The received version value.\n * @returns `*` if the version is `undefined` or `latest\", otherwise returns\n * the specified version.\n */\nexport function resolveVersionRange(\n  version?: Json,\n): [error: undefined, range: SemVerRange] | [error: Error, range: undefined] {\n  if (version === undefined || version === 'latest') {\n    return [undefined, DEFAULT_REQUESTED_SNAP_VERSION];\n  }\n  return validate(version, VersionRangeStruct);\n}\n"]}
\ No newline at end of file
diff --git a/dist/chunk-K2OTEZZZ.mjs.map b/dist/chunk-K2OTEZZZ.mjs.map
index b623c2ab78896142fbff273a9813822161439244..a9fcc0f68061a1d9df5235806eea7b4d0cfdbf50 100644
--- a/dist/chunk-K2OTEZZZ.mjs.map
+++ b/dist/chunk-K2OTEZZZ.mjs.map
@@ -1 +1 @@
-{"version":3,"sources":["../src/json-rpc.ts"],"sourcesContent":["import { SubjectType } from '@metamask/permission-controller';\nimport type {\n  AssertionErrorConstructor,\n  Json,\n  JsonRpcSuccess,\n} from '@metamask/utils';\nimport {\n  assertStruct,\n  isJsonRpcFailure,\n  isJsonRpcSuccess,\n} from '@metamask/utils';\nimport type { Infer } from 'superstruct';\nimport { array, boolean, object, optional, refine, string } from 'superstruct';\n\nconst AllowedOriginsStruct = array(\n  refine(string(), 'Allowed origin', (value) => {\n    const wildcards = value.split('*').length - 1;\n    if (wildcards > 2) {\n      return 'No more than two wildcards (\"*\") are allowed in an origin specifier.';\n    }\n\n    return true;\n  }),\n);\n\nexport const RpcOriginsStruct = refine(\n  object({\n    dapps: optional(boolean()),\n    snaps: optional(boolean()),\n    allowedOrigins: optional(AllowedOriginsStruct),\n  }),\n  'RPC origins',\n  (value) => {\n    const hasOrigins = Boolean(\n      value.snaps === true ||\n        value.dapps === true ||\n        (value.allowedOrigins && value.allowedOrigins.length > 0),\n    );\n\n    if (hasOrigins) {\n      return true;\n    }\n\n    return 'Must specify at least one JSON-RPC origin.';\n  },\n);\n\nexport type RpcOrigins = Infer<typeof RpcOriginsStruct>;\n\n/**\n * Asserts that the given value is a valid {@link RpcOrigins} object.\n *\n * @param value - The value to assert.\n * @param ErrorWrapper - An optional error wrapper to use. Defaults to\n * {@link AssertionError}.\n * @throws If the value is not a valid {@link RpcOrigins} object.\n */\nexport function assertIsRpcOrigins(\n  value: unknown,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper?: AssertionErrorConstructor,\n): asserts value is RpcOrigins {\n  assertStruct(\n    value,\n    RpcOriginsStruct,\n    'Invalid JSON-RPC origins',\n    ErrorWrapper,\n  );\n}\n\nexport const KeyringOriginsStruct = object({\n  allowedOrigins: optional(AllowedOriginsStruct),\n});\n\nexport type KeyringOrigins = Infer<typeof KeyringOriginsStruct>;\n\n/**\n * Assert that the given value is a valid {@link KeyringOrigins} object.\n *\n * @param value - The value to assert.\n * @param ErrorWrapper - An optional error wrapper to use. Defaults to\n * {@link AssertionError}.\n * @throws If the value is not a valid {@link KeyringOrigins} object.\n */\nexport function assertIsKeyringOrigins(\n  value: unknown,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper?: AssertionErrorConstructor,\n): asserts value is KeyringOrigins {\n  assertStruct(\n    value,\n    KeyringOriginsStruct,\n    'Invalid keyring origins',\n    ErrorWrapper,\n  );\n}\n\n/**\n * Create regular expression for matching against an origin while allowing wildcards.\n *\n * The \"*\" symbol is treated as a wildcard and will match 0 or more characters.\n *\n * @param matcher - The string to create the regular expression with.\n * @returns The regular expression.\n */\nfunction createOriginRegExp(matcher: string) {\n  // Escape potential Regex characters\n  const escaped = matcher.replace(/[.*+?^${}()|[\\]\\\\]/gu, '\\\\$&');\n  // Support wildcards\n  const regex = escaped.replace(/\\*/gu, '.*');\n  return RegExp(regex, 'u');\n}\n\n/**\n * Check whether an origin is allowed or not using a matcher string.\n *\n * The matcher string may be a specific origin to match or include wildcards.\n * The \"*\" symbol is treated as a wildcard and will match 0 or more characters.\n * Note: this means that https://*metamask.io matches both https://metamask.io\n * and https://snaps.metamask.io.\n *\n * @param matcher - The matcher string.\n * @param origin - The origin.\n * @returns Whether the origin is allowed.\n */\nfunction checkAllowedOrigin(matcher: string, origin: string) {\n  // If the matcher is a single wildcard or identical to the origin we can return true immediately.\n  if (matcher === '*' || matcher === origin) {\n    return true;\n  }\n\n  const regex = createOriginRegExp(matcher);\n  return regex.test(origin);\n}\n\n/**\n * Check if the given origin is allowed by the given JSON-RPC origins object.\n *\n * @param origins - The JSON-RPC origins object.\n * @param subjectType - The type of the origin.\n * @param origin - The origin to check.\n * @returns Whether the origin is allowed.\n */\nexport function isOriginAllowed(\n  origins: RpcOrigins,\n  subjectType: SubjectType,\n  origin: string,\n) {\n  // The MetaMask client is always allowed.\n  if (origin === 'metamask') {\n    return true;\n  }\n\n  // If the origin is in the `allowedOrigins` list, it is allowed.\n  if (\n    origins.allowedOrigins?.some((matcher) =>\n      checkAllowedOrigin(matcher, origin),\n    )\n  ) {\n    return true;\n  }\n\n  // If the origin is a website and `dapps` is true, it is allowed.\n  if (subjectType === SubjectType.Website && origins.dapps) {\n    return true;\n  }\n\n  // If the origin is a snap and `snaps` is true, it is allowed.\n  return Boolean(subjectType === SubjectType.Snap && origins.snaps);\n}\n\n/**\n * Assert that the given value is a successful JSON-RPC response. If the value\n * is not a success response, an error is thrown. If the value is an JSON-RPC\n * error, the error message is included in the thrown error.\n *\n * @param value - The value to check.\n * @throws If the value is not a JSON-RPC success response.\n */\nexport function assertIsJsonRpcSuccess(\n  value: unknown,\n): asserts value is JsonRpcSuccess<Json> {\n  if (!isJsonRpcSuccess(value)) {\n    if (isJsonRpcFailure(value)) {\n      throw new Error(`JSON-RPC request failed: ${value.error.message}`);\n    }\n\n    throw new Error('Invalid JSON-RPC response.');\n  }\n}\n"],"mappings":";AAAA,SAAS,mBAAmB;AAM5B;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAEP,SAAS,OAAO,SAAS,QAAQ,UAAU,QAAQ,cAAc;AAEjE,IAAM,uBAAuB;AAAA,EAC3B,OAAO,OAAO,GAAG,kBAAkB,CAAC,UAAU;AAC5C,UAAM,YAAY,MAAM,MAAM,GAAG,EAAE,SAAS;AAC5C,QAAI,YAAY,GAAG;AACjB,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT,CAAC;AACH;AAEO,IAAM,mBAAmB;AAAA,EAC9B,OAAO;AAAA,IACL,OAAO,SAAS,QAAQ,CAAC;AAAA,IACzB,OAAO,SAAS,QAAQ,CAAC;AAAA,IACzB,gBAAgB,SAAS,oBAAoB;AAAA,EAC/C,CAAC;AAAA,EACD;AAAA,EACA,CAAC,UAAU;AACT,UAAM,aAAa;AAAA,MACjB,MAAM,UAAU,QACd,MAAM,UAAU,QACf,MAAM,kBAAkB,MAAM,eAAe,SAAS;AAAA,IAC3D;AAEA,QAAI,YAAY;AACd,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AACF;AAYO,SAAS,mBACd,OAEA,cAC6B;AAC7B;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAEO,IAAM,uBAAuB,OAAO;AAAA,EACzC,gBAAgB,SAAS,oBAAoB;AAC/C,CAAC;AAYM,SAAS,uBACd,OAEA,cACiC;AACjC;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAUA,SAAS,mBAAmB,SAAiB;AAE3C,QAAM,UAAU,QAAQ,QAAQ,wBAAwB,MAAM;AAE9D,QAAM,QAAQ,QAAQ,QAAQ,QAAQ,IAAI;AAC1C,SAAO,OAAO,OAAO,GAAG;AAC1B;AAcA,SAAS,mBAAmB,SAAiB,QAAgB;AAE3D,MAAI,YAAY,OAAO,YAAY,QAAQ;AACzC,WAAO;AAAA,EACT;AAEA,QAAM,QAAQ,mBAAmB,OAAO;AACxC,SAAO,MAAM,KAAK,MAAM;AAC1B;AAUO,SAAS,gBACd,SACA,aACA,QACA;AAEA,MAAI,WAAW,YAAY;AACzB,WAAO;AAAA,EACT;AAGA,MACE,QAAQ,gBAAgB;AAAA,IAAK,CAAC,YAC5B,mBAAmB,SAAS,MAAM;AAAA,EACpC,GACA;AACA,WAAO;AAAA,EACT;AAGA,MAAI,gBAAgB,YAAY,WAAW,QAAQ,OAAO;AACxD,WAAO;AAAA,EACT;AAGA,SAAO,QAAQ,gBAAgB,YAAY,QAAQ,QAAQ,KAAK;AAClE;AAUO,SAAS,uBACd,OACuC;AACvC,MAAI,CAAC,iBAAiB,KAAK,GAAG;AAC5B,QAAI,iBAAiB,KAAK,GAAG;AAC3B,YAAM,IAAI,MAAM,4BAA4B,MAAM,MAAM,OAAO,EAAE;AAAA,IACnE;AAEA,UAAM,IAAI,MAAM,4BAA4B;AAAA,EAC9C;AACF;","names":[]}
\ No newline at end of file
+{"version":3,"sources":["../src/json-rpc.ts"],"sourcesContent":["import { SubjectType } from '@metamask/permission-controller';\nimport type {\n  AssertionErrorConstructor,\n  Json,\n  JsonRpcSuccess,\n} from '@metamask/utils';\nimport {\n  assertStruct,\n  isJsonRpcFailure,\n  isJsonRpcSuccess,\n} from '@metamask/utils';\nimport type { Infer } from '@metamask/superstruct';\nimport { array, boolean, object, optional, refine, string } from '@metamask/superstruct';\n\nconst AllowedOriginsStruct = array(\n  refine(string(), 'Allowed origin', (value) => {\n    const wildcards = value.split('*').length - 1;\n    if (wildcards > 2) {\n      return 'No more than two wildcards (\"*\") are allowed in an origin specifier.';\n    }\n\n    return true;\n  }),\n);\n\nexport const RpcOriginsStruct = refine(\n  object({\n    dapps: optional(boolean()),\n    snaps: optional(boolean()),\n    allowedOrigins: optional(AllowedOriginsStruct),\n  }),\n  'RPC origins',\n  (value) => {\n    const hasOrigins = Boolean(\n      value.snaps === true ||\n        value.dapps === true ||\n        (value.allowedOrigins && value.allowedOrigins.length > 0),\n    );\n\n    if (hasOrigins) {\n      return true;\n    }\n\n    return 'Must specify at least one JSON-RPC origin.';\n  },\n);\n\nexport type RpcOrigins = Infer<typeof RpcOriginsStruct>;\n\n/**\n * Asserts that the given value is a valid {@link RpcOrigins} object.\n *\n * @param value - The value to assert.\n * @param ErrorWrapper - An optional error wrapper to use. Defaults to\n * {@link AssertionError}.\n * @throws If the value is not a valid {@link RpcOrigins} object.\n */\nexport function assertIsRpcOrigins(\n  value: unknown,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper?: AssertionErrorConstructor,\n): asserts value is RpcOrigins {\n  assertStruct(\n    value,\n    RpcOriginsStruct,\n    'Invalid JSON-RPC origins',\n    ErrorWrapper,\n  );\n}\n\nexport const KeyringOriginsStruct = object({\n  allowedOrigins: optional(AllowedOriginsStruct),\n});\n\nexport type KeyringOrigins = Infer<typeof KeyringOriginsStruct>;\n\n/**\n * Assert that the given value is a valid {@link KeyringOrigins} object.\n *\n * @param value - The value to assert.\n * @param ErrorWrapper - An optional error wrapper to use. Defaults to\n * {@link AssertionError}.\n * @throws If the value is not a valid {@link KeyringOrigins} object.\n */\nexport function assertIsKeyringOrigins(\n  value: unknown,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper?: AssertionErrorConstructor,\n): asserts value is KeyringOrigins {\n  assertStruct(\n    value,\n    KeyringOriginsStruct,\n    'Invalid keyring origins',\n    ErrorWrapper,\n  );\n}\n\n/**\n * Create regular expression for matching against an origin while allowing wildcards.\n *\n * The \"*\" symbol is treated as a wildcard and will match 0 or more characters.\n *\n * @param matcher - The string to create the regular expression with.\n * @returns The regular expression.\n */\nfunction createOriginRegExp(matcher: string) {\n  // Escape potential Regex characters\n  const escaped = matcher.replace(/[.*+?^${}()|[\\]\\\\]/gu, '\\\\$&');\n  // Support wildcards\n  const regex = escaped.replace(/\\*/gu, '.*');\n  return RegExp(regex, 'u');\n}\n\n/**\n * Check whether an origin is allowed or not using a matcher string.\n *\n * The matcher string may be a specific origin to match or include wildcards.\n * The \"*\" symbol is treated as a wildcard and will match 0 or more characters.\n * Note: this means that https://*metamask.io matches both https://metamask.io\n * and https://snaps.metamask.io.\n *\n * @param matcher - The matcher string.\n * @param origin - The origin.\n * @returns Whether the origin is allowed.\n */\nfunction checkAllowedOrigin(matcher: string, origin: string) {\n  // If the matcher is a single wildcard or identical to the origin we can return true immediately.\n  if (matcher === '*' || matcher === origin) {\n    return true;\n  }\n\n  const regex = createOriginRegExp(matcher);\n  return regex.test(origin);\n}\n\n/**\n * Check if the given origin is allowed by the given JSON-RPC origins object.\n *\n * @param origins - The JSON-RPC origins object.\n * @param subjectType - The type of the origin.\n * @param origin - The origin to check.\n * @returns Whether the origin is allowed.\n */\nexport function isOriginAllowed(\n  origins: RpcOrigins,\n  subjectType: SubjectType,\n  origin: string,\n) {\n  // The MetaMask client is always allowed.\n  if (origin === 'metamask') {\n    return true;\n  }\n\n  // If the origin is in the `allowedOrigins` list, it is allowed.\n  if (\n    origins.allowedOrigins?.some((matcher) =>\n      checkAllowedOrigin(matcher, origin),\n    )\n  ) {\n    return true;\n  }\n\n  // If the origin is a website and `dapps` is true, it is allowed.\n  if (subjectType === SubjectType.Website && origins.dapps) {\n    return true;\n  }\n\n  // If the origin is a snap and `snaps` is true, it is allowed.\n  return Boolean(subjectType === SubjectType.Snap && origins.snaps);\n}\n\n/**\n * Assert that the given value is a successful JSON-RPC response. If the value\n * is not a success response, an error is thrown. If the value is an JSON-RPC\n * error, the error message is included in the thrown error.\n *\n * @param value - The value to check.\n * @throws If the value is not a JSON-RPC success response.\n */\nexport function assertIsJsonRpcSuccess(\n  value: unknown,\n): asserts value is JsonRpcSuccess<Json> {\n  if (!isJsonRpcSuccess(value)) {\n    if (isJsonRpcFailure(value)) {\n      throw new Error(`JSON-RPC request failed: ${value.error.message}`);\n    }\n\n    throw new Error('Invalid JSON-RPC response.');\n  }\n}\n"],"mappings":";AAAA,SAAS,mBAAmB;AAM5B;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAEP,SAAS,OAAO,SAAS,QAAQ,UAAU,QAAQ,cAAc;AAEjE,IAAM,uBAAuB;AAAA,EAC3B,OAAO,OAAO,GAAG,kBAAkB,CAAC,UAAU;AAC5C,UAAM,YAAY,MAAM,MAAM,GAAG,EAAE,SAAS;AAC5C,QAAI,YAAY,GAAG;AACjB,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT,CAAC;AACH;AAEO,IAAM,mBAAmB;AAAA,EAC9B,OAAO;AAAA,IACL,OAAO,SAAS,QAAQ,CAAC;AAAA,IACzB,OAAO,SAAS,QAAQ,CAAC;AAAA,IACzB,gBAAgB,SAAS,oBAAoB;AAAA,EAC/C,CAAC;AAAA,EACD;AAAA,EACA,CAAC,UAAU;AACT,UAAM,aAAa;AAAA,MACjB,MAAM,UAAU,QACd,MAAM,UAAU,QACf,MAAM,kBAAkB,MAAM,eAAe,SAAS;AAAA,IAC3D;AAEA,QAAI,YAAY;AACd,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AACF;AAYO,SAAS,mBACd,OAEA,cAC6B;AAC7B;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAEO,IAAM,uBAAuB,OAAO;AAAA,EACzC,gBAAgB,SAAS,oBAAoB;AAC/C,CAAC;AAYM,SAAS,uBACd,OAEA,cACiC;AACjC;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAUA,SAAS,mBAAmB,SAAiB;AAE3C,QAAM,UAAU,QAAQ,QAAQ,wBAAwB,MAAM;AAE9D,QAAM,QAAQ,QAAQ,QAAQ,QAAQ,IAAI;AAC1C,SAAO,OAAO,OAAO,GAAG;AAC1B;AAcA,SAAS,mBAAmB,SAAiB,QAAgB;AAE3D,MAAI,YAAY,OAAO,YAAY,QAAQ;AACzC,WAAO;AAAA,EACT;AAEA,QAAM,QAAQ,mBAAmB,OAAO;AACxC,SAAO,MAAM,KAAK,MAAM;AAC1B;AAUO,SAAS,gBACd,SACA,aACA,QACA;AAEA,MAAI,WAAW,YAAY;AACzB,WAAO;AAAA,EACT;AAGA,MACE,QAAQ,gBAAgB;AAAA,IAAK,CAAC,YAC5B,mBAAmB,SAAS,MAAM;AAAA,EACpC,GACA;AACA,WAAO;AAAA,EACT;AAGA,MAAI,gBAAgB,YAAY,WAAW,QAAQ,OAAO;AACxD,WAAO;AAAA,EACT;AAGA,SAAO,QAAQ,gBAAgB,YAAY,QAAQ,QAAQ,KAAK;AAClE;AAUO,SAAS,uBACd,OACuC;AACvC,MAAI,CAAC,iBAAiB,KAAK,GAAG;AAC5B,QAAI,iBAAiB,KAAK,GAAG;AAC3B,YAAM,IAAI,MAAM,4BAA4B,MAAM,MAAM,OAAO,EAAE;AAAA,IACnE;AAEA,UAAM,IAAI,MAAM,4BAA4B;AAAA,EAC9C;AACF;","names":[]}
\ No newline at end of file
diff --git a/dist/chunk-K4B37F3L.js.map b/dist/chunk-K4B37F3L.js.map
index bb47f82ae64b7c323a9e436e60611a30557544d1..5f353c3538fd5408070be0294c934309621dccdc 100644
--- a/dist/chunk-K4B37F3L.js.map
+++ b/dist/chunk-K4B37F3L.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../src/snaps.ts"],"names":["SnapStatus","SnapStatusEvents"],"mappings":"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","sourcesContent":["import type {\n  Caveat,\n  SubjectPermissions,\n  PermissionConstraint,\n} from '@metamask/permission-controller';\nimport type { BlockReason } from '@metamask/snaps-registry';\nimport type { SnapId, Snap as TruncatedSnap } from '@metamask/snaps-sdk';\nimport type { Json } from '@metamask/utils';\nimport { assert, isObject, assertStruct } from '@metamask/utils';\nimport { base64 } from '@scure/base';\nimport stableStringify from 'fast-json-stable-stringify';\nimport type { Struct } from 'superstruct';\nimport {\n  empty,\n  enums,\n  intersection,\n  literal,\n  pattern,\n  refine,\n  string,\n  union,\n  validate,\n} from 'superstruct';\nimport validateNPMPackage from 'validate-npm-package-name';\n\nimport { SnapCaveatType } from './caveats';\nimport { checksumFiles } from './checksum';\nimport type { LocalizationFile } from './localization';\nimport type {\n  InitialConnections,\n  SnapManifest,\n  SnapPermissions,\n} from './manifest/validation';\nimport type { FetchedSnapFiles, SnapsPermissionRequest } from './types';\nimport { SnapIdPrefixes, SnapValidationFailureReason, uri } from './types';\nimport type { VirtualFile } from './virtual-file';\n\n// This RegEx matches valid npm package names (with some exceptions) and space-\n// separated alphanumerical words, optionally with dashes and underscores.\n// The RegEx consists of two parts. The first part matches space-separated\n// words. It is based on the following Stackoverflow answer:\n// https://stackoverflow.com/a/34974982\n// The second part, after the pipe operator, is the same RegEx used for the\n// `name` field of the official package.json JSON Schema, except that we allow\n// mixed-case letters. It was originally copied from:\n// https://github.com/SchemaStore/schemastore/blob/81a16897c1dabfd98c72242a5fd62eb080ff76d8/src/schemas/json/package.json#L132-L138\nexport const PROPOSED_NAME_REGEX =\n  /^(?:[A-Za-z0-9-_]+( [A-Za-z0-9-_]+)*)|(?:(?:@[A-Za-z0-9-*~][A-Za-z0-9-*._~]*\\/)?[A-Za-z0-9-~][A-Za-z0-9-._~]*)$/u;\n\nexport enum SnapStatus {\n  Installing = 'installing',\n  Updating = 'updating',\n  Running = 'running',\n  Stopped = 'stopped',\n  Crashed = 'crashed',\n}\n\nexport enum SnapStatusEvents {\n  Start = 'START',\n  Stop = 'STOP',\n  Crash = 'CRASH',\n  Update = 'UPDATE',\n}\n\nexport type StatusContext = { snapId: SnapId };\nexport type StatusEvents = { type: SnapStatusEvents };\nexport type StatusStates = {\n  value: SnapStatus;\n  context: StatusContext;\n};\nexport type Status = StatusStates['value'];\n\nexport type VersionHistory = {\n  origin: string;\n  version: string;\n  // Unix timestamp\n  date: number;\n};\n\nexport type SnapAuxilaryFile = {\n  path: string;\n  // Value here should be stored as base64\n  value: string;\n};\n\nexport type PersistedSnap = Snap;\n\n/**\n * A Snap as it exists in {@link SnapController} state.\n */\nexport type Snap = TruncatedSnap & {\n  /**\n   * The initial connections of the Snap, optional, requested on installation.\n   */\n  initialConnections?: InitialConnections;\n  /**\n   * The initial permissions of the Snap, which will be requested when it is\n   * installed.\n   */\n  initialPermissions: SnapPermissions;\n\n  /**\n   * The source code of the Snap.\n   */\n  sourceCode: string;\n\n  /**\n   * The Snap's manifest file.\n   */\n  manifest: SnapManifest;\n\n  /**\n   * Information detailing why the snap is blocked.\n   */\n  blockInformation?: BlockReason;\n\n  /**\n   * The current status of the Snap, e.g. whether it's running or stopped.\n   */\n  status: Status;\n\n  /**\n   * The version history of the Snap.\n   * Can be used to derive when the Snap was installed, when it was updated to a certain version and who requested the change.\n   */\n  versionHistory: VersionHistory[];\n\n  /**\n   * Static auxiliary files that can be loaded at runtime.\n   */\n  auxiliaryFiles?: SnapAuxilaryFile[];\n\n  /**\n   * Localization files which are used to translate the manifest.\n   */\n  localizationFiles?: LocalizationFile[];\n\n  /**\n   * Flag to signal whether this snap was preinstalled or not.\n   *\n   * A lack of specifying this option will be deemed as not preinstalled.\n   */\n  preinstalled?: boolean;\n\n  /**\n   * Flag to signal whether this snap is removable or not.\n   *\n   * A lack of specifying this option will be deemed as removable.\n   */\n  removable?: boolean;\n\n  /**\n   * Flag to signal whether this snap should be hidden from the user or not.\n   */\n  hidden?: boolean;\n};\n\nexport type TruncatedSnapFields =\n  | 'id'\n  | 'initialPermissions'\n  | 'version'\n  | 'enabled'\n  | 'blocked';\n\n/**\n * An error indicating that a Snap validation failure is programmatically\n * fixable during development.\n */\nexport class ProgrammaticallyFixableSnapError extends Error {\n  reason: SnapValidationFailureReason;\n\n  constructor(message: string, reason: SnapValidationFailureReason) {\n    super(message);\n    this.reason = reason;\n  }\n}\n\n/**\n * Gets a checksummable manifest by removing the shasum property and reserializing the JSON using a deterministic algorithm.\n *\n * @param manifest - The manifest itself.\n * @returns A virtual file containing the checksummable manifest.\n */\nfunction getChecksummableManifest(\n  manifest: VirtualFile<SnapManifest>,\n): VirtualFile {\n  const manifestCopy = manifest.clone() as VirtualFile<any>;\n  delete manifestCopy.result.source.shasum;\n\n  // We use fast-json-stable-stringify to deterministically serialize the JSON\n  // This is required before checksumming so we get reproducible checksums across platforms etc\n  manifestCopy.value = stableStringify(manifestCopy.result);\n  return manifestCopy;\n}\n\n/**\n * Calculates the Base64-encoded SHA-256 digest of all required Snap files.\n *\n * @param files - All required Snap files to be included in the checksum.\n * @returns The Base64-encoded SHA-256 digest of the source code.\n */\nexport async function getSnapChecksum(\n  files: FetchedSnapFiles,\n): Promise<string> {\n  const { manifest, sourceCode, svgIcon, auxiliaryFiles, localizationFiles } =\n    files;\n\n  const all = [\n    getChecksummableManifest(manifest),\n    sourceCode,\n    svgIcon,\n    ...auxiliaryFiles,\n    ...localizationFiles,\n  ].filter((file) => file !== undefined);\n\n  return base64.encode(await checksumFiles(all as VirtualFile[]));\n}\n\n/**\n * Checks whether the `source.shasum` property of a Snap manifest matches the\n * shasum of the snap.\n *\n * @param files - All required Snap files to be included in the checksum.\n * @param errorMessage - The error message to throw if validation fails.\n */\nexport async function validateSnapShasum(\n  files: FetchedSnapFiles,\n  errorMessage = 'Invalid Snap manifest: manifest shasum does not match computed shasum.',\n): Promise<void> {\n  if (files.manifest.result.source.shasum !== (await getSnapChecksum(files))) {\n    throw new ProgrammaticallyFixableSnapError(\n      errorMessage,\n      SnapValidationFailureReason.ShasumMismatch,\n    );\n  }\n}\n\nexport const LOCALHOST_HOSTNAMES = ['localhost', '127.0.0.1', '[::1]'] as const;\n\n// Require snap ids to only consist of printable ASCII characters\nexport const BaseSnapIdStruct = pattern(string(), /^[\\x21-\\x7E]*$/u);\n\nconst LocalSnapIdSubUrlStruct = uri({\n  protocol: enums(['http:', 'https:']),\n  hostname: enums(LOCALHOST_HOSTNAMES),\n  hash: empty(string()),\n  search: empty(string()),\n});\n\nexport const LocalSnapIdStruct = refine(\n  BaseSnapIdStruct,\n  'local Snap Id',\n  (value) => {\n    if (!value.startsWith(SnapIdPrefixes.local)) {\n      return `Expected local snap ID, got \"${value}\".`;\n    }\n\n    const [error] = validate(\n      value.slice(SnapIdPrefixes.local.length),\n      LocalSnapIdSubUrlStruct,\n    );\n    return error ?? true;\n  },\n);\nexport const NpmSnapIdStruct = intersection([\n  BaseSnapIdStruct,\n  uri({\n    protocol: literal(SnapIdPrefixes.npm),\n    pathname: refine(string(), 'package name', function* (value) {\n      const normalized = value.startsWith('/') ? value.slice(1) : value;\n      const { errors, validForNewPackages, warnings } =\n        validateNPMPackage(normalized);\n      if (!validForNewPackages) {\n        if (errors === undefined) {\n          assert(warnings !== undefined);\n          yield* warnings;\n        } else {\n          yield* errors;\n        }\n      }\n      return true;\n    }),\n    search: empty(string()),\n    hash: empty(string()),\n  }),\n]) as unknown as Struct<string, null>;\n\nexport const HttpSnapIdStruct = intersection([\n  BaseSnapIdStruct,\n  uri({\n    protocol: enums(['http:', 'https:']),\n    search: empty(string()),\n    hash: empty(string()),\n  }),\n]) as unknown as Struct<string, null>;\n\nexport const SnapIdStruct = union([NpmSnapIdStruct, LocalSnapIdStruct]);\n\n/**\n * Extracts the snap prefix from a snap ID.\n *\n * @param snapId - The snap ID to extract the prefix from.\n * @returns The snap prefix from a snap id, e.g. `npm:`.\n */\nexport function getSnapPrefix(snapId: string): SnapIdPrefixes {\n  const prefix = Object.values(SnapIdPrefixes).find((possiblePrefix) =>\n    snapId.startsWith(possiblePrefix),\n  );\n  if (prefix !== undefined) {\n    return prefix;\n  }\n  throw new Error(`Invalid or no prefix found for \"${snapId}\"`);\n}\n\n/**\n * Strips snap prefix from a full snap ID.\n *\n * @param snapId - The snap ID to strip.\n * @returns The stripped snap ID.\n */\nexport function stripSnapPrefix(snapId: string): string {\n  return snapId.replace(getSnapPrefix(snapId), '');\n}\n\n/**\n * Assert that the given value is a valid snap ID.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid snap ID.\n */\nexport function assertIsValidSnapId(value: unknown): asserts value is SnapId {\n  assertStruct(value, SnapIdStruct, 'Invalid snap ID');\n}\n\n/**\n * Typeguard to ensure a chainId follows the CAIP-2 standard.\n *\n * @param chainId - The chainId being tested.\n * @returns `true` if the value is a valid CAIP chain id, and `false` otherwise.\n */\nexport function isCaipChainId(chainId: unknown): chainId is string {\n  return (\n    typeof chainId === 'string' &&\n    /^(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-a-zA-Z0-9]{1,32})$/u.test(\n      chainId,\n    )\n  );\n}\n\n/**\n * Utility function to check if an origin has permission (and caveat) for a particular snap.\n *\n * @param permissions - An origin's permissions object.\n * @param snapId - The id of the snap.\n * @returns A boolean based on if an origin has the specified snap.\n */\nexport function isSnapPermitted(\n  permissions: SubjectPermissions<PermissionConstraint>,\n  snapId: SnapId,\n) {\n  return Boolean(\n    (\n      (\n        (permissions?.wallet_snap?.caveats?.find(\n          (caveat) => caveat.type === SnapCaveatType.SnapIds,\n        ) ?? {}) as Caveat<string, Json>\n      ).value as Record<string, unknown>\n    )?.[snapId],\n  );\n}\n\n/**\n * Checks whether the passed in requestedPermissions is a valid\n * permission request for a `wallet_snap` permission.\n *\n * @param requestedPermissions - The requested permissions.\n * @throws If the criteria is not met.\n */\nexport function verifyRequestedSnapPermissions(\n  requestedPermissions: unknown,\n): asserts requestedPermissions is SnapsPermissionRequest {\n  assert(\n    isObject(requestedPermissions),\n    'Requested permissions must be an object.',\n  );\n\n  const { wallet_snap: walletSnapPermission } = requestedPermissions;\n\n  assert(\n    isObject(walletSnapPermission),\n    'wallet_snap is missing from the requested permissions.',\n  );\n\n  const { caveats } = walletSnapPermission;\n\n  assert(\n    Array.isArray(caveats) && caveats.length === 1,\n    'wallet_snap must have a caveat property with a single-item array value.',\n  );\n\n  const [caveat] = caveats;\n\n  assert(\n    isObject(caveat) &&\n      caveat.type === SnapCaveatType.SnapIds &&\n      isObject(caveat.value),\n    `The requested permissions do not have a valid ${SnapCaveatType.SnapIds} caveat.`,\n  );\n}\n\nexport type { Snap as TruncatedSnap } from '@metamask/snaps-sdk';\n"]}
\ No newline at end of file
+{"version":3,"sources":["../src/snaps.ts"],"names":["SnapStatus","SnapStatusEvents"],"mappings":"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","sourcesContent":["import type {\n  Caveat,\n  SubjectPermissions,\n  PermissionConstraint,\n} from '@metamask/permission-controller';\nimport type { BlockReason } from '@metamask/snaps-registry';\nimport type { SnapId, Snap as TruncatedSnap } from '@metamask/snaps-sdk';\nimport type { Json } from '@metamask/utils';\nimport { assert, isObject, assertStruct } from '@metamask/utils';\nimport { base64 } from '@scure/base';\nimport stableStringify from 'fast-json-stable-stringify';\nimport type { Struct } from '@metamask/superstruct';\nimport {\n  empty,\n  enums,\n  intersection,\n  literal,\n  pattern,\n  refine,\n  string,\n  union,\n  validate,\n} from '@metamask/superstruct';\nimport validateNPMPackage from 'validate-npm-package-name';\n\nimport { SnapCaveatType } from './caveats';\nimport { checksumFiles } from './checksum';\nimport type { LocalizationFile } from './localization';\nimport type {\n  InitialConnections,\n  SnapManifest,\n  SnapPermissions,\n} from './manifest/validation';\nimport type { FetchedSnapFiles, SnapsPermissionRequest } from './types';\nimport { SnapIdPrefixes, SnapValidationFailureReason, uri } from './types';\nimport type { VirtualFile } from './virtual-file';\n\n// This RegEx matches valid npm package names (with some exceptions) and space-\n// separated alphanumerical words, optionally with dashes and underscores.\n// The RegEx consists of two parts. The first part matches space-separated\n// words. It is based on the following Stackoverflow answer:\n// https://stackoverflow.com/a/34974982\n// The second part, after the pipe operator, is the same RegEx used for the\n// `name` field of the official package.json JSON Schema, except that we allow\n// mixed-case letters. It was originally copied from:\n// https://github.com/SchemaStore/schemastore/blob/81a16897c1dabfd98c72242a5fd62eb080ff76d8/src/schemas/json/package.json#L132-L138\nexport const PROPOSED_NAME_REGEX =\n  /^(?:[A-Za-z0-9-_]+( [A-Za-z0-9-_]+)*)|(?:(?:@[A-Za-z0-9-*~][A-Za-z0-9-*._~]*\\/)?[A-Za-z0-9-~][A-Za-z0-9-._~]*)$/u;\n\nexport enum SnapStatus {\n  Installing = 'installing',\n  Updating = 'updating',\n  Running = 'running',\n  Stopped = 'stopped',\n  Crashed = 'crashed',\n}\n\nexport enum SnapStatusEvents {\n  Start = 'START',\n  Stop = 'STOP',\n  Crash = 'CRASH',\n  Update = 'UPDATE',\n}\n\nexport type StatusContext = { snapId: SnapId };\nexport type StatusEvents = { type: SnapStatusEvents };\nexport type StatusStates = {\n  value: SnapStatus;\n  context: StatusContext;\n};\nexport type Status = StatusStates['value'];\n\nexport type VersionHistory = {\n  origin: string;\n  version: string;\n  // Unix timestamp\n  date: number;\n};\n\nexport type SnapAuxilaryFile = {\n  path: string;\n  // Value here should be stored as base64\n  value: string;\n};\n\nexport type PersistedSnap = Snap;\n\n/**\n * A Snap as it exists in {@link SnapController} state.\n */\nexport type Snap = TruncatedSnap & {\n  /**\n   * The initial connections of the Snap, optional, requested on installation.\n   */\n  initialConnections?: InitialConnections;\n  /**\n   * The initial permissions of the Snap, which will be requested when it is\n   * installed.\n   */\n  initialPermissions: SnapPermissions;\n\n  /**\n   * The source code of the Snap.\n   */\n  sourceCode: string;\n\n  /**\n   * The Snap's manifest file.\n   */\n  manifest: SnapManifest;\n\n  /**\n   * Information detailing why the snap is blocked.\n   */\n  blockInformation?: BlockReason;\n\n  /**\n   * The current status of the Snap, e.g. whether it's running or stopped.\n   */\n  status: Status;\n\n  /**\n   * The version history of the Snap.\n   * Can be used to derive when the Snap was installed, when it was updated to a certain version and who requested the change.\n   */\n  versionHistory: VersionHistory[];\n\n  /**\n   * Static auxiliary files that can be loaded at runtime.\n   */\n  auxiliaryFiles?: SnapAuxilaryFile[];\n\n  /**\n   * Localization files which are used to translate the manifest.\n   */\n  localizationFiles?: LocalizationFile[];\n\n  /**\n   * Flag to signal whether this snap was preinstalled or not.\n   *\n   * A lack of specifying this option will be deemed as not preinstalled.\n   */\n  preinstalled?: boolean;\n\n  /**\n   * Flag to signal whether this snap is removable or not.\n   *\n   * A lack of specifying this option will be deemed as removable.\n   */\n  removable?: boolean;\n\n  /**\n   * Flag to signal whether this snap should be hidden from the user or not.\n   */\n  hidden?: boolean;\n};\n\nexport type TruncatedSnapFields =\n  | 'id'\n  | 'initialPermissions'\n  | 'version'\n  | 'enabled'\n  | 'blocked';\n\n/**\n * An error indicating that a Snap validation failure is programmatically\n * fixable during development.\n */\nexport class ProgrammaticallyFixableSnapError extends Error {\n  reason: SnapValidationFailureReason;\n\n  constructor(message: string, reason: SnapValidationFailureReason) {\n    super(message);\n    this.reason = reason;\n  }\n}\n\n/**\n * Gets a checksummable manifest by removing the shasum property and reserializing the JSON using a deterministic algorithm.\n *\n * @param manifest - The manifest itself.\n * @returns A virtual file containing the checksummable manifest.\n */\nfunction getChecksummableManifest(\n  manifest: VirtualFile<SnapManifest>,\n): VirtualFile {\n  const manifestCopy = manifest.clone() as VirtualFile<any>;\n  delete manifestCopy.result.source.shasum;\n\n  // We use fast-json-stable-stringify to deterministically serialize the JSON\n  // This is required before checksumming so we get reproducible checksums across platforms etc\n  manifestCopy.value = stableStringify(manifestCopy.result);\n  return manifestCopy;\n}\n\n/**\n * Calculates the Base64-encoded SHA-256 digest of all required Snap files.\n *\n * @param files - All required Snap files to be included in the checksum.\n * @returns The Base64-encoded SHA-256 digest of the source code.\n */\nexport async function getSnapChecksum(\n  files: FetchedSnapFiles,\n): Promise<string> {\n  const { manifest, sourceCode, svgIcon, auxiliaryFiles, localizationFiles } =\n    files;\n\n  const all = [\n    getChecksummableManifest(manifest),\n    sourceCode,\n    svgIcon,\n    ...auxiliaryFiles,\n    ...localizationFiles,\n  ].filter((file) => file !== undefined);\n\n  return base64.encode(await checksumFiles(all as VirtualFile[]));\n}\n\n/**\n * Checks whether the `source.shasum` property of a Snap manifest matches the\n * shasum of the snap.\n *\n * @param files - All required Snap files to be included in the checksum.\n * @param errorMessage - The error message to throw if validation fails.\n */\nexport async function validateSnapShasum(\n  files: FetchedSnapFiles,\n  errorMessage = 'Invalid Snap manifest: manifest shasum does not match computed shasum.',\n): Promise<void> {\n  if (files.manifest.result.source.shasum !== (await getSnapChecksum(files))) {\n    throw new ProgrammaticallyFixableSnapError(\n      errorMessage,\n      SnapValidationFailureReason.ShasumMismatch,\n    );\n  }\n}\n\nexport const LOCALHOST_HOSTNAMES = ['localhost', '127.0.0.1', '[::1]'] as const;\n\n// Require snap ids to only consist of printable ASCII characters\nexport const BaseSnapIdStruct = pattern(string(), /^[\\x21-\\x7E]*$/u);\n\nconst LocalSnapIdSubUrlStruct = uri({\n  protocol: enums(['http:', 'https:']),\n  hostname: enums(LOCALHOST_HOSTNAMES),\n  hash: empty(string()),\n  search: empty(string()),\n});\n\nexport const LocalSnapIdStruct = refine(\n  BaseSnapIdStruct,\n  'local Snap Id',\n  (value) => {\n    if (!value.startsWith(SnapIdPrefixes.local)) {\n      return `Expected local snap ID, got \"${value}\".`;\n    }\n\n    const [error] = validate(\n      value.slice(SnapIdPrefixes.local.length),\n      LocalSnapIdSubUrlStruct,\n    );\n    return error ?? true;\n  },\n);\nexport const NpmSnapIdStruct = intersection([\n  BaseSnapIdStruct,\n  uri({\n    protocol: literal(SnapIdPrefixes.npm),\n    pathname: refine(string(), 'package name', function* (value) {\n      const normalized = value.startsWith('/') ? value.slice(1) : value;\n      const { errors, validForNewPackages, warnings } =\n        validateNPMPackage(normalized);\n      if (!validForNewPackages) {\n        if (errors === undefined) {\n          assert(warnings !== undefined);\n          yield* warnings;\n        } else {\n          yield* errors;\n        }\n      }\n      return true;\n    }),\n    search: empty(string()),\n    hash: empty(string()),\n  }),\n]) as unknown as Struct<string, null>;\n\nexport const HttpSnapIdStruct = intersection([\n  BaseSnapIdStruct,\n  uri({\n    protocol: enums(['http:', 'https:']),\n    search: empty(string()),\n    hash: empty(string()),\n  }),\n]) as unknown as Struct<string, null>;\n\nexport const SnapIdStruct = union([NpmSnapIdStruct, LocalSnapIdStruct]);\n\n/**\n * Extracts the snap prefix from a snap ID.\n *\n * @param snapId - The snap ID to extract the prefix from.\n * @returns The snap prefix from a snap id, e.g. `npm:`.\n */\nexport function getSnapPrefix(snapId: string): SnapIdPrefixes {\n  const prefix = Object.values(SnapIdPrefixes).find((possiblePrefix) =>\n    snapId.startsWith(possiblePrefix),\n  );\n  if (prefix !== undefined) {\n    return prefix;\n  }\n  throw new Error(`Invalid or no prefix found for \"${snapId}\"`);\n}\n\n/**\n * Strips snap prefix from a full snap ID.\n *\n * @param snapId - The snap ID to strip.\n * @returns The stripped snap ID.\n */\nexport function stripSnapPrefix(snapId: string): string {\n  return snapId.replace(getSnapPrefix(snapId), '');\n}\n\n/**\n * Assert that the given value is a valid snap ID.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid snap ID.\n */\nexport function assertIsValidSnapId(value: unknown): asserts value is SnapId {\n  assertStruct(value, SnapIdStruct, 'Invalid snap ID');\n}\n\n/**\n * Typeguard to ensure a chainId follows the CAIP-2 standard.\n *\n * @param chainId - The chainId being tested.\n * @returns `true` if the value is a valid CAIP chain id, and `false` otherwise.\n */\nexport function isCaipChainId(chainId: unknown): chainId is string {\n  return (\n    typeof chainId === 'string' &&\n    /^(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-a-zA-Z0-9]{1,32})$/u.test(\n      chainId,\n    )\n  );\n}\n\n/**\n * Utility function to check if an origin has permission (and caveat) for a particular snap.\n *\n * @param permissions - An origin's permissions object.\n * @param snapId - The id of the snap.\n * @returns A boolean based on if an origin has the specified snap.\n */\nexport function isSnapPermitted(\n  permissions: SubjectPermissions<PermissionConstraint>,\n  snapId: SnapId,\n) {\n  return Boolean(\n    (\n      (\n        (permissions?.wallet_snap?.caveats?.find(\n          (caveat) => caveat.type === SnapCaveatType.SnapIds,\n        ) ?? {}) as Caveat<string, Json>\n      ).value as Record<string, unknown>\n    )?.[snapId],\n  );\n}\n\n/**\n * Checks whether the passed in requestedPermissions is a valid\n * permission request for a `wallet_snap` permission.\n *\n * @param requestedPermissions - The requested permissions.\n * @throws If the criteria is not met.\n */\nexport function verifyRequestedSnapPermissions(\n  requestedPermissions: unknown,\n): asserts requestedPermissions is SnapsPermissionRequest {\n  assert(\n    isObject(requestedPermissions),\n    'Requested permissions must be an object.',\n  );\n\n  const { wallet_snap: walletSnapPermission } = requestedPermissions;\n\n  assert(\n    isObject(walletSnapPermission),\n    'wallet_snap is missing from the requested permissions.',\n  );\n\n  const { caveats } = walletSnapPermission;\n\n  assert(\n    Array.isArray(caveats) && caveats.length === 1,\n    'wallet_snap must have a caveat property with a single-item array value.',\n  );\n\n  const [caveat] = caveats;\n\n  assert(\n    isObject(caveat) &&\n      caveat.type === SnapCaveatType.SnapIds &&\n      isObject(caveat.value),\n    `The requested permissions do not have a valid ${SnapCaveatType.SnapIds} caveat.`,\n  );\n}\n\nexport type { Snap as TruncatedSnap } from '@metamask/snaps-sdk';\n"]}
\ No newline at end of file
diff --git a/dist/chunk-NHGIT2SZ.mjs.map b/dist/chunk-NHGIT2SZ.mjs.map
index 120c6ed6c981ea15ce54af2ee50e3606a95a7c18..08b57cf5253fe0bb5f9a7153d832ce5e1a3dc030 100644
--- a/dist/chunk-NHGIT2SZ.mjs.map
+++ b/dist/chunk-NHGIT2SZ.mjs.map
@@ -1 +1 @@
-{"version":3,"sources":["../src/structs.ts"],"sourcesContent":["import { union } from '@metamask/snaps-sdk';\nimport type { NonEmptyArray } from '@metamask/utils';\nimport { assert, isObject } from '@metamask/utils';\nimport { bold, green, red } from 'chalk';\nimport type { Failure } from 'superstruct';\nimport {\n  is,\n  validate,\n  type as superstructType,\n  Struct,\n  StructError,\n  create,\n  assign,\n} from 'superstruct';\nimport type {\n  AnyStruct,\n  Assign,\n  ObjectSchema,\n  ObjectType,\n} from 'superstruct/dist/utils';\n\nimport { indent } from './strings';\n\n/**\n * Infer a struct type, only if it matches the specified type. This is useful\n * for defining types and structs that are related to each other in separate\n * files.\n *\n * @example\n * ```typescript\n * // In file A\n * export type GetFileArgs = {\n *   path: string;\n *   encoding?: EnumToUnion<AuxiliaryFileEncoding>;\n * };\n *\n * // In file B\n * export const GetFileArgsStruct = object(...);\n *\n * // If the type and struct are in the same file, this will return the type.\n * // Otherwise, it will return `never`.\n * export type GetFileArgs =\n *   InferMatching<typeof GetFileArgsStruct, GetFileArgs>;\n * ```\n */\nexport type InferMatching<\n  StructType extends Struct<any, any>,\n  Type,\n> = StructType['TYPE'] extends Type ? Type : never;\n\n/**\n * Colorize a value with a color function. This is useful for colorizing values\n * in error messages. If colorization is disabled, the original value is\n * returned.\n *\n * @param value - The value to colorize.\n * @param colorFunction - The color function to use.\n * @param enabled - Whether to colorize the value.\n * @returns The colorized value, or the original value if colorization is\n * disabled.\n */\nfunction color(\n  value: string,\n  colorFunction: (value: string) => string,\n  enabled: boolean,\n) {\n  if (enabled) {\n    return colorFunction(value);\n  }\n\n  return value;\n}\n\n/**\n * Define a struct, and also define the name of the struct as the given name.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n *\n * @param name - The name of the struct.\n * @param struct - The struct.\n * @returns The struct.\n */\nexport function named<Type, Schema>(\n  name: string,\n  struct: Struct<Type, Schema>,\n) {\n  return new Struct({\n    ...struct,\n    type: name,\n  });\n}\n\nexport class SnapsStructError<Type, Schema> extends StructError {\n  constructor(\n    struct: Struct<Type, Schema>,\n    prefix: string,\n    suffix: string,\n    failure: StructError,\n    failures: () => Generator<Failure>,\n    colorize = true,\n  ) {\n    super(failure, failures);\n\n    this.name = 'SnapsStructError';\n    this.message = `${prefix}.\\n\\n${getStructErrorMessage(\n      struct,\n      [...failures()],\n      colorize,\n    )}${suffix ? `\\n\\n${suffix}` : ''}`;\n  }\n}\n\ntype GetErrorOptions<Type, Schema> = {\n  struct: Struct<Type, Schema>;\n  prefix: string;\n  suffix?: string;\n  error: StructError;\n  colorize?: boolean;\n};\n\n/**\n * Converts an array to a generator function that yields the items in the\n * array.\n *\n * @param array - The array.\n * @returns A generator function.\n * @yields The items in the array.\n */\nexport function* arrayToGenerator<Type>(\n  array: Type[],\n): Generator<Type, void, undefined> {\n  for (const item of array) {\n    yield item;\n  }\n}\n\n/**\n * Returns a `SnapsStructError` with the given prefix and suffix.\n *\n * @param options - The options.\n * @param options.struct - The struct that caused the error.\n * @param options.prefix - The prefix to add to the error message.\n * @param options.suffix - The suffix to add to the error message. Defaults to\n * an empty string.\n * @param options.error - The `superstruct` error to wrap.\n * @param options.colorize - Whether to colorize the value. Defaults to `true`.\n * @returns The `SnapsStructError`.\n */\nexport function getError<Type, Schema>({\n  struct,\n  prefix,\n  suffix = '',\n  error,\n  colorize,\n}: GetErrorOptions<Type, Schema>) {\n  return new SnapsStructError(\n    struct,\n    prefix,\n    suffix,\n    error,\n    () => arrayToGenerator(error.failures()),\n    colorize,\n  );\n}\n\n/**\n * A wrapper of `superstruct`'s `create` function that throws a\n * `SnapsStructError` instead of a `StructError`. This is useful for improving\n * the error messages returned by `superstruct`.\n *\n * @param value - The value to validate.\n * @param struct - The `superstruct` struct to validate the value against.\n * @param prefix - The prefix to add to the error message.\n * @param suffix - The suffix to add to the error message. Defaults to an empty\n * string.\n * @returns The validated value.\n */\nexport function createFromStruct<Type, Schema>(\n  value: unknown,\n  struct: Struct<Type, Schema>,\n  prefix: string,\n  suffix = '',\n) {\n  try {\n    return create(value, struct);\n  } catch (error) {\n    if (error instanceof StructError) {\n      throw getError({ struct, prefix, suffix, error });\n    }\n\n    throw error;\n  }\n}\n\n/**\n * Get a struct from a failure path.\n *\n * @param struct - The struct.\n * @param path - The failure path.\n * @returns The struct at the failure path.\n */\nexport function getStructFromPath<Type, Schema>(\n  struct: Struct<Type, Schema>,\n  path: string[],\n) {\n  return path.reduce<AnyStruct>((result, key) => {\n    if (isObject(struct.schema) && struct.schema[key]) {\n      return struct.schema[key] as AnyStruct;\n    }\n\n    return result;\n  }, struct);\n}\n\n/**\n * Get the union struct names from a struct.\n *\n * @param struct - The struct.\n * @param colorize - Whether to colorize the value. Defaults to `true`.\n * @returns The union struct names, or `null` if the struct is not a union\n * struct.\n */\nexport function getUnionStructNames<Type, Schema>(\n  struct: Struct<Type, Schema>,\n  colorize = true,\n) {\n  if (Array.isArray(struct.schema)) {\n    return struct.schema.map(({ type }) => color(type, green, colorize));\n  }\n\n  return null;\n}\n\n/**\n * Get an error prefix from a `superstruct` failure. This is useful for\n * formatting the error message returned by `superstruct`.\n *\n * @param failure - The `superstruct` failure.\n * @param colorize - Whether to colorize the value. Defaults to `true`.\n * @returns The error prefix.\n */\nexport function getStructErrorPrefix(failure: Failure, colorize = true) {\n  if (failure.type === 'never' || failure.path.length === 0) {\n    return '';\n  }\n\n  return `At path: ${color(failure.path.join('.'), bold, colorize)}  `;\n}\n\n/**\n * Get a string describing the failure. This is similar to the `message`\n * property of `superstruct`'s `Failure` type, but formats the value in a more\n * readable way.\n *\n * @param struct - The struct that caused the failure.\n * @param failure - The `superstruct` failure.\n * @param colorize - Whether to colorize the value. Defaults to `true`.\n * @returns A string describing the failure.\n */\nexport function getStructFailureMessage<Type, Schema>(\n  struct: Struct<Type, Schema>,\n  failure: Failure,\n  colorize = true,\n) {\n  const received = color(JSON.stringify(failure.value), red, colorize);\n  const prefix = getStructErrorPrefix(failure, colorize);\n\n  if (failure.type === 'union') {\n    const childStruct = getStructFromPath(struct, failure.path);\n    const unionNames = getUnionStructNames(childStruct, colorize);\n\n    if (unionNames) {\n      return `${prefix}Expected the value to be one of: ${unionNames.join(\n        ', ',\n      )}, but received: ${received}.`;\n    }\n\n    return `${prefix}${failure.message}.`;\n  }\n\n  if (failure.type === 'literal') {\n    // Superstruct's failure does not provide information about which literal\n    // value was expected, so we need to parse the message to get the literal.\n    const message = failure.message\n      .replace(\n        /the literal `(.+)`,/u,\n        `the value to be \\`${color('$1', green, colorize)}\\`,`,\n      )\n      .replace(\n        /, but received: (.+)/u,\n        `, but received: ${color('$1', red, colorize)}`,\n      );\n\n    return `${prefix}${message}.`;\n  }\n\n  if (failure.type === 'never') {\n    return `Unknown key: ${color(\n      failure.path.join('.'),\n      bold,\n      colorize,\n    )}, received: ${received}.`;\n  }\n\n  if (failure.refinement === 'size') {\n    const message = failure.message\n      .replace(\n        /length between `(\\d+)` and `(\\d+)`/u,\n        `length between ${color('$1', green, colorize)} and ${color(\n          '$2',\n          green,\n          colorize,\n        )},`,\n      )\n      .replace(/length of `(\\d+)`/u, `length of ${color('$1', red, colorize)}`)\n      .replace(/a array/u, 'an array');\n\n    return `${prefix}${message}.`;\n  }\n\n  return `${prefix}Expected a value of type ${color(\n    failure.type,\n    green,\n    colorize,\n  )}, but received: ${received}.`;\n}\n\n/**\n * Get a string describing the errors. This formats all the errors in a\n * human-readable way.\n *\n * @param struct - The struct that caused the failures.\n * @param failures - The `superstruct` failures.\n * @param colorize - Whether to colorize the value. Defaults to `true`.\n * @returns A string describing the errors.\n */\nexport function getStructErrorMessage<Type, Schema>(\n  struct: Struct<Type, Schema>,\n  failures: Failure[],\n  colorize = true,\n) {\n  const formattedFailures = failures.map((failure) =>\n    indent(` ${getStructFailureMessage(struct, failure, colorize)}`),\n  );\n\n  return formattedFailures.join('\\n');\n}\n\n/**\n * Validate a union struct, and throw readable errors if the value does not\n * satisfy the struct. This is useful for improving the error messages returned\n * by `superstruct`.\n *\n * @param value - The value to validate.\n * @param struct - The `superstruct` union struct to validate the value against.\n * This struct must be a union of object structs, and must have at least one\n * shared key to validate against.\n * @param structKey - The key to validate against. This key must be present in\n * all the object structs in the union struct, and is expected to be a literal\n * value.\n * @param coerce - Whether to coerce the value to satisfy the struct. Defaults\n * to `false`.\n * @returns The validated value.\n * @throws If the value does not satisfy the struct.\n * @example\n * const struct = union([\n *   object({ type: literal('a'), value: string() }),\n *   object({ type: literal('b'), value: number() }),\n *   object({ type: literal('c'), value: boolean() }),\n *   // ...\n * ]);\n *\n * // At path: type  Expected the value to be one of: \"a\", \"b\", \"c\", but received: \"d\".\n * validateUnion({ type: 'd', value: 'foo' }, struct, 'type');\n *\n * // At path: value  Expected a value of type string, but received: 42.\n * validateUnion({ type: 'a', value: 42 }, struct, 'value');\n */\nexport function validateUnion<Type, Schema extends readonly Struct<any, any>[]>(\n  value: unknown,\n  struct: Struct<Type, Schema>,\n  structKey: keyof Type,\n  coerce = false,\n) {\n  assert(\n    struct.schema,\n    'Expected a struct with a schema. Make sure to use `union` from `@metamask/snaps-sdk`.',\n  );\n  assert(struct.schema.length > 0, 'Expected a non-empty array of structs.');\n\n  const keyUnion = struct.schema.map(\n    (innerStruct) => innerStruct.schema[structKey],\n    // This is guaranteed to be a non-empty array by the assertion above. We\n    // need to cast it since `superstruct` requires a non-empty array of structs\n    // for the `union` struct.\n  ) as NonEmptyArray<Struct>;\n\n  const key = superstructType({\n    [structKey]: union(keyUnion),\n  });\n\n  const [keyError] = validate(value, key, { coerce });\n  if (keyError) {\n    throw new Error(\n      getStructFailureMessage(key, keyError.failures()[0], false),\n    );\n  }\n\n  // At this point it's guaranteed that the value is an object, so we can safely\n  // cast it to a Record.\n  const objectValue = value as Record<PropertyKey, unknown>;\n  const objectStructs = struct.schema.filter((innerStruct) =>\n    is(objectValue[structKey], innerStruct.schema[structKey]),\n  );\n\n  assert(objectStructs.length > 0, 'Expected a struct to match the value.');\n\n  // We need to validate the value against all the object structs that match the\n  // struct key, and return the first validated value.\n  const validationResults = objectStructs.map((objectStruct) =>\n    validate(objectValue, objectStruct, { coerce }),\n  );\n\n  const validatedValue = validationResults.find(([error]) => !error);\n  if (validatedValue) {\n    return validatedValue[1];\n  }\n\n  assert(validationResults[0][0], 'Expected at least one error.');\n\n  // If there is no validated value, we need to find the error with the least\n  // number of failures (with the assumption that it's the most specific error).\n  const validationError = validationResults.reduce((error, [innerError]) => {\n    assert(innerError, 'Expected an error.');\n    if (innerError.failures().length < error.failures().length) {\n      return innerError;\n    }\n\n    return error;\n  }, validationResults[0][0]);\n\n  throw new Error(\n    getStructFailureMessage(struct, validationError.failures()[0], false),\n  );\n}\n\n/**\n * Create a value with the coercion logic of a union struct, and throw readable\n * errors if the value does not satisfy the struct. This is useful for improving\n * the error messages returned by `superstruct`.\n *\n * @param value - The value to validate.\n * @param struct - The `superstruct` union struct to validate the value against.\n * This struct must be a union of object structs, and must have at least one\n * shared key to validate against.\n * @param structKey - The key to validate against. This key must be present in\n * all the object structs in the union struct, and is expected to be a literal\n * value.\n * @returns The validated value.\n * @throws If the value does not satisfy the struct.\n * @see validateUnion\n */\nexport function createUnion<Type, Schema extends readonly Struct<any, any>[]>(\n  value: unknown,\n  struct: Struct<Type, Schema>,\n  structKey: keyof Type,\n) {\n  return validateUnion(value, struct, structKey, true);\n}\n\n// These types are copied from Superstruct, to mirror `assign`.\nexport function mergeStructs<\n  ObjectA extends ObjectSchema,\n  ObjectB extends ObjectSchema,\n>(\n  A: Struct<ObjectType<ObjectA>, ObjectA>,\n  B: Struct<ObjectType<ObjectB>, ObjectB>,\n): Struct<ObjectType<Assign<ObjectA, ObjectB>>, Assign<ObjectA, ObjectB>>;\nexport function mergeStructs<\n  ObjectA extends ObjectSchema,\n  ObjectB extends ObjectSchema,\n  ObjectC extends ObjectSchema,\n>(\n  A: Struct<ObjectType<ObjectA>, ObjectA>,\n  B: Struct<ObjectType<ObjectB>, ObjectB>,\n  C: Struct<ObjectType<ObjectC>, ObjectC>,\n): Struct<\n  ObjectType<Assign<Assign<ObjectA, ObjectB>, ObjectC>>,\n  Assign<Assign<ObjectA, ObjectB>, ObjectC>\n>;\nexport function mergeStructs<\n  ObjectA extends ObjectSchema,\n  ObjectB extends ObjectSchema,\n  ObjectC extends ObjectSchema,\n  ObjectD extends ObjectSchema,\n>(\n  A: Struct<ObjectType<ObjectA>, ObjectA>,\n  B: Struct<ObjectType<ObjectB>, ObjectB>,\n  C: Struct<ObjectType<ObjectC>, ObjectC>,\n  D: Struct<ObjectType<ObjectD>, ObjectD>,\n): Struct<\n  ObjectType<Assign<Assign<Assign<ObjectA, ObjectB>, ObjectC>, ObjectD>>,\n  Assign<Assign<Assign<ObjectA, ObjectB>, ObjectC>, ObjectD>\n>;\nexport function mergeStructs<\n  ObjectA extends ObjectSchema,\n  ObjectB extends ObjectSchema,\n  ObjectC extends ObjectSchema,\n  ObjectD extends ObjectSchema,\n  ObjectE extends ObjectSchema,\n>(\n  A: Struct<ObjectType<ObjectA>, ObjectA>,\n  B: Struct<ObjectType<ObjectB>, ObjectB>,\n  C: Struct<ObjectType<ObjectC>, ObjectC>,\n  D: Struct<ObjectType<ObjectD>, ObjectD>,\n  E: Struct<ObjectType<ObjectE>, ObjectE>,\n): Struct<\n  ObjectType<\n    Assign<Assign<Assign<Assign<ObjectA, ObjectB>, ObjectC>, ObjectD>, ObjectE>\n  >,\n  Assign<Assign<Assign<Assign<ObjectA, ObjectB>, ObjectC>, ObjectD>, ObjectE>\n>;\n\n/**\n * Merge multiple structs into one, using superstruct `assign`.\n *\n * Differently from plain `assign`, this function also copies over refinements from each struct.\n *\n * @param structs - The `superstruct` structs to merge.\n * @returns The merged struct.\n */\nexport function mergeStructs(...structs: Struct<any>[]): Struct<any> {\n  const mergedStruct = (assign as (...structs: Struct<any>[]) => Struct)(\n    ...structs,\n  );\n  return new Struct({\n    ...mergedStruct,\n    *refiner(value, ctx) {\n      for (const struct of structs) {\n        yield* struct.refiner(value, ctx);\n      }\n    },\n  });\n}\n"],"mappings":";;;;;AAAA,SAAS,aAAa;AAEtB,SAAS,QAAQ,gBAAgB;AACjC,SAAS,MAAM,OAAO,WAAW;AAEjC;AAAA,EACE;AAAA,EACA;AAAA,EACA,QAAQ;AAAA,EACR;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAgDP,SAAS,MACP,OACA,eACA,SACA;AACA,MAAI,SAAS;AACX,WAAO,cAAc,KAAK;AAAA,EAC5B;AAEA,SAAO;AACT;AAWO,SAAS,MACd,MACA,QACA;AACA,SAAO,IAAI,OAAO;AAAA,IAChB,GAAG;AAAA,IACH,MAAM;AAAA,EACR,CAAC;AACH;AAEO,IAAM,mBAAN,cAA6C,YAAY;AAAA,EAC9D,YACE,QACA,QACA,QACA,SACA,UACA,WAAW,MACX;AACA,UAAM,SAAS,QAAQ;AAEvB,SAAK,OAAO;AACZ,SAAK,UAAU,GAAG,MAAM;AAAA;AAAA,EAAQ;AAAA,MAC9B;AAAA,MACA,CAAC,GAAG,SAAS,CAAC;AAAA,MACd;AAAA,IACF,CAAC,GAAG,SAAS;AAAA;AAAA,EAAO,MAAM,KAAK,EAAE;AAAA,EACnC;AACF;AAkBO,UAAU,iBACf,OACkC;AAClC,aAAW,QAAQ,OAAO;AACxB,UAAM;AAAA,EACR;AACF;AAcO,SAAS,SAAuB;AAAA,EACrC;AAAA,EACA;AAAA,EACA,SAAS;AAAA,EACT;AAAA,EACA;AACF,GAAkC;AAChC,SAAO,IAAI;AAAA,IACT;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,MAAM,iBAAiB,MAAM,SAAS,CAAC;AAAA,IACvC;AAAA,EACF;AACF;AAcO,SAAS,iBACd,OACA,QACA,QACA,SAAS,IACT;AACA,MAAI;AACF,WAAO,OAAO,OAAO,MAAM;AAAA,EAC7B,SAAS,OAAO;AACd,QAAI,iBAAiB,aAAa;AAChC,YAAM,SAAS,EAAE,QAAQ,QAAQ,QAAQ,MAAM,CAAC;AAAA,IAClD;AAEA,UAAM;AAAA,EACR;AACF;AASO,SAAS,kBACd,QACA,MACA;AACA,SAAO,KAAK,OAAkB,CAAC,QAAQ,QAAQ;AAC7C,QAAI,SAAS,OAAO,MAAM,KAAK,OAAO,OAAO,GAAG,GAAG;AACjD,aAAO,OAAO,OAAO,GAAG;AAAA,IAC1B;AAEA,WAAO;AAAA,EACT,GAAG,MAAM;AACX;AAUO,SAAS,oBACd,QACA,WAAW,MACX;AACA,MAAI,MAAM,QAAQ,OAAO,MAAM,GAAG;AAChC,WAAO,OAAO,OAAO,IAAI,CAAC,EAAE,KAAK,MAAM,MAAM,MAAM,OAAO,QAAQ,CAAC;AAAA,EACrE;AAEA,SAAO;AACT;AAUO,SAAS,qBAAqB,SAAkB,WAAW,MAAM;AACtE,MAAI,QAAQ,SAAS,WAAW,QAAQ,KAAK,WAAW,GAAG;AACzD,WAAO;AAAA,EACT;AAEA,SAAO,YAAY,MAAM,QAAQ,KAAK,KAAK,GAAG,GAAG,MAAM,QAAQ,CAAC;AAClE;AAYO,SAAS,wBACd,QACA,SACA,WAAW,MACX;AACA,QAAM,WAAW,MAAM,KAAK,UAAU,QAAQ,KAAK,GAAG,KAAK,QAAQ;AACnE,QAAM,SAAS,qBAAqB,SAAS,QAAQ;AAErD,MAAI,QAAQ,SAAS,SAAS;AAC5B,UAAM,cAAc,kBAAkB,QAAQ,QAAQ,IAAI;AAC1D,UAAM,aAAa,oBAAoB,aAAa,QAAQ;AAE5D,QAAI,YAAY;AACd,aAAO,GAAG,MAAM,oCAAoC,WAAW;AAAA,QAC7D;AAAA,MACF,CAAC,mBAAmB,QAAQ;AAAA,IAC9B;AAEA,WAAO,GAAG,MAAM,GAAG,QAAQ,OAAO;AAAA,EACpC;AAEA,MAAI,QAAQ,SAAS,WAAW;AAG9B,UAAM,UAAU,QAAQ,QACrB;AAAA,MACC;AAAA,MACA,qBAAqB,MAAM,MAAM,OAAO,QAAQ,CAAC;AAAA,IACnD,EACC;AAAA,MACC;AAAA,MACA,mBAAmB,MAAM,MAAM,KAAK,QAAQ,CAAC;AAAA,IAC/C;AAEF,WAAO,GAAG,MAAM,GAAG,OAAO;AAAA,EAC5B;AAEA,MAAI,QAAQ,SAAS,SAAS;AAC5B,WAAO,gBAAgB;AAAA,MACrB,QAAQ,KAAK,KAAK,GAAG;AAAA,MACrB;AAAA,MACA;AAAA,IACF,CAAC,eAAe,QAAQ;AAAA,EAC1B;AAEA,MAAI,QAAQ,eAAe,QAAQ;AACjC,UAAM,UAAU,QAAQ,QACrB;AAAA,MACC;AAAA,MACA,kBAAkB,MAAM,MAAM,OAAO,QAAQ,CAAC,QAAQ;AAAA,QACpD;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC;AAAA,IACH,EACC,QAAQ,sBAAsB,aAAa,MAAM,MAAM,KAAK,QAAQ,CAAC,EAAE,EACvE,QAAQ,YAAY,UAAU;AAEjC,WAAO,GAAG,MAAM,GAAG,OAAO;AAAA,EAC5B;AAEA,SAAO,GAAG,MAAM,4BAA4B;AAAA,IAC1C,QAAQ;AAAA,IACR;AAAA,IACA;AAAA,EACF,CAAC,mBAAmB,QAAQ;AAC9B;AAWO,SAAS,sBACd,QACA,UACA,WAAW,MACX;AACA,QAAM,oBAAoB,SAAS;AAAA,IAAI,CAAC,YACtC,OAAO,UAAK,wBAAwB,QAAQ,SAAS,QAAQ,CAAC,EAAE;AAAA,EAClE;AAEA,SAAO,kBAAkB,KAAK,IAAI;AACpC;AAgCO,SAAS,cACd,OACA,QACA,WACA,SAAS,OACT;AACA;AAAA,IACE,OAAO;AAAA,IACP;AAAA,EACF;AACA,SAAO,OAAO,OAAO,SAAS,GAAG,wCAAwC;AAEzE,QAAM,WAAW,OAAO,OAAO;AAAA,IAC7B,CAAC,gBAAgB,YAAY,OAAO,SAAS;AAAA;AAAA;AAAA;AAAA,EAI/C;AAEA,QAAM,MAAM,gBAAgB;AAAA,IAC1B,CAAC,SAAS,GAAG,MAAM,QAAQ;AAAA,EAC7B,CAAC;AAED,QAAM,CAAC,QAAQ,IAAI,SAAS,OAAO,KAAK,EAAE,OAAO,CAAC;AAClD,MAAI,UAAU;AACZ,UAAM,IAAI;AAAA,MACR,wBAAwB,KAAK,SAAS,SAAS,EAAE,CAAC,GAAG,KAAK;AAAA,IAC5D;AAAA,EACF;AAIA,QAAM,cAAc;AACpB,QAAM,gBAAgB,OAAO,OAAO;AAAA,IAAO,CAAC,gBAC1C,GAAG,YAAY,SAAS,GAAG,YAAY,OAAO,SAAS,CAAC;AAAA,EAC1D;AAEA,SAAO,cAAc,SAAS,GAAG,uCAAuC;AAIxE,QAAM,oBAAoB,cAAc;AAAA,IAAI,CAAC,iBAC3C,SAAS,aAAa,cAAc,EAAE,OAAO,CAAC;AAAA,EAChD;AAEA,QAAM,iBAAiB,kBAAkB,KAAK,CAAC,CAAC,KAAK,MAAM,CAAC,KAAK;AACjE,MAAI,gBAAgB;AAClB,WAAO,eAAe,CAAC;AAAA,EACzB;AAEA,SAAO,kBAAkB,CAAC,EAAE,CAAC,GAAG,8BAA8B;AAI9D,QAAM,kBAAkB,kBAAkB,OAAO,CAAC,OAAO,CAAC,UAAU,MAAM;AACxE,WAAO,YAAY,oBAAoB;AACvC,QAAI,WAAW,SAAS,EAAE,SAAS,MAAM,SAAS,EAAE,QAAQ;AAC1D,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT,GAAG,kBAAkB,CAAC,EAAE,CAAC,CAAC;AAE1B,QAAM,IAAI;AAAA,IACR,wBAAwB,QAAQ,gBAAgB,SAAS,EAAE,CAAC,GAAG,KAAK;AAAA,EACtE;AACF;AAkBO,SAAS,YACd,OACA,QACA,WACA;AACA,SAAO,cAAc,OAAO,QAAQ,WAAW,IAAI;AACrD;AA+DO,SAAS,gBAAgB,SAAqC;AACnE,QAAM,eAAgB;AAAA,IACpB,GAAG;AAAA,EACL;AACA,SAAO,IAAI,OAAO;AAAA,IAChB,GAAG;AAAA,IACH,CAAC,QAAQ,OAAO,KAAK;AACnB,iBAAW,UAAU,SAAS;AAC5B,eAAO,OAAO,QAAQ,OAAO,GAAG;AAAA,MAClC;AAAA,IACF;AAAA,EACF,CAAC;AACH;","names":[]}
\ No newline at end of file
+{"version":3,"sources":["../src/structs.ts"],"sourcesContent":["import { union } from '@metamask/snaps-sdk';\nimport type { NonEmptyArray } from '@metamask/utils';\nimport { assert, isObject } from '@metamask/utils';\nimport { bold, green, red } from 'chalk';\nimport type { Failure } from '@metamask/superstruct';\nimport {\n  is,\n  validate,\n  type as superstructType,\n  Struct,\n  StructError,\n  create,\n  assign,\n} from '@metamask/superstruct';\nimport type {\n  AnyStruct,\n  Assign,\n  ObjectSchema,\n  ObjectType,\n} from '@metamask/superstruct';\n\nimport { indent } from './strings';\n\n/**\n * Infer a struct type, only if it matches the specified type. This is useful\n * for defining types and structs that are related to each other in separate\n * files.\n *\n * @example\n * ```typescript\n * // In file A\n * export type GetFileArgs = {\n *   path: string;\n *   encoding?: EnumToUnion<AuxiliaryFileEncoding>;\n * };\n *\n * // In file B\n * export const GetFileArgsStruct = object(...);\n *\n * // If the type and struct are in the same file, this will return the type.\n * // Otherwise, it will return `never`.\n * export type GetFileArgs =\n *   InferMatching<typeof GetFileArgsStruct, GetFileArgs>;\n * ```\n */\nexport type InferMatching<\n  StructType extends Struct<any, any>,\n  Type,\n> = StructType['TYPE'] extends Type ? Type : never;\n\n/**\n * Colorize a value with a color function. This is useful for colorizing values\n * in error messages. If colorization is disabled, the original value is\n * returned.\n *\n * @param value - The value to colorize.\n * @param colorFunction - The color function to use.\n * @param enabled - Whether to colorize the value.\n * @returns The colorized value, or the original value if colorization is\n * disabled.\n */\nfunction color(\n  value: string,\n  colorFunction: (value: string) => string,\n  enabled: boolean,\n) {\n  if (enabled) {\n    return colorFunction(value);\n  }\n\n  return value;\n}\n\n/**\n * Define a struct, and also define the name of the struct as the given name.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n *\n * @param name - The name of the struct.\n * @param struct - The struct.\n * @returns The struct.\n */\nexport function named<Type, Schema>(\n  name: string,\n  struct: Struct<Type, Schema>,\n) {\n  return new Struct({\n    ...struct,\n    type: name,\n  });\n}\n\nexport class SnapsStructError<Type, Schema> extends StructError {\n  constructor(\n    struct: Struct<Type, Schema>,\n    prefix: string,\n    suffix: string,\n    failure: StructError,\n    failures: () => Generator<Failure>,\n    colorize = true,\n  ) {\n    super(failure, failures);\n\n    this.name = 'SnapsStructError';\n    this.message = `${prefix}.\\n\\n${getStructErrorMessage(\n      struct,\n      [...failures()],\n      colorize,\n    )}${suffix ? `\\n\\n${suffix}` : ''}`;\n  }\n}\n\ntype GetErrorOptions<Type, Schema> = {\n  struct: Struct<Type, Schema>;\n  prefix: string;\n  suffix?: string;\n  error: StructError;\n  colorize?: boolean;\n};\n\n/**\n * Converts an array to a generator function that yields the items in the\n * array.\n *\n * @param array - The array.\n * @returns A generator function.\n * @yields The items in the array.\n */\nexport function* arrayToGenerator<Type>(\n  array: Type[],\n): Generator<Type, void, undefined> {\n  for (const item of array) {\n    yield item;\n  }\n}\n\n/**\n * Returns a `SnapsStructError` with the given prefix and suffix.\n *\n * @param options - The options.\n * @param options.struct - The struct that caused the error.\n * @param options.prefix - The prefix to add to the error message.\n * @param options.suffix - The suffix to add to the error message. Defaults to\n * an empty string.\n * @param options.error - The `superstruct` error to wrap.\n * @param options.colorize - Whether to colorize the value. Defaults to `true`.\n * @returns The `SnapsStructError`.\n */\nexport function getError<Type, Schema>({\n  struct,\n  prefix,\n  suffix = '',\n  error,\n  colorize,\n}: GetErrorOptions<Type, Schema>) {\n  return new SnapsStructError(\n    struct,\n    prefix,\n    suffix,\n    error,\n    () => arrayToGenerator(error.failures()),\n    colorize,\n  );\n}\n\n/**\n * A wrapper of `superstruct`'s `create` function that throws a\n * `SnapsStructError` instead of a `StructError`. This is useful for improving\n * the error messages returned by `superstruct`.\n *\n * @param value - The value to validate.\n * @param struct - The `superstruct` struct to validate the value against.\n * @param prefix - The prefix to add to the error message.\n * @param suffix - The suffix to add to the error message. Defaults to an empty\n * string.\n * @returns The validated value.\n */\nexport function createFromStruct<Type, Schema>(\n  value: unknown,\n  struct: Struct<Type, Schema>,\n  prefix: string,\n  suffix = '',\n) {\n  try {\n    return create(value, struct);\n  } catch (error) {\n    if (error instanceof StructError) {\n      throw getError({ struct, prefix, suffix, error });\n    }\n\n    throw error;\n  }\n}\n\n/**\n * Get a struct from a failure path.\n *\n * @param struct - The struct.\n * @param path - The failure path.\n * @returns The struct at the failure path.\n */\nexport function getStructFromPath<Type, Schema>(\n  struct: Struct<Type, Schema>,\n  path: string[],\n) {\n  return path.reduce<AnyStruct>((result, key) => {\n    if (isObject(struct.schema) && struct.schema[key]) {\n      return struct.schema[key] as AnyStruct;\n    }\n\n    return result;\n  }, struct);\n}\n\n/**\n * Get the union struct names from a struct.\n *\n * @param struct - The struct.\n * @param colorize - Whether to colorize the value. Defaults to `true`.\n * @returns The union struct names, or `null` if the struct is not a union\n * struct.\n */\nexport function getUnionStructNames<Type, Schema>(\n  struct: Struct<Type, Schema>,\n  colorize = true,\n) {\n  if (Array.isArray(struct.schema)) {\n    return struct.schema.map(({ type }) => color(type, green, colorize));\n  }\n\n  return null;\n}\n\n/**\n * Get an error prefix from a `superstruct` failure. This is useful for\n * formatting the error message returned by `superstruct`.\n *\n * @param failure - The `superstruct` failure.\n * @param colorize - Whether to colorize the value. Defaults to `true`.\n * @returns The error prefix.\n */\nexport function getStructErrorPrefix(failure: Failure, colorize = true) {\n  if (failure.type === 'never' || failure.path.length === 0) {\n    return '';\n  }\n\n  return `At path: ${color(failure.path.join('.'), bold, colorize)}  `;\n}\n\n/**\n * Get a string describing the failure. This is similar to the `message`\n * property of `superstruct`'s `Failure` type, but formats the value in a more\n * readable way.\n *\n * @param struct - The struct that caused the failure.\n * @param failure - The `superstruct` failure.\n * @param colorize - Whether to colorize the value. Defaults to `true`.\n * @returns A string describing the failure.\n */\nexport function getStructFailureMessage<Type, Schema>(\n  struct: Struct<Type, Schema>,\n  failure: Failure,\n  colorize = true,\n) {\n  const received = color(JSON.stringify(failure.value), red, colorize);\n  const prefix = getStructErrorPrefix(failure, colorize);\n\n  if (failure.type === 'union') {\n    const childStruct = getStructFromPath(struct, failure.path);\n    const unionNames = getUnionStructNames(childStruct, colorize);\n\n    if (unionNames) {\n      return `${prefix}Expected the value to be one of: ${unionNames.join(\n        ', ',\n      )}, but received: ${received}.`;\n    }\n\n    return `${prefix}${failure.message}.`;\n  }\n\n  if (failure.type === 'literal') {\n    // Superstruct's failure does not provide information about which literal\n    // value was expected, so we need to parse the message to get the literal.\n    const message = failure.message\n      .replace(\n        /the literal `(.+)`,/u,\n        `the value to be \\`${color('$1', green, colorize)}\\`,`,\n      )\n      .replace(\n        /, but received: (.+)/u,\n        `, but received: ${color('$1', red, colorize)}`,\n      );\n\n    return `${prefix}${message}.`;\n  }\n\n  if (failure.type === 'never') {\n    return `Unknown key: ${color(\n      failure.path.join('.'),\n      bold,\n      colorize,\n    )}, received: ${received}.`;\n  }\n\n  if (failure.refinement === 'size') {\n    const message = failure.message\n      .replace(\n        /length between `(\\d+)` and `(\\d+)`/u,\n        `length between ${color('$1', green, colorize)} and ${color(\n          '$2',\n          green,\n          colorize,\n        )},`,\n      )\n      .replace(/length of `(\\d+)`/u, `length of ${color('$1', red, colorize)}`)\n      .replace(/a array/u, 'an array');\n\n    return `${prefix}${message}.`;\n  }\n\n  return `${prefix}Expected a value of type ${color(\n    failure.type,\n    green,\n    colorize,\n  )}, but received: ${received}.`;\n}\n\n/**\n * Get a string describing the errors. This formats all the errors in a\n * human-readable way.\n *\n * @param struct - The struct that caused the failures.\n * @param failures - The `superstruct` failures.\n * @param colorize - Whether to colorize the value. Defaults to `true`.\n * @returns A string describing the errors.\n */\nexport function getStructErrorMessage<Type, Schema>(\n  struct: Struct<Type, Schema>,\n  failures: Failure[],\n  colorize = true,\n) {\n  const formattedFailures = failures.map((failure) =>\n    indent(` ${getStructFailureMessage(struct, failure, colorize)}`),\n  );\n\n  return formattedFailures.join('\\n');\n}\n\n/**\n * Validate a union struct, and throw readable errors if the value does not\n * satisfy the struct. This is useful for improving the error messages returned\n * by `superstruct`.\n *\n * @param value - The value to validate.\n * @param struct - The `superstruct` union struct to validate the value against.\n * This struct must be a union of object structs, and must have at least one\n * shared key to validate against.\n * @param structKey - The key to validate against. This key must be present in\n * all the object structs in the union struct, and is expected to be a literal\n * value.\n * @param coerce - Whether to coerce the value to satisfy the struct. Defaults\n * to `false`.\n * @returns The validated value.\n * @throws If the value does not satisfy the struct.\n * @example\n * const struct = union([\n *   object({ type: literal('a'), value: string() }),\n *   object({ type: literal('b'), value: number() }),\n *   object({ type: literal('c'), value: boolean() }),\n *   // ...\n * ]);\n *\n * // At path: type  Expected the value to be one of: \"a\", \"b\", \"c\", but received: \"d\".\n * validateUnion({ type: 'd', value: 'foo' }, struct, 'type');\n *\n * // At path: value  Expected a value of type string, but received: 42.\n * validateUnion({ type: 'a', value: 42 }, struct, 'value');\n */\nexport function validateUnion<Type, Schema extends readonly Struct<any, any>[]>(\n  value: unknown,\n  struct: Struct<Type, Schema>,\n  structKey: keyof Type,\n  coerce = false,\n) {\n  assert(\n    struct.schema,\n    'Expected a struct with a schema. Make sure to use `union` from `@metamask/snaps-sdk`.',\n  );\n  assert(struct.schema.length > 0, 'Expected a non-empty array of structs.');\n\n  const keyUnion = struct.schema.map(\n    (innerStruct) => innerStruct.schema[structKey],\n    // This is guaranteed to be a non-empty array by the assertion above. We\n    // need to cast it since `superstruct` requires a non-empty array of structs\n    // for the `union` struct.\n  ) as NonEmptyArray<Struct>;\n\n  const key = superstructType({\n    [structKey]: union(keyUnion),\n  });\n\n  const [keyError] = validate(value, key, { coerce });\n  if (keyError) {\n    throw new Error(\n      getStructFailureMessage(key, keyError.failures()[0], false),\n    );\n  }\n\n  // At this point it's guaranteed that the value is an object, so we can safely\n  // cast it to a Record.\n  const objectValue = value as Record<PropertyKey, unknown>;\n  const objectStructs = struct.schema.filter((innerStruct) =>\n    is(objectValue[structKey], innerStruct.schema[structKey]),\n  );\n\n  assert(objectStructs.length > 0, 'Expected a struct to match the value.');\n\n  // We need to validate the value against all the object structs that match the\n  // struct key, and return the first validated value.\n  const validationResults = objectStructs.map((objectStruct) =>\n    validate(objectValue, objectStruct, { coerce }),\n  );\n\n  const validatedValue = validationResults.find(([error]) => !error);\n  if (validatedValue) {\n    return validatedValue[1];\n  }\n\n  assert(validationResults[0][0], 'Expected at least one error.');\n\n  // If there is no validated value, we need to find the error with the least\n  // number of failures (with the assumption that it's the most specific error).\n  const validationError = validationResults.reduce((error, [innerError]) => {\n    assert(innerError, 'Expected an error.');\n    if (innerError.failures().length < error.failures().length) {\n      return innerError;\n    }\n\n    return error;\n  }, validationResults[0][0]);\n\n  throw new Error(\n    getStructFailureMessage(struct, validationError.failures()[0], false),\n  );\n}\n\n/**\n * Create a value with the coercion logic of a union struct, and throw readable\n * errors if the value does not satisfy the struct. This is useful for improving\n * the error messages returned by `superstruct`.\n *\n * @param value - The value to validate.\n * @param struct - The `superstruct` union struct to validate the value against.\n * This struct must be a union of object structs, and must have at least one\n * shared key to validate against.\n * @param structKey - The key to validate against. This key must be present in\n * all the object structs in the union struct, and is expected to be a literal\n * value.\n * @returns The validated value.\n * @throws If the value does not satisfy the struct.\n * @see validateUnion\n */\nexport function createUnion<Type, Schema extends readonly Struct<any, any>[]>(\n  value: unknown,\n  struct: Struct<Type, Schema>,\n  structKey: keyof Type,\n) {\n  return validateUnion(value, struct, structKey, true);\n}\n\n// These types are copied from Superstruct, to mirror `assign`.\nexport function mergeStructs<\n  ObjectA extends ObjectSchema,\n  ObjectB extends ObjectSchema,\n>(\n  A: Struct<ObjectType<ObjectA>, ObjectA>,\n  B: Struct<ObjectType<ObjectB>, ObjectB>,\n): Struct<ObjectType<Assign<ObjectA, ObjectB>>, Assign<ObjectA, ObjectB>>;\nexport function mergeStructs<\n  ObjectA extends ObjectSchema,\n  ObjectB extends ObjectSchema,\n  ObjectC extends ObjectSchema,\n>(\n  A: Struct<ObjectType<ObjectA>, ObjectA>,\n  B: Struct<ObjectType<ObjectB>, ObjectB>,\n  C: Struct<ObjectType<ObjectC>, ObjectC>,\n): Struct<\n  ObjectType<Assign<Assign<ObjectA, ObjectB>, ObjectC>>,\n  Assign<Assign<ObjectA, ObjectB>, ObjectC>\n>;\nexport function mergeStructs<\n  ObjectA extends ObjectSchema,\n  ObjectB extends ObjectSchema,\n  ObjectC extends ObjectSchema,\n  ObjectD extends ObjectSchema,\n>(\n  A: Struct<ObjectType<ObjectA>, ObjectA>,\n  B: Struct<ObjectType<ObjectB>, ObjectB>,\n  C: Struct<ObjectType<ObjectC>, ObjectC>,\n  D: Struct<ObjectType<ObjectD>, ObjectD>,\n): Struct<\n  ObjectType<Assign<Assign<Assign<ObjectA, ObjectB>, ObjectC>, ObjectD>>,\n  Assign<Assign<Assign<ObjectA, ObjectB>, ObjectC>, ObjectD>\n>;\nexport function mergeStructs<\n  ObjectA extends ObjectSchema,\n  ObjectB extends ObjectSchema,\n  ObjectC extends ObjectSchema,\n  ObjectD extends ObjectSchema,\n  ObjectE extends ObjectSchema,\n>(\n  A: Struct<ObjectType<ObjectA>, ObjectA>,\n  B: Struct<ObjectType<ObjectB>, ObjectB>,\n  C: Struct<ObjectType<ObjectC>, ObjectC>,\n  D: Struct<ObjectType<ObjectD>, ObjectD>,\n  E: Struct<ObjectType<ObjectE>, ObjectE>,\n): Struct<\n  ObjectType<\n    Assign<Assign<Assign<Assign<ObjectA, ObjectB>, ObjectC>, ObjectD>, ObjectE>\n  >,\n  Assign<Assign<Assign<Assign<ObjectA, ObjectB>, ObjectC>, ObjectD>, ObjectE>\n>;\n\n/**\n * Merge multiple structs into one, using superstruct `assign`.\n *\n * Differently from plain `assign`, this function also copies over refinements from each struct.\n *\n * @param structs - The `superstruct` structs to merge.\n * @returns The merged struct.\n */\nexport function mergeStructs(...structs: Struct<any>[]): Struct<any> {\n  const mergedStruct = (assign as (...structs: Struct<any>[]) => Struct)(\n    ...structs,\n  );\n  return new Struct({\n    ...mergedStruct,\n    *refiner(value, ctx) {\n      for (const struct of structs) {\n        yield* struct.refiner(value, ctx);\n      }\n    },\n  });\n}\n"],"mappings":"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","names":[]}
\ No newline at end of file
diff --git a/dist/chunk-OJM2SKJZ.js.map b/dist/chunk-OJM2SKJZ.js.map
index a622c3eb7b64f74286be6ef92c07d0d979a06390..19e60107094e01124b389f80675aa40b70e538e8 100644
--- a/dist/chunk-OJM2SKJZ.js.map
+++ b/dist/chunk-OJM2SKJZ.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../src/handlers.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  OnCronjobHandler,\n  OnHomePageHandler,\n  OnInstallHandler,\n  OnKeyringRequestHandler,\n  OnNameLookupHandler,\n  OnRpcRequestHandler,\n  OnSignatureHandler,\n  OnTransactionHandler,\n  OnUpdateHandler,\n  OnUserInputHandler,\n} from '@metamask/snaps-sdk';\nimport { ComponentOrElementStruct, SeverityLevel } from '@metamask/snaps-sdk';\nimport {\n  assign,\n  literal,\n  nullable,\n  object,\n  optional,\n  string,\n  array,\n  size,\n  union,\n} from 'superstruct';\n\nimport type { SnapHandler } from './handler-types';\nimport { HandlerType } from './handler-types';\n\nexport type SnapRpcHookArgs = {\n  origin: string;\n  handler: HandlerType;\n  request: Record<string, unknown>;\n};\n\nexport const SNAP_EXPORTS = {\n  [HandlerType.OnRpcRequest]: {\n    type: HandlerType.OnRpcRequest,\n    required: true,\n    validator: (snapExport: unknown): snapExport is OnRpcRequestHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n  [HandlerType.OnTransaction]: {\n    type: HandlerType.OnTransaction,\n    required: true,\n    validator: (snapExport: unknown): snapExport is OnTransactionHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n  [HandlerType.OnCronjob]: {\n    type: HandlerType.OnCronjob,\n    required: true,\n    validator: (snapExport: unknown): snapExport is OnCronjobHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n  [HandlerType.OnNameLookup]: {\n    type: HandlerType.OnNameLookup,\n    required: true,\n    validator: (snapExport: unknown): snapExport is OnNameLookupHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n  [HandlerType.OnInstall]: {\n    type: HandlerType.OnInstall,\n    required: false,\n    validator: (snapExport: unknown): snapExport is OnInstallHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n  [HandlerType.OnUpdate]: {\n    type: HandlerType.OnUpdate,\n    required: false,\n    validator: (snapExport: unknown): snapExport is OnUpdateHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n  [HandlerType.OnKeyringRequest]: {\n    type: HandlerType.OnKeyringRequest,\n    required: true,\n    validator: (snapExport: unknown): snapExport is OnKeyringRequestHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n  [HandlerType.OnHomePage]: {\n    type: HandlerType.OnHomePage,\n    required: true,\n    validator: (snapExport: unknown): snapExport is OnHomePageHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n  [HandlerType.OnSignature]: {\n    type: HandlerType.OnSignature,\n    required: true,\n    validator: (snapExport: unknown): snapExport is OnSignatureHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n  [HandlerType.OnUserInput]: {\n    type: HandlerType.OnUserInput,\n    required: false,\n    validator: (snapExport: unknown): snapExport is OnUserInputHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n} as const;\n\nexport const OnTransactionSeverityResponseStruct = object({\n  severity: optional(literal(SeverityLevel.Critical)),\n});\n\nexport const OnTransactionResponseWithIdStruct = assign(\n  OnTransactionSeverityResponseStruct,\n  object({\n    id: string(),\n  }),\n);\n\nexport const OnTransactionResponseWithContentStruct = assign(\n  OnTransactionSeverityResponseStruct,\n  object({\n    content: ComponentOrElementStruct,\n  }),\n);\n\nexport const OnTransactionResponseStruct = nullable(\n  union([\n    OnTransactionResponseWithContentStruct,\n    OnTransactionResponseWithIdStruct,\n  ]),\n);\n\nexport const OnSignatureResponseStruct = OnTransactionResponseStruct;\n\nexport const OnHomePageResponseWithContentStruct = object({\n  content: ComponentOrElementStruct,\n});\n\nexport const OnHomePageResponseWithIdStruct = object({\n  id: string(),\n});\n\nexport const OnHomePageResponseStruct = union([\n  OnHomePageResponseWithContentStruct,\n  OnHomePageResponseWithIdStruct,\n]);\n\nexport const AddressResolutionStruct = object({\n  protocol: string(),\n  resolvedDomain: string(),\n});\n\nexport const DomainResolutionStruct = object({\n  protocol: string(),\n  resolvedAddress: string(),\n  domainName: string(),\n});\n\nexport const AddressResolutionResponseStruct = object({\n  resolvedDomains: size(array(AddressResolutionStruct), 1, Infinity),\n});\n\nexport const DomainResolutionResponseStruct = object({\n  resolvedAddresses: size(array(DomainResolutionStruct), 1, Infinity),\n});\n\nexport const OnNameLookupResponseStruct = nullable(\n  union([AddressResolutionResponseStruct, DomainResolutionResponseStruct]),\n);\n\n/**\n * Utility type for getting the handler function type from a handler type.\n */\nexport type HandlerFunction<Type extends SnapHandler> =\n  Type['validator'] extends (snapExport: unknown) => snapExport is infer Handler\n    ? Handler\n    : never;\n\n/**\n * All the function-based handlers that a snap can implement.\n */\nexport type SnapFunctionExports = {\n  [Key in keyof typeof SNAP_EXPORTS]?: HandlerFunction<\n    (typeof SNAP_EXPORTS)[Key]\n  >;\n};\n\n/**\n * All handlers that a snap can implement.\n */\nexport type SnapExports = SnapFunctionExports;\n"]}
\ No newline at end of file
+{"version":3,"sources":["../src/handlers.ts"],"names":[],"mappings":";AAYA,SAAS,0BAA0B,qBAAqB;AACxD;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAWA,IAAM,eAAe;AAAA,EAC1B,kCAAyB,GAAG;AAAA,IAC1B;AAAA,IACA,UAAU;AAAA,IACV,WAAW,CAAC,eAA2D;AACrE,aAAO,OAAO,eAAe;AAAA,IAC/B;AAAA,EACF;AAAA,EACA,oCAA0B,GAAG;AAAA,IAC3B;AAAA,IACA,UAAU;AAAA,IACV,WAAW,CAAC,eAA4D;AACtE,aAAO,OAAO,eAAe;AAAA,IAC/B;AAAA,EACF;AAAA,EACA,4BAAsB,GAAG;AAAA,IACvB;AAAA,IACA,UAAU;AAAA,IACV,WAAW,CAAC,eAAwD;AAClE,aAAO,OAAO,eAAe;AAAA,IAC/B;AAAA,EACF;AAAA,EACA,kCAAyB,GAAG;AAAA,IAC1B;AAAA,IACA,UAAU;AAAA,IACV,WAAW,CAAC,eAA2D;AACrE,aAAO,OAAO,eAAe;AAAA,IAC/B;AAAA,EACF;AAAA,EACA,4BAAsB,GAAG;AAAA,IACvB;AAAA,IACA,UAAU;AAAA,IACV,WAAW,CAAC,eAAwD;AAClE,aAAO,OAAO,eAAe;AAAA,IAC/B;AAAA,EACF;AAAA,EACA,0BAAqB,GAAG;AAAA,IACtB;AAAA,IACA,UAAU;AAAA,IACV,WAAW,CAAC,eAAuD;AACjE,aAAO,OAAO,eAAe;AAAA,IAC/B;AAAA,EACF;AAAA,EACA,0CAA6B,GAAG;AAAA,IAC9B;AAAA,IACA,UAAU;AAAA,IACV,WAAW,CAAC,eAA+D;AACzE,aAAO,OAAO,eAAe;AAAA,IAC/B;AAAA,EACF;AAAA,EACA,8BAAuB,GAAG;AAAA,IACxB;AAAA,IACA,UAAU;AAAA,IACV,WAAW,CAAC,eAAyD;AACnE,aAAO,OAAO,eAAe;AAAA,IAC/B;AAAA,EACF;AAAA,EACA,gCAAwB,GAAG;AAAA,IACzB;AAAA,IACA,UAAU;AAAA,IACV,WAAW,CAAC,eAA0D;AACpE,aAAO,OAAO,eAAe;AAAA,IAC/B;AAAA,EACF;AAAA,EACA,gCAAwB,GAAG;AAAA,IACzB;AAAA,IACA,UAAU;AAAA,IACV,WAAW,CAAC,eAA0D;AACpE,aAAO,OAAO,eAAe;AAAA,IAC/B;AAAA,EACF;AACF;AAEO,IAAM,sCAAsC,OAAO;AAAA,EACxD,UAAU,SAAS,QAAQ,cAAc,QAAQ,CAAC;AACpD,CAAC;AAEM,IAAM,oCAAoC;AAAA,EAC/C;AAAA,EACA,OAAO;AAAA,IACL,IAAI,OAAO;AAAA,EACb,CAAC;AACH;AAEO,IAAM,yCAAyC;AAAA,EACpD;AAAA,EACA,OAAO;AAAA,IACL,SAAS;AAAA,EACX,CAAC;AACH;AAEO,IAAM,8BAA8B;AAAA,EACzC,MAAM;AAAA,IACJ;AAAA,IACA;AAAA,EACF,CAAC;AACH;AAEO,IAAM,4BAA4B;AAElC,IAAM,sCAAsC,OAAO;AAAA,EACxD,SAAS;AACX,CAAC;AAEM,IAAM,iCAAiC,OAAO;AAAA,EACnD,IAAI,OAAO;AACb,CAAC;AAEM,IAAM,2BAA2B,MAAM;AAAA,EAC5C;AAAA,EACA;AACF,CAAC;AAEM,IAAM,0BAA0B,OAAO;AAAA,EAC5C,UAAU,OAAO;AAAA,EACjB,gBAAgB,OAAO;AACzB,CAAC;AAEM,IAAM,yBAAyB,OAAO;AAAA,EAC3C,UAAU,OAAO;AAAA,EACjB,iBAAiB,OAAO;AAAA,EACxB,YAAY,OAAO;AACrB,CAAC;AAEM,IAAM,kCAAkC,OAAO;AAAA,EACpD,iBAAiB,KAAK,MAAM,uBAAuB,GAAG,GAAG,QAAQ;AACnE,CAAC;AAEM,IAAM,iCAAiC,OAAO;AAAA,EACnD,mBAAmB,KAAK,MAAM,sBAAsB,GAAG,GAAG,QAAQ;AACpE,CAAC;AAEM,IAAM,6BAA6B;AAAA,EACxC,MAAM,CAAC,iCAAiC,8BAA8B,CAAC;AACzE","sourcesContent":["import type {\n  OnCronjobHandler,\n  OnHomePageHandler,\n  OnInstallHandler,\n  OnKeyringRequestHandler,\n  OnNameLookupHandler,\n  OnRpcRequestHandler,\n  OnSignatureHandler,\n  OnTransactionHandler,\n  OnUpdateHandler,\n  OnUserInputHandler,\n} from '@metamask/snaps-sdk';\nimport { ComponentOrElementStruct, SeverityLevel } from '@metamask/snaps-sdk';\nimport {\n  assign,\n  literal,\n  nullable,\n  object,\n  optional,\n  string,\n  array,\n  size,\n  union,\n} from '@metamask/superstruct';\n\nimport type { SnapHandler } from './handler-types';\nimport { HandlerType } from './handler-types';\n\nexport type SnapRpcHookArgs = {\n  origin: string;\n  handler: HandlerType;\n  request: Record<string, unknown>;\n};\n\nexport const SNAP_EXPORTS = {\n  [HandlerType.OnRpcRequest]: {\n    type: HandlerType.OnRpcRequest,\n    required: true,\n    validator: (snapExport: unknown): snapExport is OnRpcRequestHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n  [HandlerType.OnTransaction]: {\n    type: HandlerType.OnTransaction,\n    required: true,\n    validator: (snapExport: unknown): snapExport is OnTransactionHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n  [HandlerType.OnCronjob]: {\n    type: HandlerType.OnCronjob,\n    required: true,\n    validator: (snapExport: unknown): snapExport is OnCronjobHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n  [HandlerType.OnNameLookup]: {\n    type: HandlerType.OnNameLookup,\n    required: true,\n    validator: (snapExport: unknown): snapExport is OnNameLookupHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n  [HandlerType.OnInstall]: {\n    type: HandlerType.OnInstall,\n    required: false,\n    validator: (snapExport: unknown): snapExport is OnInstallHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n  [HandlerType.OnUpdate]: {\n    type: HandlerType.OnUpdate,\n    required: false,\n    validator: (snapExport: unknown): snapExport is OnUpdateHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n  [HandlerType.OnKeyringRequest]: {\n    type: HandlerType.OnKeyringRequest,\n    required: true,\n    validator: (snapExport: unknown): snapExport is OnKeyringRequestHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n  [HandlerType.OnHomePage]: {\n    type: HandlerType.OnHomePage,\n    required: true,\n    validator: (snapExport: unknown): snapExport is OnHomePageHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n  [HandlerType.OnSignature]: {\n    type: HandlerType.OnSignature,\n    required: true,\n    validator: (snapExport: unknown): snapExport is OnSignatureHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n  [HandlerType.OnUserInput]: {\n    type: HandlerType.OnUserInput,\n    required: false,\n    validator: (snapExport: unknown): snapExport is OnUserInputHandler => {\n      return typeof snapExport === 'function';\n    },\n  },\n} as const;\n\nexport const OnTransactionSeverityResponseStruct = object({\n  severity: optional(literal(SeverityLevel.Critical)),\n});\n\nexport const OnTransactionResponseWithIdStruct = assign(\n  OnTransactionSeverityResponseStruct,\n  object({\n    id: string(),\n  }),\n);\n\nexport const OnTransactionResponseWithContentStruct = assign(\n  OnTransactionSeverityResponseStruct,\n  object({\n    content: ComponentOrElementStruct,\n  }),\n);\n\nexport const OnTransactionResponseStruct = nullable(\n  union([\n    OnTransactionResponseWithContentStruct,\n    OnTransactionResponseWithIdStruct,\n  ]),\n);\n\nexport const OnSignatureResponseStruct = OnTransactionResponseStruct;\n\nexport const OnHomePageResponseWithContentStruct = object({\n  content: ComponentOrElementStruct,\n});\n\nexport const OnHomePageResponseWithIdStruct = object({\n  id: string(),\n});\n\nexport const OnHomePageResponseStruct = union([\n  OnHomePageResponseWithContentStruct,\n  OnHomePageResponseWithIdStruct,\n]);\n\nexport const AddressResolutionStruct = object({\n  protocol: string(),\n  resolvedDomain: string(),\n});\n\nexport const DomainResolutionStruct = object({\n  protocol: string(),\n  resolvedAddress: string(),\n  domainName: string(),\n});\n\nexport const AddressResolutionResponseStruct = object({\n  resolvedDomains: size(array(AddressResolutionStruct), 1, Infinity),\n});\n\nexport const DomainResolutionResponseStruct = object({\n  resolvedAddresses: size(array(DomainResolutionStruct), 1, Infinity),\n});\n\nexport const OnNameLookupResponseStruct = nullable(\n  union([AddressResolutionResponseStruct, DomainResolutionResponseStruct]),\n);\n\n/**\n * Utility type for getting the handler function type from a handler type.\n */\nexport type HandlerFunction<Type extends SnapHandler> =\n  Type['validator'] extends (snapExport: unknown) => snapExport is infer Handler\n    ? Handler\n    : never;\n\n/**\n * All the function-based handlers that a snap can implement.\n */\nexport type SnapFunctionExports = {\n  [Key in keyof typeof SNAP_EXPORTS]?: HandlerFunction<\n    (typeof SNAP_EXPORTS)[Key]\n  >;\n};\n\n/**\n * All handlers that a snap can implement.\n */\nexport type SnapExports = SnapFunctionExports;\n"]}
\ No newline at end of file
diff --git a/dist/chunk-R5DO7T2D.js.map b/dist/chunk-R5DO7T2D.js.map
index b390f18cbf1b3e55bd82fc01c337ed068a12973e..48f29fe714b4dd41823c5e16b40bf400ec7d013d 100644
--- a/dist/chunk-R5DO7T2D.js.map
+++ b/dist/chunk-R5DO7T2D.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../src/localization.ts"],"names":[],"mappings":";;;;;AAAA,SAAS,uBAAuB;AAEhC;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAMA,IAAM,qBAAqB,CAAC,eAAe,cAAc;AAEzD,IAAM,yBAAyB,OAAO;AAAA,EAC3C,QAAQ,OAAO;AAAA,EACf,UAAU;AAAA,IACR,OAAO;AAAA,IACP,OAAO;AAAA,MACL,SAAS,OAAO;AAAA,MAChB,aAAa,SAAS,OAAO,CAAC;AAAA,IAChC,CAAC;AAAA,EACH;AACF,CAAC;AAWM,SAAS,8BACd,mBACiC;AACjC,aAAW,QAAQ,mBAAmB;AACpC,QAAI;AACF,WAAK,SAAS,OAAO,UAAU,KAAK,SAAS,CAAC,GAAG,sBAAsB;AAAA,IACzE,SAAS,OAAO;AACd,UAAI,iBAAiB,aAAa;AAChC,cAAM,IAAI;AAAA,UACR,yCAAyC,KAAK,IAAI,MAAM,MAAM,OAAO;AAAA,QACvE;AAAA,MACF;AAEA,UAAI,iBAAiB,aAAa;AAChC,cAAM,IAAI;AAAA,UACR,sCAAsC,KAAK,IAAI;AAAA,QACjD;AAAA,MACF;AAEA,YAAM;AAAA,IACR;AAAA,EACF;AAEA,SAAO;AACT;AAWO,SAAS,oBACd,QACA,mBACA;AACA,QAAM,OAAO,kBAAkB;AAAA,IAC7B,CAAC,qBAAqB,iBAAiB,WAAW;AAAA,EACpD;AAEA,MAAI,CAAC,MAAM;AACT,WAAO,kBAAkB;AAAA,MACvB,CAAC,qBAAqB,iBAAiB,WAAW;AAAA,IACpD;AAAA,EACF;AAEA,SAAO;AACT;AAEO,IAAM,oBAAoB;AAa1B,SAAS,UAAU,OAAe,MAAoC;AAC3E,QAAM,UAAU,MAAM,SAAS,iBAAiB;AAChD,QAAM,QAAQ,MAAM,KAAK,OAAO;AAEhC,SAAO,MAAM,OAAe,CAAC,QAAQ,CAAC,OAAO,GAAG,MAAM;AACpD,QAAI,CAAC,MAAM;AACT,YAAM,IAAI;AAAA,QACR,wBAAwB,KAAK;AAAA,MAC/B;AAAA,IACF;AAEA,UAAM,cAAc,KAAK,SAAS,IAAI,KAAK,CAAC;AAC5C,QAAI,CAAC,aAAa;AAChB,YAAM,IAAI;AAAA,QACR,wBAAwB,KAAK,gCAAgC,IAAI,KAAK,CAAC,SACrE,KAAK,MACP;AAAA,MACF;AAAA,IACF;AAEA,WAAO,OAAO,QAAQ,OAAO,YAAY,OAAO;AAAA,EAClD,GAAG,KAAK;AACV;AAWO,SAAS,yBACd,cACA,QACA,mBACA;AACA,QAAM,OAAO,oBAAoB,QAAQ,iBAAiB;AAE1D,SAAO,mBAAmB,OAAO,CAAC,UAAU,UAAU;AACpD,UAAM,cAAc,UAAU,SAAS,KAAK,GAAG,IAAI;AACnD,WAAO;AAAA,MACL,GAAG;AAAA,MACH,CAAC,KAAK,GAAG;AAAA,IACX;AAAA,EACF,GAAG,YAAY;AACjB;AASO,SAAS,kCACd,cACA,mBACA;AACA,MAAI;AAGF,sBACG,OAAO,CAAC,SAAS,KAAK,WAAW,IAAI,EACrC,QAAQ,CAAC,SAAS;AACjB,+BAAyB,cAAc,KAAK,QAAQ,iBAAiB;AAAA,IACvE,CAAC;AAGH,6BAAyB,cAAc,MAAM,iBAAiB;AAAA,EAChE,SAAS,OAAO;AACd,UAAM,IAAI;AAAA,MACR,qCAAqC,gBAAgB,KAAK,CAAC;AAAA,IAC7D;AAAA,EACF;AACF","sourcesContent":["import { getErrorMessage } from '@metamask/snaps-sdk';\nimport type { Infer } from 'superstruct';\nimport {\n  create,\n  object,\n  optional,\n  record,\n  string,\n  StructError,\n} from 'superstruct';\n\nimport { parseJson } from './json';\nimport type { SnapManifest } from './manifest';\nimport type { VirtualFile } from './virtual-file';\n\nexport const LOCALIZABLE_FIELDS = ['description', 'proposedName'] as const;\n\nexport const LocalizationFileStruct = object({\n  locale: string(),\n  messages: record(\n    string(),\n    object({\n      message: string(),\n      description: optional(string()),\n    }),\n  ),\n});\n\nexport type LocalizationFile = Infer<typeof LocalizationFileStruct>;\n\n/**\n * Validate a list of localization files.\n *\n * @param localizationFiles - The localization files to validate.\n * @returns The validated localization files.\n * @throws If any of the files are considered invalid.\n */\nexport function getValidatedLocalizationFiles(\n  localizationFiles: VirtualFile[],\n): VirtualFile<LocalizationFile>[] {\n  for (const file of localizationFiles) {\n    try {\n      file.result = create(parseJson(file.toString()), LocalizationFileStruct);\n    } catch (error) {\n      if (error instanceof StructError) {\n        throw new Error(\n          `Failed to validate localization file \"${file.path}\": ${error.message}.`,\n        );\n      }\n\n      if (error instanceof SyntaxError) {\n        throw new Error(\n          `Failed to parse localization file \"${file.path}\" as JSON.`,\n        );\n      }\n\n      throw error;\n    }\n  }\n\n  return localizationFiles as VirtualFile<LocalizationFile>[];\n}\n\n/**\n * Get the localization file for a given locale. If the locale is not found,\n * the English localization file will be returned.\n *\n * @param locale - The locale to use.\n * @param localizationFiles - The localization files to use.\n * @returns The localization file, or `undefined` if no localization file was\n * found.\n */\nexport function getLocalizationFile(\n  locale: string,\n  localizationFiles: LocalizationFile[],\n) {\n  const file = localizationFiles.find(\n    (localizationFile) => localizationFile.locale === locale,\n  );\n\n  if (!file) {\n    return localizationFiles.find(\n      (localizationFile) => localizationFile.locale === 'en',\n    );\n  }\n\n  return file;\n}\n\nexport const TRANSLATION_REGEX = /\\{\\{\\s?([a-zA-Z0-9-_\\s]+)\\s?\\}\\}/gu;\n\n/**\n * Translate a string using a localization file. This will replace all instances\n * of `{{key}}` with the localized version of `key`.\n *\n * @param value - The string to translate.\n * @param file - The localization file to use, or `undefined` if no localization\n * file was found.\n * @returns The translated string.\n * @throws If the string contains a key that is not present in the localization\n * file, or if no localization file was found.\n */\nexport function translate(value: string, file: LocalizationFile | undefined) {\n  const matches = value.matchAll(TRANSLATION_REGEX);\n  const array = Array.from(matches);\n\n  return array.reduce<string>((result, [match, key]) => {\n    if (!file) {\n      throw new Error(\n        `Failed to translate \"${value}\": No localization file found.`,\n      );\n    }\n\n    const translation = file.messages[key.trim()];\n    if (!translation) {\n      throw new Error(\n        `Failed to translate \"${value}\": No translation found for \"${key.trim()}\" in \"${\n          file.locale\n        }\" file.`,\n      );\n    }\n\n    return result.replace(match, translation.message);\n  }, value);\n}\n\n/**\n * Get the localized Snap manifest for a given locale. This will replace all\n * localized strings in the manifest with the localized version.\n *\n * @param snapManifest - The Snap manifest to localize.\n * @param locale - The locale to use.\n * @param localizationFiles - The localization files to use.\n * @returns The localized Snap manifest.\n */\nexport function getLocalizedSnapManifest(\n  snapManifest: SnapManifest,\n  locale: string,\n  localizationFiles: LocalizationFile[],\n) {\n  const file = getLocalizationFile(locale, localizationFiles);\n\n  return LOCALIZABLE_FIELDS.reduce((manifest, field) => {\n    const translation = translate(manifest[field], file);\n    return {\n      ...manifest,\n      [field]: translation,\n    };\n  }, snapManifest);\n}\n\n/**\n * Validate the localization files for a Snap manifest.\n *\n * @param snapManifest - The Snap manifest to validate.\n * @param localizationFiles - The localization files to validate.\n * @throws If the manifest cannot be localized.\n */\nexport function validateSnapManifestLocalizations(\n  snapManifest: SnapManifest,\n  localizationFiles: LocalizationFile[],\n) {\n  try {\n    // `translate` throws if the manifest cannot be localized, so we just attempt\n    // to translate the manifest using all localization files.\n    localizationFiles\n      .filter((file) => file.locale !== 'en')\n      .forEach((file) => {\n        getLocalizedSnapManifest(snapManifest, file.locale, localizationFiles);\n      });\n\n    // The manifest must be localizable in English.\n    getLocalizedSnapManifest(snapManifest, 'en', localizationFiles);\n  } catch (error) {\n    throw new Error(\n      `Failed to localize Snap manifest: ${getErrorMessage(error)}`,\n    );\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"sources":["../src/localization.ts"],"names":[],"mappings":";;;;;AAAA,SAAS,uBAAuB;AAEhC;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAMA,IAAM,qBAAqB,CAAC,eAAe,cAAc;AAEzD,IAAM,yBAAyB,OAAO;AAAA,EAC3C,QAAQ,OAAO;AAAA,EACf,UAAU;AAAA,IACR,OAAO;AAAA,IACP,OAAO;AAAA,MACL,SAAS,OAAO;AAAA,MAChB,aAAa,SAAS,OAAO,CAAC;AAAA,IAChC,CAAC;AAAA,EACH;AACF,CAAC;AAWM,SAAS,8BACd,mBACiC;AACjC,aAAW,QAAQ,mBAAmB;AACpC,QAAI;AACF,WAAK,SAAS,OAAO,UAAU,KAAK,SAAS,CAAC,GAAG,sBAAsB;AAAA,IACzE,SAAS,OAAO;AACd,UAAI,iBAAiB,aAAa;AAChC,cAAM,IAAI;AAAA,UACR,yCAAyC,KAAK,IAAI,MAAM,MAAM,OAAO;AAAA,QACvE;AAAA,MACF;AAEA,UAAI,iBAAiB,aAAa;AAChC,cAAM,IAAI;AAAA,UACR,sCAAsC,KAAK,IAAI;AAAA,QACjD;AAAA,MACF;AAEA,YAAM;AAAA,IACR;AAAA,EACF;AAEA,SAAO;AACT;AAWO,SAAS,oBACd,QACA,mBACA;AACA,QAAM,OAAO,kBAAkB;AAAA,IAC7B,CAAC,qBAAqB,iBAAiB,WAAW;AAAA,EACpD;AAEA,MAAI,CAAC,MAAM;AACT,WAAO,kBAAkB;AAAA,MACvB,CAAC,qBAAqB,iBAAiB,WAAW;AAAA,IACpD;AAAA,EACF;AAEA,SAAO;AACT;AAEO,IAAM,oBAAoB;AAa1B,SAAS,UAAU,OAAe,MAAoC;AAC3E,QAAM,UAAU,MAAM,SAAS,iBAAiB;AAChD,QAAM,QAAQ,MAAM,KAAK,OAAO;AAEhC,SAAO,MAAM,OAAe,CAAC,QAAQ,CAAC,OAAO,GAAG,MAAM;AACpD,QAAI,CAAC,MAAM;AACT,YAAM,IAAI;AAAA,QACR,wBAAwB,KAAK;AAAA,MAC/B;AAAA,IACF;AAEA,UAAM,cAAc,KAAK,SAAS,IAAI,KAAK,CAAC;AAC5C,QAAI,CAAC,aAAa;AAChB,YAAM,IAAI;AAAA,QACR,wBAAwB,KAAK,gCAAgC,IAAI,KAAK,CAAC,SACrE,KAAK,MACP;AAAA,MACF;AAAA,IACF;AAEA,WAAO,OAAO,QAAQ,OAAO,YAAY,OAAO;AAAA,EAClD,GAAG,KAAK;AACV;AAWO,SAAS,yBACd,cACA,QACA,mBACA;AACA,QAAM,OAAO,oBAAoB,QAAQ,iBAAiB;AAE1D,SAAO,mBAAmB,OAAO,CAAC,UAAU,UAAU;AACpD,UAAM,cAAc,UAAU,SAAS,KAAK,GAAG,IAAI;AACnD,WAAO;AAAA,MACL,GAAG;AAAA,MACH,CAAC,KAAK,GAAG;AAAA,IACX;AAAA,EACF,GAAG,YAAY;AACjB;AASO,SAAS,kCACd,cACA,mBACA;AACA,MAAI;AAGF,sBACG,OAAO,CAAC,SAAS,KAAK,WAAW,IAAI,EACrC,QAAQ,CAAC,SAAS;AACjB,+BAAyB,cAAc,KAAK,QAAQ,iBAAiB;AAAA,IACvE,CAAC;AAGH,6BAAyB,cAAc,MAAM,iBAAiB;AAAA,EAChE,SAAS,OAAO;AACd,UAAM,IAAI;AAAA,MACR,qCAAqC,gBAAgB,KAAK,CAAC;AAAA,IAC7D;AAAA,EACF;AACF","sourcesContent":["import { getErrorMessage } from '@metamask/snaps-sdk';\nimport type { Infer } from '@metamask/superstruct';\nimport {\n  create,\n  object,\n  optional,\n  record,\n  string,\n  StructError,\n} from '@metamask/superstruct';\n\nimport { parseJson } from './json';\nimport type { SnapManifest } from './manifest';\nimport type { VirtualFile } from './virtual-file';\n\nexport const LOCALIZABLE_FIELDS = ['description', 'proposedName'] as const;\n\nexport const LocalizationFileStruct = object({\n  locale: string(),\n  messages: record(\n    string(),\n    object({\n      message: string(),\n      description: optional(string()),\n    }),\n  ),\n});\n\nexport type LocalizationFile = Infer<typeof LocalizationFileStruct>;\n\n/**\n * Validate a list of localization files.\n *\n * @param localizationFiles - The localization files to validate.\n * @returns The validated localization files.\n * @throws If any of the files are considered invalid.\n */\nexport function getValidatedLocalizationFiles(\n  localizationFiles: VirtualFile[],\n): VirtualFile<LocalizationFile>[] {\n  for (const file of localizationFiles) {\n    try {\n      file.result = create(parseJson(file.toString()), LocalizationFileStruct);\n    } catch (error) {\n      if (error instanceof StructError) {\n        throw new Error(\n          `Failed to validate localization file \"${file.path}\": ${error.message}.`,\n        );\n      }\n\n      if (error instanceof SyntaxError) {\n        throw new Error(\n          `Failed to parse localization file \"${file.path}\" as JSON.`,\n        );\n      }\n\n      throw error;\n    }\n  }\n\n  return localizationFiles as VirtualFile<LocalizationFile>[];\n}\n\n/**\n * Get the localization file for a given locale. If the locale is not found,\n * the English localization file will be returned.\n *\n * @param locale - The locale to use.\n * @param localizationFiles - The localization files to use.\n * @returns The localization file, or `undefined` if no localization file was\n * found.\n */\nexport function getLocalizationFile(\n  locale: string,\n  localizationFiles: LocalizationFile[],\n) {\n  const file = localizationFiles.find(\n    (localizationFile) => localizationFile.locale === locale,\n  );\n\n  if (!file) {\n    return localizationFiles.find(\n      (localizationFile) => localizationFile.locale === 'en',\n    );\n  }\n\n  return file;\n}\n\nexport const TRANSLATION_REGEX = /\\{\\{\\s?([a-zA-Z0-9-_\\s]+)\\s?\\}\\}/gu;\n\n/**\n * Translate a string using a localization file. This will replace all instances\n * of `{{key}}` with the localized version of `key`.\n *\n * @param value - The string to translate.\n * @param file - The localization file to use, or `undefined` if no localization\n * file was found.\n * @returns The translated string.\n * @throws If the string contains a key that is not present in the localization\n * file, or if no localization file was found.\n */\nexport function translate(value: string, file: LocalizationFile | undefined) {\n  const matches = value.matchAll(TRANSLATION_REGEX);\n  const array = Array.from(matches);\n\n  return array.reduce<string>((result, [match, key]) => {\n    if (!file) {\n      throw new Error(\n        `Failed to translate \"${value}\": No localization file found.`,\n      );\n    }\n\n    const translation = file.messages[key.trim()];\n    if (!translation) {\n      throw new Error(\n        `Failed to translate \"${value}\": No translation found for \"${key.trim()}\" in \"${\n          file.locale\n        }\" file.`,\n      );\n    }\n\n    return result.replace(match, translation.message);\n  }, value);\n}\n\n/**\n * Get the localized Snap manifest for a given locale. This will replace all\n * localized strings in the manifest with the localized version.\n *\n * @param snapManifest - The Snap manifest to localize.\n * @param locale - The locale to use.\n * @param localizationFiles - The localization files to use.\n * @returns The localized Snap manifest.\n */\nexport function getLocalizedSnapManifest(\n  snapManifest: SnapManifest,\n  locale: string,\n  localizationFiles: LocalizationFile[],\n) {\n  const file = getLocalizationFile(locale, localizationFiles);\n\n  return LOCALIZABLE_FIELDS.reduce((manifest, field) => {\n    const translation = translate(manifest[field], file);\n    return {\n      ...manifest,\n      [field]: translation,\n    };\n  }, snapManifest);\n}\n\n/**\n * Validate the localization files for a Snap manifest.\n *\n * @param snapManifest - The Snap manifest to validate.\n * @param localizationFiles - The localization files to validate.\n * @throws If the manifest cannot be localized.\n */\nexport function validateSnapManifestLocalizations(\n  snapManifest: SnapManifest,\n  localizationFiles: LocalizationFile[],\n) {\n  try {\n    // `translate` throws if the manifest cannot be localized, so we just attempt\n    // to translate the manifest using all localization files.\n    localizationFiles\n      .filter((file) => file.locale !== 'en')\n      .forEach((file) => {\n        getLocalizedSnapManifest(snapManifest, file.locale, localizationFiles);\n      });\n\n    // The manifest must be localizable in English.\n    getLocalizedSnapManifest(snapManifest, 'en', localizationFiles);\n  } catch (error) {\n    throw new Error(\n      `Failed to localize Snap manifest: ${getErrorMessage(error)}`,\n    );\n  }\n}\n"]}
\ No newline at end of file
diff --git a/dist/chunk-T6FWIDA6.mjs.map b/dist/chunk-T6FWIDA6.mjs.map
index be6d80b92f7a57482e3338b4ca61efbe9707ea83..d32530db73b52bece342442d8fe86fe3edb69219 100644
--- a/dist/chunk-T6FWIDA6.mjs.map
+++ b/dist/chunk-T6FWIDA6.mjs.map
@@ -1 +1 @@
-{"version":3,"sources":["../src/types.ts"],"sourcesContent":["import type { Json } from '@metamask/utils';\nimport { assertStruct, VersionStruct } from '@metamask/utils';\nimport type { Infer, Struct } from 'superstruct';\nimport {\n  instance,\n  is,\n  object,\n  optional,\n  pattern,\n  refine,\n  size,\n  string,\n  type,\n  union,\n  assert as assertSuperstruct,\n} from 'superstruct';\n\nimport type { SnapCaveatType } from './caveats';\nimport type { SnapFunctionExports, SnapRpcHookArgs } from './handlers';\nimport type { LocalizationFile } from './localization';\nimport type { SnapManifest } from './manifest';\nimport type { VirtualFile } from './virtual-file';\n\nexport enum NpmSnapFileNames {\n  PackageJson = 'package.json',\n  Manifest = 'snap.manifest.json',\n}\n\nexport const NameStruct = size(\n  pattern(\n    string(),\n    /^(?:@[a-z0-9-*~][a-z0-9-*._~]*\\/)?[a-z0-9-~][a-z0-9-._~]*$/u,\n  ),\n  1,\n  214,\n);\n\n// Note we use `type` instead of `object` here, because the latter does not\n// allow unknown keys.\nexport const NpmSnapPackageJsonStruct = type({\n  version: VersionStruct,\n  name: NameStruct,\n  main: optional(size(string(), 1, Infinity)),\n  repository: optional(\n    object({\n      type: size(string(), 1, Infinity),\n      url: size(string(), 1, Infinity),\n    }),\n  ),\n});\n\nexport type NpmSnapPackageJson = Infer<typeof NpmSnapPackageJsonStruct> &\n  Record<string, any>;\n\n/**\n * Check if the given value is a valid {@link NpmSnapPackageJson} object.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid {@link NpmSnapPackageJson} object.\n */\nexport function isNpmSnapPackageJson(\n  value: unknown,\n): value is NpmSnapPackageJson {\n  return is(value, NpmSnapPackageJsonStruct);\n}\n\n/**\n * Asserts that the given value is a valid {@link NpmSnapPackageJson} object.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid {@link NpmSnapPackageJson} object.\n */\nexport function assertIsNpmSnapPackageJson(\n  value: unknown,\n): asserts value is NpmSnapPackageJson {\n  assertStruct(\n    value,\n    NpmSnapPackageJsonStruct,\n    `\"${NpmSnapFileNames.PackageJson}\" is invalid`,\n  );\n}\n\n/**\n * An object for storing parsed but unvalidated Snap file contents.\n */\nexport type UnvalidatedSnapFiles = {\n  manifest?: VirtualFile<Json>;\n  packageJson?: VirtualFile<Json>;\n  sourceCode?: VirtualFile;\n  svgIcon?: VirtualFile;\n  auxiliaryFiles: VirtualFile[];\n  localizationFiles: VirtualFile[];\n};\n\n/**\n * An object for storing the contents of Snap files that have passed JSON\n * Schema validation, or are non-empty if they are strings.\n */\nexport type SnapFiles = {\n  manifest: VirtualFile<SnapManifest>;\n  packageJson: VirtualFile<NpmSnapPackageJson>;\n  sourceCode: VirtualFile;\n  svgIcon?: VirtualFile;\n  auxiliaryFiles: VirtualFile[];\n  localizationFiles: VirtualFile<LocalizationFile>[];\n};\n\n/**\n * A subset of snap files extracted from a fetched snap.\n */\nexport type FetchedSnapFiles = Pick<\n  SnapFiles,\n  'manifest' | 'sourceCode' | 'svgIcon' | 'auxiliaryFiles' | 'localizationFiles'\n>;\n\n/**\n * The possible prefixes for snap ids.\n */\n/* eslint-disable @typescript-eslint/naming-convention */\nexport enum SnapIdPrefixes {\n  npm = 'npm:',\n  local = 'local:',\n}\n/* eslint-enable @typescript-eslint/naming-convention */\n\n/**\n * Snap validation failure reason codes that are programmatically fixable\n * if validation occurs during development.\n */\nexport enum SnapValidationFailureReason {\n  NameMismatch = '\"name\" field mismatch',\n  VersionMismatch = '\"version\" field mismatch',\n  RepositoryMismatch = '\"repository\" field mismatch',\n  ShasumMismatch = '\"shasum\" field mismatch',\n}\n\n/* eslint-disable @typescript-eslint/naming-convention */\nexport enum SNAP_STREAM_NAMES {\n  JSON_RPC = 'jsonRpc',\n  COMMAND = 'command',\n}\n/* eslint-enable @typescript-eslint/naming-convention */\n\n// The snap is the callee\nexport type SnapRpcHook = (options: SnapRpcHookArgs) => Promise<unknown>;\n\ntype ObjectParameters<\n  Type extends Record<string, (...args: any[]) => unknown>,\n> = Parameters<Type[keyof Type]>;\n\nexport type SnapExportsParameters = ObjectParameters<SnapFunctionExports>;\n\ntype UriOptions<Type extends string> = {\n  protocol?: Struct<Type>;\n  hash?: Struct<Type>;\n  port?: Struct<Type>;\n  hostname?: Struct<Type>;\n  pathname?: Struct<Type>;\n  search?: Struct<Type>;\n};\n\nexport const uri = (opts: UriOptions<any> = {}) =>\n  refine(union([string(), instance(URL)]), 'uri', (value) => {\n    try {\n      const url = new URL(value);\n\n      const UrlStruct = type(opts);\n      assertSuperstruct(url, UrlStruct);\n      return true;\n    } catch {\n      return `Expected URL, got \"${value.toString()}\".`;\n    }\n  });\n\n/**\n * Returns whether a given value is a valid URL.\n *\n * @param url - The value to check.\n * @param opts - Optional constraints for url checking.\n * @returns Whether `url` is valid URL or not.\n */\nexport function isValidUrl(\n  url: unknown,\n  opts: UriOptions<any> = {},\n): url is string | URL {\n  return is(url, uri(opts));\n}\n\n// redefining here to avoid circular dependency\nexport const WALLET_SNAP_PERMISSION_KEY = 'wallet_snap';\n\nexport type SnapsPermissionRequest = {\n  [WALLET_SNAP_PERMISSION_KEY]: {\n    caveats: [\n      {\n        type: SnapCaveatType.SnapIds;\n        value: Record<string, Json>;\n      },\n    ];\n  };\n};\n"],"mappings":";AACA,SAAS,cAAc,qBAAqB;AAE5C;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,UAAU;AAAA,OACL;AAQA,IAAK,mBAAL,kBAAKA,sBAAL;AACL,EAAAA,kBAAA,iBAAc;AACd,EAAAA,kBAAA,cAAW;AAFD,SAAAA;AAAA,GAAA;AAKL,IAAM,aAAa;AAAA,EACxB;AAAA,IACE,OAAO;AAAA,IACP;AAAA,EACF;AAAA,EACA;AAAA,EACA;AACF;AAIO,IAAM,2BAA2B,KAAK;AAAA,EAC3C,SAAS;AAAA,EACT,MAAM;AAAA,EACN,MAAM,SAAS,KAAK,OAAO,GAAG,GAAG,QAAQ,CAAC;AAAA,EAC1C,YAAY;AAAA,IACV,OAAO;AAAA,MACL,MAAM,KAAK,OAAO,GAAG,GAAG,QAAQ;AAAA,MAChC,KAAK,KAAK,OAAO,GAAG,GAAG,QAAQ;AAAA,IACjC,CAAC;AAAA,EACH;AACF,CAAC;AAWM,SAAS,qBACd,OAC6B;AAC7B,SAAO,GAAG,OAAO,wBAAwB;AAC3C;AAQO,SAAS,2BACd,OACqC;AACrC;AAAA,IACE;AAAA,IACA;AAAA,IACA,IAAI,gCAA4B;AAAA,EAClC;AACF;AAuCO,IAAK,iBAAL,kBAAKC,oBAAL;AACL,EAAAA,gBAAA,SAAM;AACN,EAAAA,gBAAA,WAAQ;AAFE,SAAAA;AAAA,GAAA;AAUL,IAAK,8BAAL,kBAAKC,iCAAL;AACL,EAAAA,6BAAA,kBAAe;AACf,EAAAA,6BAAA,qBAAkB;AAClB,EAAAA,6BAAA,wBAAqB;AACrB,EAAAA,6BAAA,oBAAiB;AAJP,SAAAA;AAAA,GAAA;AAQL,IAAK,oBAAL,kBAAKC,uBAAL;AACL,EAAAA,mBAAA,cAAW;AACX,EAAAA,mBAAA,aAAU;AAFA,SAAAA;AAAA,GAAA;AAwBL,IAAM,MAAM,CAAC,OAAwB,CAAC,MAC3C,OAAO,MAAM,CAAC,OAAO,GAAG,SAAS,GAAG,CAAC,CAAC,GAAG,OAAO,CAAC,UAAU;AACzD,MAAI;AACF,UAAM,MAAM,IAAI,IAAI,KAAK;AAEzB,UAAM,YAAY,KAAK,IAAI;AAC3B,sBAAkB,KAAK,SAAS;AAChC,WAAO;AAAA,EACT,QAAQ;AACN,WAAO,sBAAsB,MAAM,SAAS,CAAC;AAAA,EAC/C;AACF,CAAC;AASI,SAAS,WACd,KACA,OAAwB,CAAC,GACJ;AACrB,SAAO,GAAG,KAAK,IAAI,IAAI,CAAC;AAC1B;AAGO,IAAM,6BAA6B;","names":["NpmSnapFileNames","SnapIdPrefixes","SnapValidationFailureReason","SNAP_STREAM_NAMES"]}
\ No newline at end of file
+{"version":3,"sources":["../src/types.ts"],"sourcesContent":["import type { Json } from '@metamask/utils';\nimport { assertStruct, VersionStruct } from '@metamask/utils';\nimport type { Infer, Struct } from '@metamask/superstruct';\nimport {\n  instance,\n  is,\n  object,\n  optional,\n  pattern,\n  refine,\n  size,\n  string,\n  type,\n  union,\n  assert as assertSuperstruct,\n} from '@metamask/superstruct';\n\nimport type { SnapCaveatType } from './caveats';\nimport type { SnapFunctionExports, SnapRpcHookArgs } from './handlers';\nimport type { LocalizationFile } from './localization';\nimport type { SnapManifest } from './manifest';\nimport type { VirtualFile } from './virtual-file';\n\nexport enum NpmSnapFileNames {\n  PackageJson = 'package.json',\n  Manifest = 'snap.manifest.json',\n}\n\nexport const NameStruct = size(\n  pattern(\n    string(),\n    /^(?:@[a-z0-9-*~][a-z0-9-*._~]*\\/)?[a-z0-9-~][a-z0-9-._~]*$/u,\n  ),\n  1,\n  214,\n);\n\n// Note we use `type` instead of `object` here, because the latter does not\n// allow unknown keys.\nexport const NpmSnapPackageJsonStruct = type({\n  version: VersionStruct,\n  name: NameStruct,\n  main: optional(size(string(), 1, Infinity)),\n  repository: optional(\n    object({\n      type: size(string(), 1, Infinity),\n      url: size(string(), 1, Infinity),\n    }),\n  ),\n});\n\nexport type NpmSnapPackageJson = Infer<typeof NpmSnapPackageJsonStruct> &\n  Record<string, any>;\n\n/**\n * Check if the given value is a valid {@link NpmSnapPackageJson} object.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid {@link NpmSnapPackageJson} object.\n */\nexport function isNpmSnapPackageJson(\n  value: unknown,\n): value is NpmSnapPackageJson {\n  return is(value, NpmSnapPackageJsonStruct);\n}\n\n/**\n * Asserts that the given value is a valid {@link NpmSnapPackageJson} object.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid {@link NpmSnapPackageJson} object.\n */\nexport function assertIsNpmSnapPackageJson(\n  value: unknown,\n): asserts value is NpmSnapPackageJson {\n  assertStruct(\n    value,\n    NpmSnapPackageJsonStruct,\n    `\"${NpmSnapFileNames.PackageJson}\" is invalid`,\n  );\n}\n\n/**\n * An object for storing parsed but unvalidated Snap file contents.\n */\nexport type UnvalidatedSnapFiles = {\n  manifest?: VirtualFile<Json>;\n  packageJson?: VirtualFile<Json>;\n  sourceCode?: VirtualFile;\n  svgIcon?: VirtualFile;\n  auxiliaryFiles: VirtualFile[];\n  localizationFiles: VirtualFile[];\n};\n\n/**\n * An object for storing the contents of Snap files that have passed JSON\n * Schema validation, or are non-empty if they are strings.\n */\nexport type SnapFiles = {\n  manifest: VirtualFile<SnapManifest>;\n  packageJson: VirtualFile<NpmSnapPackageJson>;\n  sourceCode: VirtualFile;\n  svgIcon?: VirtualFile;\n  auxiliaryFiles: VirtualFile[];\n  localizationFiles: VirtualFile<LocalizationFile>[];\n};\n\n/**\n * A subset of snap files extracted from a fetched snap.\n */\nexport type FetchedSnapFiles = Pick<\n  SnapFiles,\n  'manifest' | 'sourceCode' | 'svgIcon' | 'auxiliaryFiles' | 'localizationFiles'\n>;\n\n/**\n * The possible prefixes for snap ids.\n */\n/* eslint-disable @typescript-eslint/naming-convention */\nexport enum SnapIdPrefixes {\n  npm = 'npm:',\n  local = 'local:',\n}\n/* eslint-enable @typescript-eslint/naming-convention */\n\n/**\n * Snap validation failure reason codes that are programmatically fixable\n * if validation occurs during development.\n */\nexport enum SnapValidationFailureReason {\n  NameMismatch = '\"name\" field mismatch',\n  VersionMismatch = '\"version\" field mismatch',\n  RepositoryMismatch = '\"repository\" field mismatch',\n  ShasumMismatch = '\"shasum\" field mismatch',\n}\n\n/* eslint-disable @typescript-eslint/naming-convention */\nexport enum SNAP_STREAM_NAMES {\n  JSON_RPC = 'jsonRpc',\n  COMMAND = 'command',\n}\n/* eslint-enable @typescript-eslint/naming-convention */\n\n// The snap is the callee\nexport type SnapRpcHook = (options: SnapRpcHookArgs) => Promise<unknown>;\n\ntype ObjectParameters<\n  Type extends Record<string, (...args: any[]) => unknown>,\n> = Parameters<Type[keyof Type]>;\n\nexport type SnapExportsParameters = ObjectParameters<SnapFunctionExports>;\n\ntype UriOptions<Type extends string> = {\n  protocol?: Struct<Type>;\n  hash?: Struct<Type>;\n  port?: Struct<Type>;\n  hostname?: Struct<Type>;\n  pathname?: Struct<Type>;\n  search?: Struct<Type>;\n};\n\nexport const uri = (opts: UriOptions<any> = {}) =>\n  refine(union([string(), instance(URL)]), 'uri', (value) => {\n    try {\n      const url = new URL(value);\n\n      const UrlStruct = type(opts);\n      assertSuperstruct(url, UrlStruct);\n      return true;\n    } catch {\n      return `Expected URL, got \"${value.toString()}\".`;\n    }\n  });\n\n/**\n * Returns whether a given value is a valid URL.\n *\n * @param url - The value to check.\n * @param opts - Optional constraints for url checking.\n * @returns Whether `url` is valid URL or not.\n */\nexport function isValidUrl(\n  url: unknown,\n  opts: UriOptions<any> = {},\n): url is string | URL {\n  return is(url, uri(opts));\n}\n\n// redefining here to avoid circular dependency\nexport const WALLET_SNAP_PERMISSION_KEY = 'wallet_snap';\n\nexport type SnapsPermissionRequest = {\n  [WALLET_SNAP_PERMISSION_KEY]: {\n    caveats: [\n      {\n        type: SnapCaveatType.SnapIds;\n        value: Record<string, Json>;\n      },\n    ];\n  };\n};\n"],"mappings":";AACA,SAAS,cAAc,qBAAqB;AAE5C;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,UAAU;AAAA,OACL;AAQA,IAAK,mBAAL,kBAAKA,sBAAL;AACL,EAAAA,kBAAA,iBAAc;AACd,EAAAA,kBAAA,cAAW;AAFD,SAAAA;AAAA,GAAA;AAKL,IAAM,aAAa;AAAA,EACxB;AAAA,IACE,OAAO;AAAA,IACP;AAAA,EACF;AAAA,EACA;AAAA,EACA;AACF;AAIO,IAAM,2BAA2B,KAAK;AAAA,EAC3C,SAAS;AAAA,EACT,MAAM;AAAA,EACN,MAAM,SAAS,KAAK,OAAO,GAAG,GAAG,QAAQ,CAAC;AAAA,EAC1C,YAAY;AAAA,IACV,OAAO;AAAA,MACL,MAAM,KAAK,OAAO,GAAG,GAAG,QAAQ;AAAA,MAChC,KAAK,KAAK,OAAO,GAAG,GAAG,QAAQ;AAAA,IACjC,CAAC;AAAA,EACH;AACF,CAAC;AAWM,SAAS,qBACd,OAC6B;AAC7B,SAAO,GAAG,OAAO,wBAAwB;AAC3C;AAQO,SAAS,2BACd,OACqC;AACrC;AAAA,IACE;AAAA,IACA;AAAA,IACA,IAAI,gCAA4B;AAAA,EAClC;AACF;AAuCO,IAAK,iBAAL,kBAAKC,oBAAL;AACL,EAAAA,gBAAA,SAAM;AACN,EAAAA,gBAAA,WAAQ;AAFE,SAAAA;AAAA,GAAA;AAUL,IAAK,8BAAL,kBAAKC,iCAAL;AACL,EAAAA,6BAAA,kBAAe;AACf,EAAAA,6BAAA,qBAAkB;AAClB,EAAAA,6BAAA,wBAAqB;AACrB,EAAAA,6BAAA,oBAAiB;AAJP,SAAAA;AAAA,GAAA;AAQL,IAAK,oBAAL,kBAAKC,uBAAL;AACL,EAAAA,mBAAA,cAAW;AACX,EAAAA,mBAAA,aAAU;AAFA,SAAAA;AAAA,GAAA;AAwBL,IAAM,MAAM,CAAC,OAAwB,CAAC,MAC3C,OAAO,MAAM,CAAC,OAAO,GAAG,SAAS,GAAG,CAAC,CAAC,GAAG,OAAO,CAAC,UAAU;AACzD,MAAI;AACF,UAAM,MAAM,IAAI,IAAI,KAAK;AAEzB,UAAM,YAAY,KAAK,IAAI;AAC3B,sBAAkB,KAAK,SAAS;AAChC,WAAO;AAAA,EACT,QAAQ;AACN,WAAO,sBAAsB,MAAM,SAAS,CAAC;AAAA,EAC/C;AACF,CAAC;AASI,SAAS,WACd,KACA,OAAwB,CAAC,GACJ;AACrB,SAAO,GAAG,KAAK,IAAI,IAAI,CAAC;AAC1B;AAGO,IAAM,6BAA6B;","names":["NpmSnapFileNames","SnapIdPrefixes","SnapValidationFailureReason","SNAP_STREAM_NAMES"]}
\ No newline at end of file
diff --git a/dist/chunk-UMZNVWEM.mjs.map b/dist/chunk-UMZNVWEM.mjs.map
index 068c800d29873541cc45a70b944c837e5721e8dc..6acac0bb8bc9dce262d6e17e4057a2b7ba2dad3f 100644
--- a/dist/chunk-UMZNVWEM.mjs.map
+++ b/dist/chunk-UMZNVWEM.mjs.map
@@ -1 +1 @@
-{"version":3,"sources":["../src/versions.ts"],"sourcesContent":["import type { Json, SemVerVersion, SemVerRange } from '@metamask/utils';\nimport { VersionRangeStruct } from '@metamask/utils';\nimport { maxSatisfying as maxSatisfyingSemver } from 'semver';\nimport { validate } from 'superstruct';\n\nexport const DEFAULT_REQUESTED_SNAP_VERSION = '*' as SemVerRange;\n\n/**\n * Return the highest version in the list that satisfies the range, or `null` if\n * none of them do. For the satisfaction check, pre-release versions will only\n * be checked if no satisfactory non-prerelease version is found first.\n *\n * @param versions - The list of version to check.\n * @param versionRange - The SemVer version range to check against.\n * @returns The highest version in the list that satisfies the range,\n * or `null` if none of them do.\n */\nexport function getTargetVersion(\n  versions: SemVerVersion[],\n  versionRange: SemVerRange,\n): SemVerVersion | null {\n  const maxSatisfyingNonPreRelease = maxSatisfyingSemver(\n    versions,\n    versionRange,\n  );\n\n  // By default don't use pre-release versions\n  if (maxSatisfyingNonPreRelease) {\n    return maxSatisfyingNonPreRelease;\n  }\n\n  // If no satisfying release version is found by default, try pre-release versions\n  return maxSatisfyingSemver(versions, versionRange, {\n    includePrerelease: true,\n  });\n}\n\n/**\n * Parse a version received by some subject attempting to access a snap.\n *\n * @param version - The received version value.\n * @returns `*` if the version is `undefined` or `latest\", otherwise returns\n * the specified version.\n */\nexport function resolveVersionRange(\n  version?: Json,\n): [error: undefined, range: SemVerRange] | [error: Error, range: undefined] {\n  if (version === undefined || version === 'latest') {\n    return [undefined, DEFAULT_REQUESTED_SNAP_VERSION];\n  }\n  return validate(version, VersionRangeStruct);\n}\n"],"mappings":";AACA,SAAS,0BAA0B;AACnC,SAAS,iBAAiB,2BAA2B;AACrD,SAAS,gBAAgB;AAElB,IAAM,iCAAiC;AAYvC,SAAS,iBACd,UACA,cACsB;AACtB,QAAM,6BAA6B;AAAA,IACjC;AAAA,IACA;AAAA,EACF;AAGA,MAAI,4BAA4B;AAC9B,WAAO;AAAA,EACT;AAGA,SAAO,oBAAoB,UAAU,cAAc;AAAA,IACjD,mBAAmB;AAAA,EACrB,CAAC;AACH;AASO,SAAS,oBACd,SAC2E;AAC3E,MAAI,YAAY,UAAa,YAAY,UAAU;AACjD,WAAO,CAAC,QAAW,8BAA8B;AAAA,EACnD;AACA,SAAO,SAAS,SAAS,kBAAkB;AAC7C;","names":[]}
\ No newline at end of file
+{"version":3,"sources":["../src/versions.ts"],"sourcesContent":["import type { Json, SemVerVersion, SemVerRange } from '@metamask/utils';\nimport { VersionRangeStruct } from '@metamask/utils';\nimport { maxSatisfying as maxSatisfyingSemver } from 'semver';\nimport { validate } from '@metamask/superstruct';\n\nexport const DEFAULT_REQUESTED_SNAP_VERSION = '*' as SemVerRange;\n\n/**\n * Return the highest version in the list that satisfies the range, or `null` if\n * none of them do. For the satisfaction check, pre-release versions will only\n * be checked if no satisfactory non-prerelease version is found first.\n *\n * @param versions - The list of version to check.\n * @param versionRange - The SemVer version range to check against.\n * @returns The highest version in the list that satisfies the range,\n * or `null` if none of them do.\n */\nexport function getTargetVersion(\n  versions: SemVerVersion[],\n  versionRange: SemVerRange,\n): SemVerVersion | null {\n  const maxSatisfyingNonPreRelease = maxSatisfyingSemver(\n    versions,\n    versionRange,\n  );\n\n  // By default don't use pre-release versions\n  if (maxSatisfyingNonPreRelease) {\n    return maxSatisfyingNonPreRelease;\n  }\n\n  // If no satisfying release version is found by default, try pre-release versions\n  return maxSatisfyingSemver(versions, versionRange, {\n    includePrerelease: true,\n  });\n}\n\n/**\n * Parse a version received by some subject attempting to access a snap.\n *\n * @param version - The received version value.\n * @returns `*` if the version is `undefined` or `latest\", otherwise returns\n * the specified version.\n */\nexport function resolveVersionRange(\n  version?: Json,\n): [error: undefined, range: SemVerRange] | [error: Error, range: undefined] {\n  if (version === undefined || version === 'latest') {\n    return [undefined, DEFAULT_REQUESTED_SNAP_VERSION];\n  }\n  return validate(version, VersionRangeStruct);\n}\n"],"mappings":";AACA,SAAS,0BAA0B;AACnC,SAAS,iBAAiB,2BAA2B;AACrD,SAAS,gBAAgB;AAElB,IAAM,iCAAiC;AAYvC,SAAS,iBACd,UACA,cACsB;AACtB,QAAM,6BAA6B;AAAA,IACjC;AAAA,IACA;AAAA,EACF;AAGA,MAAI,4BAA4B;AAC9B,WAAO;AAAA,EACT;AAGA,SAAO,oBAAoB,UAAU,cAAc;AAAA,IACjD,mBAAmB;AAAA,EACrB,CAAC;AACH;AASO,SAAS,oBACd,SAC2E;AAC3E,MAAI,YAAY,UAAa,YAAY,UAAU;AACjD,WAAO,CAAC,QAAW,8BAA8B;AAAA,EACnD;AACA,SAAO,SAAS,SAAS,kBAAkB;AAC7C;","names":[]}
\ No newline at end of file
diff --git a/dist/chunk-WZ457PEQ.mjs.map b/dist/chunk-WZ457PEQ.mjs.map
index 033c5aadae4bede2958eeb2331507609b3650588..b958605e41d54d9979bb8f84fecaedc41c711d95 100644
--- a/dist/chunk-WZ457PEQ.mjs.map
+++ b/dist/chunk-WZ457PEQ.mjs.map
@@ -1 +1 @@
-{"version":3,"sources":["../src/localization.ts"],"sourcesContent":["import { getErrorMessage } from '@metamask/snaps-sdk';\nimport type { Infer } from 'superstruct';\nimport {\n  create,\n  object,\n  optional,\n  record,\n  string,\n  StructError,\n} from 'superstruct';\n\nimport { parseJson } from './json';\nimport type { SnapManifest } from './manifest';\nimport type { VirtualFile } from './virtual-file';\n\nexport const LOCALIZABLE_FIELDS = ['description', 'proposedName'] as const;\n\nexport const LocalizationFileStruct = object({\n  locale: string(),\n  messages: record(\n    string(),\n    object({\n      message: string(),\n      description: optional(string()),\n    }),\n  ),\n});\n\nexport type LocalizationFile = Infer<typeof LocalizationFileStruct>;\n\n/**\n * Validate a list of localization files.\n *\n * @param localizationFiles - The localization files to validate.\n * @returns The validated localization files.\n * @throws If any of the files are considered invalid.\n */\nexport function getValidatedLocalizationFiles(\n  localizationFiles: VirtualFile[],\n): VirtualFile<LocalizationFile>[] {\n  for (const file of localizationFiles) {\n    try {\n      file.result = create(parseJson(file.toString()), LocalizationFileStruct);\n    } catch (error) {\n      if (error instanceof StructError) {\n        throw new Error(\n          `Failed to validate localization file \"${file.path}\": ${error.message}.`,\n        );\n      }\n\n      if (error instanceof SyntaxError) {\n        throw new Error(\n          `Failed to parse localization file \"${file.path}\" as JSON.`,\n        );\n      }\n\n      throw error;\n    }\n  }\n\n  return localizationFiles as VirtualFile<LocalizationFile>[];\n}\n\n/**\n * Get the localization file for a given locale. If the locale is not found,\n * the English localization file will be returned.\n *\n * @param locale - The locale to use.\n * @param localizationFiles - The localization files to use.\n * @returns The localization file, or `undefined` if no localization file was\n * found.\n */\nexport function getLocalizationFile(\n  locale: string,\n  localizationFiles: LocalizationFile[],\n) {\n  const file = localizationFiles.find(\n    (localizationFile) => localizationFile.locale === locale,\n  );\n\n  if (!file) {\n    return localizationFiles.find(\n      (localizationFile) => localizationFile.locale === 'en',\n    );\n  }\n\n  return file;\n}\n\nexport const TRANSLATION_REGEX = /\\{\\{\\s?([a-zA-Z0-9-_\\s]+)\\s?\\}\\}/gu;\n\n/**\n * Translate a string using a localization file. This will replace all instances\n * of `{{key}}` with the localized version of `key`.\n *\n * @param value - The string to translate.\n * @param file - The localization file to use, or `undefined` if no localization\n * file was found.\n * @returns The translated string.\n * @throws If the string contains a key that is not present in the localization\n * file, or if no localization file was found.\n */\nexport function translate(value: string, file: LocalizationFile | undefined) {\n  const matches = value.matchAll(TRANSLATION_REGEX);\n  const array = Array.from(matches);\n\n  return array.reduce<string>((result, [match, key]) => {\n    if (!file) {\n      throw new Error(\n        `Failed to translate \"${value}\": No localization file found.`,\n      );\n    }\n\n    const translation = file.messages[key.trim()];\n    if (!translation) {\n      throw new Error(\n        `Failed to translate \"${value}\": No translation found for \"${key.trim()}\" in \"${\n          file.locale\n        }\" file.`,\n      );\n    }\n\n    return result.replace(match, translation.message);\n  }, value);\n}\n\n/**\n * Get the localized Snap manifest for a given locale. This will replace all\n * localized strings in the manifest with the localized version.\n *\n * @param snapManifest - The Snap manifest to localize.\n * @param locale - The locale to use.\n * @param localizationFiles - The localization files to use.\n * @returns The localized Snap manifest.\n */\nexport function getLocalizedSnapManifest(\n  snapManifest: SnapManifest,\n  locale: string,\n  localizationFiles: LocalizationFile[],\n) {\n  const file = getLocalizationFile(locale, localizationFiles);\n\n  return LOCALIZABLE_FIELDS.reduce((manifest, field) => {\n    const translation = translate(manifest[field], file);\n    return {\n      ...manifest,\n      [field]: translation,\n    };\n  }, snapManifest);\n}\n\n/**\n * Validate the localization files for a Snap manifest.\n *\n * @param snapManifest - The Snap manifest to validate.\n * @param localizationFiles - The localization files to validate.\n * @throws If the manifest cannot be localized.\n */\nexport function validateSnapManifestLocalizations(\n  snapManifest: SnapManifest,\n  localizationFiles: LocalizationFile[],\n) {\n  try {\n    // `translate` throws if the manifest cannot be localized, so we just attempt\n    // to translate the manifest using all localization files.\n    localizationFiles\n      .filter((file) => file.locale !== 'en')\n      .forEach((file) => {\n        getLocalizedSnapManifest(snapManifest, file.locale, localizationFiles);\n      });\n\n    // The manifest must be localizable in English.\n    getLocalizedSnapManifest(snapManifest, 'en', localizationFiles);\n  } catch (error) {\n    throw new Error(\n      `Failed to localize Snap manifest: ${getErrorMessage(error)}`,\n    );\n  }\n}\n"],"mappings":";;;;;AAAA,SAAS,uBAAuB;AAEhC;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAMA,IAAM,qBAAqB,CAAC,eAAe,cAAc;AAEzD,IAAM,yBAAyB,OAAO;AAAA,EAC3C,QAAQ,OAAO;AAAA,EACf,UAAU;AAAA,IACR,OAAO;AAAA,IACP,OAAO;AAAA,MACL,SAAS,OAAO;AAAA,MAChB,aAAa,SAAS,OAAO,CAAC;AAAA,IAChC,CAAC;AAAA,EACH;AACF,CAAC;AAWM,SAAS,8BACd,mBACiC;AACjC,aAAW,QAAQ,mBAAmB;AACpC,QAAI;AACF,WAAK,SAAS,OAAO,UAAU,KAAK,SAAS,CAAC,GAAG,sBAAsB;AAAA,IACzE,SAAS,OAAO;AACd,UAAI,iBAAiB,aAAa;AAChC,cAAM,IAAI;AAAA,UACR,yCAAyC,KAAK,IAAI,MAAM,MAAM,OAAO;AAAA,QACvE;AAAA,MACF;AAEA,UAAI,iBAAiB,aAAa;AAChC,cAAM,IAAI;AAAA,UACR,sCAAsC,KAAK,IAAI;AAAA,QACjD;AAAA,MACF;AAEA,YAAM;AAAA,IACR;AAAA,EACF;AAEA,SAAO;AACT;AAWO,SAAS,oBACd,QACA,mBACA;AACA,QAAM,OAAO,kBAAkB;AAAA,IAC7B,CAAC,qBAAqB,iBAAiB,WAAW;AAAA,EACpD;AAEA,MAAI,CAAC,MAAM;AACT,WAAO,kBAAkB;AAAA,MACvB,CAAC,qBAAqB,iBAAiB,WAAW;AAAA,IACpD;AAAA,EACF;AAEA,SAAO;AACT;AAEO,IAAM,oBAAoB;AAa1B,SAAS,UAAU,OAAe,MAAoC;AAC3E,QAAM,UAAU,MAAM,SAAS,iBAAiB;AAChD,QAAM,QAAQ,MAAM,KAAK,OAAO;AAEhC,SAAO,MAAM,OAAe,CAAC,QAAQ,CAAC,OAAO,GAAG,MAAM;AACpD,QAAI,CAAC,MAAM;AACT,YAAM,IAAI;AAAA,QACR,wBAAwB,KAAK;AAAA,MAC/B;AAAA,IACF;AAEA,UAAM,cAAc,KAAK,SAAS,IAAI,KAAK,CAAC;AAC5C,QAAI,CAAC,aAAa;AAChB,YAAM,IAAI;AAAA,QACR,wBAAwB,KAAK,gCAAgC,IAAI,KAAK,CAAC,SACrE,KAAK,MACP;AAAA,MACF;AAAA,IACF;AAEA,WAAO,OAAO,QAAQ,OAAO,YAAY,OAAO;AAAA,EAClD,GAAG,KAAK;AACV;AAWO,SAAS,yBACd,cACA,QACA,mBACA;AACA,QAAM,OAAO,oBAAoB,QAAQ,iBAAiB;AAE1D,SAAO,mBAAmB,OAAO,CAAC,UAAU,UAAU;AACpD,UAAM,cAAc,UAAU,SAAS,KAAK,GAAG,IAAI;AACnD,WAAO;AAAA,MACL,GAAG;AAAA,MACH,CAAC,KAAK,GAAG;AAAA,IACX;AAAA,EACF,GAAG,YAAY;AACjB;AASO,SAAS,kCACd,cACA,mBACA;AACA,MAAI;AAGF,sBACG,OAAO,CAAC,SAAS,KAAK,WAAW,IAAI,EACrC,QAAQ,CAAC,SAAS;AACjB,+BAAyB,cAAc,KAAK,QAAQ,iBAAiB;AAAA,IACvE,CAAC;AAGH,6BAAyB,cAAc,MAAM,iBAAiB;AAAA,EAChE,SAAS,OAAO;AACd,UAAM,IAAI;AAAA,MACR,qCAAqC,gBAAgB,KAAK,CAAC;AAAA,IAC7D;AAAA,EACF;AACF;","names":[]}
\ No newline at end of file
+{"version":3,"sources":["../src/localization.ts"],"sourcesContent":["import { getErrorMessage } from '@metamask/snaps-sdk';\nimport type { Infer } from '@metamask/superstruct';\nimport {\n  create,\n  object,\n  optional,\n  record,\n  string,\n  StructError,\n} from '@metamask/superstruct';\n\nimport { parseJson } from './json';\nimport type { SnapManifest } from './manifest';\nimport type { VirtualFile } from './virtual-file';\n\nexport const LOCALIZABLE_FIELDS = ['description', 'proposedName'] as const;\n\nexport const LocalizationFileStruct = object({\n  locale: string(),\n  messages: record(\n    string(),\n    object({\n      message: string(),\n      description: optional(string()),\n    }),\n  ),\n});\n\nexport type LocalizationFile = Infer<typeof LocalizationFileStruct>;\n\n/**\n * Validate a list of localization files.\n *\n * @param localizationFiles - The localization files to validate.\n * @returns The validated localization files.\n * @throws If any of the files are considered invalid.\n */\nexport function getValidatedLocalizationFiles(\n  localizationFiles: VirtualFile[],\n): VirtualFile<LocalizationFile>[] {\n  for (const file of localizationFiles) {\n    try {\n      file.result = create(parseJson(file.toString()), LocalizationFileStruct);\n    } catch (error) {\n      if (error instanceof StructError) {\n        throw new Error(\n          `Failed to validate localization file \"${file.path}\": ${error.message}.`,\n        );\n      }\n\n      if (error instanceof SyntaxError) {\n        throw new Error(\n          `Failed to parse localization file \"${file.path}\" as JSON.`,\n        );\n      }\n\n      throw error;\n    }\n  }\n\n  return localizationFiles as VirtualFile<LocalizationFile>[];\n}\n\n/**\n * Get the localization file for a given locale. If the locale is not found,\n * the English localization file will be returned.\n *\n * @param locale - The locale to use.\n * @param localizationFiles - The localization files to use.\n * @returns The localization file, or `undefined` if no localization file was\n * found.\n */\nexport function getLocalizationFile(\n  locale: string,\n  localizationFiles: LocalizationFile[],\n) {\n  const file = localizationFiles.find(\n    (localizationFile) => localizationFile.locale === locale,\n  );\n\n  if (!file) {\n    return localizationFiles.find(\n      (localizationFile) => localizationFile.locale === 'en',\n    );\n  }\n\n  return file;\n}\n\nexport const TRANSLATION_REGEX = /\\{\\{\\s?([a-zA-Z0-9-_\\s]+)\\s?\\}\\}/gu;\n\n/**\n * Translate a string using a localization file. This will replace all instances\n * of `{{key}}` with the localized version of `key`.\n *\n * @param value - The string to translate.\n * @param file - The localization file to use, or `undefined` if no localization\n * file was found.\n * @returns The translated string.\n * @throws If the string contains a key that is not present in the localization\n * file, or if no localization file was found.\n */\nexport function translate(value: string, file: LocalizationFile | undefined) {\n  const matches = value.matchAll(TRANSLATION_REGEX);\n  const array = Array.from(matches);\n\n  return array.reduce<string>((result, [match, key]) => {\n    if (!file) {\n      throw new Error(\n        `Failed to translate \"${value}\": No localization file found.`,\n      );\n    }\n\n    const translation = file.messages[key.trim()];\n    if (!translation) {\n      throw new Error(\n        `Failed to translate \"${value}\": No translation found for \"${key.trim()}\" in \"${\n          file.locale\n        }\" file.`,\n      );\n    }\n\n    return result.replace(match, translation.message);\n  }, value);\n}\n\n/**\n * Get the localized Snap manifest for a given locale. This will replace all\n * localized strings in the manifest with the localized version.\n *\n * @param snapManifest - The Snap manifest to localize.\n * @param locale - The locale to use.\n * @param localizationFiles - The localization files to use.\n * @returns The localized Snap manifest.\n */\nexport function getLocalizedSnapManifest(\n  snapManifest: SnapManifest,\n  locale: string,\n  localizationFiles: LocalizationFile[],\n) {\n  const file = getLocalizationFile(locale, localizationFiles);\n\n  return LOCALIZABLE_FIELDS.reduce((manifest, field) => {\n    const translation = translate(manifest[field], file);\n    return {\n      ...manifest,\n      [field]: translation,\n    };\n  }, snapManifest);\n}\n\n/**\n * Validate the localization files for a Snap manifest.\n *\n * @param snapManifest - The Snap manifest to validate.\n * @param localizationFiles - The localization files to validate.\n * @throws If the manifest cannot be localized.\n */\nexport function validateSnapManifestLocalizations(\n  snapManifest: SnapManifest,\n  localizationFiles: LocalizationFile[],\n) {\n  try {\n    // `translate` throws if the manifest cannot be localized, so we just attempt\n    // to translate the manifest using all localization files.\n    localizationFiles\n      .filter((file) => file.locale !== 'en')\n      .forEach((file) => {\n        getLocalizedSnapManifest(snapManifest, file.locale, localizationFiles);\n      });\n\n    // The manifest must be localizable in English.\n    getLocalizedSnapManifest(snapManifest, 'en', localizationFiles);\n  } catch (error) {\n    throw new Error(\n      `Failed to localize Snap manifest: ${getErrorMessage(error)}`,\n    );\n  }\n}\n"],"mappings":";;;;;AAAA,SAAS,uBAAuB;AAEhC;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAMA,IAAM,qBAAqB,CAAC,eAAe,cAAc;AAEzD,IAAM,yBAAyB,OAAO;AAAA,EAC3C,QAAQ,OAAO;AAAA,EACf,UAAU;AAAA,IACR,OAAO;AAAA,IACP,OAAO;AAAA,MACL,SAAS,OAAO;AAAA,MAChB,aAAa,SAAS,OAAO,CAAC;AAAA,IAChC,CAAC;AAAA,EACH;AACF,CAAC;AAWM,SAAS,8BACd,mBACiC;AACjC,aAAW,QAAQ,mBAAmB;AACpC,QAAI;AACF,WAAK,SAAS,OAAO,UAAU,KAAK,SAAS,CAAC,GAAG,sBAAsB;AAAA,IACzE,SAAS,OAAO;AACd,UAAI,iBAAiB,aAAa;AAChC,cAAM,IAAI;AAAA,UACR,yCAAyC,KAAK,IAAI,MAAM,MAAM,OAAO;AAAA,QACvE;AAAA,MACF;AAEA,UAAI,iBAAiB,aAAa;AAChC,cAAM,IAAI;AAAA,UACR,sCAAsC,KAAK,IAAI;AAAA,QACjD;AAAA,MACF;AAEA,YAAM;AAAA,IACR;AAAA,EACF;AAEA,SAAO;AACT;AAWO,SAAS,oBACd,QACA,mBACA;AACA,QAAM,OAAO,kBAAkB;AAAA,IAC7B,CAAC,qBAAqB,iBAAiB,WAAW;AAAA,EACpD;AAEA,MAAI,CAAC,MAAM;AACT,WAAO,kBAAkB;AAAA,MACvB,CAAC,qBAAqB,iBAAiB,WAAW;AAAA,IACpD;AAAA,EACF;AAEA,SAAO;AACT;AAEO,IAAM,oBAAoB;AAa1B,SAAS,UAAU,OAAe,MAAoC;AAC3E,QAAM,UAAU,MAAM,SAAS,iBAAiB;AAChD,QAAM,QAAQ,MAAM,KAAK,OAAO;AAEhC,SAAO,MAAM,OAAe,CAAC,QAAQ,CAAC,OAAO,GAAG,MAAM;AACpD,QAAI,CAAC,MAAM;AACT,YAAM,IAAI;AAAA,QACR,wBAAwB,KAAK;AAAA,MAC/B;AAAA,IACF;AAEA,UAAM,cAAc,KAAK,SAAS,IAAI,KAAK,CAAC;AAC5C,QAAI,CAAC,aAAa;AAChB,YAAM,IAAI;AAAA,QACR,wBAAwB,KAAK,gCAAgC,IAAI,KAAK,CAAC,SACrE,KAAK,MACP;AAAA,MACF;AAAA,IACF;AAEA,WAAO,OAAO,QAAQ,OAAO,YAAY,OAAO;AAAA,EAClD,GAAG,KAAK;AACV;AAWO,SAAS,yBACd,cACA,QACA,mBACA;AACA,QAAM,OAAO,oBAAoB,QAAQ,iBAAiB;AAE1D,SAAO,mBAAmB,OAAO,CAAC,UAAU,UAAU;AACpD,UAAM,cAAc,UAAU,SAAS,KAAK,GAAG,IAAI;AACnD,WAAO;AAAA,MACL,GAAG;AAAA,MACH,CAAC,KAAK,GAAG;AAAA,IACX;AAAA,EACF,GAAG,YAAY;AACjB;AASO,SAAS,kCACd,cACA,mBACA;AACA,MAAI;AAGF,sBACG,OAAO,CAAC,SAAS,KAAK,WAAW,IAAI,EACrC,QAAQ,CAAC,SAAS;AACjB,+BAAyB,cAAc,KAAK,QAAQ,iBAAiB;AAAA,IACvE,CAAC;AAGH,6BAAyB,cAAc,MAAM,iBAAiB;AAAA,EAChE,SAAS,OAAO;AACd,UAAM,IAAI;AAAA,MACR,qCAAqC,gBAAgB,KAAK,CAAC;AAAA,IAC7D;AAAA,EACF;AACF;","names":[]}
\ No newline at end of file
diff --git a/dist/chunk-YCIPY3UP.mjs.map b/dist/chunk-YCIPY3UP.mjs.map
index 5321ffd13eb7a88be2952f1e156cd774d5e9444b..5ba5fe5846aa56f87e227efea27ce2ae9138f0bc 100644
--- a/dist/chunk-YCIPY3UP.mjs.map
+++ b/dist/chunk-YCIPY3UP.mjs.map
@@ -1 +1 @@
-{"version":3,"sources":["../src/snaps.ts"],"sourcesContent":["import type {\n  Caveat,\n  SubjectPermissions,\n  PermissionConstraint,\n} from '@metamask/permission-controller';\nimport type { BlockReason } from '@metamask/snaps-registry';\nimport type { SnapId, Snap as TruncatedSnap } from '@metamask/snaps-sdk';\nimport type { Json } from '@metamask/utils';\nimport { assert, isObject, assertStruct } from '@metamask/utils';\nimport { base64 } from '@scure/base';\nimport stableStringify from 'fast-json-stable-stringify';\nimport type { Struct } from 'superstruct';\nimport {\n  empty,\n  enums,\n  intersection,\n  literal,\n  pattern,\n  refine,\n  string,\n  union,\n  validate,\n} from 'superstruct';\nimport validateNPMPackage from 'validate-npm-package-name';\n\nimport { SnapCaveatType } from './caveats';\nimport { checksumFiles } from './checksum';\nimport type { LocalizationFile } from './localization';\nimport type {\n  InitialConnections,\n  SnapManifest,\n  SnapPermissions,\n} from './manifest/validation';\nimport type { FetchedSnapFiles, SnapsPermissionRequest } from './types';\nimport { SnapIdPrefixes, SnapValidationFailureReason, uri } from './types';\nimport type { VirtualFile } from './virtual-file';\n\n// This RegEx matches valid npm package names (with some exceptions) and space-\n// separated alphanumerical words, optionally with dashes and underscores.\n// The RegEx consists of two parts. The first part matches space-separated\n// words. It is based on the following Stackoverflow answer:\n// https://stackoverflow.com/a/34974982\n// The second part, after the pipe operator, is the same RegEx used for the\n// `name` field of the official package.json JSON Schema, except that we allow\n// mixed-case letters. It was originally copied from:\n// https://github.com/SchemaStore/schemastore/blob/81a16897c1dabfd98c72242a5fd62eb080ff76d8/src/schemas/json/package.json#L132-L138\nexport const PROPOSED_NAME_REGEX =\n  /^(?:[A-Za-z0-9-_]+( [A-Za-z0-9-_]+)*)|(?:(?:@[A-Za-z0-9-*~][A-Za-z0-9-*._~]*\\/)?[A-Za-z0-9-~][A-Za-z0-9-._~]*)$/u;\n\nexport enum SnapStatus {\n  Installing = 'installing',\n  Updating = 'updating',\n  Running = 'running',\n  Stopped = 'stopped',\n  Crashed = 'crashed',\n}\n\nexport enum SnapStatusEvents {\n  Start = 'START',\n  Stop = 'STOP',\n  Crash = 'CRASH',\n  Update = 'UPDATE',\n}\n\nexport type StatusContext = { snapId: SnapId };\nexport type StatusEvents = { type: SnapStatusEvents };\nexport type StatusStates = {\n  value: SnapStatus;\n  context: StatusContext;\n};\nexport type Status = StatusStates['value'];\n\nexport type VersionHistory = {\n  origin: string;\n  version: string;\n  // Unix timestamp\n  date: number;\n};\n\nexport type SnapAuxilaryFile = {\n  path: string;\n  // Value here should be stored as base64\n  value: string;\n};\n\nexport type PersistedSnap = Snap;\n\n/**\n * A Snap as it exists in {@link SnapController} state.\n */\nexport type Snap = TruncatedSnap & {\n  /**\n   * The initial connections of the Snap, optional, requested on installation.\n   */\n  initialConnections?: InitialConnections;\n  /**\n   * The initial permissions of the Snap, which will be requested when it is\n   * installed.\n   */\n  initialPermissions: SnapPermissions;\n\n  /**\n   * The source code of the Snap.\n   */\n  sourceCode: string;\n\n  /**\n   * The Snap's manifest file.\n   */\n  manifest: SnapManifest;\n\n  /**\n   * Information detailing why the snap is blocked.\n   */\n  blockInformation?: BlockReason;\n\n  /**\n   * The current status of the Snap, e.g. whether it's running or stopped.\n   */\n  status: Status;\n\n  /**\n   * The version history of the Snap.\n   * Can be used to derive when the Snap was installed, when it was updated to a certain version and who requested the change.\n   */\n  versionHistory: VersionHistory[];\n\n  /**\n   * Static auxiliary files that can be loaded at runtime.\n   */\n  auxiliaryFiles?: SnapAuxilaryFile[];\n\n  /**\n   * Localization files which are used to translate the manifest.\n   */\n  localizationFiles?: LocalizationFile[];\n\n  /**\n   * Flag to signal whether this snap was preinstalled or not.\n   *\n   * A lack of specifying this option will be deemed as not preinstalled.\n   */\n  preinstalled?: boolean;\n\n  /**\n   * Flag to signal whether this snap is removable or not.\n   *\n   * A lack of specifying this option will be deemed as removable.\n   */\n  removable?: boolean;\n\n  /**\n   * Flag to signal whether this snap should be hidden from the user or not.\n   */\n  hidden?: boolean;\n};\n\nexport type TruncatedSnapFields =\n  | 'id'\n  | 'initialPermissions'\n  | 'version'\n  | 'enabled'\n  | 'blocked';\n\n/**\n * An error indicating that a Snap validation failure is programmatically\n * fixable during development.\n */\nexport class ProgrammaticallyFixableSnapError extends Error {\n  reason: SnapValidationFailureReason;\n\n  constructor(message: string, reason: SnapValidationFailureReason) {\n    super(message);\n    this.reason = reason;\n  }\n}\n\n/**\n * Gets a checksummable manifest by removing the shasum property and reserializing the JSON using a deterministic algorithm.\n *\n * @param manifest - The manifest itself.\n * @returns A virtual file containing the checksummable manifest.\n */\nfunction getChecksummableManifest(\n  manifest: VirtualFile<SnapManifest>,\n): VirtualFile {\n  const manifestCopy = manifest.clone() as VirtualFile<any>;\n  delete manifestCopy.result.source.shasum;\n\n  // We use fast-json-stable-stringify to deterministically serialize the JSON\n  // This is required before checksumming so we get reproducible checksums across platforms etc\n  manifestCopy.value = stableStringify(manifestCopy.result);\n  return manifestCopy;\n}\n\n/**\n * Calculates the Base64-encoded SHA-256 digest of all required Snap files.\n *\n * @param files - All required Snap files to be included in the checksum.\n * @returns The Base64-encoded SHA-256 digest of the source code.\n */\nexport async function getSnapChecksum(\n  files: FetchedSnapFiles,\n): Promise<string> {\n  const { manifest, sourceCode, svgIcon, auxiliaryFiles, localizationFiles } =\n    files;\n\n  const all = [\n    getChecksummableManifest(manifest),\n    sourceCode,\n    svgIcon,\n    ...auxiliaryFiles,\n    ...localizationFiles,\n  ].filter((file) => file !== undefined);\n\n  return base64.encode(await checksumFiles(all as VirtualFile[]));\n}\n\n/**\n * Checks whether the `source.shasum` property of a Snap manifest matches the\n * shasum of the snap.\n *\n * @param files - All required Snap files to be included in the checksum.\n * @param errorMessage - The error message to throw if validation fails.\n */\nexport async function validateSnapShasum(\n  files: FetchedSnapFiles,\n  errorMessage = 'Invalid Snap manifest: manifest shasum does not match computed shasum.',\n): Promise<void> {\n  if (files.manifest.result.source.shasum !== (await getSnapChecksum(files))) {\n    throw new ProgrammaticallyFixableSnapError(\n      errorMessage,\n      SnapValidationFailureReason.ShasumMismatch,\n    );\n  }\n}\n\nexport const LOCALHOST_HOSTNAMES = ['localhost', '127.0.0.1', '[::1]'] as const;\n\n// Require snap ids to only consist of printable ASCII characters\nexport const BaseSnapIdStruct = pattern(string(), /^[\\x21-\\x7E]*$/u);\n\nconst LocalSnapIdSubUrlStruct = uri({\n  protocol: enums(['http:', 'https:']),\n  hostname: enums(LOCALHOST_HOSTNAMES),\n  hash: empty(string()),\n  search: empty(string()),\n});\n\nexport const LocalSnapIdStruct = refine(\n  BaseSnapIdStruct,\n  'local Snap Id',\n  (value) => {\n    if (!value.startsWith(SnapIdPrefixes.local)) {\n      return `Expected local snap ID, got \"${value}\".`;\n    }\n\n    const [error] = validate(\n      value.slice(SnapIdPrefixes.local.length),\n      LocalSnapIdSubUrlStruct,\n    );\n    return error ?? true;\n  },\n);\nexport const NpmSnapIdStruct = intersection([\n  BaseSnapIdStruct,\n  uri({\n    protocol: literal(SnapIdPrefixes.npm),\n    pathname: refine(string(), 'package name', function* (value) {\n      const normalized = value.startsWith('/') ? value.slice(1) : value;\n      const { errors, validForNewPackages, warnings } =\n        validateNPMPackage(normalized);\n      if (!validForNewPackages) {\n        if (errors === undefined) {\n          assert(warnings !== undefined);\n          yield* warnings;\n        } else {\n          yield* errors;\n        }\n      }\n      return true;\n    }),\n    search: empty(string()),\n    hash: empty(string()),\n  }),\n]) as unknown as Struct<string, null>;\n\nexport const HttpSnapIdStruct = intersection([\n  BaseSnapIdStruct,\n  uri({\n    protocol: enums(['http:', 'https:']),\n    search: empty(string()),\n    hash: empty(string()),\n  }),\n]) as unknown as Struct<string, null>;\n\nexport const SnapIdStruct = union([NpmSnapIdStruct, LocalSnapIdStruct]);\n\n/**\n * Extracts the snap prefix from a snap ID.\n *\n * @param snapId - The snap ID to extract the prefix from.\n * @returns The snap prefix from a snap id, e.g. `npm:`.\n */\nexport function getSnapPrefix(snapId: string): SnapIdPrefixes {\n  const prefix = Object.values(SnapIdPrefixes).find((possiblePrefix) =>\n    snapId.startsWith(possiblePrefix),\n  );\n  if (prefix !== undefined) {\n    return prefix;\n  }\n  throw new Error(`Invalid or no prefix found for \"${snapId}\"`);\n}\n\n/**\n * Strips snap prefix from a full snap ID.\n *\n * @param snapId - The snap ID to strip.\n * @returns The stripped snap ID.\n */\nexport function stripSnapPrefix(snapId: string): string {\n  return snapId.replace(getSnapPrefix(snapId), '');\n}\n\n/**\n * Assert that the given value is a valid snap ID.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid snap ID.\n */\nexport function assertIsValidSnapId(value: unknown): asserts value is SnapId {\n  assertStruct(value, SnapIdStruct, 'Invalid snap ID');\n}\n\n/**\n * Typeguard to ensure a chainId follows the CAIP-2 standard.\n *\n * @param chainId - The chainId being tested.\n * @returns `true` if the value is a valid CAIP chain id, and `false` otherwise.\n */\nexport function isCaipChainId(chainId: unknown): chainId is string {\n  return (\n    typeof chainId === 'string' &&\n    /^(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-a-zA-Z0-9]{1,32})$/u.test(\n      chainId,\n    )\n  );\n}\n\n/**\n * Utility function to check if an origin has permission (and caveat) for a particular snap.\n *\n * @param permissions - An origin's permissions object.\n * @param snapId - The id of the snap.\n * @returns A boolean based on if an origin has the specified snap.\n */\nexport function isSnapPermitted(\n  permissions: SubjectPermissions<PermissionConstraint>,\n  snapId: SnapId,\n) {\n  return Boolean(\n    (\n      (\n        (permissions?.wallet_snap?.caveats?.find(\n          (caveat) => caveat.type === SnapCaveatType.SnapIds,\n        ) ?? {}) as Caveat<string, Json>\n      ).value as Record<string, unknown>\n    )?.[snapId],\n  );\n}\n\n/**\n * Checks whether the passed in requestedPermissions is a valid\n * permission request for a `wallet_snap` permission.\n *\n * @param requestedPermissions - The requested permissions.\n * @throws If the criteria is not met.\n */\nexport function verifyRequestedSnapPermissions(\n  requestedPermissions: unknown,\n): asserts requestedPermissions is SnapsPermissionRequest {\n  assert(\n    isObject(requestedPermissions),\n    'Requested permissions must be an object.',\n  );\n\n  const { wallet_snap: walletSnapPermission } = requestedPermissions;\n\n  assert(\n    isObject(walletSnapPermission),\n    'wallet_snap is missing from the requested permissions.',\n  );\n\n  const { caveats } = walletSnapPermission;\n\n  assert(\n    Array.isArray(caveats) && caveats.length === 1,\n    'wallet_snap must have a caveat property with a single-item array value.',\n  );\n\n  const [caveat] = caveats;\n\n  assert(\n    isObject(caveat) &&\n      caveat.type === SnapCaveatType.SnapIds &&\n      isObject(caveat.value),\n    `The requested permissions do not have a valid ${SnapCaveatType.SnapIds} caveat.`,\n  );\n}\n\nexport type { Snap as TruncatedSnap } from '@metamask/snaps-sdk';\n"],"mappings":"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","names":["SnapStatus","SnapStatusEvents"]}
\ No newline at end of file
+{"version":3,"sources":["../src/snaps.ts"],"sourcesContent":["import type {\n  Caveat,\n  SubjectPermissions,\n  PermissionConstraint,\n} from '@metamask/permission-controller';\nimport type { BlockReason } from '@metamask/snaps-registry';\nimport type { SnapId, Snap as TruncatedSnap } from '@metamask/snaps-sdk';\nimport type { Json } from '@metamask/utils';\nimport { assert, isObject, assertStruct } from '@metamask/utils';\nimport { base64 } from '@scure/base';\nimport stableStringify from 'fast-json-stable-stringify';\nimport type { Struct } from '@metamask/superstruct';\nimport {\n  empty,\n  enums,\n  intersection,\n  literal,\n  pattern,\n  refine,\n  string,\n  union,\n  validate,\n} from '@metamask/superstruct';\nimport validateNPMPackage from 'validate-npm-package-name';\n\nimport { SnapCaveatType } from './caveats';\nimport { checksumFiles } from './checksum';\nimport type { LocalizationFile } from './localization';\nimport type {\n  InitialConnections,\n  SnapManifest,\n  SnapPermissions,\n} from './manifest/validation';\nimport type { FetchedSnapFiles, SnapsPermissionRequest } from './types';\nimport { SnapIdPrefixes, SnapValidationFailureReason, uri } from './types';\nimport type { VirtualFile } from './virtual-file';\n\n// This RegEx matches valid npm package names (with some exceptions) and space-\n// separated alphanumerical words, optionally with dashes and underscores.\n// The RegEx consists of two parts. The first part matches space-separated\n// words. It is based on the following Stackoverflow answer:\n// https://stackoverflow.com/a/34974982\n// The second part, after the pipe operator, is the same RegEx used for the\n// `name` field of the official package.json JSON Schema, except that we allow\n// mixed-case letters. It was originally copied from:\n// https://github.com/SchemaStore/schemastore/blob/81a16897c1dabfd98c72242a5fd62eb080ff76d8/src/schemas/json/package.json#L132-L138\nexport const PROPOSED_NAME_REGEX =\n  /^(?:[A-Za-z0-9-_]+( [A-Za-z0-9-_]+)*)|(?:(?:@[A-Za-z0-9-*~][A-Za-z0-9-*._~]*\\/)?[A-Za-z0-9-~][A-Za-z0-9-._~]*)$/u;\n\nexport enum SnapStatus {\n  Installing = 'installing',\n  Updating = 'updating',\n  Running = 'running',\n  Stopped = 'stopped',\n  Crashed = 'crashed',\n}\n\nexport enum SnapStatusEvents {\n  Start = 'START',\n  Stop = 'STOP',\n  Crash = 'CRASH',\n  Update = 'UPDATE',\n}\n\nexport type StatusContext = { snapId: SnapId };\nexport type StatusEvents = { type: SnapStatusEvents };\nexport type StatusStates = {\n  value: SnapStatus;\n  context: StatusContext;\n};\nexport type Status = StatusStates['value'];\n\nexport type VersionHistory = {\n  origin: string;\n  version: string;\n  // Unix timestamp\n  date: number;\n};\n\nexport type SnapAuxilaryFile = {\n  path: string;\n  // Value here should be stored as base64\n  value: string;\n};\n\nexport type PersistedSnap = Snap;\n\n/**\n * A Snap as it exists in {@link SnapController} state.\n */\nexport type Snap = TruncatedSnap & {\n  /**\n   * The initial connections of the Snap, optional, requested on installation.\n   */\n  initialConnections?: InitialConnections;\n  /**\n   * The initial permissions of the Snap, which will be requested when it is\n   * installed.\n   */\n  initialPermissions: SnapPermissions;\n\n  /**\n   * The source code of the Snap.\n   */\n  sourceCode: string;\n\n  /**\n   * The Snap's manifest file.\n   */\n  manifest: SnapManifest;\n\n  /**\n   * Information detailing why the snap is blocked.\n   */\n  blockInformation?: BlockReason;\n\n  /**\n   * The current status of the Snap, e.g. whether it's running or stopped.\n   */\n  status: Status;\n\n  /**\n   * The version history of the Snap.\n   * Can be used to derive when the Snap was installed, when it was updated to a certain version and who requested the change.\n   */\n  versionHistory: VersionHistory[];\n\n  /**\n   * Static auxiliary files that can be loaded at runtime.\n   */\n  auxiliaryFiles?: SnapAuxilaryFile[];\n\n  /**\n   * Localization files which are used to translate the manifest.\n   */\n  localizationFiles?: LocalizationFile[];\n\n  /**\n   * Flag to signal whether this snap was preinstalled or not.\n   *\n   * A lack of specifying this option will be deemed as not preinstalled.\n   */\n  preinstalled?: boolean;\n\n  /**\n   * Flag to signal whether this snap is removable or not.\n   *\n   * A lack of specifying this option will be deemed as removable.\n   */\n  removable?: boolean;\n\n  /**\n   * Flag to signal whether this snap should be hidden from the user or not.\n   */\n  hidden?: boolean;\n};\n\nexport type TruncatedSnapFields =\n  | 'id'\n  | 'initialPermissions'\n  | 'version'\n  | 'enabled'\n  | 'blocked';\n\n/**\n * An error indicating that a Snap validation failure is programmatically\n * fixable during development.\n */\nexport class ProgrammaticallyFixableSnapError extends Error {\n  reason: SnapValidationFailureReason;\n\n  constructor(message: string, reason: SnapValidationFailureReason) {\n    super(message);\n    this.reason = reason;\n  }\n}\n\n/**\n * Gets a checksummable manifest by removing the shasum property and reserializing the JSON using a deterministic algorithm.\n *\n * @param manifest - The manifest itself.\n * @returns A virtual file containing the checksummable manifest.\n */\nfunction getChecksummableManifest(\n  manifest: VirtualFile<SnapManifest>,\n): VirtualFile {\n  const manifestCopy = manifest.clone() as VirtualFile<any>;\n  delete manifestCopy.result.source.shasum;\n\n  // We use fast-json-stable-stringify to deterministically serialize the JSON\n  // This is required before checksumming so we get reproducible checksums across platforms etc\n  manifestCopy.value = stableStringify(manifestCopy.result);\n  return manifestCopy;\n}\n\n/**\n * Calculates the Base64-encoded SHA-256 digest of all required Snap files.\n *\n * @param files - All required Snap files to be included in the checksum.\n * @returns The Base64-encoded SHA-256 digest of the source code.\n */\nexport async function getSnapChecksum(\n  files: FetchedSnapFiles,\n): Promise<string> {\n  const { manifest, sourceCode, svgIcon, auxiliaryFiles, localizationFiles } =\n    files;\n\n  const all = [\n    getChecksummableManifest(manifest),\n    sourceCode,\n    svgIcon,\n    ...auxiliaryFiles,\n    ...localizationFiles,\n  ].filter((file) => file !== undefined);\n\n  return base64.encode(await checksumFiles(all as VirtualFile[]));\n}\n\n/**\n * Checks whether the `source.shasum` property of a Snap manifest matches the\n * shasum of the snap.\n *\n * @param files - All required Snap files to be included in the checksum.\n * @param errorMessage - The error message to throw if validation fails.\n */\nexport async function validateSnapShasum(\n  files: FetchedSnapFiles,\n  errorMessage = 'Invalid Snap manifest: manifest shasum does not match computed shasum.',\n): Promise<void> {\n  if (files.manifest.result.source.shasum !== (await getSnapChecksum(files))) {\n    throw new ProgrammaticallyFixableSnapError(\n      errorMessage,\n      SnapValidationFailureReason.ShasumMismatch,\n    );\n  }\n}\n\nexport const LOCALHOST_HOSTNAMES = ['localhost', '127.0.0.1', '[::1]'] as const;\n\n// Require snap ids to only consist of printable ASCII characters\nexport const BaseSnapIdStruct = pattern(string(), /^[\\x21-\\x7E]*$/u);\n\nconst LocalSnapIdSubUrlStruct = uri({\n  protocol: enums(['http:', 'https:']),\n  hostname: enums(LOCALHOST_HOSTNAMES),\n  hash: empty(string()),\n  search: empty(string()),\n});\n\nexport const LocalSnapIdStruct = refine(\n  BaseSnapIdStruct,\n  'local Snap Id',\n  (value) => {\n    if (!value.startsWith(SnapIdPrefixes.local)) {\n      return `Expected local snap ID, got \"${value}\".`;\n    }\n\n    const [error] = validate(\n      value.slice(SnapIdPrefixes.local.length),\n      LocalSnapIdSubUrlStruct,\n    );\n    return error ?? true;\n  },\n);\nexport const NpmSnapIdStruct = intersection([\n  BaseSnapIdStruct,\n  uri({\n    protocol: literal(SnapIdPrefixes.npm),\n    pathname: refine(string(), 'package name', function* (value) {\n      const normalized = value.startsWith('/') ? value.slice(1) : value;\n      const { errors, validForNewPackages, warnings } =\n        validateNPMPackage(normalized);\n      if (!validForNewPackages) {\n        if (errors === undefined) {\n          assert(warnings !== undefined);\n          yield* warnings;\n        } else {\n          yield* errors;\n        }\n      }\n      return true;\n    }),\n    search: empty(string()),\n    hash: empty(string()),\n  }),\n]) as unknown as Struct<string, null>;\n\nexport const HttpSnapIdStruct = intersection([\n  BaseSnapIdStruct,\n  uri({\n    protocol: enums(['http:', 'https:']),\n    search: empty(string()),\n    hash: empty(string()),\n  }),\n]) as unknown as Struct<string, null>;\n\nexport const SnapIdStruct = union([NpmSnapIdStruct, LocalSnapIdStruct]);\n\n/**\n * Extracts the snap prefix from a snap ID.\n *\n * @param snapId - The snap ID to extract the prefix from.\n * @returns The snap prefix from a snap id, e.g. `npm:`.\n */\nexport function getSnapPrefix(snapId: string): SnapIdPrefixes {\n  const prefix = Object.values(SnapIdPrefixes).find((possiblePrefix) =>\n    snapId.startsWith(possiblePrefix),\n  );\n  if (prefix !== undefined) {\n    return prefix;\n  }\n  throw new Error(`Invalid or no prefix found for \"${snapId}\"`);\n}\n\n/**\n * Strips snap prefix from a full snap ID.\n *\n * @param snapId - The snap ID to strip.\n * @returns The stripped snap ID.\n */\nexport function stripSnapPrefix(snapId: string): string {\n  return snapId.replace(getSnapPrefix(snapId), '');\n}\n\n/**\n * Assert that the given value is a valid snap ID.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid snap ID.\n */\nexport function assertIsValidSnapId(value: unknown): asserts value is SnapId {\n  assertStruct(value, SnapIdStruct, 'Invalid snap ID');\n}\n\n/**\n * Typeguard to ensure a chainId follows the CAIP-2 standard.\n *\n * @param chainId - The chainId being tested.\n * @returns `true` if the value is a valid CAIP chain id, and `false` otherwise.\n */\nexport function isCaipChainId(chainId: unknown): chainId is string {\n  return (\n    typeof chainId === 'string' &&\n    /^(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-a-zA-Z0-9]{1,32})$/u.test(\n      chainId,\n    )\n  );\n}\n\n/**\n * Utility function to check if an origin has permission (and caveat) for a particular snap.\n *\n * @param permissions - An origin's permissions object.\n * @param snapId - The id of the snap.\n * @returns A boolean based on if an origin has the specified snap.\n */\nexport function isSnapPermitted(\n  permissions: SubjectPermissions<PermissionConstraint>,\n  snapId: SnapId,\n) {\n  return Boolean(\n    (\n      (\n        (permissions?.wallet_snap?.caveats?.find(\n          (caveat) => caveat.type === SnapCaveatType.SnapIds,\n        ) ?? {}) as Caveat<string, Json>\n      ).value as Record<string, unknown>\n    )?.[snapId],\n  );\n}\n\n/**\n * Checks whether the passed in requestedPermissions is a valid\n * permission request for a `wallet_snap` permission.\n *\n * @param requestedPermissions - The requested permissions.\n * @throws If the criteria is not met.\n */\nexport function verifyRequestedSnapPermissions(\n  requestedPermissions: unknown,\n): asserts requestedPermissions is SnapsPermissionRequest {\n  assert(\n    isObject(requestedPermissions),\n    'Requested permissions must be an object.',\n  );\n\n  const { wallet_snap: walletSnapPermission } = requestedPermissions;\n\n  assert(\n    isObject(walletSnapPermission),\n    'wallet_snap is missing from the requested permissions.',\n  );\n\n  const { caveats } = walletSnapPermission;\n\n  assert(\n    Array.isArray(caveats) && caveats.length === 1,\n    'wallet_snap must have a caveat property with a single-item array value.',\n  );\n\n  const [caveat] = caveats;\n\n  assert(\n    isObject(caveat) &&\n      caveat.type === SnapCaveatType.SnapIds &&\n      isObject(caveat.value),\n    `The requested permissions do not have a valid ${SnapCaveatType.SnapIds} caveat.`,\n  );\n}\n\nexport type { Snap as TruncatedSnap } from '@metamask/snaps-sdk';\n"],"mappings":"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","names":["SnapStatus","SnapStatusEvents"]}
\ No newline at end of file
diff --git a/dist/chunk-ZJKG5Q2C.js.map b/dist/chunk-ZJKG5Q2C.js.map
index 913794892e5f673c8d0c13691e6c3f6429d14867..fd057e45b69a442d17b721703c2f57dda2f817c5 100644
--- a/dist/chunk-ZJKG5Q2C.js.map
+++ b/dist/chunk-ZJKG5Q2C.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../src/manifest/validation.ts"],"names":[],"mappings":"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","sourcesContent":["import type { SupportedCurve } from '@metamask/key-tree';\nimport { isValidBIP32PathSegment } from '@metamask/key-tree';\nimport type { EmptyObject, InitialPermissions } from '@metamask/snaps-sdk';\nimport {\n  assertStruct,\n  ChecksumStruct,\n  VersionStruct,\n  isValidSemVerRange,\n  inMilliseconds,\n  Duration,\n} from '@metamask/utils';\nimport type { Describe, Infer, Struct } from 'superstruct';\nimport {\n  array,\n  boolean,\n  create,\n  enums,\n  integer,\n  is,\n  literal,\n  object,\n  optional,\n  refine,\n  record,\n  size,\n  string,\n  type,\n  union,\n  intersection,\n} from 'superstruct';\n\nimport { isEqual } from '../array';\nimport { CronjobSpecificationArrayStruct } from '../cronjob';\nimport { SIP_6_MAGIC_VALUE, STATE_ENCRYPTION_MAGIC_VALUE } from '../entropy';\nimport { KeyringOriginsStruct, RpcOriginsStruct } from '../json-rpc';\nimport { ChainIdStruct } from '../namespace';\nimport { SnapIdStruct } from '../snaps';\nimport { mergeStructs, type InferMatching } from '../structs';\nimport { NameStruct, NpmSnapFileNames, uri } from '../types';\n\n// BIP-43 purposes that cannot be used for entropy derivation. These are in the\n// string form, ending with `'`.\nconst FORBIDDEN_PURPOSES: string[] = [\n  SIP_6_MAGIC_VALUE,\n  STATE_ENCRYPTION_MAGIC_VALUE,\n];\n\nexport const FORBIDDEN_COIN_TYPES: number[] = [60];\nconst FORBIDDEN_PATHS: string[][] = FORBIDDEN_COIN_TYPES.map((coinType) => [\n  'm',\n  \"44'\",\n  `${coinType}'`,\n]);\n\nexport const Bip32PathStruct = refine(\n  array(string()),\n  'BIP-32 path',\n  (path: string[]) => {\n    if (path.length === 0) {\n      return 'Path must be a non-empty BIP-32 derivation path array';\n    }\n\n    if (path[0] !== 'm') {\n      return 'Path must start with \"m\".';\n    }\n\n    if (path.length < 3) {\n      return 'Paths must have a length of at least three.';\n    }\n\n    if (path.slice(1).some((part) => !isValidBIP32PathSegment(part))) {\n      return 'Path must be a valid BIP-32 derivation path array.';\n    }\n\n    if (FORBIDDEN_PURPOSES.includes(path[1])) {\n      return `The purpose \"${path[1]}\" is not allowed for entropy derivation.`;\n    }\n\n    if (\n      FORBIDDEN_PATHS.some((forbiddenPath) =>\n        isEqual(path.slice(0, forbiddenPath.length), forbiddenPath),\n      )\n    ) {\n      return `The path \"${path.join(\n        '/',\n      )}\" is not allowed for entropy derivation.`;\n    }\n\n    return true;\n  },\n);\n\nexport const bip32entropy = <\n  Type extends { path: string[]; curve: string },\n  Schema,\n>(\n  struct: Struct<Type, Schema>,\n) =>\n  refine(struct, 'BIP-32 entropy', (value) => {\n    if (\n      value.curve === 'ed25519' &&\n      value.path.slice(1).some((part) => !part.endsWith(\"'\"))\n    ) {\n      return 'Ed25519 does not support unhardened paths.';\n    }\n\n    return true;\n  });\n\nexport const CurveStruct: Describe<SupportedCurve> = enums([\n  'ed25519',\n  'secp256k1',\n  'ed25519Bip32',\n]);\n\n// Used outside @metamask/snap-utils\nexport const Bip32EntropyStruct = bip32entropy(\n  type({\n    path: Bip32PathStruct,\n    curve: CurveStruct,\n  }),\n);\n\nexport type Bip32Entropy = Infer<typeof Bip32EntropyStruct>;\n\nexport const SnapGetBip32EntropyPermissionsStruct = size(\n  array(Bip32EntropyStruct),\n  1,\n  Infinity,\n);\n\nexport const SemVerRangeStruct = refine(string(), 'SemVer range', (value) => {\n  if (isValidSemVerRange(value)) {\n    return true;\n  }\n  return 'Expected a valid SemVer range.';\n});\n\nexport const SnapIdsStruct = refine(\n  record(SnapIdStruct, object({ version: optional(SemVerRangeStruct) })),\n  'SnapIds',\n  (value) => {\n    if (Object.keys(value).length === 0) {\n      return false;\n    }\n\n    return true;\n  },\n);\n\nexport type SnapIds = Infer<typeof SnapIdsStruct>;\n\nexport const ChainIdsStruct = size(array(ChainIdStruct), 1, Infinity);\n\nexport const LookupMatchersStruct = union([\n  object({\n    tlds: size(array(string()), 1, Infinity),\n  }),\n  object({\n    schemes: size(array(string()), 1, Infinity),\n  }),\n  object({\n    tlds: size(array(string()), 1, Infinity),\n    schemes: size(array(string()), 1, Infinity),\n  }),\n]);\n\nexport const MINIMUM_REQUEST_TIMEOUT = inMilliseconds(5, Duration.Second);\nexport const MAXIMUM_REQUEST_TIMEOUT = inMilliseconds(3, Duration.Minute);\n\nexport const MaxRequestTimeStruct = size(\n  integer(),\n  MINIMUM_REQUEST_TIMEOUT,\n  MAXIMUM_REQUEST_TIMEOUT,\n);\n\n// Utility type to union with for all handler structs\nexport const HandlerCaveatsStruct = object({\n  maxRequestTime: optional(MaxRequestTimeStruct),\n});\n\nexport type HandlerCaveats = Infer<typeof HandlerCaveatsStruct>;\n\nexport const EmptyObjectStruct = object<EmptyObject>({}) as unknown as Struct<\n  EmptyObject,\n  null\n>;\n\n/* eslint-disable @typescript-eslint/naming-convention */\nexport const PermissionsStruct: Describe<InitialPermissions> = type({\n  'endowment:cronjob': optional(\n    mergeStructs(\n      HandlerCaveatsStruct,\n      object({ jobs: CronjobSpecificationArrayStruct }),\n    ),\n  ),\n  'endowment:ethereum-provider': optional(EmptyObjectStruct),\n  'endowment:keyring': optional(\n    mergeStructs(HandlerCaveatsStruct, KeyringOriginsStruct),\n  ),\n  'endowment:lifecycle-hooks': optional(HandlerCaveatsStruct),\n  'endowment:name-lookup': optional(\n    mergeStructs(\n      HandlerCaveatsStruct,\n      object({\n        chains: optional(ChainIdsStruct),\n        matchers: optional(LookupMatchersStruct),\n      }),\n    ),\n  ),\n  'endowment:network-access': optional(EmptyObjectStruct),\n  'endowment:page-home': optional(HandlerCaveatsStruct),\n  'endowment:rpc': optional(\n    mergeStructs(HandlerCaveatsStruct, RpcOriginsStruct),\n  ),\n  'endowment:signature-insight': optional(\n    mergeStructs(\n      HandlerCaveatsStruct,\n      object({\n        allowSignatureOrigin: optional(boolean()),\n      }),\n    ),\n  ),\n  'endowment:transaction-insight': optional(\n    mergeStructs(\n      HandlerCaveatsStruct,\n      object({\n        allowTransactionOrigin: optional(boolean()),\n      }),\n    ),\n  ),\n  'endowment:webassembly': optional(EmptyObjectStruct),\n  snap_dialog: optional(EmptyObjectStruct),\n  snap_manageState: optional(EmptyObjectStruct),\n  snap_manageAccounts: optional(EmptyObjectStruct),\n  snap_notify: optional(EmptyObjectStruct),\n  snap_getBip32Entropy: optional(SnapGetBip32EntropyPermissionsStruct),\n  snap_getBip32PublicKey: optional(SnapGetBip32EntropyPermissionsStruct),\n  snap_getBip44Entropy: optional(\n    size(\n      array(object({ coinType: size(integer(), 0, 2 ** 32 - 1) })),\n      1,\n      Infinity,\n    ),\n  ),\n  snap_getEntropy: optional(EmptyObjectStruct),\n  snap_getLocale: optional(EmptyObjectStruct),\n  wallet_snap: optional(SnapIdsStruct),\n});\n/* eslint-enable @typescript-eslint/naming-convention */\n\nexport type SnapPermissions = InferMatching<\n  typeof PermissionsStruct,\n  InitialPermissions\n>;\n\nexport const SnapAuxilaryFilesStruct = array(string());\n\nexport const InitialConnectionsStruct = record(\n  intersection([string(), uri()]),\n  object({}),\n);\n\nexport type InitialConnections = Infer<typeof InitialConnectionsStruct>;\n\nexport const SnapManifestStruct = object({\n  version: VersionStruct,\n  description: size(string(), 1, 280),\n  proposedName: size(string(), 1, 214),\n  repository: optional(\n    object({\n      type: size(string(), 1, Infinity),\n      url: size(string(), 1, Infinity),\n    }),\n  ),\n  source: object({\n    shasum: ChecksumStruct,\n    location: object({\n      npm: object({\n        filePath: size(string(), 1, Infinity),\n        iconPath: optional(size(string(), 1, Infinity)),\n        packageName: NameStruct,\n        registry: union([\n          literal('https://registry.npmjs.org'),\n          literal('https://registry.npmjs.org/'),\n        ]),\n      }),\n    }),\n    files: optional(SnapAuxilaryFilesStruct),\n    locales: optional(SnapAuxilaryFilesStruct),\n  }),\n  initialConnections: optional(InitialConnectionsStruct),\n  initialPermissions: PermissionsStruct,\n  manifestVersion: literal('0.1'),\n  $schema: optional(string()), // enables JSON-Schema linting in VSC and other IDEs\n});\n\nexport type SnapManifest = Infer<typeof SnapManifestStruct>;\n\n/**\n * Check if the given value is a valid {@link SnapManifest} object.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid {@link SnapManifest} object.\n */\nexport function isSnapManifest(value: unknown): value is SnapManifest {\n  return is(value, SnapManifestStruct);\n}\n\n/**\n * Assert that the given value is a valid {@link SnapManifest} object.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid {@link SnapManifest} object.\n */\nexport function assertIsSnapManifest(\n  value: unknown,\n): asserts value is SnapManifest {\n  assertStruct(\n    value,\n    SnapManifestStruct,\n    `\"${NpmSnapFileNames.Manifest}\" is invalid`,\n  );\n}\n\n/**\n * Creates a {@link SnapManifest} object from JSON.\n *\n * @param value - The value to check.\n * @throws If the value cannot be coerced to a {@link SnapManifest} object.\n * @returns The created {@link SnapManifest} object.\n */\nexport function createSnapManifest(value: unknown): SnapManifest {\n  // TODO: Add a utility to prefix these errors similar to assertStruct\n  return create(value, SnapManifestStruct);\n}\n"]}
\ No newline at end of file
+{"version":3,"sources":["../src/manifest/validation.ts"],"names":[],"mappings":"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","sourcesContent":["import type { SupportedCurve } from '@metamask/key-tree';\nimport { isValidBIP32PathSegment } from '@metamask/key-tree';\nimport type { EmptyObject, InitialPermissions } from '@metamask/snaps-sdk';\nimport {\n  assertStruct,\n  ChecksumStruct,\n  VersionStruct,\n  isValidSemVerRange,\n  inMilliseconds,\n  Duration,\n} from '@metamask/utils';\nimport type { Describe, Infer, Struct } from '@metamask/superstruct';\nimport {\n  array,\n  boolean,\n  create,\n  enums,\n  integer,\n  is,\n  literal,\n  object,\n  optional,\n  refine,\n  record,\n  size,\n  string,\n  type,\n  union,\n  intersection,\n} from '@metamask/superstruct';\n\nimport { isEqual } from '../array';\nimport { CronjobSpecificationArrayStruct } from '../cronjob';\nimport { SIP_6_MAGIC_VALUE, STATE_ENCRYPTION_MAGIC_VALUE } from '../entropy';\nimport { KeyringOriginsStruct, RpcOriginsStruct } from '../json-rpc';\nimport { ChainIdStruct } from '../namespace';\nimport { SnapIdStruct } from '../snaps';\nimport { mergeStructs, type InferMatching } from '../structs';\nimport { NameStruct, NpmSnapFileNames, uri } from '../types';\n\n// BIP-43 purposes that cannot be used for entropy derivation. These are in the\n// string form, ending with `'`.\nconst FORBIDDEN_PURPOSES: string[] = [\n  SIP_6_MAGIC_VALUE,\n  STATE_ENCRYPTION_MAGIC_VALUE,\n];\n\nexport const FORBIDDEN_COIN_TYPES: number[] = [60];\nconst FORBIDDEN_PATHS: string[][] = FORBIDDEN_COIN_TYPES.map((coinType) => [\n  'm',\n  \"44'\",\n  `${coinType}'`,\n]);\n\nexport const Bip32PathStruct = refine(\n  array(string()),\n  'BIP-32 path',\n  (path: string[]) => {\n    if (path.length === 0) {\n      return 'Path must be a non-empty BIP-32 derivation path array';\n    }\n\n    if (path[0] !== 'm') {\n      return 'Path must start with \"m\".';\n    }\n\n    if (path.length < 3) {\n      return 'Paths must have a length of at least three.';\n    }\n\n    if (path.slice(1).some((part) => !isValidBIP32PathSegment(part))) {\n      return 'Path must be a valid BIP-32 derivation path array.';\n    }\n\n    if (FORBIDDEN_PURPOSES.includes(path[1])) {\n      return `The purpose \"${path[1]}\" is not allowed for entropy derivation.`;\n    }\n\n    if (\n      FORBIDDEN_PATHS.some((forbiddenPath) =>\n        isEqual(path.slice(0, forbiddenPath.length), forbiddenPath),\n      )\n    ) {\n      return `The path \"${path.join(\n        '/',\n      )}\" is not allowed for entropy derivation.`;\n    }\n\n    return true;\n  },\n);\n\nexport const bip32entropy = <\n  Type extends { path: string[]; curve: string },\n  Schema,\n>(\n  struct: Struct<Type, Schema>,\n) =>\n  refine(struct, 'BIP-32 entropy', (value) => {\n    if (\n      value.curve === 'ed25519' &&\n      value.path.slice(1).some((part) => !part.endsWith(\"'\"))\n    ) {\n      return 'Ed25519 does not support unhardened paths.';\n    }\n\n    return true;\n  });\n\nexport const CurveStruct: Describe<SupportedCurve> = enums([\n  'ed25519',\n  'secp256k1',\n  'ed25519Bip32',\n]);\n\n// Used outside @metamask/snap-utils\nexport const Bip32EntropyStruct = bip32entropy(\n  type({\n    path: Bip32PathStruct,\n    curve: CurveStruct,\n  }),\n);\n\nexport type Bip32Entropy = Infer<typeof Bip32EntropyStruct>;\n\nexport const SnapGetBip32EntropyPermissionsStruct = size(\n  array(Bip32EntropyStruct),\n  1,\n  Infinity,\n);\n\nexport const SemVerRangeStruct = refine(string(), 'SemVer range', (value) => {\n  if (isValidSemVerRange(value)) {\n    return true;\n  }\n  return 'Expected a valid SemVer range.';\n});\n\nexport const SnapIdsStruct = refine(\n  record(SnapIdStruct, object({ version: optional(SemVerRangeStruct) })),\n  'SnapIds',\n  (value) => {\n    if (Object.keys(value).length === 0) {\n      return false;\n    }\n\n    return true;\n  },\n);\n\nexport type SnapIds = Infer<typeof SnapIdsStruct>;\n\nexport const ChainIdsStruct = size(array(ChainIdStruct), 1, Infinity);\n\nexport const LookupMatchersStruct = union([\n  object({\n    tlds: size(array(string()), 1, Infinity),\n  }),\n  object({\n    schemes: size(array(string()), 1, Infinity),\n  }),\n  object({\n    tlds: size(array(string()), 1, Infinity),\n    schemes: size(array(string()), 1, Infinity),\n  }),\n]);\n\nexport const MINIMUM_REQUEST_TIMEOUT = inMilliseconds(5, Duration.Second);\nexport const MAXIMUM_REQUEST_TIMEOUT = inMilliseconds(3, Duration.Minute);\n\nexport const MaxRequestTimeStruct = size(\n  integer(),\n  MINIMUM_REQUEST_TIMEOUT,\n  MAXIMUM_REQUEST_TIMEOUT,\n);\n\n// Utility type to union with for all handler structs\nexport const HandlerCaveatsStruct = object({\n  maxRequestTime: optional(MaxRequestTimeStruct),\n});\n\nexport type HandlerCaveats = Infer<typeof HandlerCaveatsStruct>;\n\nexport const EmptyObjectStruct = object<EmptyObject>({}) as unknown as Struct<\n  EmptyObject,\n  null\n>;\n\n/* eslint-disable @typescript-eslint/naming-convention */\nexport const PermissionsStruct: Describe<InitialPermissions> = type({\n  'endowment:cronjob': optional(\n    mergeStructs(\n      HandlerCaveatsStruct,\n      object({ jobs: CronjobSpecificationArrayStruct }),\n    ),\n  ),\n  'endowment:ethereum-provider': optional(EmptyObjectStruct),\n  'endowment:keyring': optional(\n    mergeStructs(HandlerCaveatsStruct, KeyringOriginsStruct),\n  ),\n  'endowment:lifecycle-hooks': optional(HandlerCaveatsStruct),\n  'endowment:name-lookup': optional(\n    mergeStructs(\n      HandlerCaveatsStruct,\n      object({\n        chains: optional(ChainIdsStruct),\n        matchers: optional(LookupMatchersStruct),\n      }),\n    ),\n  ),\n  'endowment:network-access': optional(EmptyObjectStruct),\n  'endowment:page-home': optional(HandlerCaveatsStruct),\n  'endowment:rpc': optional(\n    mergeStructs(HandlerCaveatsStruct, RpcOriginsStruct),\n  ),\n  'endowment:signature-insight': optional(\n    mergeStructs(\n      HandlerCaveatsStruct,\n      object({\n        allowSignatureOrigin: optional(boolean()),\n      }),\n    ),\n  ),\n  'endowment:transaction-insight': optional(\n    mergeStructs(\n      HandlerCaveatsStruct,\n      object({\n        allowTransactionOrigin: optional(boolean()),\n      }),\n    ),\n  ),\n  'endowment:webassembly': optional(EmptyObjectStruct),\n  snap_dialog: optional(EmptyObjectStruct),\n  snap_manageState: optional(EmptyObjectStruct),\n  snap_manageAccounts: optional(EmptyObjectStruct),\n  snap_notify: optional(EmptyObjectStruct),\n  snap_getBip32Entropy: optional(SnapGetBip32EntropyPermissionsStruct),\n  snap_getBip32PublicKey: optional(SnapGetBip32EntropyPermissionsStruct),\n  snap_getBip44Entropy: optional(\n    size(\n      array(object({ coinType: size(integer(), 0, 2 ** 32 - 1) })),\n      1,\n      Infinity,\n    ),\n  ),\n  snap_getEntropy: optional(EmptyObjectStruct),\n  snap_getLocale: optional(EmptyObjectStruct),\n  wallet_snap: optional(SnapIdsStruct),\n});\n/* eslint-enable @typescript-eslint/naming-convention */\n\nexport type SnapPermissions = InferMatching<\n  typeof PermissionsStruct,\n  InitialPermissions\n>;\n\nexport const SnapAuxilaryFilesStruct = array(string());\n\nexport const InitialConnectionsStruct = record(\n  intersection([string(), uri()]),\n  object({}),\n);\n\nexport type InitialConnections = Infer<typeof InitialConnectionsStruct>;\n\nexport const SnapManifestStruct = object({\n  version: VersionStruct,\n  description: size(string(), 1, 280),\n  proposedName: size(string(), 1, 214),\n  repository: optional(\n    object({\n      type: size(string(), 1, Infinity),\n      url: size(string(), 1, Infinity),\n    }),\n  ),\n  source: object({\n    shasum: ChecksumStruct,\n    location: object({\n      npm: object({\n        filePath: size(string(), 1, Infinity),\n        iconPath: optional(size(string(), 1, Infinity)),\n        packageName: NameStruct,\n        registry: union([\n          literal('https://registry.npmjs.org'),\n          literal('https://registry.npmjs.org/'),\n        ]),\n      }),\n    }),\n    files: optional(SnapAuxilaryFilesStruct),\n    locales: optional(SnapAuxilaryFilesStruct),\n  }),\n  initialConnections: optional(InitialConnectionsStruct),\n  initialPermissions: PermissionsStruct,\n  manifestVersion: literal('0.1'),\n  $schema: optional(string()), // enables JSON-Schema linting in VSC and other IDEs\n});\n\nexport type SnapManifest = Infer<typeof SnapManifestStruct>;\n\n/**\n * Check if the given value is a valid {@link SnapManifest} object.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid {@link SnapManifest} object.\n */\nexport function isSnapManifest(value: unknown): value is SnapManifest {\n  return is(value, SnapManifestStruct);\n}\n\n/**\n * Assert that the given value is a valid {@link SnapManifest} object.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid {@link SnapManifest} object.\n */\nexport function assertIsSnapManifest(\n  value: unknown,\n): asserts value is SnapManifest {\n  assertStruct(\n    value,\n    SnapManifestStruct,\n    `\"${NpmSnapFileNames.Manifest}\" is invalid`,\n  );\n}\n\n/**\n * Creates a {@link SnapManifest} object from JSON.\n *\n * @param value - The value to check.\n * @throws If the value cannot be coerced to a {@link SnapManifest} object.\n * @returns The created {@link SnapManifest} object.\n */\nexport function createSnapManifest(value: unknown): SnapManifest {\n  // TODO: Add a utility to prefix these errors similar to assertStruct\n  return create(value, SnapManifestStruct);\n}\n"]}
\ No newline at end of file
diff --git a/dist/types/cronjob.d.ts b/dist/types/cronjob.d.ts
index bbd2e815e1a5291aa4e4424092f0733de29a9615..ba11906cdfc68042627ed2a7cc077ce397586f23 100644
--- a/dist/types/cronjob.d.ts
+++ b/dist/types/cronjob.d.ts
@@ -1,17 +1,17 @@
-import type { Infer } from 'superstruct';
-export declare const CronjobRpcRequestStruct: import("superstruct").Struct<{
+import type { Infer } from '@metamask/superstruct';
+export declare const CronjobRpcRequestStruct: import("@metamask/superstruct").Struct<{
     method: string;
     id?: string | number | null | undefined;
     jsonrpc?: "2.0" | undefined;
     params?: Record<string, import("@metamask/utils").Json> | import("@metamask/utils").Json[] | undefined;
 }, {
-    jsonrpc: import("superstruct").Struct<"2.0" | undefined, "2.0">;
-    id: import("superstruct").Struct<string | number | null | undefined, null>;
-    method: import("superstruct").Struct<string, null>;
-    params: import("superstruct").Struct<Record<string, import("@metamask/utils").Json> | import("@metamask/utils").Json[] | undefined, null>;
+    jsonrpc: import("@metamask/superstruct").Struct<"2.0" | undefined, "2.0">;
+    id: import("@metamask/superstruct").Struct<string | number | null | undefined, null>;
+    method: import("@metamask/superstruct").Struct<string, null>;
+    params: import("@metamask/superstruct").Struct<Record<string, import("@metamask/utils").Json> | import("@metamask/utils").Json[] | undefined, null>;
 }>;
 export declare type CronjobRpcRequest = Infer<typeof CronjobRpcRequestStruct>;
-export declare const CronExpressionStruct: import("superstruct").Struct<string, null>;
+export declare const CronExpressionStruct: import("@metamask/superstruct").Struct<string, null>;
 export declare type CronExpression = Infer<typeof CronExpressionStruct>;
 /**
  * Parses a cron expression.
@@ -20,7 +20,7 @@ export declare type CronExpression = Infer<typeof CronExpressionStruct>;
  * @returns A CronExpression class instance.
  */
 export declare function parseCronExpression(expression: string | object): import("cron-parser").CronExpression<false>;
-export declare const CronjobSpecificationStruct: import("superstruct").Struct<{
+export declare const CronjobSpecificationStruct: import("@metamask/superstruct").Struct<{
     request: {
         method: string;
         id?: string | number | null | undefined;
@@ -29,17 +29,17 @@ export declare const CronjobSpecificationStruct: import("superstruct").Struct<{
     };
     expression: string;
 }, {
-    expression: import("superstruct").Struct<string, null>;
-    request: import("superstruct").Struct<{
+    expression: import("@metamask/superstruct").Struct<string, null>;
+    request: import("@metamask/superstruct").Struct<{
         method: string;
         id?: string | number | null | undefined;
         jsonrpc?: "2.0" | undefined;
         params?: Record<string, import("@metamask/utils").Json> | import("@metamask/utils").Json[] | undefined;
     }, {
-        jsonrpc: import("superstruct").Struct<"2.0" | undefined, "2.0">;
-        id: import("superstruct").Struct<string | number | null | undefined, null>;
-        method: import("superstruct").Struct<string, null>;
-        params: import("superstruct").Struct<Record<string, import("@metamask/utils").Json> | import("@metamask/utils").Json[] | undefined, null>;
+        jsonrpc: import("@metamask/superstruct").Struct<"2.0" | undefined, "2.0">;
+        id: import("@metamask/superstruct").Struct<string | number | null | undefined, null>;
+        method: import("@metamask/superstruct").Struct<string, null>;
+        params: import("@metamask/superstruct").Struct<Record<string, import("@metamask/utils").Json> | import("@metamask/utils").Json[] | undefined, null>;
     }>;
 }>;
 export declare type CronjobSpecification = Infer<typeof CronjobSpecificationStruct>;
@@ -50,7 +50,7 @@ export declare type CronjobSpecification = Infer<typeof CronjobSpecificationStru
  * @returns Whether the value is a valid {@link CronjobSpecification} object.
  */
 export declare function isCronjobSpecification(value: unknown): boolean;
-export declare const CronjobSpecificationArrayStruct: import("superstruct").Struct<{
+export declare const CronjobSpecificationArrayStruct: import("@metamask/superstruct").Struct<{
     request: {
         method: string;
         id?: string | number | null | undefined;
@@ -58,7 +58,7 @@ export declare const CronjobSpecificationArrayStruct: import("superstruct").Stru
         params?: Record<string, import("@metamask/utils").Json> | import("@metamask/utils").Json[] | undefined;
     };
     expression: string;
-}[], import("superstruct").Struct<{
+}[], import("@metamask/superstruct").Struct<{
     request: {
         method: string;
         id?: string | number | null | undefined;
@@ -67,17 +67,17 @@ export declare const CronjobSpecificationArrayStruct: import("superstruct").Stru
     };
     expression: string;
 }, {
-    expression: import("superstruct").Struct<string, null>;
-    request: import("superstruct").Struct<{
+    expression: import("@metamask/superstruct").Struct<string, null>;
+    request: import("@metamask/superstruct").Struct<{
         method: string;
         id?: string | number | null | undefined;
         jsonrpc?: "2.0" | undefined;
         params?: Record<string, import("@metamask/utils").Json> | import("@metamask/utils").Json[] | undefined;
     }, {
-        jsonrpc: import("superstruct").Struct<"2.0" | undefined, "2.0">;
-        id: import("superstruct").Struct<string | number | null | undefined, null>;
-        method: import("superstruct").Struct<string, null>;
-        params: import("superstruct").Struct<Record<string, import("@metamask/utils").Json> | import("@metamask/utils").Json[] | undefined, null>;
+        jsonrpc: import("@metamask/superstruct").Struct<"2.0" | undefined, "2.0">;
+        id: import("@metamask/superstruct").Struct<string | number | null | undefined, null>;
+        method: import("@metamask/superstruct").Struct<string, null>;
+        params: import("@metamask/superstruct").Struct<Record<string, import("@metamask/utils").Json> | import("@metamask/utils").Json[] | undefined, null>;
     }>;
 }>>;
 /**
diff --git a/dist/types/handlers.d.ts b/dist/types/handlers.d.ts
index e271e2cf2b00a6c0191fbbd241508a2843245056..51263fb1b8025fe075f1f1a3d9b11cc7a3fb45bc 100644
--- a/dist/types/handlers.d.ts
+++ b/dist/types/handlers.d.ts
@@ -59,19 +59,19 @@ export declare const SNAP_EXPORTS: {
         readonly validator: (snapExport: unknown) => snapExport is OnUserInputHandler;
     };
 };
-export declare const OnTransactionSeverityResponseStruct: import("superstruct").Struct<{
+export declare const OnTransactionSeverityResponseStruct: import("@metamask/superstruct").Struct<{
     severity?: SeverityLevel | undefined;
 }, {
-    severity: import("superstruct").Struct<SeverityLevel | undefined, SeverityLevel>;
+    severity: import("@metamask/superstruct").Struct<SeverityLevel | undefined, SeverityLevel>;
 }>;
-export declare const OnTransactionResponseWithIdStruct: import("superstruct").Struct<{
+export declare const OnTransactionResponseWithIdStruct: import("@metamask/superstruct").Struct<{
     id: string;
     severity?: SeverityLevel | undefined;
 }, {
-    id: import("superstruct").Struct<string, null>;
-    severity: import("superstruct").Struct<SeverityLevel | undefined, SeverityLevel>;
+    id: import("@metamask/superstruct").Struct<string, null>;
+    severity: import("@metamask/superstruct").Struct<SeverityLevel | undefined, SeverityLevel>;
 }>;
-export declare const OnTransactionResponseWithContentStruct: import("superstruct").Struct<{
+export declare const OnTransactionResponseWithContentStruct: import("@metamask/superstruct").Struct<{
     content: import("@metamask/snaps-sdk").Panel | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").ButtonProps, "Button"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").CheckboxProps, "Checkbox"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").FormProps, "Form"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").FileInputProps, "FileInput"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").InputProps, "Input"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").DropdownProps, "Dropdown"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").BoldProps, "Bold"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").ItalicProps, "Italic"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").AddressProps, "Address"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").BoxProps, "Box"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").CopyableProps, "Copyable"> | import("@metamask/snaps-sdk/jsx").SnapElement<Record<string, never>, "Divider"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").LinkProps, "Link"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").RowProps, "Row"> | import("@metamask/snaps-sdk/jsx").SnapElement<Record<string, never>, "Spinner"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").TextProps, "Text"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").TooltipProps, "Tooltip"> | {
         value: string;
         type: import("@metamask/snaps-sdk").NodeType.Copyable;
@@ -148,7 +148,7 @@ export declare const OnTransactionResponseWithContentStruct: import("superstruct
     }, "Image">;
     severity?: SeverityLevel | undefined;
 }, {
-    content: import("superstruct").Struct<import("@metamask/snaps-sdk").Panel | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").ButtonProps, "Button"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").CheckboxProps, "Checkbox"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").FormProps, "Form"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").FileInputProps, "FileInput"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").InputProps, "Input"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").DropdownProps, "Dropdown"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").BoldProps, "Bold"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").ItalicProps, "Italic"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").AddressProps, "Address"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").BoxProps, "Box"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").CopyableProps, "Copyable"> | import("@metamask/snaps-sdk/jsx").SnapElement<Record<string, never>, "Divider"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").LinkProps, "Link"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").RowProps, "Row"> | import("@metamask/snaps-sdk/jsx").SnapElement<Record<string, never>, "Spinner"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").TextProps, "Text"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").TooltipProps, "Tooltip"> | {
+    content: import("@metamask/superstruct").Struct<import("@metamask/snaps-sdk").Panel | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").ButtonProps, "Button"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").CheckboxProps, "Checkbox"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").FormProps, "Form"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").FileInputProps, "FileInput"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").InputProps, "Input"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").DropdownProps, "Dropdown"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").BoldProps, "Bold"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").ItalicProps, "Italic"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").AddressProps, "Address"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").BoxProps, "Box"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").CopyableProps, "Copyable"> | import("@metamask/snaps-sdk/jsx").SnapElement<Record<string, never>, "Divider"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").LinkProps, "Link"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").RowProps, "Row"> | import("@metamask/snaps-sdk/jsx").SnapElement<Record<string, never>, "Spinner"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").TextProps, "Text"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").TooltipProps, "Tooltip"> | {
         value: string;
         type: import("@metamask/snaps-sdk").NodeType.Copyable;
         sensitive?: boolean | undefined;
@@ -222,9 +222,9 @@ export declare const OnTransactionResponseWithContentStruct: import("superstruct
         src: string;
         alt?: string | undefined;
     }, "Image">, null>;
-    severity: import("superstruct").Struct<SeverityLevel | undefined, SeverityLevel>;
+    severity: import("@metamask/superstruct").Struct<SeverityLevel | undefined, SeverityLevel>;
 }>;
-export declare const OnTransactionResponseStruct: import("superstruct").Struct<{
+export declare const OnTransactionResponseStruct: import("@metamask/superstruct").Struct<{
     id: string;
     severity?: SeverityLevel | undefined;
 } | {
@@ -304,7 +304,7 @@ export declare const OnTransactionResponseStruct: import("superstruct").Struct<{
     }, "Image">;
     severity?: SeverityLevel | undefined;
 } | null, null>;
-export declare const OnSignatureResponseStruct: import("superstruct").Struct<{
+export declare const OnSignatureResponseStruct: import("@metamask/superstruct").Struct<{
     id: string;
     severity?: SeverityLevel | undefined;
 } | {
@@ -384,7 +384,7 @@ export declare const OnSignatureResponseStruct: import("superstruct").Struct<{
     }, "Image">;
     severity?: SeverityLevel | undefined;
 } | null, null>;
-export declare const OnHomePageResponseWithContentStruct: import("superstruct").Struct<{
+export declare const OnHomePageResponseWithContentStruct: import("@metamask/superstruct").Struct<{
     content: import("@metamask/snaps-sdk").Panel | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").ButtonProps, "Button"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").CheckboxProps, "Checkbox"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").FormProps, "Form"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").FileInputProps, "FileInput"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").InputProps, "Input"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").DropdownProps, "Dropdown"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").BoldProps, "Bold"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").ItalicProps, "Italic"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").AddressProps, "Address"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").BoxProps, "Box"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").CopyableProps, "Copyable"> | import("@metamask/snaps-sdk/jsx").SnapElement<Record<string, never>, "Divider"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").LinkProps, "Link"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").RowProps, "Row"> | import("@metamask/snaps-sdk/jsx").SnapElement<Record<string, never>, "Spinner"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").TextProps, "Text"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").TooltipProps, "Tooltip"> | {
         value: string;
         type: import("@metamask/snaps-sdk").NodeType.Copyable;
@@ -460,7 +460,7 @@ export declare const OnHomePageResponseWithContentStruct: import("superstruct").
         alt?: string | undefined;
     }, "Image">;
 }, {
-    content: import("superstruct").Struct<import("@metamask/snaps-sdk").Panel | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").ButtonProps, "Button"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").CheckboxProps, "Checkbox"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").FormProps, "Form"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").FileInputProps, "FileInput"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").InputProps, "Input"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").DropdownProps, "Dropdown"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").BoldProps, "Bold"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").ItalicProps, "Italic"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").AddressProps, "Address"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").BoxProps, "Box"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").CopyableProps, "Copyable"> | import("@metamask/snaps-sdk/jsx").SnapElement<Record<string, never>, "Divider"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").LinkProps, "Link"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").RowProps, "Row"> | import("@metamask/snaps-sdk/jsx").SnapElement<Record<string, never>, "Spinner"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").TextProps, "Text"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").TooltipProps, "Tooltip"> | {
+    content: import("@metamask/superstruct").Struct<import("@metamask/snaps-sdk").Panel | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").ButtonProps, "Button"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").CheckboxProps, "Checkbox"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").FormProps, "Form"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").FileInputProps, "FileInput"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").InputProps, "Input"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").DropdownProps, "Dropdown"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").BoldProps, "Bold"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").ItalicProps, "Italic"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").AddressProps, "Address"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").BoxProps, "Box"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").CopyableProps, "Copyable"> | import("@metamask/snaps-sdk/jsx").SnapElement<Record<string, never>, "Divider"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").LinkProps, "Link"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").RowProps, "Row"> | import("@metamask/snaps-sdk/jsx").SnapElement<Record<string, never>, "Spinner"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").TextProps, "Text"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").TooltipProps, "Tooltip"> | {
         value: string;
         type: import("@metamask/snaps-sdk").NodeType.Copyable;
         sensitive?: boolean | undefined;
@@ -535,12 +535,12 @@ export declare const OnHomePageResponseWithContentStruct: import("superstruct").
         alt?: string | undefined;
     }, "Image">, null>;
 }>;
-export declare const OnHomePageResponseWithIdStruct: import("superstruct").Struct<{
+export declare const OnHomePageResponseWithIdStruct: import("@metamask/superstruct").Struct<{
     id: string;
 }, {
-    id: import("superstruct").Struct<string, null>;
+    id: import("@metamask/superstruct").Struct<string, null>;
 }>;
-export declare const OnHomePageResponseStruct: import("superstruct").Struct<{
+export declare const OnHomePageResponseStruct: import("@metamask/superstruct").Struct<{
     content: import("@metamask/snaps-sdk").Panel | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").ButtonProps, "Button"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").CheckboxProps, "Checkbox"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").FormProps, "Form"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").FileInputProps, "FileInput"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").InputProps, "Input"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").DropdownProps, "Dropdown"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").BoldProps, "Bold"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").ItalicProps, "Italic"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").AddressProps, "Address"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").BoxProps, "Box"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").CopyableProps, "Copyable"> | import("@metamask/snaps-sdk/jsx").SnapElement<Record<string, never>, "Divider"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").LinkProps, "Link"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").RowProps, "Row"> | import("@metamask/snaps-sdk/jsx").SnapElement<Record<string, never>, "Spinner"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").TextProps, "Text"> | import("@metamask/snaps-sdk/jsx").SnapElement<import("@metamask/snaps-sdk/jsx").TooltipProps, "Tooltip"> | {
         value: string;
         type: import("@metamask/snaps-sdk").NodeType.Copyable;
@@ -618,61 +618,61 @@ export declare const OnHomePageResponseStruct: import("superstruct").Struct<{
 } | {
     id: string;
 }, null>;
-export declare const AddressResolutionStruct: import("superstruct").Struct<{
+export declare const AddressResolutionStruct: import("@metamask/superstruct").Struct<{
     protocol: string;
     resolvedDomain: string;
 }, {
-    protocol: import("superstruct").Struct<string, null>;
-    resolvedDomain: import("superstruct").Struct<string, null>;
+    protocol: import("@metamask/superstruct").Struct<string, null>;
+    resolvedDomain: import("@metamask/superstruct").Struct<string, null>;
 }>;
-export declare const DomainResolutionStruct: import("superstruct").Struct<{
+export declare const DomainResolutionStruct: import("@metamask/superstruct").Struct<{
     protocol: string;
     resolvedAddress: string;
     domainName: string;
 }, {
-    protocol: import("superstruct").Struct<string, null>;
-    resolvedAddress: import("superstruct").Struct<string, null>;
-    domainName: import("superstruct").Struct<string, null>;
+    protocol: import("@metamask/superstruct").Struct<string, null>;
+    resolvedAddress: import("@metamask/superstruct").Struct<string, null>;
+    domainName: import("@metamask/superstruct").Struct<string, null>;
 }>;
-export declare const AddressResolutionResponseStruct: import("superstruct").Struct<{
+export declare const AddressResolutionResponseStruct: import("@metamask/superstruct").Struct<{
     resolvedDomains: {
         protocol: string;
         resolvedDomain: string;
     }[];
 }, {
-    resolvedDomains: import("superstruct").Struct<{
+    resolvedDomains: import("@metamask/superstruct").Struct<{
         protocol: string;
         resolvedDomain: string;
-    }[], import("superstruct").Struct<{
+    }[], import("@metamask/superstruct").Struct<{
         protocol: string;
         resolvedDomain: string;
     }, {
-        protocol: import("superstruct").Struct<string, null>;
-        resolvedDomain: import("superstruct").Struct<string, null>;
+        protocol: import("@metamask/superstruct").Struct<string, null>;
+        resolvedDomain: import("@metamask/superstruct").Struct<string, null>;
     }>>;
 }>;
-export declare const DomainResolutionResponseStruct: import("superstruct").Struct<{
+export declare const DomainResolutionResponseStruct: import("@metamask/superstruct").Struct<{
     resolvedAddresses: {
         protocol: string;
         resolvedAddress: string;
         domainName: string;
     }[];
 }, {
-    resolvedAddresses: import("superstruct").Struct<{
+    resolvedAddresses: import("@metamask/superstruct").Struct<{
         protocol: string;
         resolvedAddress: string;
         domainName: string;
-    }[], import("superstruct").Struct<{
+    }[], import("@metamask/superstruct").Struct<{
         protocol: string;
         resolvedAddress: string;
         domainName: string;
     }, {
-        protocol: import("superstruct").Struct<string, null>;
-        resolvedAddress: import("superstruct").Struct<string, null>;
-        domainName: import("superstruct").Struct<string, null>;
+        protocol: import("@metamask/superstruct").Struct<string, null>;
+        resolvedAddress: import("@metamask/superstruct").Struct<string, null>;
+        domainName: import("@metamask/superstruct").Struct<string, null>;
     }>>;
 }>;
-export declare const OnNameLookupResponseStruct: import("superstruct").Struct<{
+export declare const OnNameLookupResponseStruct: import("@metamask/superstruct").Struct<{
     resolvedDomains: {
         protocol: string;
         resolvedDomain: string;
diff --git a/dist/types/json-rpc.d.ts b/dist/types/json-rpc.d.ts
index 38718479d623d46c3d8642c4657cab146deb9fca..b55af402712933d212257936c8d2bbafe230feb0 100644
--- a/dist/types/json-rpc.d.ts
+++ b/dist/types/json-rpc.d.ts
@@ -1,14 +1,14 @@
 import { SubjectType } from '@metamask/permission-controller';
 import type { AssertionErrorConstructor, Json, JsonRpcSuccess } from '@metamask/utils';
-import type { Infer } from 'superstruct';
-export declare const RpcOriginsStruct: import("superstruct").Struct<{
+import type { Infer } from '@metamask/superstruct';
+export declare const RpcOriginsStruct: import("@metamask/superstruct").Struct<{
     snaps?: boolean | undefined;
     dapps?: boolean | undefined;
     allowedOrigins?: string[] | undefined;
 }, {
-    dapps: import("superstruct").Struct<boolean | undefined, null>;
-    snaps: import("superstruct").Struct<boolean | undefined, null>;
-    allowedOrigins: import("superstruct").Struct<string[] | undefined, import("superstruct").Struct<string, null>>;
+    dapps: import("@metamask/superstruct").Struct<boolean | undefined, null>;
+    snaps: import("@metamask/superstruct").Struct<boolean | undefined, null>;
+    allowedOrigins: import("@metamask/superstruct").Struct<string[] | undefined, import("@metamask/superstruct").Struct<string, null>>;
 }>;
 export declare type RpcOrigins = Infer<typeof RpcOriginsStruct>;
 /**
@@ -20,10 +20,10 @@ export declare type RpcOrigins = Infer<typeof RpcOriginsStruct>;
  * @throws If the value is not a valid {@link RpcOrigins} object.
  */
 export declare function assertIsRpcOrigins(value: unknown, ErrorWrapper?: AssertionErrorConstructor): asserts value is RpcOrigins;
-export declare const KeyringOriginsStruct: import("superstruct").Struct<{
+export declare const KeyringOriginsStruct: import("@metamask/superstruct").Struct<{
     allowedOrigins?: string[] | undefined;
 }, {
-    allowedOrigins: import("superstruct").Struct<string[] | undefined, import("superstruct").Struct<string, null>>;
+    allowedOrigins: import("@metamask/superstruct").Struct<string[] | undefined, import("@metamask/superstruct").Struct<string, null>>;
 }>;
 export declare type KeyringOrigins = Infer<typeof KeyringOriginsStruct>;
 /**
diff --git a/dist/types/localization.d.ts b/dist/types/localization.d.ts
index c7912195703b45df5901b048022d9ba4bdb6602e..629c378bfb330ce3ae2a9161e871eb30dc55a653 100644
--- a/dist/types/localization.d.ts
+++ b/dist/types/localization.d.ts
@@ -1,16 +1,16 @@
-import type { Infer } from 'superstruct';
+import type { Infer } from '@metamask/superstruct';
 import type { SnapManifest } from './manifest';
 import type { VirtualFile } from './virtual-file';
 export declare const LOCALIZABLE_FIELDS: readonly ["description", "proposedName"];
-export declare const LocalizationFileStruct: import("superstruct").Struct<{
+export declare const LocalizationFileStruct: import("@metamask/superstruct").Struct<{
     locale: string;
     messages: Record<string, {
         message: string;
         description?: string | undefined;
     }>;
 }, {
-    locale: import("superstruct").Struct<string, null>;
-    messages: import("superstruct").Struct<Record<string, {
+    locale: import("@metamask/superstruct").Struct<string, null>;
+    messages: import("@metamask/superstruct").Struct<Record<string, {
         message: string;
         description?: string | undefined;
     }>, null>;
diff --git a/dist/types/manifest/validation.d.ts b/dist/types/manifest/validation.d.ts
index b76e0771aaf0c63be437bb65c3f9df6ea88c3c90..aed799be05f1dc2cb3a55ef2118b5dbdd80a881b 100644
--- a/dist/types/manifest/validation.d.ts
+++ b/dist/types/manifest/validation.d.ts
@@ -1,6 +1,6 @@
 import type { SupportedCurve } from '@metamask/key-tree';
 import type { EmptyObject, InitialPermissions } from '@metamask/snaps-sdk';
-import type { Describe, Infer, Struct } from 'superstruct';
+import type { Describe, Infer, Struct } from '@metamask/superstruct';
 import { type InferMatching } from '../structs';
 export declare const FORBIDDEN_COIN_TYPES: number[];
 export declare const Bip32PathStruct: Struct<string[], Struct<string, null>>;
diff --git a/dist/types/namespace.d.ts b/dist/types/namespace.d.ts
index acff27ac189ddfcd7d2b1da3351e874b8514545f..028eee911e7614e9e25d8a283d408cba1721576f 100644
--- a/dist/types/namespace.d.ts
+++ b/dist/types/namespace.d.ts
@@ -1,5 +1,5 @@
 import type { AccountId, ChainId } from '@metamask/snaps-sdk';
-import type { Infer } from 'superstruct';
+import type { Infer } from '@metamask/superstruct';
 import type { InferMatching } from './structs';
 export declare const CHAIN_ID_REGEX: RegExp;
 export declare const ACCOUNT_ID_REGEX: RegExp;
@@ -34,29 +34,29 @@ export declare function parseAccountId(accountId: AccountId): {
  * A helper struct for a string with a minimum length of 1 and a maximum length
  * of 40.
  */
-export declare const LimitedString: import("superstruct").Struct<string, null>;
-export declare const ChainIdStringStruct: import("superstruct").Struct<`${string}:${string}`, null>;
+export declare const LimitedString: import("@metamask/superstruct").Struct<string, null>;
+export declare const ChainIdStringStruct: import("@metamask/superstruct").Struct<`${string}:${string}`, null>;
 /**
  * A CAIP-2 chain ID, i.e., a human-readable namespace and reference.
  */
-export declare const ChainIdStruct: import("superstruct").Struct<`${string}:${string}`, null>;
+export declare const ChainIdStruct: import("@metamask/superstruct").Struct<`${string}:${string}`, null>;
 export declare type Caip2ChainId = InferMatching<typeof ChainIdStruct, ChainId>;
-export declare const AccountIdStruct: import("superstruct").Struct<string, null>;
-export declare const AccountIdArrayStruct: import("superstruct").Struct<string[], import("superstruct").Struct<string, null>>;
-export declare const AccountAddressStruct: import("superstruct").Struct<string, null>;
+export declare const AccountIdStruct: import("@metamask/superstruct").Struct<string, null>;
+export declare const AccountIdArrayStruct: import("@metamask/superstruct").Struct<string[], import("@metamask/superstruct").Struct<string, null>>;
+export declare const AccountAddressStruct: import("@metamask/superstruct").Struct<string, null>;
 export declare type AccountAddress = Infer<typeof AccountAddressStruct>;
 /**
  * A chain descriptor.
  */
-export declare const ChainStruct: import("superstruct").Struct<{
+export declare const ChainStruct: import("@metamask/superstruct").Struct<{
     name: string;
     id: `${string}:${string}`;
 }, {
-    id: import("superstruct").Struct<`${string}:${string}`, null>;
-    name: import("superstruct").Struct<string, null>;
+    id: import("@metamask/superstruct").Struct<`${string}:${string}`, null>;
+    name: import("@metamask/superstruct").Struct<string, null>;
 }>;
 export declare type Chain = Infer<typeof ChainStruct>;
-export declare const NamespaceStruct: import("superstruct").Struct<{
+export declare const NamespaceStruct: import("@metamask/superstruct").Struct<{
     chains: {
         name: string;
         id: `${string}:${string}`;
@@ -67,30 +67,30 @@ export declare const NamespaceStruct: import("superstruct").Struct<{
     /**
      * A list of supported chains in the namespace.
      */
-    chains: import("superstruct").Struct<{
+    chains: import("@metamask/superstruct").Struct<{
         name: string;
         id: `${string}:${string}`;
-    }[], import("superstruct").Struct<{
+    }[], import("@metamask/superstruct").Struct<{
         name: string;
         id: `${string}:${string}`;
     }, {
-        id: import("superstruct").Struct<`${string}:${string}`, null>;
-        name: import("superstruct").Struct<string, null>;
+        id: import("@metamask/superstruct").Struct<`${string}:${string}`, null>;
+        name: import("@metamask/superstruct").Struct<string, null>;
     }>>;
     /**
      * A list of supported RPC methods on the namespace, that a DApp can call.
      */
-    methods: import("superstruct").Struct<string[] | undefined, import("superstruct").Struct<string, null>>;
+    methods: import("@metamask/superstruct").Struct<string[] | undefined, import("@metamask/superstruct").Struct<string, null>>;
     /**
      * A list of supported RPC events on the namespace, that a DApp can listen to.
      */
-    events: import("superstruct").Struct<string[] | undefined, import("superstruct").Struct<string, null>>;
+    events: import("@metamask/superstruct").Struct<string[] | undefined, import("@metamask/superstruct").Struct<string, null>>;
 }>;
 export declare type Namespace = Infer<typeof NamespaceStruct>;
 /**
  * A CAIP-2 namespace, i.e., the first part of a chain ID.
  */
-export declare const NamespaceIdStruct: import("superstruct").Struct<string, null>;
+export declare const NamespaceIdStruct: import("@metamask/superstruct").Struct<string, null>;
 export declare type NamespaceId = Infer<typeof NamespaceIdStruct>;
 /**
  * Check if the given value is a CAIP-2 namespace ID.
diff --git a/dist/types/snaps.d.ts b/dist/types/snaps.d.ts
index 3a71172cf0237fdec276a638432f5ecb1ce5fa31..1952369cfbacf55ed2f34589db63789bd9f29cce 100644
--- a/dist/types/snaps.d.ts
+++ b/dist/types/snaps.d.ts
@@ -1,7 +1,7 @@
 import type { SubjectPermissions, PermissionConstraint } from '@metamask/permission-controller';
 import type { BlockReason } from '@metamask/snaps-registry';
 import type { SnapId, Snap as TruncatedSnap } from '@metamask/snaps-sdk';
-import type { Struct } from 'superstruct';
+import type { Struct } from '@metamask/superstruct';
 import type { LocalizationFile } from './localization';
 import type { InitialConnections, SnapManifest, SnapPermissions } from './manifest/validation';
 import type { FetchedSnapFiles, SnapsPermissionRequest } from './types';
diff --git a/dist/types/structs.d.ts b/dist/types/structs.d.ts
index 5b422c937aa9255ddb1f6c4318c397ac9c5b502d..af17efed045764133a569d5c119e2bfb4eb05bbe 100644
--- a/dist/types/structs.d.ts
+++ b/dist/types/structs.d.ts
@@ -1,6 +1,6 @@
-import type { Failure } from 'superstruct';
-import { Struct, StructError } from 'superstruct';
-import type { AnyStruct, Assign, ObjectSchema, ObjectType } from 'superstruct/dist/utils';
+import type { Failure } from '@metamask/superstruct';
+import { Struct, StructError } from '@metamask/superstruct';
+import type { AnyStruct, Assign, ObjectSchema, ObjectType } from '@metamask/superstruct';
 /**
  * Infer a struct type, only if it matches the specified type. This is useful
  * for defining types and structs that are related to each other in separate
diff --git a/dist/types/types.d.ts b/dist/types/types.d.ts
index 352b24b26e23625aa1590b282ce0968c7b8ee4c4..cb077cc2b076462353efaafc0fe27523a45fe994 100644
--- a/dist/types/types.d.ts
+++ b/dist/types/types.d.ts
@@ -1,5 +1,5 @@
 import type { Json } from '@metamask/utils';
-import type { Infer, Struct } from 'superstruct';
+import type { Infer, Struct } from '@metamask/superstruct';
 import type { SnapCaveatType } from './caveats';
 import type { SnapFunctionExports, SnapRpcHookArgs } from './handlers';
 import type { LocalizationFile } from './localization';
diff --git a/package.json b/package.json
index 0c83f7a3ab9a033d1aa188629ba722da9a224278..32a782b54a76d9237892bbadbc71da2910fda36c 100644
--- a/package.json
+++ b/package.json
@@ -49,6 +49,9 @@
     "lint:dependencies": "depcheck",
     "build:ci": "tsup --clean"
   },
+  "resolutions": {
+    "@metamask/superstruct": "3.1.0"
+  },
   "dependencies": {
     "@babel/core": "^7.23.2",
     "@babel/types": "^7.23.0",
@@ -59,7 +62,8 @@
     "@metamask/slip44": "^3.1.0",
     "@metamask/snaps-registry": "^3.1.0",
     "@metamask/snaps-sdk": "^6.0.0",
-    "@metamask/utils": "^8.3.0",
+    "@metamask/superstruct": "^3.1.0",
+    "@metamask/utils": "^9.0.0",
     "@noble/hashes": "^1.3.1",
     "@scure/base": "^1.1.1",
     "chalk": "^4.1.2",
@@ -71,7 +75,6 @@
     "rfdc": "^1.3.0",
     "semver": "^7.5.4",
     "ses": "^1.1.0",
-    "superstruct": "^1.0.3",
     "validate-npm-package-name": "^5.0.0"
   },
   "devDependencies": {
