diff --git a/dist/index.js.map b/dist/index.js.map
index bc3f309176a232b6b86e5f564ae0b39e155f7682..e70dfadc820a716f322123c11580549fbe515b5f 100644
--- a/dist/index.js.map
+++ b/dist/index.js.map
@@ -1 +1,125 @@
-{"version":3,"sources":["../src/index.ts","../src/errors.ts","../src/internals/error-wrappers.ts","../src/internals/errors.ts","../src/internals/structs.ts","../src/internals/jsx.ts","../src/internals/svg.ts","../src/error-wrappers.ts","../src/images.ts","../src/ui/components/address.ts","../src/ui/builder.ts","../src/ui/nodes.ts","../src/ui/components/copyable.ts","../src/ui/components/divider.ts","../src/ui/components/heading.ts","../src/ui/components/image.ts","../src/ui/components/panel.ts","../src/ui/components/button.ts","../src/ui/components/form.ts","../src/ui/components/input.ts","../src/ui/components/row.ts","../src/ui/components/text.ts","../src/ui/components/spinner.ts","../src/ui/component.ts","../src/types/handlers/transaction.ts","../src/types/handlers/user-input.ts","../src/types/methods/dialog.ts","../src/types/methods/get-file.ts","../src/types/methods/manage-state.ts","../src/types/methods/notify.ts","../src/types/interface.ts","../src/jsx/validation.ts"],"sourcesContent":["// Only internals that are used by other Snaps packages should be exported here.\nexport type { EnumToUnion } from './internals';\nexport {\n  getErrorData,\n  getErrorMessage,\n  getErrorStack,\n  SNAP_ERROR_CODE,\n  SNAP_ERROR_MESSAGE,\n  literal,\n  union,\n  enumValue,\n} from './internals';\n\n// Re-exported from `@metamask/utils` for convenience.\nexport type {\n  Json,\n  JsonRpcError,\n  JsonRpcRequest,\n  JsonRpcParams,\n} from '@metamask/utils';\nexport { assert } from '@metamask/utils';\n\nexport * from './errors';\nexport * from './error-wrappers';\nexport * from './images';\nexport * from './types';\nexport * from './ui';\n","import type { Json, JsonRpcError } from '@metamask/utils';\n\nimport {\n  getErrorCode,\n  getErrorData,\n  getErrorMessage,\n  SNAP_ERROR_CODE,\n  SNAP_ERROR_MESSAGE,\n} from './internals';\n\n/**\n * A generic error which can be thrown by a Snap, without it causing the Snap to\n * crash.\n */\nexport class SnapError extends Error {\n  readonly #code: number;\n\n  readonly #message: string;\n\n  readonly #data?: Record<string, Json>;\n\n  readonly #stack?: string;\n\n  /**\n   * Create a new `SnapError`.\n   *\n   * @param error - The error to create the `SnapError` from. If this is a\n   * `string`, it will be used as the error message. If this is an `Error`, its\n   * `message` property will be used as the error message. If this is a\n   * `JsonRpcError`, its `message` property will be used as the error message\n   * and its `code` property will be used as the error code. Otherwise, the\n   * error will be converted to a string and used as the error message.\n   * @param data - Additional data to include in the error. This will be merged\n   * with the error data, if any.\n   */\n  constructor(\n    error: string | Error | JsonRpcError,\n    data: Record<string, Json> = {},\n  ) {\n    const message = getErrorMessage(error);\n    super(message);\n\n    this.#message = message;\n    this.#code = getErrorCode(error);\n\n    const mergedData = { ...getErrorData(error), ...data };\n    if (Object.keys(mergedData).length > 0) {\n      this.#data = mergedData;\n    }\n\n    this.#stack = super.stack;\n  }\n\n  /**\n   * The error name.\n   *\n   * @returns The error name.\n   */\n  get name() {\n    return 'SnapError';\n  }\n\n  /**\n   * The error code.\n   *\n   * @returns The error code.\n   */\n  get code() {\n    return this.#code;\n  }\n\n  /**\n   * The error message.\n   *\n   * @returns The error message.\n   */\n  // This line is covered, but Jest doesn't pick it up for some reason.\n  /* istanbul ignore next */\n  get message() {\n    return this.#message;\n  }\n\n  /**\n   * Additional data for the error.\n   *\n   * @returns Additional data for the error.\n   */\n  get data() {\n    return this.#data;\n  }\n\n  /**\n   * The error stack.\n   *\n   * @returns The error stack.\n   */\n  // This line is covered, but Jest doesn't pick it up for some reason.\n  /* istanbul ignore next */\n  get stack() {\n    return this.#stack;\n  }\n\n  /**\n   * Convert the error to a JSON object.\n   *\n   * @returns The JSON object.\n   */\n  toJSON(): SerializedSnapError {\n    return {\n      code: SNAP_ERROR_CODE,\n      message: SNAP_ERROR_MESSAGE,\n      data: {\n        cause: {\n          code: this.code,\n          message: this.message,\n          stack: this.stack,\n          ...(this.data ? { data: this.data } : {}),\n        },\n      },\n    };\n  }\n\n  /**\n   * Serialize the error to a JSON object. This is called by\n   * `@metamask/rpc-errors` when serializing the error.\n   *\n   * @returns The JSON object.\n   */\n  serialize() {\n    return this.toJSON();\n  }\n}\n\n/**\n * A serialized {@link SnapError}. It's JSON-serializable, so it can be sent\n * over the RPC. The original error is wrapped in the `cause` property.\n *\n * @property code - The error code. This is always `-31002`.\n * @property message - The error message. This is always `'Snap Error'`.\n * @property data - The error data.\n * @property data.cause - The cause of the error.\n * @property data.cause.code - The error code.\n * @property data.cause.message - The error message.\n * @property data.cause.stack - The error stack.\n * @property data.cause.data - Additional data for the error.\n * @see SnapError\n */\nexport type SerializedSnapError = {\n  code: typeof SNAP_ERROR_CODE;\n  message: typeof SNAP_ERROR_MESSAGE;\n  data: {\n    cause: JsonRpcError;\n  };\n};\n","import type { rpcErrors } from '@metamask/rpc-errors';\nimport type { Json } from '@metamask/utils';\n\nimport { SnapError } from '../errors';\n\nexport type JsonRpcErrorFunction = typeof rpcErrors.parse;\n\n/**\n * Create a `SnapError` class from an error function from\n * `@metamask/rpc-errors`. This is useful for creating custom error classes\n * which can be thrown by a Snap.\n *\n * The created class will inherit the message, code, and data properties from\n * the error function.\n *\n * @param fn - The error function to create the class from.\n * @returns The created `SnapError` class.\n */\nexport function createSnapError(fn: JsonRpcErrorFunction) {\n  return class SnapJsonRpcError extends SnapError {\n    /**\n     * Create a new `SnapJsonRpcError` from a message.\n     *\n     * @param message - The message to create the error from.\n     */\n    constructor(message?: string);\n\n    /**\n     * Create a new `SnapJsonRpcError` from data.\n     *\n     * @param data - The data to create the error from.\n     */\n    constructor(data?: Record<string, Json>);\n\n    /**\n     * Create a new `SnapJsonRpcError` from a message and data.\n     *\n     * @param message - The message to create the error from.\n     * @param data - The data to create the error from.\n     */\n    constructor(\n      message?: string | Record<string, Json>,\n      data?: Record<string, Json>,\n    );\n\n    /**\n     * Create a new `SnapJsonRpcError` from a message and data.\n     *\n     * @param message - The message to create the error from.\n     * @param data - The data to create the error from.\n     */\n    constructor(\n      message?: string | Record<string, Json>,\n      data?: Record<string, Json>,\n    ) {\n      if (typeof message === 'object') {\n        const error = fn();\n        super({\n          code: error.code,\n          message: error.message,\n          data: message,\n        });\n\n        return;\n      }\n\n      const error = fn(message);\n      super({\n        code: error.code,\n        message: error.message,\n        data,\n      });\n    }\n  };\n}\n","import { hasProperty, isObject, isValidJson } from '@metamask/utils';\n\nexport const SNAP_ERROR_CODE = -31002;\nexport const SNAP_ERROR_MESSAGE = 'Snap Error';\n\n/**\n * Get the error message from an unknown error type.\n *\n * - If the error is an object with a `message` property, return the message.\n * - Otherwise, return the error converted to a string.\n *\n * @param error - The error to get the message from.\n * @returns The error message.\n * @internal\n */\nexport function getErrorMessage(error: unknown) {\n  if (\n    isObject(error) &&\n    hasProperty(error, 'message') &&\n    typeof error.message === 'string'\n  ) {\n    return error.message;\n  }\n\n  return String(error);\n}\n\n/**\n * Get the error stack from an unknown error type.\n *\n * @param error - The error to get the stack from.\n * @returns The error stack, or undefined if the error does not have a valid\n * stack.\n * @internal\n */\nexport function getErrorStack(error: unknown) {\n  if (\n    isObject(error) &&\n    hasProperty(error, 'stack') &&\n    typeof error.stack === 'string'\n  ) {\n    return error.stack;\n  }\n\n  return undefined;\n}\n\n/**\n * Get the error code from an unknown error type.\n *\n * @param error - The error to get the code from.\n * @returns The error code, or `-32603` if the error does not have a valid code.\n * @internal\n */\nexport function getErrorCode(error: unknown) {\n  if (\n    isObject(error) &&\n    hasProperty(error, 'code') &&\n    typeof error.code === 'number' &&\n    Number.isInteger(error.code)\n  ) {\n    return error.code;\n  }\n\n  return -32603;\n}\n\n/**\n * Get the error data from an unknown error type.\n *\n * @param error - The error to get the data from.\n * @returns The error data, or an empty object if the error does not have valid\n * data.\n * @internal\n */\nexport function getErrorData(error: unknown) {\n  if (\n    isObject(error) &&\n    hasProperty(error, 'data') &&\n    typeof error.data === 'object' &&\n    error.data !== null &&\n    isValidJson(error.data) &&\n    !Array.isArray(error.data)\n  ) {\n    return error.data;\n  }\n\n  return {};\n}\n","import type { Infer } from 'superstruct';\nimport {\n  Struct,\n  define,\n  literal as superstructLiteral,\n  union as superstructUnion,\n} from 'superstruct';\nimport type { AnyStruct, InferStructTuple } from 'superstruct/dist/utils';\n\nimport type { EnumToUnion } from './helpers';\n\n/**\n * A wrapper of `superstruct`'s `literal` struct that also defines the name of\n * the struct as the literal value.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n * For example, instead of returning an error like:\n *\n * ```\n * Expected the value to satisfy a union of `literal | literal`, but received: \\\"baz\\\"\n * ```\n *\n * This struct will return an error like:\n *\n * ```\n * Expected the value to satisfy a union of `\"foo\" | \"bar\"`, but received: \\\"baz\\\"\n * ```\n *\n * @param value - The literal value.\n * @returns The `superstruct` struct, which validates that the value is equal\n * to the literal value.\n */\nexport function literal<Type extends string | number | boolean>(value: Type) {\n  return define<Type>(\n    JSON.stringify(value),\n    superstructLiteral(value).validator,\n  );\n}\n\n/**\n * A wrapper of `superstruct`'s `union` struct that also defines the schema as\n * the union of the schemas of the structs.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n *\n * @param structs - The structs to union.\n * @param structs.\"0\" - The first struct.\n * @param structs.\"1\" - The remaining structs.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function union<Head extends AnyStruct, Tail extends AnyStruct[]>([\n  head,\n  ...tail\n]: [head: Head, ...tail: Tail]): Struct<\n  Infer<Head> | InferStructTuple<Tail>[number],\n  [head: Head, ...tail: Tail]\n> {\n  const struct = superstructUnion([head, ...tail]);\n\n  return new Struct({\n    ...struct,\n    schema: [head, ...tail],\n  });\n}\n\n/**\n * Superstruct struct for validating an enum value. This allows using both the\n * enum string values and the enum itself as values.\n *\n * @param constant - The enum to validate against.\n * @returns The superstruct struct.\n */\nexport function enumValue<Type extends string>(\n  constant: Type,\n): Struct<EnumToUnion<Type>, null> {\n  return literal(constant as EnumToUnion<Type>);\n}\n","import type { Infer, Struct } from 'superstruct';\nimport type {\n  AnyStruct,\n  EnumSchema,\n  InferStructTuple,\n  IsExactMatch,\n  IsMatch,\n  IsRecord,\n  IsTuple,\n  UnionToIntersection,\n} from 'superstruct/dist/utils';\n\nimport type { EmptyObject } from '../types';\nimport { union } from './structs';\n\n/**\n * Check if a type is a union. Infers `true` if it is a union, otherwise\n * `false`.\n */\ntype IsUnion<Type> = [Type] extends [UnionToIntersection<Type>] ? false : true;\n\n/**\n * Get a struct schema for a type.\n *\n * This is copied from `superstruct` but fixes some issues with the original\n * implementation.\n */\ntype StructSchema<Type> = IsUnion<Type> extends true\n  ? null\n  : [Type] extends [EmptyObject]\n  ? EmptyObject\n  : [Type] extends [string | undefined | null]\n  ? [Type] extends [`0x${string}`]\n    ? null\n    : [Type] extends [IsMatch<Type, string | undefined | null>]\n    ? null\n    : [Type] extends [IsUnion<Type>]\n    ? EnumSchema<Type>\n    : Type\n  : [Type] extends [number | undefined | null]\n  ? [Type] extends [IsMatch<Type, number | undefined | null>]\n    ? null\n    : [Type] extends [IsUnion<Type>]\n    ? EnumSchema<Type>\n    : Type\n  : [Type] extends [boolean]\n  ? [Type] extends [IsExactMatch<Type, boolean>]\n    ? null\n    : Type\n  : Type extends\n      | bigint\n      | symbol\n      | undefined\n      | null\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      | Function\n      | Date\n      | Error\n      | RegExp\n      | Map<any, any>\n      | WeakMap<any, any>\n      | Set<any>\n      | WeakSet<any>\n      | Promise<any>\n  ? null\n  : Type extends (infer E)[]\n  ? Type extends IsTuple<Type>\n    ? null\n    : Struct<E>\n  : Type extends object\n  ? Type extends IsRecord<Type>\n    ? null\n    : {\n        [InnerKey in keyof Type]: Describe<Type[InnerKey]>;\n      }\n  : null;\n\n/**\n * Describe a struct type.\n */\nexport type Describe<Type> = Struct<Type, StructSchema<Type>>;\n\n/**\n * Create a union struct that uses `null` for the schema type, for better\n * compatibility with `Describe`.\n *\n * @param structs - The structs to union.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function nullUnion<Head extends AnyStruct, Tail extends AnyStruct[]>(\n  structs: [head: Head, ...tail: Tail],\n): Struct<Infer<Head> | InferStructTuple<Tail>[number], null> {\n  return union(structs) as unknown as Struct<\n    Infer<Head> | InferStructTuple<Tail>[number],\n    null\n  >;\n}\n","import { refine, string } from 'superstruct';\n\n/**\n * Get a Struct that validates a string as a valid SVG.\n *\n * @returns A Struct that validates a string as a valid SVG.\n * @internal\n */\nexport function svg() {\n  return refine(string(), 'SVG', (value) => {\n    // This validation is intentionally very basic, we don't need to be that strict\n    // and merely have this extra validation as a helpful error if devs aren't\n    // passing in SVGs.\n    if (!value.includes('<svg')) {\n      return 'Value is not a valid SVG.';\n    }\n\n    return true;\n  });\n}\n","import { providerErrors, rpcErrors } from '@metamask/rpc-errors';\n\nimport { createSnapError } from './internals';\n\n/**\n * A JSON-RPC 2.0 Internal (-32603) error.\n *\n * This can be thrown by a Snap to indicate that an internal error occurred,\n * without crashing the Snap.\n *\n * @see https://www.jsonrpc.org/specification#error_object\n */\nexport const InternalError = createSnapError(rpcErrors.internal);\n\n/**\n * An Ethereum JSON-RPC Invalid Input (-32000) error.\n *\n * This can be thrown by a Snap to indicate that the input to a method is\n * invalid, without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport const InvalidInputError = createSnapError(rpcErrors.invalidInput);\n\n/**\n * A JSON-RPC 2.0 Invalid Params (-32602) error.\n *\n * This can be thrown by a Snap to indicate that the parameters to a method are\n * invalid, without crashing the Snap.\n *\n * @see https://www.jsonrpc.org/specification#error_object\n */\nexport const InvalidParamsError = createSnapError(rpcErrors.invalidParams);\n\n/**\n * A JSON-RPC 2.0 Invalid Request (-32600) error.\n *\n * This can be thrown by a Snap to indicate that the request is invalid, without\n * crashing the Snap.\n *\n * @see https://www.jsonrpc.org/specification#error_object\n */\nexport const InvalidRequestError = createSnapError(rpcErrors.invalidRequest);\n\n/**\n * An Ethereum JSON-RPC Limit Exceeded (-32005) error.\n *\n * This can be thrown by a Snap to indicate that a limit has been exceeded,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport const LimitExceededError = createSnapError(rpcErrors.limitExceeded);\n\n/**\n * An Ethereum JSON-RPC Method Not Found (-32601) error.\n *\n * This can be thrown by a Snap to indicate that a method does not exist,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport const MethodNotFoundError = createSnapError(rpcErrors.methodNotFound);\n\n/**\n * An Ethereum JSON-RPC Method Not Supported (-32004) error.\n *\n * This can be thrown by a Snap to indicate that a method is not supported,\n * without crashing the Snap.\n */\nexport const MethodNotSupportedError = createSnapError(\n  rpcErrors.methodNotSupported,\n);\n\n/**\n * A JSON-RPC 2.0 Parse (-32700) error.\n *\n * This can be thrown by a Snap to indicate that a request is not valid JSON,\n * without crashing the Snap.\n *\n * @see https://www.jsonrpc.org/specification#error_object\n */\nexport const ParseError = createSnapError(rpcErrors.parse);\n\n/**\n * An Ethereum JSON-RPC Resource Not Found (-32001) error.\n *\n * This can be thrown by a Snap to indicate that a resource does not exist,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport const ResourceNotFoundError = createSnapError(\n  rpcErrors.resourceNotFound,\n);\n\n/**\n * An Ethereum JSON-RPC Resource Unavailable (-32002) error.\n *\n * This can be thrown by a Snap to indicate that a resource is unavailable,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport const ResourceUnavailableError = createSnapError(\n  rpcErrors.resourceUnavailable,\n);\n\n/**\n * An Ethereum JSON-RPC Transaction Rejected (-32003) error.\n *\n * This can be thrown by a Snap to indicate that a transaction was rejected,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport const TransactionRejected = createSnapError(\n  rpcErrors.transactionRejected,\n);\n\n/**\n * An Ethereum Provider Chain Disconnected (4901) error.\n *\n * This can be thrown by a Snap to indicate that the provider is disconnected\n * from the requested chain, without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport const ChainDisconnectedError = createSnapError(\n  providerErrors.chainDisconnected,\n);\n\n/**\n * An Ethereum Provider Disconnected (4900) error.\n *\n * This can be thrown by a Snap to indicate that the provider is disconnected,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport const DisconnectedError = createSnapError(providerErrors.disconnected);\n\n/**\n * An Ethereum Provider Unauthorized (4100) error.\n *\n * This can be thrown by a Snap to indicate that the requested method / account\n * is not authorized by the user, without crashing the Snap.\n */\nexport const UnauthorizedError = createSnapError(providerErrors.unauthorized);\n\n/**\n * An Ethereum Provider Unsupported Method (4200) error.\n *\n * This can be thrown by a Snap to indicate that the requested method is not\n * supported by the provider, without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport const UnsupportedMethodError = createSnapError(\n  providerErrors.unsupportedMethod,\n);\n\n/**\n * An Ethereum Provider User Rejected Request (4001) error.\n *\n * This can be thrown by a Snap to indicate that the user rejected the request,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport const UserRejectedRequestError = createSnapError(\n  providerErrors.userRejectedRequest,\n);\n","import { assert, bytesToBase64 } from '@metamask/utils';\n\nimport { image } from './ui';\n\n/**\n * Get raw image data from a URL.\n *\n * @param url - The URL to get the image data from.\n * @param options - The options to use when fetching the image data. This is\n * passed directly to `fetch`.\n * @returns A promise that resolves to the image data as a blob.\n */\nasync function getRawImageData(url: string, options?: RequestInit) {\n  if (typeof fetch !== 'function') {\n    throw new Error(\n      `Failed to fetch image data from \"${url}\": Using this function requires the \"endowment:network-access\" permission.`,\n    );\n  }\n\n  return fetch(url, options).then(async (response) => {\n    if (!response.ok) {\n      throw new Error(\n        `Failed to fetch image data from \"${url}\": ${response.status} ${response.statusText}`,\n      );\n    }\n\n    const blob = await response.blob();\n    assert(\n      blob.type === 'image/jpeg' || blob.type === 'image/png',\n      'Expected image data to be a JPEG or PNG image.',\n    );\n\n    return blob;\n  });\n}\n\n/**\n * Get image data as data-string from a URL. This is useful for embedding images\n * inside of SVGs. Only JPEG and PNG images are supported.\n *\n * Note: This function uses `fetch` to get the image data. This means that using\n * it requires the `endowment:network-access` permission.\n *\n * @example\n * const imageData = await getImageData('https://cataas.com/cat');\n * const svg = `\n *   <svg width=\"100\" height=\"100\" xmlns=\"http://www.w3.org/2000/svg\">\n *     <image href=\"${imageData}\" />\n *   </svg>\n * `;\n *\n * // Render the SVG in a Snap UI.\n * const ui = image(svg);\n * @param url - The URL to get the image data from.\n * @param options - The options to use when fetching the image data. This is\n * passed directly to `fetch`.\n * @returns A promise that resolves to the image data as a data-string.\n */\nexport async function getImageData(url: string, options?: RequestInit) {\n  const blob = await getRawImageData(url, options);\n  const bytes = new Uint8Array(await blob.arrayBuffer());\n\n  return `data:${blob.type};base64,${bytesToBase64(bytes)}`;\n}\n\n/**\n * Options for getting an SVG image element from a URL.\n *\n * @property width - The width of the image.\n * @property height - The height of the image. If this is not provided, the\n * width will be used as the height.\n * @property request - The options to use when fetching the image data. This is\n * passed directly to `fetch`.\n */\nexport type ImageOptions = {\n  width: number;\n  height?: number;\n  request?: RequestInit;\n};\n\n/**\n * Get an image component from a URL. This is useful for embedding images inside\n * Snap UIs. Only JPEG and PNG images are supported.\n *\n * Note: This function uses `fetch` to get the image data. This means that using\n * it requires the `endowment:network-access` permission.\n *\n * @example\n * const component = await getImage('https://cataas.com/cat');\n *\n * return await snap.request({\n *   method: 'snap_dialog',\n *   params: {\n *     type: 'alert',\n *     content: panel([\n *       component,\n *     ]),\n *   },\n * });\n * @param url - The URL to get the image data from.\n * @param options - The options to use when fetching and rendering the image.\n * @param options.width - The width of the image.\n * @param options.height - The height of the image. If this is not provided, the\n * width will be used as the height.\n * @param options.request - The options to use when fetching the image data.\n * This is passed directly to `fetch`.\n * @returns A promise that resolves to the image data as an image component.\n */\nexport async function getImageComponent(\n  url: string,\n  { width, height = width, request }: ImageOptions,\n) {\n  assert(\n    typeof width === 'number' && width > 0,\n    'Expected width to be a number greater than 0.',\n  );\n\n  assert(\n    typeof height === 'number' && height > 0,\n    'Expected height to be a number greater than 0.',\n  );\n\n  const imageData = await getImageData(url, request);\n  const size = `width=\"${width}\" height=\"${height}\"`;\n\n  return image(\n    `<svg ${size.trim()} xmlns=\"http://www.w3.org/2000/svg\"><image ${size.trim()} href=\"${imageData}\" /></svg>`,\n  );\n}\n","import { HexChecksumAddressStruct } from '@metamask/utils';\nimport type { Infer } from 'superstruct';\nimport { assign, literal, object } from 'superstruct';\n\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\n\nexport const AddressStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Address),\n    value: HexChecksumAddressStruct,\n  }),\n);\n\n/**\n * A address node, that renders an EVM-like address and its icon.\n *\n * @property type - The type of the node. Must be the string `address`.\n * @property value - The address in hexadecimal, including 0x.\n */\nexport type Address = Infer<typeof AddressStruct>;\n\n/**\n * Create an {@link Address} node.\n *\n * @param args - The node arguments. This can either be a string, or an object\n * with the `value` property.\n * @param args.value - The address to be rendered.\n * @returns The address node as an object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = address({ value: '0x4bbeeb066ed09b7aed07bf39eee0460dfa261520' });\n * const node = address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520');\n */\nexport const address = createBuilder(NodeType.Address, AddressStruct, [\n  'value',\n]);\n","import { assertStruct, isPlainObject } from '@metamask/utils';\nimport type { Struct } from 'superstruct';\n\nimport type { Component } from './components';\nimport type { NodeType } from './nodes';\n\n/**\n * A function that builds a {@link Component}. This infers the proper args type\n * from the given node.\n *\n * @internal\n */\ntype NodeBuilder<Node extends Component, Keys extends (keyof Node)[]> = Omit<\n  Node,\n  'type'\n> extends Record<string, never>\n  ? (...args: []) => Node\n  : (...args: [Omit<Node, 'type'>] | NodeArrayType<Node, Keys>) => Node;\n\n/**\n * Map from an array of node keys to the corresponding array type.\n *\n * @example\n * type Node = { type: 'node'; a: string; b: number; c: boolean };\n * type Keys = ['a', 'b', 'c'];\n *\n * type NodeArray = NodeArrayType<Node, Keys>; // [string, number, boolean]\n * @internal\n */\ntype NodeArrayType<Node extends Component, Keys extends (keyof Node)[]> = {\n  [Key in keyof Keys]: Node[Keys[Key]];\n};\n\n/**\n * A function that returns a function to \"build\" a {@link Component}. It infers\n * the type of the component from the given struct, and performs validation on\n * the created component.\n *\n * The returned function can handle the node arguments in two ways:\n * 1. As a single object, with the keys corresponding to the node's properties,\n * excluding the `type` property.\n * 2. As an array of arguments, with the order corresponding to the given keys.\n *\n * @param type - The type of the component to build.\n * @param struct - The struct to use to validate the component.\n * @param keys - The keys of the component to use as arguments to the builder.\n * The order of the keys determines the order of the arguments.\n * @returns A function that builds a component of the given type.\n * @internal\n */\nexport function createBuilder<\n  Node extends Component,\n  Keys extends (keyof Node)[] = [],\n>(\n  type: NodeType,\n  struct: Struct<Node>,\n  keys: Keys = [] as unknown as Keys,\n): NodeBuilder<Node, Keys> {\n  return (...args: [Omit<Node, 'type'>] | NodeArrayType<Node, Keys> | []) => {\n    // Node passed as a single object.\n    if (args.length === 1 && isPlainObject(args[0])) {\n      const node = { ...args[0], type };\n\n      // The user could be passing invalid values to the builder, so we need to\n      // validate them as per the component's struct.\n      assertStruct(node, struct, `Invalid ${type} component`);\n      return node;\n    }\n\n    // Node passed as an array of arguments.\n    const node = keys.reduce<Partial<Component>>(\n      (partialNode, key, index) => {\n        if (args[index] !== undefined) {\n          return {\n            ...partialNode,\n            [key]: args[index],\n          };\n        }\n\n        return partialNode;\n      },\n      { type },\n    );\n\n    // The user could be passing invalid values to the builder, so we need to\n    // validate them as per the component's struct.\n    assertStruct(node, struct, `Invalid ${type} component`);\n    return node;\n  };\n}\n","import type { Infer } from 'superstruct';\nimport { assign, object, string, unknown } from 'superstruct';\n\n/**\n * The supported node types. This is based on SIP-7.\n *\n * @see https://metamask.github.io/SIPs/SIPS/sip-7\n */\nexport enum NodeType {\n  Copyable = 'copyable',\n  Divider = 'divider',\n  Heading = 'heading',\n  Panel = 'panel',\n  Spinner = 'spinner',\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  Text = 'text',\n  Image = 'image',\n  Row = 'row',\n  Address = 'address',\n  Button = 'button',\n  Input = 'input',\n  Form = 'form',\n}\n\n/**\n * @internal\n */\nexport const NodeStruct = object({\n  type: string(),\n});\n\n/**\n * The base node type. All nodes extend this type.\n *\n * @property type - The type of the node. See {@link NodeType} for the supported\n * node types.\n * @internal\n */\nexport type Node = Infer<typeof NodeStruct>;\n\n/**\n * @internal\n */\nexport const LiteralStruct = assign(\n  NodeStruct,\n  object({\n    value: unknown(),\n  }),\n);\n\n/**\n * A node with a value. This is used for nodes that render a value, such as\n * {@link Text}.\n *\n * @property type - The type of the node.\n * @property value - The value of the node. The type of the value depends on the\n * node type.\n * @internal\n */\nexport type Literal = Infer<typeof LiteralStruct>;\n","import type { Infer } from 'superstruct';\nimport {\n  assign,\n  boolean,\n  literal,\n  object,\n  optional,\n  string,\n} from 'superstruct';\n\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\n\nexport const CopyableStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Copyable),\n    value: string(),\n    sensitive: optional(boolean()),\n  }),\n);\n\n/**\n * Text that can be copied to the clipboard. It can optionally be marked as\n * sensitive, in which case it will only be displayed to the user after clicking\n * on the component.\n *\n * @property type - The type of the node. Must be the string `copyable`.\n * @property value - The text to be copied.\n * @property sensitive - Whether the value is sensitive or not. Sensitive values\n * are only displayed to the user after clicking on the component. Defaults to\n * false.\n */\nexport type Copyable = Infer<typeof CopyableStruct>;\n\n/**\n * Create a {@link Copyable} component.\n *\n * @param args - The node arguments. This can either be a string, or an object\n * with the `text` property.\n * @param args.value - The text to be copied.\n * @param args.sensitive - Whether the value is sensitive or not. Sensitive\n * values are only displayed to the user after clicking on the component.\n * Defaults to false.\n * @returns A {@link Copyable} component.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = copyable('Hello, world!');\n * const node = copyable({ value: 'Hello, world!' });\n */\nexport const copyable = createBuilder(NodeType.Copyable, CopyableStruct, [\n  'value',\n  'sensitive',\n]);\n","import type { Infer } from 'superstruct';\nimport { assign, literal, object } from 'superstruct';\n\nimport { createBuilder } from '../builder';\nimport { NodeStruct, NodeType } from '../nodes';\n\nexport const DividerStruct = assign(\n  NodeStruct,\n  object({\n    type: literal(NodeType.Divider),\n  }),\n);\n\n/**\n * A divider node, that renders a line between other nodes.\n */\nexport type Divider = Infer<typeof DividerStruct>;\n\n/**\n * Create a {@link Divider} node.\n *\n * @returns The divider node as object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = divider();\n */\nexport const divider = createBuilder(NodeType.Divider, DividerStruct);\n","import type { Infer } from 'superstruct';\nimport { assign, literal, object, string } from 'superstruct';\n\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\n\nexport const HeadingStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Heading),\n    value: string(),\n  }),\n);\n\n/**\n * A heading node, that renders the text as a heading. The level of the heading\n * is determined by the depth of the heading in the document.\n *\n * @property type - The type of the node, must be the string 'text'.\n * @property value - The text content of the node, either as plain text, or as a\n * markdown string.\n */\nexport type Heading = Infer<typeof HeadingStruct>;\n\n/**\n * Create a {@link Heading} node.\n *\n * @param args - The node arguments. This can either be a string, or an object\n * with the `value` property.\n * @param args.value - The heading text.\n * @returns The heading node as object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = heading({ value: 'Hello, world!' });\n * const node = heading('Hello, world!');\n */\nexport const heading = createBuilder(NodeType.Heading, HeadingStruct, [\n  'value',\n]);\n","import type { Infer } from 'superstruct';\nimport { assign, literal, object } from 'superstruct';\n\nimport { svg } from '../../internals';\nimport { createBuilder } from '../builder';\nimport { NodeStruct, NodeType } from '../nodes';\n\nexport const ImageStruct = assign(\n  NodeStruct,\n  object({\n    type: literal(NodeType.Image),\n    value: svg(),\n  }),\n);\n\n/**\n * An image node, that renders an SVG image.\n *\n * @property type - The type of the node. Must be the string `image`.\n * @property value - The SVG image to be rendered.\n */\nexport type Image = Infer<typeof ImageStruct>;\n\n/**\n * Create an {@link Image} node.\n *\n * @param args - The node arguments. This can either be a string, or an object\n * with the `value` property.\n * @param args.value - The SVG image to be rendered. Must be a valid SVG string.\n * @returns The image node as object. Other image formats are supported by\n * embedding them as data URLs in the SVG.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = image({ value: '<svg />' });\n * const node = image('<svg />');\n */\nexport const image = createBuilder(NodeType.Image, ImageStruct, ['value']);\n","import type { Infer, Struct } from 'superstruct';\nimport { array, assign, lazy, literal, object, union } from 'superstruct';\n\nimport { createBuilder } from '../builder';\nimport { NodeStruct, NodeType } from '../nodes';\nimport { AddressStruct } from './address';\nimport { ButtonStruct } from './button';\nimport { CopyableStruct } from './copyable';\nimport { DividerStruct } from './divider';\nimport { FormStruct } from './form';\nimport { HeadingStruct } from './heading';\nimport { ImageStruct } from './image';\nimport { InputStruct } from './input';\nimport { RowStruct } from './row';\nimport { SpinnerStruct } from './spinner';\nimport { TextStruct } from './text';\n\n/**\n * @internal\n */\nexport const ParentStruct = assign(\n  NodeStruct,\n  object({\n    // This node references itself indirectly, so we need to use `lazy()`.\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    children: array(lazy(() => ComponentStruct)),\n  }),\n);\n\n/**\n * A node which supports child nodes. This is used for nodes that render their\n * children, such as {@link Panel}.\n *\n * @property type - The type of the node.\n * @property children - The children of the node\n * @internal\n */\nexport type Parent = Infer<typeof ParentStruct>;\n\n/**\n * @internal\n */\nexport const PanelStruct: Struct<Panel> = assign(\n  ParentStruct,\n  object({\n    type: literal(NodeType.Panel),\n  }),\n);\n\n/**\n * A panel node, which renders its children.\n *\n * @property type - The type of the node, must be the string 'text'.\n * @property value - The text content of the node, either as plain text, or as a\n * markdown string.\n */\n// This node references itself indirectly, so it cannot be inferred.\nexport type Panel = {\n  type: NodeType.Panel;\n  children: Component[];\n};\n\n/**\n * Create a {@link Panel} node.\n *\n * @param args - The node arguments. This can be either an array of children, or\n * an object with a `children` property.\n * @param args.children - The child nodes of the panel. This can be any valid\n * {@link Component}.\n * @returns The panel node as object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = panel({\n *  children: [\n *    heading({ text: 'Hello, world!' }),\n *    text({ text: 'This is a panel.' }),\n *  ],\n * });\n *\n * const node = panel([\n *   heading('Hello, world!'),\n *   text('This is a panel.'),\n * ]);\n */\nexport const panel = createBuilder(NodeType.Panel, PanelStruct, ['children']);\n\n// This is defined separately from `Component` to avoid circular dependencies.\nexport const ComponentStruct = union([\n  CopyableStruct,\n  DividerStruct,\n  HeadingStruct,\n  ImageStruct,\n  PanelStruct,\n  SpinnerStruct,\n  TextStruct,\n  RowStruct,\n  AddressStruct,\n  InputStruct,\n  FormStruct,\n  ButtonStruct,\n]);\n\n/**\n * All supported component types.\n */\nexport type Component = Infer<typeof ComponentStruct>;\n","import type { Infer } from 'superstruct';\nimport { assign, literal, object, optional, string, union } from 'superstruct';\n\nimport { enumValue } from '../../internals';\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\n\nexport enum ButtonVariant {\n  Primary = 'primary',\n  Secondary = 'secondary',\n}\n\nexport enum ButtonType {\n  Button = 'button',\n  Submit = 'submit',\n}\n\nexport const ButtonStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Button),\n    value: string(),\n    variant: optional(\n      union([\n        enumValue(ButtonVariant.Primary),\n        enumValue(ButtonVariant.Secondary),\n      ]),\n    ),\n    buttonType: optional(\n      union([enumValue(ButtonType.Button), enumValue(ButtonType.Submit)]),\n    ),\n    name: optional(string()),\n  }),\n);\n\n/**\n * A button node, that renders either a primary or a secondary button.\n *\n * @property type - The type of the node, must be the string 'button'.\n * @property variant - The style variant of the node, must be either 'primary' or 'secondary'.\n * @property value - The text content of the node as plain text.\n * @property buttonType - The type of the button, must be either 'button' or 'submit'.\n * @property name - An optional name to identify the button.\n */\nexport type Button = Infer<typeof ButtonStruct>;\n\n/**\n * Create a {@link Button} node.\n *\n * @param args - The node arguments. This can be either a string, or an object\n * with a `value` property. A set of optional properties can be passed.\n * @param args.variant - The optional variant of the button.\n * @param args.value - The text content of the node.\n * @param args.name - The optional name of the button.\n * @returns The text node as object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * ```typescript\n * const node = button({  variant: 'primary', text: 'Hello, world!', name: 'myButton' });\n * const node = button('Hello, world!', 'button', 'myButton', 'primary');\n * const node = button('Hello, world!');\n * ```\n */\nexport const button = createBuilder(NodeType.Button, ButtonStruct, [\n  'value',\n  'buttonType',\n  'name',\n  'variant',\n]);\n","import type { Infer } from 'superstruct';\nimport { array, assign, literal, object, string, union } from 'superstruct';\n\nimport { createBuilder } from '../builder';\nimport { NodeStruct, NodeType } from '../nodes';\nimport { ButtonStruct } from './button';\nimport { InputStruct } from './input';\n\nexport const FormComponentStruct = union([InputStruct, ButtonStruct]);\n\n/**\n * The subset of nodes allowed as children in the {@link Form} node.\n */\nexport type FormComponent = Infer<typeof FormComponentStruct>;\n\nexport const FormStruct = assign(\n  NodeStruct,\n  object({\n    type: literal(NodeType.Form),\n    children: array(FormComponentStruct),\n    name: string(),\n  }),\n);\n\n/**\n * A form node that takes children {@link FormComponent} nodes and renders a form.\n *\n * @property type - The type of the node. Must be the string `form`.\n * @property children - The children of the node. Only {@link FormComponent} nodes are allowed.\n * @property name - The form name used to identify it.\n */\nexport type Form = Infer<typeof FormStruct>;\n\n/**\n * Create a {@link Form} node.\n *\n * @param args - The node arguments. This can be either an array of children and a string, or\n * an object with a `name` and `children` property.\n * @param args.name - The form name used to identify it.\n * @param args.children - The child nodes of the form. This can be any valid\n * {@link FormComponent}.\n * @returns The form node as object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = form({\n *  name: 'myForm',\n *  children: [\n *    input({ name: 'myInput' }),\n *    button({ value: 'Hello, world!' }),\n *  ],\n * });\n *\n * const node = form('myForm', [input('myInput'), button('Hello, world!')]);\n */\nexport const form = createBuilder(NodeType.Form, FormStruct, [\n  'name',\n  'children',\n]);\n","import type { Infer } from 'superstruct';\nimport { assign, literal, object, optional, string, union } from 'superstruct';\n\nimport { enumValue } from '../../internals';\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\n\n/**\n * This replicates the available input types from the metamask extension.\n * https://github.com/MetaMask/metamask-extension/develop/ui/components/component-library/input/input.constants.js\n */\nexport enum InputType {\n  /* eslint-disable @typescript-eslint/no-shadow */\n  Text = 'text',\n  Number = 'number',\n  /* eslint-enable @typescript-eslint/no-shadow */\n  Password = 'password',\n}\n\nexport const InputStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Input),\n    value: optional(string()),\n    name: string(),\n    inputType: optional(\n      union([\n        enumValue(InputType.Text),\n        enumValue(InputType.Password),\n        enumValue(InputType.Number),\n      ]),\n    ),\n    placeholder: optional(string()),\n    label: optional(string()),\n    error: optional(string()),\n  }),\n);\n\n/**\n * An input node, that renders an input.\n *\n * @property type - The type of the node, must be the string 'input'.\n * @property name - The name for the input.\n * @property value - The value of the input.\n * @property inputType - An optional type, either `text`, `password` or `number`.\n * @property placeholder - An optional input placeholder.\n * @property label - An optional input label.\n * @property error - An optional error text.\n */\nexport type Input = Infer<typeof InputStruct>;\n\n/**\n * Create a {@link Input} node.\n *\n * @param args - The node arguments. This can either be a name and an optional variant, value and placeholder or an object\n * with the properties: `inputType`, `value`, `variant`, `placeholder` and `name`.\n * @param args.name - The name for the input.\n * @param args.value - The value of the input.\n * @param args.inputType - An optional type, either `text`, `password` or `number`.\n * @param args.placeholder - An optional input placeholder.\n * @param args.label - An optional input label.\n * @param args.error - An optional error text.\n * @returns The input node as an object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = input('myInput');\n * const node = input('myInput', InputType.Text, 'my placeholder', 'myValue', 'myLabel');\n * const node = input({ name: 'myInput' });\n * const node = input({name: 'myInput', value: 'myValue', inputType: InputType.Password, placeholder: 'placeholder'})\n */\nexport const input = createBuilder(NodeType.Input, InputStruct, [\n  'name',\n  'inputType',\n  'placeholder',\n  'value',\n  'label',\n]);\n","import type { Infer } from 'superstruct';\nimport { assign, literal, object, string, optional, union } from 'superstruct';\n\nimport { enumValue } from '../../internals';\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\nimport { AddressStruct } from './address';\nimport { ImageStruct } from './image';\nimport { TextStruct } from './text';\n\nexport enum RowVariant {\n  Default = 'default',\n  Critical = 'critical',\n  Warning = 'warning',\n}\n\n// A subset of components made available to the row\nconst RowComponentStruct = union([ImageStruct, TextStruct, AddressStruct]);\n\nexport const RowStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Row),\n    variant: optional(\n      union([\n        enumValue(RowVariant.Default),\n        enumValue(RowVariant.Critical),\n        enumValue(RowVariant.Warning),\n      ]),\n    ),\n    label: string(),\n    value: RowComponentStruct,\n  }),\n);\n\n/**\n * A row node, that renders a row with a label and a value.\n *\n * @property type - The type of the node. Must be the string `row`.\n * @property label - The label for the row.\n * @property value - A sub component to be rendered\n * on one side of the row.\n * @property variant - Optional variant for styling.\n */\nexport type Row = Infer<typeof RowStruct>;\n\n/**\n * Create a {@link Row} node.\n *\n * @param args - The node arguments. This can either be a string, a component and an optional variant or an object\n * with the properties: `label`, `value` and `variant`.\n * @param args.label - The label for the row.\n * @param args.value - Another component, is currently limited to `image`, `text` and `address`.\n * @param args.variant - An optional variant, either `default`, `warning` or `critical`.\n * @returns The row node as an object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = row({ label: 'Address', value: address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520') });\n * const node = row({ label: 'Address', value: address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520'), variant: RowVariant.Warning });\n * const node = row('Address', address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520'));\n * const node = row('Address', address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520'), RowVariant.Warning);\n */\nexport const row = createBuilder(NodeType.Row, RowStruct, [\n  'label',\n  'value',\n  'variant',\n]);\n","import type { Infer } from 'superstruct';\nimport {\n  assign,\n  boolean,\n  literal,\n  object,\n  optional,\n  string,\n} from 'superstruct';\n\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\n\nexport const TextStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Text),\n    value: string(),\n    markdown: optional(boolean()),\n  }),\n);\n\n/**\n * A text node, that renders the text as one or more paragraphs.\n *\n * @property type - The type of the node, must be the string 'text'.\n * @property value - The text content of the node, either as plain text, or as a\n * markdown string.\n * @property markdown - A flag to enable/disable markdown, if nothing is specified\n * markdown will be enabled.\n */\nexport type Text = Infer<typeof TextStruct>;\n\n/**\n * Create a {@link Text} node.\n *\n * @param args - The node arguments. This can be either a string\n * and a boolean, or an object with a `value` property\n * and an optional `markdown` property.\n * @param args.value - The text content of the node.\n * @param args.markdown - An optional flag to enable or disable markdown. This\n * is enabled by default.\n * @returns The text node as object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = text({ value: 'Hello, world!' });\n * const node = text('Hello, world!');\n * const node = text({ value: 'Hello, world!', markdown: false });\n * const node = text('Hello, world!', false);\n */\nexport const text = createBuilder(NodeType.Text, TextStruct, [\n  'value',\n  'markdown',\n]);\n","import type { Infer } from 'superstruct';\nimport { assign, literal, object } from 'superstruct';\n\nimport { createBuilder } from '../builder';\nimport { NodeStruct, NodeType } from '../nodes';\n\nexport const SpinnerStruct = assign(\n  NodeStruct,\n  object({\n    type: literal(NodeType.Spinner),\n  }),\n);\n\n/**\n * A spinner node, that renders a spinner, either as a full-screen overlay, or\n * inline when nested inside a {@link Panel}.\n */\nexport type Spinner = Infer<typeof SpinnerStruct>;\n\n/**\n * Create a {@link Spinner} node.\n *\n * @returns The spinner node as object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = spinner();\n */\nexport const spinner = createBuilder(NodeType.Spinner, SpinnerStruct);\n","import { assertStruct } from '@metamask/utils';\nimport { is } from 'superstruct';\n\nimport { ComponentStruct } from './components';\nimport type { Component } from './components';\n\n/**\n * Check if the given value is a {@link Component}. This performs recursive\n * validation of the component's children (if any).\n *\n * @param value - The value to check.\n * @returns `true` if the value is a {@link Component}, `false` otherwise.\n */\nexport function isComponent(value: unknown): value is Component {\n  return is(value, ComponentStruct);\n}\n\n/**\n * Assert that the given value is a {@link Component}. This performs recursive\n * validation of the component's children (if any).\n *\n * @param value - The value to check.\n * @throws If the value is not a {@link Component}.\n */\nexport function assertIsComponent(value: unknown): asserts value is Component {\n  assertStruct(value, ComponentStruct, 'Invalid component');\n}\n","import type { ComponentOrElement } from '..';\nimport type { EnumToUnion } from '../../internals';\nimport type { ChainId } from '../caip';\n\n/**\n * The severity level of content being returned from a transaction insight.\n * Currently only one level is supported:\n *\n * - `critical` - The transaction is critical and should not be submitted by the\n * user.\n */\nexport enum SeverityLevel {\n  Critical = 'critical',\n}\n\n/**\n * An EIP-1559 (type 2) transaction object.\n *\n * @property from - The address the transaction is being sent from.\n * @property to - The address the transaction is being sent to.\n * @property nonce - The nonce of the transaction.\n * @property value - The value of the transaction.\n * @property data - The data of the transaction.\n * @property gas - The gas limit of the transaction.\n * @property maxFeePerGas - The maximum fee per gas of the transaction.\n * @property maxPriorityFeePerGas - The maximum priority fee per gas of the\n * transaction.\n * @property estimateSuggested - The suggested gas price for the transaction.\n * @property estimateUsed - The gas price used for the transaction.\n * @see https://eips.ethereum.org/EIPS/eip-1559\n */\nexport type EIP1559Transaction = {\n  from: string;\n  to: string;\n  nonce: string;\n  value: string;\n  data: string;\n  gas: string;\n  maxFeePerGas: string;\n  maxPriorityFeePerGas: string;\n  estimateSuggested: string;\n  estimateUsed: string;\n};\n\n/**\n * A legacy (type \"0\") transaction object.\n *\n * @property from - The address the transaction is being sent from.\n * @property to - The address the transaction is being sent to.\n * @property nonce - The nonce of the transaction.\n * @property value - The value of the transaction.\n * @property data - The data of the transaction.\n * @property gas - The gas limit of the transaction.\n * @property gasPrice - The gas price of the transaction.\n * @property estimateSuggested - The suggested gas price for the transaction.\n * @property estimateUsed - The gas price used for the transaction.\n */\nexport type LegacyTransaction = {\n  from: string;\n  to: string;\n  nonce: string;\n  value: string;\n  data: string;\n  gas: string;\n  gasPrice: string;\n  estimateSuggested: string;\n  estimateUsed: string;\n};\n\n/**\n * A transaction object. This can be either an EIP-1559 transaction or a legacy\n * transaction.\n *\n * @see EIP1559Transaction\n * @see LegacyTransaction\n */\nexport type Transaction = EIP1559Transaction | LegacyTransaction;\n\n/**\n * The `onTransaction` handler. This is called whenever a transaction is\n * submitted to the snap. It can return insights about the transaction, which\n * will be displayed to the user.\n *\n * Note that using this handler requires the `endowment:transaction-insights`\n * permission.\n *\n * @param args - The request arguments.\n * @param args.transaction - The transaction object, containing the address,\n * value, data, and other properties of the transaction.\n * @param args.chainId - The CAIP-2 {@link ChainId} of the network the\n * transaction is being submitted to.\n * @param args.transactionOrigin - The origin of the transaction. This is the\n * URL of the website that submitted the transaction. This is only available if\n * the Snap has enabled the `allowTransactionOrigin` option in the\n * `endowment:transaction-insight` permission.\n * @returns An object containing insights about the transaction. See\n * {@link OnTransactionResponse}. Can also return `null` if no insights are\n * available.\n */\nexport type OnTransactionHandler = (args: {\n  transaction: Transaction;\n  chainId: ChainId;\n  transactionOrigin?: string;\n}) => Promise<OnTransactionResponse | null>;\n\n/**\n * The response from a Snap's `onTransaction` handler.\n *\n * @property component - A custom UI component, that will be shown in MetaMask.\n * @property id - A Snap interface ID.\n * @property severity - The severity level of the content. Currently only one\n * level is supported: `critical`.\n */\nexport type OnTransactionResponse =\n  | {\n      content: ComponentOrElement;\n      severity?: EnumToUnion<SeverityLevel>;\n    }\n  | {\n      id: string;\n      severity?: EnumToUnion<SeverityLevel>;\n    };\n","import type { Infer } from 'superstruct';\nimport {\n  number,\n  assign,\n  literal,\n  nullable,\n  object,\n  optional,\n  record,\n  string,\n  union,\n  boolean,\n} from 'superstruct';\n\nimport type { InterfaceContext } from '../interface';\n\n/**\n * The type of user input event fired.\n * Currently only three events are supported:\n *\n * - `ButtonClickEvent` - A button has been clicked in the UI.\n * - `FormSubmitEvent` - A Form has been submitted in the UI.\n * - `InputChangeEvent` - The value of an input field has changed in the UI.\n * - `FileUploadEvent` - A file has been uploaded in the UI.\n */\nexport enum UserInputEventType {\n  ButtonClickEvent = 'ButtonClickEvent',\n  FormSubmitEvent = 'FormSubmitEvent',\n  InputChangeEvent = 'InputChangeEvent',\n  FileUploadEvent = 'FileUploadEvent',\n}\n\nexport const GenericEventStruct = object({\n  type: string(),\n  name: optional(string()),\n});\n\nexport const ButtonClickEventStruct = assign(\n  GenericEventStruct,\n  object({\n    type: literal(UserInputEventType.ButtonClickEvent),\n    name: optional(string()),\n  }),\n);\n\n/**\n * A button click event fired in the UI. This is passed to the params of the\n * `onUserInput` handler.\n *\n * @property type - The type of event fired. See {@link UserInputEventType} for\n * the different types. This is always `ButtonClickEvent`.\n * @property name - The optional component name that fired the event.\n */\nexport type ButtonClickEvent = Infer<typeof ButtonClickEventStruct>;\n\nexport const FileStruct = object({\n  name: string(),\n  size: number(),\n  contentType: string(),\n  contents: string(),\n});\n\n/**\n * A file object containing the file name, size, content type, and the base64\n * encoded contents of the file.\n *\n * @property name - The name of the file.\n * @property size - The size of the file in bytes.\n * @property contentType - The content type of the file.\n * @property contents - The base64 encoded contents of the file.\n */\nexport type File = Infer<typeof FileStruct>;\n\nexport const FormSubmitEventStruct = assign(\n  GenericEventStruct,\n  object({\n    type: literal(UserInputEventType.FormSubmitEvent),\n    value: record(string(), nullable(union([string(), FileStruct, boolean()]))),\n    name: string(),\n  }),\n);\n\n/**\n * A form submit event, which is fired when a submit button is clicked.\n *\n * @property type - The type of event fired. This is always `FormSubmitEvent`.\n * @property name - The name of the form that was submitted.\n * @property value - The form values submitted as an object. The keys are the\n * names of the form fields and the values are the values of the form fields. If\n * a form field is empty, the value is `null` or an empty string.\n * @property files - The files uploaded in the form. The keys are the names of\n * the file input fields and the values are the file objects containing the file\n * name, size, content type, and the base64 encoded contents of the file. See\n * {@link File}.\n */\nexport type FormSubmitEvent = Infer<typeof FormSubmitEventStruct>;\n\nexport const InputChangeEventStruct = assign(\n  GenericEventStruct,\n  object({\n    type: literal(UserInputEventType.InputChangeEvent),\n    name: string(),\n    value: union([string(), boolean()]),\n  }),\n);\n\n/**\n * An input change event, which is fired when the value of an input field\n * changes.\n *\n * @property type - The type of event fired. This is always `InputChangeEvent`.\n * @property name - The name of the input field that changed.\n * @property value - The new value of the input field.\n */\nexport type InputChangeEvent = Infer<typeof InputChangeEventStruct>;\n\nexport const FileUploadEventStruct = assign(\n  GenericEventStruct,\n  object({\n    type: literal(UserInputEventType.FileUploadEvent),\n    name: string(),\n    file: nullable(FileStruct),\n  }),\n);\n\n/**\n * A file upload event, which is fired when a file is uploaded.\n *\n * @property type - The type of event fired. This is always `FileUploadEvent`.\n * @property name - The name of the file input field that was used to upload the\n * file.\n * @property file - The file object containing the file name, size,\n * content type, and the base64 encoded contents of the file.\n * @see File\n */\nexport type FileUploadEvent = Infer<typeof FileUploadEventStruct>;\n\nexport const UserInputEventStruct = union([\n  ButtonClickEventStruct,\n  FormSubmitEventStruct,\n  InputChangeEventStruct,\n  FileUploadEventStruct,\n]);\n\n/**\n * A user input event fired in the UI. This is passed to the params of the `onUserInput` handler.\n *\n * @property type - The type of event fired. See {@link UserInputEventType} for the different types.\n * @property name - The component name that fired the event. It is optional for\n * an {@link UserInputEventType.ButtonClickEvent}.\n * @property value - The value associated with the event. Only available when an\n * {@link UserInputEventType.FormSubmitEvent} is fired. It contains the form values submitted.\n */\nexport type UserInputEvent =\n  | ButtonClickEvent\n  | FormSubmitEvent\n  | InputChangeEvent\n  | FileUploadEvent;\n\n/**\n * The `onUserInput` handler. This is called when an user input event is fired in the UI.\n *\n * @param args - The user input event.\n * @param args.id - The user interface id.\n * @param args.event - The {@link UserInputEvent} object, containing the data about the fired event.\n */\nexport type OnUserInputHandler = (args: {\n  id: string;\n  event: UserInputEvent;\n  context: InterfaceContext | null;\n}) => Promise<void>;\n","import type { ComponentOrElement } from '..';\nimport type { EnumToUnion } from '../../internals';\n\n/**\n * The type of dialog to display.\n *\n * - `alert` - A dialog with a single button.\n * - `confirmation` - A dialog with two buttons, one to confirm and one to\n * cancel.\n * - `prompt` - A dialog with two buttons and a text input.\n */\nexport enum DialogType {\n  Alert = 'alert',\n  Confirmation = 'confirmation',\n  Prompt = 'prompt',\n}\n\n/**\n * An alert dialog.\n *\n * @property type - The type of dialog. Must be `alert`.\n * @property content - The content to display in the dialog.\n * @property id - The Snap interface ID.\n */\nexport type AlertDialog =\n  | {\n      type: EnumToUnion<DialogType.Alert>;\n      content: ComponentOrElement;\n    }\n  | {\n      type: EnumToUnion<DialogType.Alert>;\n      id: string;\n    };\n\n/**\n * A confirmation dialog.\n *\n * @property type - The type of dialog. Must be `confirmation`.\n * @property content - The content to display in the dialog.\n * @property id - The Snap interface ID.\n */\nexport type ConfirmationDialog =\n  | {\n      type: EnumToUnion<DialogType.Confirmation>;\n      content: ComponentOrElement;\n    }\n  | {\n      type: EnumToUnion<DialogType.Confirmation>;\n      id: string;\n    };\n\n/**\n * A prompt dialog.\n *\n * @property type - The type of dialog. Must be `prompt`.\n * @property content - The content to display in the dialog.\n * @property id - The Snap interface ID.\n * @property placeholder - An optional placeholder text to display in the text\n * input.\n */\nexport type PromptDialog =\n  | {\n      type: EnumToUnion<DialogType.Prompt>;\n      content: ComponentOrElement;\n      placeholder?: string;\n    }\n  | {\n      type: EnumToUnion<DialogType.Prompt>;\n      id: string;\n      placeholder?: string;\n    };\n\n/**\n * The request parameters for the `snap_dialog` method.\n *\n * @property type - The type of dialog to display.\n * @property content - The content to display in the dialog.\n * @property id - The Snap interface ID.\n * @property placeholder - The placeholder text to display in the dialog. Only\n * applicable for the `prompt` dialog.\n */\nexport type DialogParams = AlertDialog | ConfirmationDialog | PromptDialog;\n\n/**\n * The result returned by the `snap_dialog` method.\n *\n * - If the dialog is an `alert`, the result is `null`.\n * - If the dialog is a `confirmation`, the result is a boolean indicating\n * whether the user confirmed the dialog.\n * - If the dialog is a `prompt`, the result is the value entered by\n * the user.\n */\nexport type DialogResult = null | boolean | string;\n","import type { EnumToUnion } from '../../internals';\n\n/**\n * The encoding to use when retrieving the file. Defaults to `Base64`.\n */\nexport enum AuxiliaryFileEncoding {\n  Base64 = 'base64',\n  Hex = 'hex',\n  Utf8 = 'utf8',\n}\n\n/**\n * The request parameters for the `snap_getFile` method.\n *\n * @property path - The path to the file to retrieve.\n * @property encoding - The encoding to use when retrieving the file.\n */\nexport type GetFileParams = {\n  path: string;\n  encoding?: EnumToUnion<AuxiliaryFileEncoding>;\n};\n\n/**\n * The result returned by the `snap_getFile` method.\n */\nexport type GetFileResult = string;\n","import type { Json } from '@metamask/utils';\n\nimport type { EnumToUnion } from '../../internals';\n\n/**\n * The operations that can be performed on the state.\n */\nexport enum ManageStateOperation {\n  ClearState = 'clear',\n  GetState = 'get',\n  UpdateState = 'update',\n}\n\n/**\n * The clear state operation, which clears the state.\n *\n * @property operation - The operation to perform on the state. Must be `clear`.\n * @property encrypted - Whether to use the separate encrypted state, or the\n * unencrypted state. Defaults to the encrypted state. Encrypted state can only\n * be used if the extension is unlocked, while unencrypted state can be used\n * whether the extension is locked or unlocked.\n */\nexport type ClearStateOperation = {\n  operation: EnumToUnion<ManageStateOperation.ClearState>;\n  encrypted?: boolean;\n};\n\n/**\n * The get state operation, which retrieves the state.\n *\n * @property operation - The operation to perform on the state. Must be `get`.\n * @property encrypted - Whether to use the separate encrypted state, or the\n * unencrypted state. Defaults to the encrypted state. Encrypted state can only\n * be used if the extension is unlocked, while unencrypted state can be used\n * whether the extension is locked or unlocked.\n */\nexport type GetStateOperation = {\n  operation: EnumToUnion<ManageStateOperation.GetState>;\n  encrypted?: boolean;\n};\n\n/**\n * The update state operation, which updates the state.\n *\n * @property operation - The operation to perform on the state. Must be\n * `update`.\n * @property encrypted - Whether to use the separate encrypted state, or the\n * unencrypted state. Defaults to the encrypted state. Encrypted state can only\n * be used if the extension is unlocked, while unencrypted state can be used\n * whether the extension is locked or unlocked.\n * @property newState - The new state to set.\n */\nexport type UpdateStateOperation = {\n  operation: EnumToUnion<ManageStateOperation.UpdateState>;\n  encrypted?: boolean;\n  newState: Record<string, Json>;\n};\n\n/**\n * The request parameters for the `snap_manageState` method.\n *\n * @property operation - The operation to perform on the state.\n * @property encrypted - Whether to use the separate encrypted state, or the\n * unencrypted state. Defaults to the encrypted state.\n * @property newState - The new state to set. Only applicable for the `set`\n * operation.\n */\nexport type ManageStateParams =\n  | ClearStateOperation\n  | GetStateOperation\n  | UpdateStateOperation;\n\n/**\n * The result returned by the `snap_manageState` method.\n *\n * If the operation is `get`, the result is the state. Otherwise, the result is\n * `null`.\n */\nexport type ManageStateResult = Record<string, Json> | null;\n","import type { EnumToUnion } from '../../internals';\n\n/**\n * The types of notifications that can be displayed.\n *\n * - `InApp` - A notification that is displayed in by the MetaMask extension.\n * - `Native` - A notification that is displayed by the operating system.\n */\nexport enum NotificationType {\n  InApp = 'inApp',\n  Native = 'native',\n}\n\n/**\n * The request parameters for the `snap_notify` method.\n *\n * @property type - The type of notification to display.\n * @property message - The message to display in the notification.\n */\nexport type NotifyParams = {\n  type: EnumToUnion<NotificationType>;\n  message: string;\n};\n\n/**\n * The result returned by the `snap_notify` method.\n *\n * This method does not return anything.\n */\nexport type NotifyResult = null;\n","import { JsonStruct } from '@metamask/utils';\nimport type { Infer } from 'superstruct';\nimport { boolean, nullable, record, string, union } from 'superstruct';\n\nimport type { JSXElement } from '../jsx';\nimport { RootJSXElementStruct } from '../jsx';\nimport type { Component } from '../ui';\nimport { ComponentStruct } from '../ui';\nimport { FileStruct } from './handlers';\n\n/**\n * To avoid typing problems with the interface state when manipulating it we\n * have to differentiate the state of a form (that will be contained inside the\n * root state) and the root state since a key in the root stat can contain\n * either the value of an input or a sub-state of a form.\n */\n\nexport const StateStruct = union([FileStruct, string(), boolean()]);\n\nexport const FormStateStruct = record(string(), nullable(StateStruct));\n\nexport const InterfaceStateStruct = record(\n  string(),\n  union([FormStateStruct, nullable(StateStruct)]),\n);\n\nexport type State = Infer<typeof StateStruct>;\nexport type FormState = Infer<typeof FormStateStruct>;\nexport type InterfaceState = Infer<typeof InterfaceStateStruct>;\n\nexport type ComponentOrElement = Component | JSXElement;\nexport const ComponentOrElementStruct = union([\n  ComponentStruct,\n  RootJSXElementStruct,\n]);\n\nexport const InterfaceContextStruct = record(string(), JsonStruct);\nexport type InterfaceContext = Infer<typeof InterfaceContextStruct>;\n","import {\n  hasProperty,\n  HexChecksumAddressStruct,\n  isPlainObject,\n  JsonStruct,\n} from '@metamask/utils';\nimport type { Infer, Struct } from 'superstruct';\nimport {\n  is,\n  boolean,\n  optional,\n  array,\n  lazy,\n  nullable,\n  number,\n  object,\n  record,\n  string,\n  tuple,\n} from 'superstruct';\nimport type {\n  AnyStruct,\n  InferStructTuple,\n  ObjectSchema,\n} from 'superstruct/dist/utils';\n\nimport type { Describe } from '../internals';\nimport { literal, nullUnion, svg } from '../internals';\nimport type { EmptyObject } from '../types';\nimport type {\n  GenericSnapElement,\n  JsonObject,\n  Key,\n  Nestable,\n  SnapElement,\n  SnapsChildren,\n  StringElement,\n} from './component';\nimport type {\n  AddressElement,\n  BoldElement,\n  BoxElement,\n  ButtonElement,\n  CheckboxElement,\n  CopyableElement,\n  DividerElement,\n  DropdownElement,\n  OptionElement,\n  FieldElement,\n  FormElement,\n  HeadingElement,\n  ImageElement,\n  InputElement,\n  ItalicElement,\n  JSXElement,\n  LinkElement,\n  RowElement,\n  SpinnerElement,\n  StandardFormattingElement,\n  TextElement,\n  TooltipElement,\n  ValueElement,\n  FileInputElement,\n} from './components';\n\n/**\n * A struct for the {@link Key} type.\n */\nexport const KeyStruct: Describe<Key> = nullUnion([string(), number()]);\n\n/**\n * A struct for the {@link StringElement} type.\n */\nexport const StringElementStruct: Describe<StringElement> = children([\n  string(),\n]);\n\n/**\n * A struct for the {@link GenericSnapElement} type.\n */\nexport const ElementStruct: Describe<GenericSnapElement> = object({\n  type: string(),\n  props: record(string(), JsonStruct),\n  key: nullable(KeyStruct),\n});\n\n/**\n * A helper function for creating a struct for a {@link Nestable} type.\n *\n * @param struct - The struct for the type to test.\n * @returns The struct for the nestable type.\n */\nfunction nestable<Type, Schema>(\n  struct: Struct<Type, Schema>,\n): Struct<Nestable<Type>, any> {\n  const nestableStruct: Struct<Nestable<Type>> = nullUnion([\n    struct,\n    array(lazy(() => nestableStruct)),\n  ]);\n\n  return nestableStruct;\n}\n\n/**\n * A helper function for creating a struct which allows children of a specific\n * type, as well as `null` and `boolean`.\n *\n * @param structs - The structs to allow as children.\n * @returns The struct for the children.\n */\nfunction children<Head extends AnyStruct, Tail extends AnyStruct[]>(\n  structs: [head: Head, ...tail: Tail],\n): Struct<\n  Nestable<Infer<Head> | InferStructTuple<Tail>[number] | boolean | null>,\n  null\n> {\n  return nestable(nullable(nullUnion([...structs, boolean()])));\n}\n\n/**\n * A helper function for creating a struct for a JSX element.\n *\n * @param name - The name of the element.\n * @param props - The props of the element.\n * @returns The struct for the element.\n */\nfunction element<Name extends string, Props extends ObjectSchema = EmptyObject>(\n  name: Name,\n  props: Props = {} as Props,\n) {\n  return object({\n    type: literal(name) as unknown as Struct<Name, Name>,\n    props: object(props),\n    key: nullable(KeyStruct),\n  });\n}\n\n/**\n * A struct for the {@link ButtonElement} type.\n */\nexport const ButtonStruct: Describe<ButtonElement> = element('Button', {\n  children: StringElementStruct,\n  name: optional(string()),\n  type: optional(nullUnion([literal('button'), literal('submit')])),\n  variant: optional(nullUnion([literal('primary'), literal('destructive')])),\n  disabled: optional(boolean()),\n});\n\n/**\n * A struct for the {@link CheckboxElement} type.\n */\nexport const CheckboxStruct: Describe<CheckboxElement> = element('Checkbox', {\n  name: string(),\n  checked: optional(boolean()),\n  label: optional(string()),\n  variant: optional(nullUnion([literal('default'), literal('toggle')])),\n});\n\n/**\n * A struct for the {@link InputElement} type.\n */\nexport const InputStruct: Describe<InputElement> = element('Input', {\n  name: string(),\n  type: optional(\n    nullUnion([literal('text'), literal('password'), literal('number')]),\n  ),\n  value: optional(string()),\n  placeholder: optional(string()),\n});\n\n/**\n * A struct for the {@link OptionElement} type.\n */\nexport const OptionStruct: Describe<OptionElement> = element('Option', {\n  value: string(),\n  children: string(),\n});\n\n/**\n * A struct for the {@link DropdownElement} type.\n */\nexport const DropdownStruct: Describe<DropdownElement> = element('Dropdown', {\n  name: string(),\n  value: optional(string()),\n  children: children([OptionStruct]),\n});\n\n/**\n * A struct for the {@link FileInputElement} type.\n */\nexport const FileInputStruct: Describe<FileInputElement> = element(\n  'FileInput',\n  {\n    name: string(),\n    accept: nullUnion([optional(array(string()))]),\n    compact: optional(boolean()),\n  },\n);\n\n/**\n * A struct for the {@link FieldElement} type.\n */\nexport const FieldStruct: Describe<FieldElement> = element('Field', {\n  label: optional(string()),\n  error: optional(string()),\n  children: nullUnion([\n    tuple([InputStruct, ButtonStruct]),\n    DropdownStruct,\n    FileInputStruct,\n    InputStruct,\n    CheckboxStruct,\n  ]),\n});\n\n/**\n * A struct for the {@link FormElement} type.\n */\nexport const FormStruct: Describe<FormElement> = element('Form', {\n  children: children(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    [FieldStruct, lazy(() => BoxChildStruct)],\n  ) as unknown as Struct<SnapsChildren<GenericSnapElement>, null>,\n  name: string(),\n});\n\n/**\n * A struct for the {@link BoldElement} type.\n */\nexport const BoldStruct: Describe<BoldElement> = element('Bold', {\n  children: children([\n    string(),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    lazy(() => ItalicStruct) as unknown as Struct<\n      SnapElement<JsonObject, 'Italic'>\n    >,\n  ]),\n});\n\n/**\n * A struct for the {@link ItalicElement} type.\n */\nexport const ItalicStruct: Describe<ItalicElement> = element('Italic', {\n  children: children([\n    string(),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    lazy(() => BoldStruct) as unknown as Struct<\n      SnapElement<JsonObject, 'Bold'>\n    >,\n  ]),\n});\n\nexport const FormattingStruct: Describe<StandardFormattingElement> = nullUnion([\n  BoldStruct,\n  ItalicStruct,\n]);\n\n/**\n * A struct for the {@link AddressElement} type.\n */\nexport const AddressStruct: Describe<AddressElement> = element('Address', {\n  address: HexChecksumAddressStruct,\n});\n\n/**\n * A struct for the {@link BoxElement} type.\n */\nexport const BoxStruct: Describe<BoxElement> = element('Box', {\n  children: children(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    [lazy(() => BoxChildStruct)],\n  ) as unknown as Struct<SnapsChildren<GenericSnapElement>, null>,\n  direction: optional(nullUnion([literal('horizontal'), literal('vertical')])),\n  alignment: optional(\n    nullUnion([\n      literal('start'),\n      literal('center'),\n      literal('end'),\n      literal('space-between'),\n      literal('space-around'),\n    ]),\n  ),\n});\n\n/**\n * A struct for the {@link CopyableElement} type.\n */\nexport const CopyableStruct: Describe<CopyableElement> = element('Copyable', {\n  value: string(),\n  sensitive: optional(boolean()),\n});\n\n/**\n * A struct for the {@link DividerElement} type.\n */\nexport const DividerStruct: Describe<DividerElement> = element('Divider');\n\n/**\n * A struct for the {@link ValueElement} type.\n */\nexport const ValueStruct: Describe<ValueElement> = element('Value', {\n  value: string(),\n  extra: string(),\n});\n\n/**\n * A struct for the {@link HeadingElement} type.\n */\nexport const HeadingStruct: Describe<HeadingElement> = element('Heading', {\n  children: StringElementStruct,\n});\n\n/**\n * A struct for the {@link ImageElement} type.\n */\nexport const ImageStruct: Describe<ImageElement> = element('Image', {\n  src: svg(),\n  alt: optional(string()),\n});\n\n/**\n * A struct for the {@link LinkElement} type.\n */\nexport const LinkStruct: Describe<LinkElement> = element('Link', {\n  href: string(),\n  children: children([FormattingStruct, string()]),\n});\n\n/**\n * A struct for the {@link TextElement} type.\n */\nexport const TextStruct: Describe<TextElement> = element('Text', {\n  children: children([string(), BoldStruct, ItalicStruct, LinkStruct]),\n  alignment: optional(\n    nullUnion([literal('start'), literal('center'), literal('end')]),\n  ),\n});\n\n/**\n * A subset of JSX elements that are allowed as children of the Tooltip component.\n * This set should include all text components and the Image.\n */\nexport const TooltipChildStruct = nullUnion([\n  TextStruct,\n  BoldStruct,\n  ItalicStruct,\n  LinkStruct,\n  ImageStruct,\n  boolean(),\n]);\n\n/**\n * A subset of JSX elements that are allowed as content of the Tooltip component.\n * This set should include all text components.\n */\nexport const TooltipContentStruct = nullUnion([\n  TextStruct,\n  BoldStruct,\n  ItalicStruct,\n  LinkStruct,\n  string(),\n]);\n\n/**\n * A struct for the {@link TooltipElement} type.\n */\nexport const TooltipStruct: Describe<TooltipElement> = element('Tooltip', {\n  children: nullable(TooltipChildStruct),\n  content: TooltipContentStruct,\n});\n\n/**\n * A struct for the {@link RowElement} type.\n */\nexport const RowStruct: Describe<RowElement> = element('Row', {\n  label: string(),\n  children: nullUnion([AddressStruct, ImageStruct, TextStruct, ValueStruct]),\n  variant: optional(\n    nullUnion([literal('default'), literal('warning'), literal('critical')]),\n  ),\n  tooltip: optional(string()),\n});\n\n/**\n * A struct for the {@link SpinnerElement} type.\n */\nexport const SpinnerStruct: Describe<SpinnerElement> = element('Spinner');\n\n/**\n * A subset of JSX elements that are allowed as children of the Box component.\n * This set includes all components, except components that need to be nested in\n * another component (e.g., Field must be contained in a Form).\n */\nexport const BoxChildStruct = nullUnion([\n  AddressStruct,\n  BoldStruct,\n  BoxStruct,\n  ButtonStruct,\n  CopyableStruct,\n  DividerStruct,\n  DropdownStruct,\n  FileInputStruct,\n  FormStruct,\n  HeadingStruct,\n  InputStruct,\n  ImageStruct,\n  ItalicStruct,\n  LinkStruct,\n  RowStruct,\n  SpinnerStruct,\n  TextStruct,\n  TooltipStruct,\n  CheckboxStruct,\n]);\n\n/**\n * For now, the allowed JSX elements at the root are the same as the allowed\n * children of the Box component.\n */\nexport const RootJSXElementStruct = BoxChildStruct;\n\n/**\n * A struct for the {@link JSXElement} type.\n */\nexport const JSXElementStruct: Describe<JSXElement> = nullUnion([\n  ButtonStruct,\n  InputStruct,\n  FileInputStruct,\n  FieldStruct,\n  FormStruct,\n  BoldStruct,\n  ItalicStruct,\n  AddressStruct,\n  BoxStruct,\n  CopyableStruct,\n  DividerStruct,\n  HeadingStruct,\n  ImageStruct,\n  LinkStruct,\n  RowStruct,\n  SpinnerStruct,\n  TextStruct,\n  DropdownStruct,\n  OptionStruct,\n  ValueStruct,\n  TooltipStruct,\n  CheckboxStruct,\n]);\n\n/**\n * Check if a value is a JSX element.\n *\n * @param value - The value to check.\n * @returns True if the value is a JSX element, false otherwise.\n */\nexport function isJSXElement(value: unknown): value is JSXElement {\n  return is(value, JSXElementStruct);\n}\n\n/**\n * Check if a value is a JSX element, without validating all of its contents.\n * This is useful when you want to validate the structure of a value, but not\n * all the children.\n *\n * This should only be used when you are sure that the value is safe to use,\n * i.e., after using {@link isJSXElement}.\n *\n * @param value - The value to check.\n * @returns True if the value is a JSX element, false otherwise.\n */\nexport function isJSXElementUnsafe(value: unknown): value is JSXElement {\n  return (\n    isPlainObject(value) &&\n    hasProperty(value, 'type') &&\n    hasProperty(value, 'props') &&\n    hasProperty(value, 'key')\n  );\n}\n\n/**\n * Assert that a value is a JSX element.\n *\n * @param value - The value to check.\n * @throws If the value is not a JSX element.\n */\nexport function assertJSXElement(value: unknown): asserts value is JSXElement {\n  // TODO: We should use the error parsing utils from `snaps-utils` to improve\n  // the error messages. It currently includes colours and potentially other\n  // formatting that we might not want to include in the SDK.\n  if (!isJSXElement(value)) {\n    throw new Error(\n      `Expected a JSX element, but received ${JSON.stringify(\n        value,\n      )}. Please refer to the documentation for the supported JSX elements and their props.`,\n    );\n  }\n}\n"],"mappings":"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","names":["error","superstructLiteral","superstructUnion","import_superstruct","import_utils","import_utils","import_utils","import_superstruct","import_utils","node","import_superstruct","NodeType","import_superstruct","import_superstruct","import_superstruct","import_superstruct","import_superstruct","import_superstruct","ButtonVariant","ButtonType","import_superstruct","import_superstruct","InputType","import_superstruct","import_superstruct","RowVariant","import_superstruct","import_utils","import_superstruct","SeverityLevel","import_superstruct","UserInputEventType","DialogType","AuxiliaryFileEncoding","ManageStateOperation","NotificationType","import_utils","import_superstruct","import_utils","import_superstruct","ButtonStruct","InputStruct","FormStruct","AddressStruct","CopyableStruct","DividerStruct","HeadingStruct","ImageStruct","TextStruct","RowStruct","SpinnerStruct"]}
\ No newline at end of file
+{
+    "version": 3,
+    "sources": [
+        "../src/index.ts",
+        "../src/errors.ts",
+        "../src/internals/error-wrappers.ts",
+        "../src/internals/errors.ts",
+        "../src/internals/structs.ts",
+        "../src/internals/jsx.ts",
+        "../src/internals/svg.ts",
+        "../src/error-wrappers.ts",
+        "../src/images.ts",
+        "../src/ui/components/address.ts",
+        "../src/ui/builder.ts",
+        "../src/ui/nodes.ts",
+        "../src/ui/components/copyable.ts",
+        "../src/ui/components/divider.ts",
+        "../src/ui/components/heading.ts",
+        "../src/ui/components/image.ts",
+        "../src/ui/components/panel.ts",
+        "../src/ui/components/button.ts",
+        "../src/ui/components/form.ts",
+        "../src/ui/components/input.ts",
+        "../src/ui/components/row.ts",
+        "../src/ui/components/text.ts",
+        "../src/ui/components/spinner.ts",
+        "../src/ui/component.ts",
+        "../src/types/handlers/transaction.ts",
+        "../src/types/handlers/user-input.ts",
+        "../src/types/methods/dialog.ts",
+        "../src/types/methods/get-file.ts",
+        "../src/types/methods/manage-state.ts",
+        "../src/types/methods/notify.ts",
+        "../src/types/interface.ts",
+        "../src/jsx/validation.ts"
+    ],
+    "sourcesContent": [
+        "// Only internals that are used by other Snaps packages should be exported here.\nexport type { EnumToUnion } from './internals';\nexport {\n  getErrorData,\n  getErrorMessage,\n  getErrorStack,\n  SNAP_ERROR_CODE,\n  SNAP_ERROR_MESSAGE,\n  literal,\n  union,\n  enumValue,\n} from './internals';\n\n// Re-exported from `@metamask/utils` for convenience.\nexport type {\n  Json,\n  JsonRpcError,\n  JsonRpcRequest,\n  JsonRpcParams,\n} from '@metamask/utils';\nexport { assert } from '@metamask/utils';\n\nexport * from './errors';\nexport * from './error-wrappers';\nexport * from './images';\nexport * from './types';\nexport * from './ui';\n",
+        "import type { Json, JsonRpcError } from '@metamask/utils';\n\nimport {\n  getErrorCode,\n  getErrorData,\n  getErrorMessage,\n  SNAP_ERROR_CODE,\n  SNAP_ERROR_MESSAGE,\n} from './internals';\n\n/**\n * A generic error which can be thrown by a Snap, without it causing the Snap to\n * crash.\n */\nexport class SnapError extends Error {\n  readonly #code: number;\n\n  readonly #message: string;\n\n  readonly #data?: Record<string, Json>;\n\n  readonly #stack?: string;\n\n  /**\n   * Create a new `SnapError`.\n   *\n   * @param error - The error to create the `SnapError` from. If this is a\n   * `string`, it will be used as the error message. If this is an `Error`, its\n   * `message` property will be used as the error message. If this is a\n   * `JsonRpcError`, its `message` property will be used as the error message\n   * and its `code` property will be used as the error code. Otherwise, the\n   * error will be converted to a string and used as the error message.\n   * @param data - Additional data to include in the error. This will be merged\n   * with the error data, if any.\n   */\n  constructor(\n    error: string | Error | JsonRpcError,\n    data: Record<string, Json> = {},\n  ) {\n    const message = getErrorMessage(error);\n    super(message);\n\n    this.#message = message;\n    this.#code = getErrorCode(error);\n\n    const mergedData = { ...getErrorData(error), ...data };\n    if (Object.keys(mergedData).length > 0) {\n      this.#data = mergedData;\n    }\n\n    this.#stack = super.stack;\n  }\n\n  /**\n   * The error name.\n   *\n   * @returns The error name.\n   */\n  get name() {\n    return 'SnapError';\n  }\n\n  /**\n   * The error code.\n   *\n   * @returns The error code.\n   */\n  get code() {\n    return this.#code;\n  }\n\n  /**\n   * The error message.\n   *\n   * @returns The error message.\n   */\n  // This line is covered, but Jest doesn't pick it up for some reason.\n  /* istanbul ignore next */\n  get message() {\n    return this.#message;\n  }\n\n  /**\n   * Additional data for the error.\n   *\n   * @returns Additional data for the error.\n   */\n  get data() {\n    return this.#data;\n  }\n\n  /**\n   * The error stack.\n   *\n   * @returns The error stack.\n   */\n  // This line is covered, but Jest doesn't pick it up for some reason.\n  /* istanbul ignore next */\n  get stack() {\n    return this.#stack;\n  }\n\n  /**\n   * Convert the error to a JSON object.\n   *\n   * @returns The JSON object.\n   */\n  toJSON(): SerializedSnapError {\n    return {\n      code: SNAP_ERROR_CODE,\n      message: SNAP_ERROR_MESSAGE,\n      data: {\n        cause: {\n          code: this.code,\n          message: this.message,\n          stack: this.stack,\n          ...(this.data ? { data: this.data } : {}),\n        },\n      },\n    };\n  }\n\n  /**\n   * Serialize the error to a JSON object. This is called by\n   * `@metamask/rpc-errors` when serializing the error.\n   *\n   * @returns The JSON object.\n   */\n  serialize() {\n    return this.toJSON();\n  }\n}\n\n/**\n * A serialized {@link SnapError}. It's JSON-serializable, so it can be sent\n * over the RPC. The original error is wrapped in the `cause` property.\n *\n * @property code - The error code. This is always `-31002`.\n * @property message - The error message. This is always `'Snap Error'`.\n * @property data - The error data.\n * @property data.cause - The cause of the error.\n * @property data.cause.code - The error code.\n * @property data.cause.message - The error message.\n * @property data.cause.stack - The error stack.\n * @property data.cause.data - Additional data for the error.\n * @see SnapError\n */\nexport type SerializedSnapError = {\n  code: typeof SNAP_ERROR_CODE;\n  message: typeof SNAP_ERROR_MESSAGE;\n  data: {\n    cause: JsonRpcError;\n  };\n};\n",
+        "import type { rpcErrors } from '@metamask/rpc-errors';\nimport type { Json } from '@metamask/utils';\n\nimport { SnapError } from '../errors';\n\nexport type JsonRpcErrorFunction = typeof rpcErrors.parse;\n\n/**\n * Create a `SnapError` class from an error function from\n * `@metamask/rpc-errors`. This is useful for creating custom error classes\n * which can be thrown by a Snap.\n *\n * The created class will inherit the message, code, and data properties from\n * the error function.\n *\n * @param fn - The error function to create the class from.\n * @returns The created `SnapError` class.\n */\nexport function createSnapError(fn: JsonRpcErrorFunction) {\n  return class SnapJsonRpcError extends SnapError {\n    /**\n     * Create a new `SnapJsonRpcError` from a message.\n     *\n     * @param message - The message to create the error from.\n     */\n    constructor(message?: string);\n\n    /**\n     * Create a new `SnapJsonRpcError` from data.\n     *\n     * @param data - The data to create the error from.\n     */\n    constructor(data?: Record<string, Json>);\n\n    /**\n     * Create a new `SnapJsonRpcError` from a message and data.\n     *\n     * @param message - The message to create the error from.\n     * @param data - The data to create the error from.\n     */\n    constructor(\n      message?: string | Record<string, Json>,\n      data?: Record<string, Json>,\n    );\n\n    /**\n     * Create a new `SnapJsonRpcError` from a message and data.\n     *\n     * @param message - The message to create the error from.\n     * @param data - The data to create the error from.\n     */\n    constructor(\n      message?: string | Record<string, Json>,\n      data?: Record<string, Json>,\n    ) {\n      if (typeof message === 'object') {\n        const error = fn();\n        super({\n          code: error.code,\n          message: error.message,\n          data: message,\n        });\n\n        return;\n      }\n\n      const error = fn(message);\n      super({\n        code: error.code,\n        message: error.message,\n        data,\n      });\n    }\n  };\n}\n",
+        "import { hasProperty, isObject, isValidJson } from '@metamask/utils';\n\nexport const SNAP_ERROR_CODE = -31002;\nexport const SNAP_ERROR_MESSAGE = 'Snap Error';\n\n/**\n * Get the error message from an unknown error type.\n *\n * - If the error is an object with a `message` property, return the message.\n * - Otherwise, return the error converted to a string.\n *\n * @param error - The error to get the message from.\n * @returns The error message.\n * @internal\n */\nexport function getErrorMessage(error: unknown) {\n  if (\n    isObject(error) &&\n    hasProperty(error, 'message') &&\n    typeof error.message === 'string'\n  ) {\n    return error.message;\n  }\n\n  return String(error);\n}\n\n/**\n * Get the error stack from an unknown error type.\n *\n * @param error - The error to get the stack from.\n * @returns The error stack, or undefined if the error does not have a valid\n * stack.\n * @internal\n */\nexport function getErrorStack(error: unknown) {\n  if (\n    isObject(error) &&\n    hasProperty(error, 'stack') &&\n    typeof error.stack === 'string'\n  ) {\n    return error.stack;\n  }\n\n  return undefined;\n}\n\n/**\n * Get the error code from an unknown error type.\n *\n * @param error - The error to get the code from.\n * @returns The error code, or `-32603` if the error does not have a valid code.\n * @internal\n */\nexport function getErrorCode(error: unknown) {\n  if (\n    isObject(error) &&\n    hasProperty(error, 'code') &&\n    typeof error.code === 'number' &&\n    Number.isInteger(error.code)\n  ) {\n    return error.code;\n  }\n\n  return -32603;\n}\n\n/**\n * Get the error data from an unknown error type.\n *\n * @param error - The error to get the data from.\n * @returns The error data, or an empty object if the error does not have valid\n * data.\n * @internal\n */\nexport function getErrorData(error: unknown) {\n  if (\n    isObject(error) &&\n    hasProperty(error, 'data') &&\n    typeof error.data === 'object' &&\n    error.data !== null &&\n    isValidJson(error.data) &&\n    !Array.isArray(error.data)\n  ) {\n    return error.data;\n  }\n\n  return {};\n}\n",
+        "import type { Infer } from '@metamask/superstruct';\nimport {\n  Struct,\n  define,\n  literal as superstructLiteral,\n  union as superstructUnion,\n} from '@metamask/superstruct';\nimport type { AnyStruct, InferStructTuple } from '@metamask/superstruct';\n\nimport type { EnumToUnion } from './helpers';\n\n/**\n * A wrapper of `superstruct`'s `literal` struct that also defines the name of\n * the struct as the literal value.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n * For example, instead of returning an error like:\n *\n * ```\n * Expected the value to satisfy a union of `literal | literal`, but received: \\\"baz\\\"\n * ```\n *\n * This struct will return an error like:\n *\n * ```\n * Expected the value to satisfy a union of `\"foo\" | \"bar\"`, but received: \\\"baz\\\"\n * ```\n *\n * @param value - The literal value.\n * @returns The `superstruct` struct, which validates that the value is equal\n * to the literal value.\n */\nexport function literal<Type extends string | number | boolean>(value: Type) {\n  return define<Type>(\n    JSON.stringify(value),\n    superstructLiteral(value).validator,\n  );\n}\n\n/**\n * A wrapper of `superstruct`'s `union` struct that also defines the schema as\n * the union of the schemas of the structs.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n *\n * @param structs - The structs to union.\n * @param structs.\"0\" - The first struct.\n * @param structs.\"1\" - The remaining structs.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function union<Head extends AnyStruct, Tail extends AnyStruct[]>([\n  head,\n  ...tail\n]: [head: Head, ...tail: Tail]): Struct<\n  Infer<Head> | InferStructTuple<Tail>[number],\n  [head: Head, ...tail: Tail]\n> {\n  const struct = superstructUnion([head, ...tail]);\n\n  return new Struct({\n    ...struct,\n    schema: [head, ...tail],\n  });\n}\n\n/**\n * Superstruct struct for validating an enum value. This allows using both the\n * enum string values and the enum itself as values.\n *\n * @param constant - The enum to validate against.\n * @returns The superstruct struct.\n */\nexport function enumValue<Type extends string>(\n  constant: Type,\n): Struct<EnumToUnion<Type>, null> {\n  return literal(constant as EnumToUnion<Type>);\n}\n",
+        "import type { Infer, Struct } from '@metamask/superstruct';\nimport type {\n  AnyStruct,\n  EnumSchema,\n  InferStructTuple,\n  IsExactMatch,\n  IsMatch,\n  IsRecord,\n  IsTuple,\n  UnionToIntersection,\n} from '@metamask/superstruct';\n\nimport type { EmptyObject } from '../types';\nimport { union } from './structs';\n\n/**\n * Check if a type is a union. Infers `true` if it is a union, otherwise\n * `false`.\n */\ntype IsUnion<Type> = [Type] extends [UnionToIntersection<Type>] ? false : true;\n\n/**\n * Get a struct schema for a type.\n *\n * This is copied from `superstruct` but fixes some issues with the original\n * implementation.\n */\ntype StructSchema<Type> = IsUnion<Type> extends true\n  ? null\n  : [Type] extends [EmptyObject]\n  ? EmptyObject\n  : [Type] extends [string | undefined | null]\n  ? [Type] extends [`0x${string}`]\n    ? null\n    : [Type] extends [IsMatch<Type, string | undefined | null>]\n    ? null\n    : [Type] extends [IsUnion<Type>]\n    ? EnumSchema<Type>\n    : Type\n  : [Type] extends [number | undefined | null]\n  ? [Type] extends [IsMatch<Type, number | undefined | null>]\n    ? null\n    : [Type] extends [IsUnion<Type>]\n    ? EnumSchema<Type>\n    : Type\n  : [Type] extends [boolean]\n  ? [Type] extends [IsExactMatch<Type, boolean>]\n    ? null\n    : Type\n  : Type extends\n      | bigint\n      | symbol\n      | undefined\n      | null\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      | Function\n      | Date\n      | Error\n      | RegExp\n      | Map<any, any>\n      | WeakMap<any, any>\n      | Set<any>\n      | WeakSet<any>\n      | Promise<any>\n  ? null\n  : Type extends (infer E)[]\n  ? Type extends IsTuple<Type>\n    ? null\n    : Struct<E>\n  : Type extends object\n  ? Type extends IsRecord<Type>\n    ? null\n    : {\n        [InnerKey in keyof Type]: Describe<Type[InnerKey]>;\n      }\n  : null;\n\n/**\n * Describe a struct type.\n */\nexport type Describe<Type> = Struct<Type, StructSchema<Type>>;\n\n/**\n * Create a union struct that uses `null` for the schema type, for better\n * compatibility with `Describe`.\n *\n * @param structs - The structs to union.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function nullUnion<Head extends AnyStruct, Tail extends AnyStruct[]>(\n  structs: [head: Head, ...tail: Tail],\n): Struct<Infer<Head> | InferStructTuple<Tail>[number], null> {\n  return union(structs) as unknown as Struct<\n    Infer<Head> | InferStructTuple<Tail>[number],\n    null\n  >;\n}\n",
+        "import { refine, string } from '@metamask/superstruct';\n\n/**\n * Get a Struct that validates a string as a valid SVG.\n *\n * @returns A Struct that validates a string as a valid SVG.\n * @internal\n */\nexport function svg() {\n  return refine(string(), 'SVG', (value) => {\n    // This validation is intentionally very basic, we don't need to be that strict\n    // and merely have this extra validation as a helpful error if devs aren't\n    // passing in SVGs.\n    if (!value.includes('<svg')) {\n      return 'Value is not a valid SVG.';\n    }\n\n    return true;\n  });\n}\n",
+        "import { providerErrors, rpcErrors } from '@metamask/rpc-errors';\n\nimport { createSnapError } from './internals';\n\n/**\n * A JSON-RPC 2.0 Internal (-32603) error.\n *\n * This can be thrown by a Snap to indicate that an internal error occurred,\n * without crashing the Snap.\n *\n * @see https://www.jsonrpc.org/specification#error_object\n */\nexport const InternalError = createSnapError(rpcErrors.internal);\n\n/**\n * An Ethereum JSON-RPC Invalid Input (-32000) error.\n *\n * This can be thrown by a Snap to indicate that the input to a method is\n * invalid, without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport const InvalidInputError = createSnapError(rpcErrors.invalidInput);\n\n/**\n * A JSON-RPC 2.0 Invalid Params (-32602) error.\n *\n * This can be thrown by a Snap to indicate that the parameters to a method are\n * invalid, without crashing the Snap.\n *\n * @see https://www.jsonrpc.org/specification#error_object\n */\nexport const InvalidParamsError = createSnapError(rpcErrors.invalidParams);\n\n/**\n * A JSON-RPC 2.0 Invalid Request (-32600) error.\n *\n * This can be thrown by a Snap to indicate that the request is invalid, without\n * crashing the Snap.\n *\n * @see https://www.jsonrpc.org/specification#error_object\n */\nexport const InvalidRequestError = createSnapError(rpcErrors.invalidRequest);\n\n/**\n * An Ethereum JSON-RPC Limit Exceeded (-32005) error.\n *\n * This can be thrown by a Snap to indicate that a limit has been exceeded,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport const LimitExceededError = createSnapError(rpcErrors.limitExceeded);\n\n/**\n * An Ethereum JSON-RPC Method Not Found (-32601) error.\n *\n * This can be thrown by a Snap to indicate that a method does not exist,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport const MethodNotFoundError = createSnapError(rpcErrors.methodNotFound);\n\n/**\n * An Ethereum JSON-RPC Method Not Supported (-32004) error.\n *\n * This can be thrown by a Snap to indicate that a method is not supported,\n * without crashing the Snap.\n */\nexport const MethodNotSupportedError = createSnapError(\n  rpcErrors.methodNotSupported,\n);\n\n/**\n * A JSON-RPC 2.0 Parse (-32700) error.\n *\n * This can be thrown by a Snap to indicate that a request is not valid JSON,\n * without crashing the Snap.\n *\n * @see https://www.jsonrpc.org/specification#error_object\n */\nexport const ParseError = createSnapError(rpcErrors.parse);\n\n/**\n * An Ethereum JSON-RPC Resource Not Found (-32001) error.\n *\n * This can be thrown by a Snap to indicate that a resource does not exist,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport const ResourceNotFoundError = createSnapError(\n  rpcErrors.resourceNotFound,\n);\n\n/**\n * An Ethereum JSON-RPC Resource Unavailable (-32002) error.\n *\n * This can be thrown by a Snap to indicate that a resource is unavailable,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport const ResourceUnavailableError = createSnapError(\n  rpcErrors.resourceUnavailable,\n);\n\n/**\n * An Ethereum JSON-RPC Transaction Rejected (-32003) error.\n *\n * This can be thrown by a Snap to indicate that a transaction was rejected,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport const TransactionRejected = createSnapError(\n  rpcErrors.transactionRejected,\n);\n\n/**\n * An Ethereum Provider Chain Disconnected (4901) error.\n *\n * This can be thrown by a Snap to indicate that the provider is disconnected\n * from the requested chain, without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport const ChainDisconnectedError = createSnapError(\n  providerErrors.chainDisconnected,\n);\n\n/**\n * An Ethereum Provider Disconnected (4900) error.\n *\n * This can be thrown by a Snap to indicate that the provider is disconnected,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport const DisconnectedError = createSnapError(providerErrors.disconnected);\n\n/**\n * An Ethereum Provider Unauthorized (4100) error.\n *\n * This can be thrown by a Snap to indicate that the requested method / account\n * is not authorized by the user, without crashing the Snap.\n */\nexport const UnauthorizedError = createSnapError(providerErrors.unauthorized);\n\n/**\n * An Ethereum Provider Unsupported Method (4200) error.\n *\n * This can be thrown by a Snap to indicate that the requested method is not\n * supported by the provider, without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport const UnsupportedMethodError = createSnapError(\n  providerErrors.unsupportedMethod,\n);\n\n/**\n * An Ethereum Provider User Rejected Request (4001) error.\n *\n * This can be thrown by a Snap to indicate that the user rejected the request,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport const UserRejectedRequestError = createSnapError(\n  providerErrors.userRejectedRequest,\n);\n",
+        "import { assert, bytesToBase64 } from '@metamask/utils';\n\nimport { image } from './ui';\n\n/**\n * Get raw image data from a URL.\n *\n * @param url - The URL to get the image data from.\n * @param options - The options to use when fetching the image data. This is\n * passed directly to `fetch`.\n * @returns A promise that resolves to the image data as a blob.\n */\nasync function getRawImageData(url: string, options?: RequestInit) {\n  if (typeof fetch !== 'function') {\n    throw new Error(\n      `Failed to fetch image data from \"${url}\": Using this function requires the \"endowment:network-access\" permission.`,\n    );\n  }\n\n  return fetch(url, options).then(async (response) => {\n    if (!response.ok) {\n      throw new Error(\n        `Failed to fetch image data from \"${url}\": ${response.status} ${response.statusText}`,\n      );\n    }\n\n    const blob = await response.blob();\n    assert(\n      blob.type === 'image/jpeg' || blob.type === 'image/png',\n      'Expected image data to be a JPEG or PNG image.',\n    );\n\n    return blob;\n  });\n}\n\n/**\n * Get image data as data-string from a URL. This is useful for embedding images\n * inside of SVGs. Only JPEG and PNG images are supported.\n *\n * Note: This function uses `fetch` to get the image data. This means that using\n * it requires the `endowment:network-access` permission.\n *\n * @example\n * const imageData = await getImageData('https://cataas.com/cat');\n * const svg = `\n *   <svg width=\"100\" height=\"100\" xmlns=\"http://www.w3.org/2000/svg\">\n *     <image href=\"${imageData}\" />\n *   </svg>\n * `;\n *\n * // Render the SVG in a Snap UI.\n * const ui = image(svg);\n * @param url - The URL to get the image data from.\n * @param options - The options to use when fetching the image data. This is\n * passed directly to `fetch`.\n * @returns A promise that resolves to the image data as a data-string.\n */\nexport async function getImageData(url: string, options?: RequestInit) {\n  const blob = await getRawImageData(url, options);\n  const bytes = new Uint8Array(await blob.arrayBuffer());\n\n  return `data:${blob.type};base64,${bytesToBase64(bytes)}`;\n}\n\n/**\n * Options for getting an SVG image element from a URL.\n *\n * @property width - The width of the image.\n * @property height - The height of the image. If this is not provided, the\n * width will be used as the height.\n * @property request - The options to use when fetching the image data. This is\n * passed directly to `fetch`.\n */\nexport type ImageOptions = {\n  width: number;\n  height?: number;\n  request?: RequestInit;\n};\n\n/**\n * Get an image component from a URL. This is useful for embedding images inside\n * Snap UIs. Only JPEG and PNG images are supported.\n *\n * Note: This function uses `fetch` to get the image data. This means that using\n * it requires the `endowment:network-access` permission.\n *\n * @example\n * const component = await getImage('https://cataas.com/cat');\n *\n * return await snap.request({\n *   method: 'snap_dialog',\n *   params: {\n *     type: 'alert',\n *     content: panel([\n *       component,\n *     ]),\n *   },\n * });\n * @param url - The URL to get the image data from.\n * @param options - The options to use when fetching and rendering the image.\n * @param options.width - The width of the image.\n * @param options.height - The height of the image. If this is not provided, the\n * width will be used as the height.\n * @param options.request - The options to use when fetching the image data.\n * This is passed directly to `fetch`.\n * @returns A promise that resolves to the image data as an image component.\n */\nexport async function getImageComponent(\n  url: string,\n  { width, height = width, request }: ImageOptions,\n) {\n  assert(\n    typeof width === 'number' && width > 0,\n    'Expected width to be a number greater than 0.',\n  );\n\n  assert(\n    typeof height === 'number' && height > 0,\n    'Expected height to be a number greater than 0.',\n  );\n\n  const imageData = await getImageData(url, request);\n  const size = `width=\"${width}\" height=\"${height}\"`;\n\n  return image(\n    `<svg ${size.trim()} xmlns=\"http://www.w3.org/2000/svg\"><image ${size.trim()} href=\"${imageData}\" /></svg>`,\n  );\n}\n",
+        "import { HexChecksumAddressStruct } from '@metamask/utils';\nimport type { Infer } from '@metamask/superstruct';\nimport { assign, literal, object } from '@metamask/superstruct';\n\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\n\nexport const AddressStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Address),\n    value: HexChecksumAddressStruct,\n  }),\n);\n\n/**\n * A address node, that renders an EVM-like address and its icon.\n *\n * @property type - The type of the node. Must be the string `address`.\n * @property value - The address in hexadecimal, including 0x.\n */\nexport type Address = Infer<typeof AddressStruct>;\n\n/**\n * Create an {@link Address} node.\n *\n * @param args - The node arguments. This can either be a string, or an object\n * with the `value` property.\n * @param args.value - The address to be rendered.\n * @returns The address node as an object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = address({ value: '0x4bbeeb066ed09b7aed07bf39eee0460dfa261520' });\n * const node = address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520');\n */\nexport const address = createBuilder(NodeType.Address, AddressStruct, [\n  'value',\n]);\n",
+        "import { assertStruct, isPlainObject } from '@metamask/utils';\nimport type { Struct } from '@metamask/superstruct';\n\nimport type { Component } from './components';\nimport type { NodeType } from './nodes';\n\n/**\n * A function that builds a {@link Component}. This infers the proper args type\n * from the given node.\n *\n * @internal\n */\ntype NodeBuilder<Node extends Component, Keys extends (keyof Node)[]> = Omit<\n  Node,\n  'type'\n> extends Record<string, never>\n  ? (...args: []) => Node\n  : (...args: [Omit<Node, 'type'>] | NodeArrayType<Node, Keys>) => Node;\n\n/**\n * Map from an array of node keys to the corresponding array type.\n *\n * @example\n * type Node = { type: 'node'; a: string; b: number; c: boolean };\n * type Keys = ['a', 'b', 'c'];\n *\n * type NodeArray = NodeArrayType<Node, Keys>; // [string, number, boolean]\n * @internal\n */\ntype NodeArrayType<Node extends Component, Keys extends (keyof Node)[]> = {\n  [Key in keyof Keys]: Node[Keys[Key]];\n};\n\n/**\n * A function that returns a function to \"build\" a {@link Component}. It infers\n * the type of the component from the given struct, and performs validation on\n * the created component.\n *\n * The returned function can handle the node arguments in two ways:\n * 1. As a single object, with the keys corresponding to the node's properties,\n * excluding the `type` property.\n * 2. As an array of arguments, with the order corresponding to the given keys.\n *\n * @param type - The type of the component to build.\n * @param struct - The struct to use to validate the component.\n * @param keys - The keys of the component to use as arguments to the builder.\n * The order of the keys determines the order of the arguments.\n * @returns A function that builds a component of the given type.\n * @internal\n */\nexport function createBuilder<\n  Node extends Component,\n  Keys extends (keyof Node)[] = [],\n>(\n  type: NodeType,\n  struct: Struct<Node>,\n  keys: Keys = [] as unknown as Keys,\n): NodeBuilder<Node, Keys> {\n  return (...args: [Omit<Node, 'type'>] | NodeArrayType<Node, Keys> | []) => {\n    // Node passed as a single object.\n    if (args.length === 1 && isPlainObject(args[0])) {\n      const node = { ...args[0], type };\n\n      // The user could be passing invalid values to the builder, so we need to\n      // validate them as per the component's struct.\n      assertStruct(node, struct, `Invalid ${type} component`);\n      return node;\n    }\n\n    // Node passed as an array of arguments.\n    const node = keys.reduce<Partial<Component>>(\n      (partialNode, key, index) => {\n        if (args[index] !== undefined) {\n          return {\n            ...partialNode,\n            [key]: args[index],\n          };\n        }\n\n        return partialNode;\n      },\n      { type },\n    );\n\n    // The user could be passing invalid values to the builder, so we need to\n    // validate them as per the component's struct.\n    assertStruct(node, struct, `Invalid ${type} component`);\n    return node;\n  };\n}\n",
+        "import type { Infer } from '@metamask/superstruct';\nimport { assign, object, string, unknown } from '@metamask/superstruct';\n\n/**\n * The supported node types. This is based on SIP-7.\n *\n * @see https://metamask.github.io/SIPs/SIPS/sip-7\n */\nexport enum NodeType {\n  Copyable = 'copyable',\n  Divider = 'divider',\n  Heading = 'heading',\n  Panel = 'panel',\n  Spinner = 'spinner',\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  Text = 'text',\n  Image = 'image',\n  Row = 'row',\n  Address = 'address',\n  Button = 'button',\n  Input = 'input',\n  Form = 'form',\n}\n\n/**\n * @internal\n */\nexport const NodeStruct = object({\n  type: string(),\n});\n\n/**\n * The base node type. All nodes extend this type.\n *\n * @property type - The type of the node. See {@link NodeType} for the supported\n * node types.\n * @internal\n */\nexport type Node = Infer<typeof NodeStruct>;\n\n/**\n * @internal\n */\nexport const LiteralStruct = assign(\n  NodeStruct,\n  object({\n    value: unknown(),\n  }),\n);\n\n/**\n * A node with a value. This is used for nodes that render a value, such as\n * {@link Text}.\n *\n * @property type - The type of the node.\n * @property value - The value of the node. The type of the value depends on the\n * node type.\n * @internal\n */\nexport type Literal = Infer<typeof LiteralStruct>;\n",
+        "import type { Infer } from '@metamask/superstruct';\nimport {\n  assign,\n  boolean,\n  literal,\n  object,\n  optional,\n  string,\n} from '@metamask/superstruct';\n\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\n\nexport const CopyableStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Copyable),\n    value: string(),\n    sensitive: optional(boolean()),\n  }),\n);\n\n/**\n * Text that can be copied to the clipboard. It can optionally be marked as\n * sensitive, in which case it will only be displayed to the user after clicking\n * on the component.\n *\n * @property type - The type of the node. Must be the string `copyable`.\n * @property value - The text to be copied.\n * @property sensitive - Whether the value is sensitive or not. Sensitive values\n * are only displayed to the user after clicking on the component. Defaults to\n * false.\n */\nexport type Copyable = Infer<typeof CopyableStruct>;\n\n/**\n * Create a {@link Copyable} component.\n *\n * @param args - The node arguments. This can either be a string, or an object\n * with the `text` property.\n * @param args.value - The text to be copied.\n * @param args.sensitive - Whether the value is sensitive or not. Sensitive\n * values are only displayed to the user after clicking on the component.\n * Defaults to false.\n * @returns A {@link Copyable} component.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = copyable('Hello, world!');\n * const node = copyable({ value: 'Hello, world!' });\n */\nexport const copyable = createBuilder(NodeType.Copyable, CopyableStruct, [\n  'value',\n  'sensitive',\n]);\n",
+        "import type { Infer } from '@metamask/superstruct';\nimport { assign, literal, object } from '@metamask/superstruct';\n\nimport { createBuilder } from '../builder';\nimport { NodeStruct, NodeType } from '../nodes';\n\nexport const DividerStruct = assign(\n  NodeStruct,\n  object({\n    type: literal(NodeType.Divider),\n  }),\n);\n\n/**\n * A divider node, that renders a line between other nodes.\n */\nexport type Divider = Infer<typeof DividerStruct>;\n\n/**\n * Create a {@link Divider} node.\n *\n * @returns The divider node as object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = divider();\n */\nexport const divider = createBuilder(NodeType.Divider, DividerStruct);\n",
+        "import type { Infer } from '@metamask/superstruct';\nimport { assign, literal, object, string } from '@metamask/superstruct';\n\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\n\nexport const HeadingStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Heading),\n    value: string(),\n  }),\n);\n\n/**\n * A heading node, that renders the text as a heading. The level of the heading\n * is determined by the depth of the heading in the document.\n *\n * @property type - The type of the node, must be the string 'text'.\n * @property value - The text content of the node, either as plain text, or as a\n * markdown string.\n */\nexport type Heading = Infer<typeof HeadingStruct>;\n\n/**\n * Create a {@link Heading} node.\n *\n * @param args - The node arguments. This can either be a string, or an object\n * with the `value` property.\n * @param args.value - The heading text.\n * @returns The heading node as object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = heading({ value: 'Hello, world!' });\n * const node = heading('Hello, world!');\n */\nexport const heading = createBuilder(NodeType.Heading, HeadingStruct, [\n  'value',\n]);\n",
+        "import type { Infer } from '@metamask/superstruct';\nimport { assign, literal, object } from '@metamask/superstruct';\n\nimport { svg } from '../../internals';\nimport { createBuilder } from '../builder';\nimport { NodeStruct, NodeType } from '../nodes';\n\nexport const ImageStruct = assign(\n  NodeStruct,\n  object({\n    type: literal(NodeType.Image),\n    value: svg(),\n  }),\n);\n\n/**\n * An image node, that renders an SVG image.\n *\n * @property type - The type of the node. Must be the string `image`.\n * @property value - The SVG image to be rendered.\n */\nexport type Image = Infer<typeof ImageStruct>;\n\n/**\n * Create an {@link Image} node.\n *\n * @param args - The node arguments. This can either be a string, or an object\n * with the `value` property.\n * @param args.value - The SVG image to be rendered. Must be a valid SVG string.\n * @returns The image node as object. Other image formats are supported by\n * embedding them as data URLs in the SVG.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = image({ value: '<svg />' });\n * const node = image('<svg />');\n */\nexport const image = createBuilder(NodeType.Image, ImageStruct, ['value']);\n",
+        "import type { Infer, Struct } from '@metamask/superstruct';\nimport { array, assign, lazy, literal, object, union } from '@metamask/superstruct';\n\nimport { createBuilder } from '../builder';\nimport { NodeStruct, NodeType } from '../nodes';\nimport { AddressStruct } from './address';\nimport { ButtonStruct } from './button';\nimport { CopyableStruct } from './copyable';\nimport { DividerStruct } from './divider';\nimport { FormStruct } from './form';\nimport { HeadingStruct } from './heading';\nimport { ImageStruct } from './image';\nimport { InputStruct } from './input';\nimport { RowStruct } from './row';\nimport { SpinnerStruct } from './spinner';\nimport { TextStruct } from './text';\n\n/**\n * @internal\n */\nexport const ParentStruct = assign(\n  NodeStruct,\n  object({\n    // This node references itself indirectly, so we need to use `lazy()`.\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    children: array(lazy(() => ComponentStruct)),\n  }),\n);\n\n/**\n * A node which supports child nodes. This is used for nodes that render their\n * children, such as {@link Panel}.\n *\n * @property type - The type of the node.\n * @property children - The children of the node\n * @internal\n */\nexport type Parent = Infer<typeof ParentStruct>;\n\n/**\n * @internal\n */\nexport const PanelStruct: Struct<Panel> = assign(\n  ParentStruct,\n  object({\n    type: literal(NodeType.Panel),\n  }),\n);\n\n/**\n * A panel node, which renders its children.\n *\n * @property type - The type of the node, must be the string 'text'.\n * @property value - The text content of the node, either as plain text, or as a\n * markdown string.\n */\n// This node references itself indirectly, so it cannot be inferred.\nexport type Panel = {\n  type: NodeType.Panel;\n  children: Component[];\n};\n\n/**\n * Create a {@link Panel} node.\n *\n * @param args - The node arguments. This can be either an array of children, or\n * an object with a `children` property.\n * @param args.children - The child nodes of the panel. This can be any valid\n * {@link Component}.\n * @returns The panel node as object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = panel({\n *  children: [\n *    heading({ text: 'Hello, world!' }),\n *    text({ text: 'This is a panel.' }),\n *  ],\n * });\n *\n * const node = panel([\n *   heading('Hello, world!'),\n *   text('This is a panel.'),\n * ]);\n */\nexport const panel = createBuilder(NodeType.Panel, PanelStruct, ['children']);\n\n// This is defined separately from `Component` to avoid circular dependencies.\nexport const ComponentStruct = union([\n  CopyableStruct,\n  DividerStruct,\n  HeadingStruct,\n  ImageStruct,\n  PanelStruct,\n  SpinnerStruct,\n  TextStruct,\n  RowStruct,\n  AddressStruct,\n  InputStruct,\n  FormStruct,\n  ButtonStruct,\n]);\n\n/**\n * All supported component types.\n */\nexport type Component = Infer<typeof ComponentStruct>;\n",
+        "import type { Infer } from '@metamask/superstruct';\nimport { assign, literal, object, optional, string, union } from '@metamask/superstruct';\n\nimport { enumValue } from '../../internals';\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\n\nexport enum ButtonVariant {\n  Primary = 'primary',\n  Secondary = 'secondary',\n}\n\nexport enum ButtonType {\n  Button = 'button',\n  Submit = 'submit',\n}\n\nexport const ButtonStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Button),\n    value: string(),\n    variant: optional(\n      union([\n        enumValue(ButtonVariant.Primary),\n        enumValue(ButtonVariant.Secondary),\n      ]),\n    ),\n    buttonType: optional(\n      union([enumValue(ButtonType.Button), enumValue(ButtonType.Submit)]),\n    ),\n    name: optional(string()),\n  }),\n);\n\n/**\n * A button node, that renders either a primary or a secondary button.\n *\n * @property type - The type of the node, must be the string 'button'.\n * @property variant - The style variant of the node, must be either 'primary' or 'secondary'.\n * @property value - The text content of the node as plain text.\n * @property buttonType - The type of the button, must be either 'button' or 'submit'.\n * @property name - An optional name to identify the button.\n */\nexport type Button = Infer<typeof ButtonStruct>;\n\n/**\n * Create a {@link Button} node.\n *\n * @param args - The node arguments. This can be either a string, or an object\n * with a `value` property. A set of optional properties can be passed.\n * @param args.variant - The optional variant of the button.\n * @param args.value - The text content of the node.\n * @param args.name - The optional name of the button.\n * @returns The text node as object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * ```typescript\n * const node = button({  variant: 'primary', text: 'Hello, world!', name: 'myButton' });\n * const node = button('Hello, world!', 'button', 'myButton', 'primary');\n * const node = button('Hello, world!');\n * ```\n */\nexport const button = createBuilder(NodeType.Button, ButtonStruct, [\n  'value',\n  'buttonType',\n  'name',\n  'variant',\n]);\n",
+        "import type { Infer } from '@metamask/superstruct';\nimport { array, assign, literal, object, string, union } from '@metamask/superstruct';\n\nimport { createBuilder } from '../builder';\nimport { NodeStruct, NodeType } from '../nodes';\nimport { ButtonStruct } from './button';\nimport { InputStruct } from './input';\n\nexport const FormComponentStruct = union([InputStruct, ButtonStruct]);\n\n/**\n * The subset of nodes allowed as children in the {@link Form} node.\n */\nexport type FormComponent = Infer<typeof FormComponentStruct>;\n\nexport const FormStruct = assign(\n  NodeStruct,\n  object({\n    type: literal(NodeType.Form),\n    children: array(FormComponentStruct),\n    name: string(),\n  }),\n);\n\n/**\n * A form node that takes children {@link FormComponent} nodes and renders a form.\n *\n * @property type - The type of the node. Must be the string `form`.\n * @property children - The children of the node. Only {@link FormComponent} nodes are allowed.\n * @property name - The form name used to identify it.\n */\nexport type Form = Infer<typeof FormStruct>;\n\n/**\n * Create a {@link Form} node.\n *\n * @param args - The node arguments. This can be either an array of children and a string, or\n * an object with a `name` and `children` property.\n * @param args.name - The form name used to identify it.\n * @param args.children - The child nodes of the form. This can be any valid\n * {@link FormComponent}.\n * @returns The form node as object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = form({\n *  name: 'myForm',\n *  children: [\n *    input({ name: 'myInput' }),\n *    button({ value: 'Hello, world!' }),\n *  ],\n * });\n *\n * const node = form('myForm', [input('myInput'), button('Hello, world!')]);\n */\nexport const form = createBuilder(NodeType.Form, FormStruct, [\n  'name',\n  'children',\n]);\n",
+        "import type { Infer } from '@metamask/superstruct';\nimport { assign, literal, object, optional, string, union } from '@metamask/superstruct';\n\nimport { enumValue } from '../../internals';\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\n\n/**\n * This replicates the available input types from the metamask extension.\n * https://github.com/MetaMask/metamask-extension/develop/ui/components/component-library/input/input.constants.js\n */\nexport enum InputType {\n  /* eslint-disable @typescript-eslint/no-shadow */\n  Text = 'text',\n  Number = 'number',\n  /* eslint-enable @typescript-eslint/no-shadow */\n  Password = 'password',\n}\n\nexport const InputStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Input),\n    value: optional(string()),\n    name: string(),\n    inputType: optional(\n      union([\n        enumValue(InputType.Text),\n        enumValue(InputType.Password),\n        enumValue(InputType.Number),\n      ]),\n    ),\n    placeholder: optional(string()),\n    label: optional(string()),\n    error: optional(string()),\n  }),\n);\n\n/**\n * An input node, that renders an input.\n *\n * @property type - The type of the node, must be the string 'input'.\n * @property name - The name for the input.\n * @property value - The value of the input.\n * @property inputType - An optional type, either `text`, `password` or `number`.\n * @property placeholder - An optional input placeholder.\n * @property label - An optional input label.\n * @property error - An optional error text.\n */\nexport type Input = Infer<typeof InputStruct>;\n\n/**\n * Create a {@link Input} node.\n *\n * @param args - The node arguments. This can either be a name and an optional variant, value and placeholder or an object\n * with the properties: `inputType`, `value`, `variant`, `placeholder` and `name`.\n * @param args.name - The name for the input.\n * @param args.value - The value of the input.\n * @param args.inputType - An optional type, either `text`, `password` or `number`.\n * @param args.placeholder - An optional input placeholder.\n * @param args.label - An optional input label.\n * @param args.error - An optional error text.\n * @returns The input node as an object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = input('myInput');\n * const node = input('myInput', InputType.Text, 'my placeholder', 'myValue', 'myLabel');\n * const node = input({ name: 'myInput' });\n * const node = input({name: 'myInput', value: 'myValue', inputType: InputType.Password, placeholder: 'placeholder'})\n */\nexport const input = createBuilder(NodeType.Input, InputStruct, [\n  'name',\n  'inputType',\n  'placeholder',\n  'value',\n  'label',\n]);\n",
+        "import type { Infer } from '@metamask/superstruct';\nimport { assign, literal, object, string, optional, union } from '@metamask/superstruct';\n\nimport { enumValue } from '../../internals';\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\nimport { AddressStruct } from './address';\nimport { ImageStruct } from './image';\nimport { TextStruct } from './text';\n\nexport enum RowVariant {\n  Default = 'default',\n  Critical = 'critical',\n  Warning = 'warning',\n}\n\n// A subset of components made available to the row\nconst RowComponentStruct = union([ImageStruct, TextStruct, AddressStruct]);\n\nexport const RowStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Row),\n    variant: optional(\n      union([\n        enumValue(RowVariant.Default),\n        enumValue(RowVariant.Critical),\n        enumValue(RowVariant.Warning),\n      ]),\n    ),\n    label: string(),\n    value: RowComponentStruct,\n  }),\n);\n\n/**\n * A row node, that renders a row with a label and a value.\n *\n * @property type - The type of the node. Must be the string `row`.\n * @property label - The label for the row.\n * @property value - A sub component to be rendered\n * on one side of the row.\n * @property variant - Optional variant for styling.\n */\nexport type Row = Infer<typeof RowStruct>;\n\n/**\n * Create a {@link Row} node.\n *\n * @param args - The node arguments. This can either be a string, a component and an optional variant or an object\n * with the properties: `label`, `value` and `variant`.\n * @param args.label - The label for the row.\n * @param args.value - Another component, is currently limited to `image`, `text` and `address`.\n * @param args.variant - An optional variant, either `default`, `warning` or `critical`.\n * @returns The row node as an object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = row({ label: 'Address', value: address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520') });\n * const node = row({ label: 'Address', value: address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520'), variant: RowVariant.Warning });\n * const node = row('Address', address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520'));\n * const node = row('Address', address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520'), RowVariant.Warning);\n */\nexport const row = createBuilder(NodeType.Row, RowStruct, [\n  'label',\n  'value',\n  'variant',\n]);\n",
+        "import type { Infer } from '@metamask/superstruct';\nimport {\n  assign,\n  boolean,\n  literal,\n  object,\n  optional,\n  string,\n} from '@metamask/superstruct';\n\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\n\nexport const TextStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Text),\n    value: string(),\n    markdown: optional(boolean()),\n  }),\n);\n\n/**\n * A text node, that renders the text as one or more paragraphs.\n *\n * @property type - The type of the node, must be the string 'text'.\n * @property value - The text content of the node, either as plain text, or as a\n * markdown string.\n * @property markdown - A flag to enable/disable markdown, if nothing is specified\n * markdown will be enabled.\n */\nexport type Text = Infer<typeof TextStruct>;\n\n/**\n * Create a {@link Text} node.\n *\n * @param args - The node arguments. This can be either a string\n * and a boolean, or an object with a `value` property\n * and an optional `markdown` property.\n * @param args.value - The text content of the node.\n * @param args.markdown - An optional flag to enable or disable markdown. This\n * is enabled by default.\n * @returns The text node as object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = text({ value: 'Hello, world!' });\n * const node = text('Hello, world!');\n * const node = text({ value: 'Hello, world!', markdown: false });\n * const node = text('Hello, world!', false);\n */\nexport const text = createBuilder(NodeType.Text, TextStruct, [\n  'value',\n  'markdown',\n]);\n",
+        "import type { Infer } from '@metamask/superstruct';\nimport { assign, literal, object } from '@metamask/superstruct';\n\nimport { createBuilder } from '../builder';\nimport { NodeStruct, NodeType } from '../nodes';\n\nexport const SpinnerStruct = assign(\n  NodeStruct,\n  object({\n    type: literal(NodeType.Spinner),\n  }),\n);\n\n/**\n * A spinner node, that renders a spinner, either as a full-screen overlay, or\n * inline when nested inside a {@link Panel}.\n */\nexport type Spinner = Infer<typeof SpinnerStruct>;\n\n/**\n * Create a {@link Spinner} node.\n *\n * @returns The spinner node as object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = spinner();\n */\nexport const spinner = createBuilder(NodeType.Spinner, SpinnerStruct);\n",
+        "import { assertStruct } from '@metamask/utils';\nimport { is } from '@metamask/superstruct';\n\nimport { ComponentStruct } from './components';\nimport type { Component } from './components';\n\n/**\n * Check if the given value is a {@link Component}. This performs recursive\n * validation of the component's children (if any).\n *\n * @param value - The value to check.\n * @returns `true` if the value is a {@link Component}, `false` otherwise.\n */\nexport function isComponent(value: unknown): value is Component {\n  return is(value, ComponentStruct);\n}\n\n/**\n * Assert that the given value is a {@link Component}. This performs recursive\n * validation of the component's children (if any).\n *\n * @param value - The value to check.\n * @throws If the value is not a {@link Component}.\n */\nexport function assertIsComponent(value: unknown): asserts value is Component {\n  assertStruct(value, ComponentStruct, 'Invalid component');\n}\n",
+        "import type { ComponentOrElement } from '..';\nimport type { EnumToUnion } from '../../internals';\nimport type { ChainId } from '../caip';\n\n/**\n * The severity level of content being returned from a transaction insight.\n * Currently only one level is supported:\n *\n * - `critical` - The transaction is critical and should not be submitted by the\n * user.\n */\nexport enum SeverityLevel {\n  Critical = 'critical',\n}\n\n/**\n * An EIP-1559 (type 2) transaction object.\n *\n * @property from - The address the transaction is being sent from.\n * @property to - The address the transaction is being sent to.\n * @property nonce - The nonce of the transaction.\n * @property value - The value of the transaction.\n * @property data - The data of the transaction.\n * @property gas - The gas limit of the transaction.\n * @property maxFeePerGas - The maximum fee per gas of the transaction.\n * @property maxPriorityFeePerGas - The maximum priority fee per gas of the\n * transaction.\n * @property estimateSuggested - The suggested gas price for the transaction.\n * @property estimateUsed - The gas price used for the transaction.\n * @see https://eips.ethereum.org/EIPS/eip-1559\n */\nexport type EIP1559Transaction = {\n  from: string;\n  to: string;\n  nonce: string;\n  value: string;\n  data: string;\n  gas: string;\n  maxFeePerGas: string;\n  maxPriorityFeePerGas: string;\n  estimateSuggested: string;\n  estimateUsed: string;\n};\n\n/**\n * A legacy (type \"0\") transaction object.\n *\n * @property from - The address the transaction is being sent from.\n * @property to - The address the transaction is being sent to.\n * @property nonce - The nonce of the transaction.\n * @property value - The value of the transaction.\n * @property data - The data of the transaction.\n * @property gas - The gas limit of the transaction.\n * @property gasPrice - The gas price of the transaction.\n * @property estimateSuggested - The suggested gas price for the transaction.\n * @property estimateUsed - The gas price used for the transaction.\n */\nexport type LegacyTransaction = {\n  from: string;\n  to: string;\n  nonce: string;\n  value: string;\n  data: string;\n  gas: string;\n  gasPrice: string;\n  estimateSuggested: string;\n  estimateUsed: string;\n};\n\n/**\n * A transaction object. This can be either an EIP-1559 transaction or a legacy\n * transaction.\n *\n * @see EIP1559Transaction\n * @see LegacyTransaction\n */\nexport type Transaction = EIP1559Transaction | LegacyTransaction;\n\n/**\n * The `onTransaction` handler. This is called whenever a transaction is\n * submitted to the snap. It can return insights about the transaction, which\n * will be displayed to the user.\n *\n * Note that using this handler requires the `endowment:transaction-insights`\n * permission.\n *\n * @param args - The request arguments.\n * @param args.transaction - The transaction object, containing the address,\n * value, data, and other properties of the transaction.\n * @param args.chainId - The CAIP-2 {@link ChainId} of the network the\n * transaction is being submitted to.\n * @param args.transactionOrigin - The origin of the transaction. This is the\n * URL of the website that submitted the transaction. This is only available if\n * the Snap has enabled the `allowTransactionOrigin` option in the\n * `endowment:transaction-insight` permission.\n * @returns An object containing insights about the transaction. See\n * {@link OnTransactionResponse}. Can also return `null` if no insights are\n * available.\n */\nexport type OnTransactionHandler = (args: {\n  transaction: Transaction;\n  chainId: ChainId;\n  transactionOrigin?: string;\n}) => Promise<OnTransactionResponse | null>;\n\n/**\n * The response from a Snap's `onTransaction` handler.\n *\n * @property component - A custom UI component, that will be shown in MetaMask.\n * @property id - A Snap interface ID.\n * @property severity - The severity level of the content. Currently only one\n * level is supported: `critical`.\n */\nexport type OnTransactionResponse =\n  | {\n      content: ComponentOrElement;\n      severity?: EnumToUnion<SeverityLevel>;\n    }\n  | {\n      id: string;\n      severity?: EnumToUnion<SeverityLevel>;\n    };\n",
+        "import type { Infer } from '@metamask/superstruct';\nimport {\n  number,\n  assign,\n  literal,\n  nullable,\n  object,\n  optional,\n  record,\n  string,\n  union,\n  boolean,\n} from '@metamask/superstruct';\n\nimport type { InterfaceContext } from '../interface';\n\n/**\n * The type of user input event fired.\n * Currently only three events are supported:\n *\n * - `ButtonClickEvent` - A button has been clicked in the UI.\n * - `FormSubmitEvent` - A Form has been submitted in the UI.\n * - `InputChangeEvent` - The value of an input field has changed in the UI.\n * - `FileUploadEvent` - A file has been uploaded in the UI.\n */\nexport enum UserInputEventType {\n  ButtonClickEvent = 'ButtonClickEvent',\n  FormSubmitEvent = 'FormSubmitEvent',\n  InputChangeEvent = 'InputChangeEvent',\n  FileUploadEvent = 'FileUploadEvent',\n}\n\nexport const GenericEventStruct = object({\n  type: string(),\n  name: optional(string()),\n});\n\nexport const ButtonClickEventStruct = assign(\n  GenericEventStruct,\n  object({\n    type: literal(UserInputEventType.ButtonClickEvent),\n    name: optional(string()),\n  }),\n);\n\n/**\n * A button click event fired in the UI. This is passed to the params of the\n * `onUserInput` handler.\n *\n * @property type - The type of event fired. See {@link UserInputEventType} for\n * the different types. This is always `ButtonClickEvent`.\n * @property name - The optional component name that fired the event.\n */\nexport type ButtonClickEvent = Infer<typeof ButtonClickEventStruct>;\n\nexport const FileStruct = object({\n  name: string(),\n  size: number(),\n  contentType: string(),\n  contents: string(),\n});\n\n/**\n * A file object containing the file name, size, content type, and the base64\n * encoded contents of the file.\n *\n * @property name - The name of the file.\n * @property size - The size of the file in bytes.\n * @property contentType - The content type of the file.\n * @property contents - The base64 encoded contents of the file.\n */\nexport type File = Infer<typeof FileStruct>;\n\nexport const FormSubmitEventStruct = assign(\n  GenericEventStruct,\n  object({\n    type: literal(UserInputEventType.FormSubmitEvent),\n    value: record(string(), nullable(union([string(), FileStruct, boolean()]))),\n    name: string(),\n  }),\n);\n\n/**\n * A form submit event, which is fired when a submit button is clicked.\n *\n * @property type - The type of event fired. This is always `FormSubmitEvent`.\n * @property name - The name of the form that was submitted.\n * @property value - The form values submitted as an object. The keys are the\n * names of the form fields and the values are the values of the form fields. If\n * a form field is empty, the value is `null` or an empty string.\n * @property files - The files uploaded in the form. The keys are the names of\n * the file input fields and the values are the file objects containing the file\n * name, size, content type, and the base64 encoded contents of the file. See\n * {@link File}.\n */\nexport type FormSubmitEvent = Infer<typeof FormSubmitEventStruct>;\n\nexport const InputChangeEventStruct = assign(\n  GenericEventStruct,\n  object({\n    type: literal(UserInputEventType.InputChangeEvent),\n    name: string(),\n    value: union([string(), boolean()]),\n  }),\n);\n\n/**\n * An input change event, which is fired when the value of an input field\n * changes.\n *\n * @property type - The type of event fired. This is always `InputChangeEvent`.\n * @property name - The name of the input field that changed.\n * @property value - The new value of the input field.\n */\nexport type InputChangeEvent = Infer<typeof InputChangeEventStruct>;\n\nexport const FileUploadEventStruct = assign(\n  GenericEventStruct,\n  object({\n    type: literal(UserInputEventType.FileUploadEvent),\n    name: string(),\n    file: nullable(FileStruct),\n  }),\n);\n\n/**\n * A file upload event, which is fired when a file is uploaded.\n *\n * @property type - The type of event fired. This is always `FileUploadEvent`.\n * @property name - The name of the file input field that was used to upload the\n * file.\n * @property file - The file object containing the file name, size,\n * content type, and the base64 encoded contents of the file.\n * @see File\n */\nexport type FileUploadEvent = Infer<typeof FileUploadEventStruct>;\n\nexport const UserInputEventStruct = union([\n  ButtonClickEventStruct,\n  FormSubmitEventStruct,\n  InputChangeEventStruct,\n  FileUploadEventStruct,\n]);\n\n/**\n * A user input event fired in the UI. This is passed to the params of the `onUserInput` handler.\n *\n * @property type - The type of event fired. See {@link UserInputEventType} for the different types.\n * @property name - The component name that fired the event. It is optional for\n * an {@link UserInputEventType.ButtonClickEvent}.\n * @property value - The value associated with the event. Only available when an\n * {@link UserInputEventType.FormSubmitEvent} is fired. It contains the form values submitted.\n */\nexport type UserInputEvent =\n  | ButtonClickEvent\n  | FormSubmitEvent\n  | InputChangeEvent\n  | FileUploadEvent;\n\n/**\n * The `onUserInput` handler. This is called when an user input event is fired in the UI.\n *\n * @param args - The user input event.\n * @param args.id - The user interface id.\n * @param args.event - The {@link UserInputEvent} object, containing the data about the fired event.\n */\nexport type OnUserInputHandler = (args: {\n  id: string;\n  event: UserInputEvent;\n  context: InterfaceContext | null;\n}) => Promise<void>;\n",
+        "import type { ComponentOrElement } from '..';\nimport type { EnumToUnion } from '../../internals';\n\n/**\n * The type of dialog to display.\n *\n * - `alert` - A dialog with a single button.\n * - `confirmation` - A dialog with two buttons, one to confirm and one to\n * cancel.\n * - `prompt` - A dialog with two buttons and a text input.\n */\nexport enum DialogType {\n  Alert = 'alert',\n  Confirmation = 'confirmation',\n  Prompt = 'prompt',\n}\n\n/**\n * An alert dialog.\n *\n * @property type - The type of dialog. Must be `alert`.\n * @property content - The content to display in the dialog.\n * @property id - The Snap interface ID.\n */\nexport type AlertDialog =\n  | {\n      type: EnumToUnion<DialogType.Alert>;\n      content: ComponentOrElement;\n    }\n  | {\n      type: EnumToUnion<DialogType.Alert>;\n      id: string;\n    };\n\n/**\n * A confirmation dialog.\n *\n * @property type - The type of dialog. Must be `confirmation`.\n * @property content - The content to display in the dialog.\n * @property id - The Snap interface ID.\n */\nexport type ConfirmationDialog =\n  | {\n      type: EnumToUnion<DialogType.Confirmation>;\n      content: ComponentOrElement;\n    }\n  | {\n      type: EnumToUnion<DialogType.Confirmation>;\n      id: string;\n    };\n\n/**\n * A prompt dialog.\n *\n * @property type - The type of dialog. Must be `prompt`.\n * @property content - The content to display in the dialog.\n * @property id - The Snap interface ID.\n * @property placeholder - An optional placeholder text to display in the text\n * input.\n */\nexport type PromptDialog =\n  | {\n      type: EnumToUnion<DialogType.Prompt>;\n      content: ComponentOrElement;\n      placeholder?: string;\n    }\n  | {\n      type: EnumToUnion<DialogType.Prompt>;\n      id: string;\n      placeholder?: string;\n    };\n\n/**\n * The request parameters for the `snap_dialog` method.\n *\n * @property type - The type of dialog to display.\n * @property content - The content to display in the dialog.\n * @property id - The Snap interface ID.\n * @property placeholder - The placeholder text to display in the dialog. Only\n * applicable for the `prompt` dialog.\n */\nexport type DialogParams = AlertDialog | ConfirmationDialog | PromptDialog;\n\n/**\n * The result returned by the `snap_dialog` method.\n *\n * - If the dialog is an `alert`, the result is `null`.\n * - If the dialog is a `confirmation`, the result is a boolean indicating\n * whether the user confirmed the dialog.\n * - If the dialog is a `prompt`, the result is the value entered by\n * the user.\n */\nexport type DialogResult = null | boolean | string;\n",
+        "import type { EnumToUnion } from '../../internals';\n\n/**\n * The encoding to use when retrieving the file. Defaults to `Base64`.\n */\nexport enum AuxiliaryFileEncoding {\n  Base64 = 'base64',\n  Hex = 'hex',\n  Utf8 = 'utf8',\n}\n\n/**\n * The request parameters for the `snap_getFile` method.\n *\n * @property path - The path to the file to retrieve.\n * @property encoding - The encoding to use when retrieving the file.\n */\nexport type GetFileParams = {\n  path: string;\n  encoding?: EnumToUnion<AuxiliaryFileEncoding>;\n};\n\n/**\n * The result returned by the `snap_getFile` method.\n */\nexport type GetFileResult = string;\n",
+        "import type { Json } from '@metamask/utils';\n\nimport type { EnumToUnion } from '../../internals';\n\n/**\n * The operations that can be performed on the state.\n */\nexport enum ManageStateOperation {\n  ClearState = 'clear',\n  GetState = 'get',\n  UpdateState = 'update',\n}\n\n/**\n * The clear state operation, which clears the state.\n *\n * @property operation - The operation to perform on the state. Must be `clear`.\n * @property encrypted - Whether to use the separate encrypted state, or the\n * unencrypted state. Defaults to the encrypted state. Encrypted state can only\n * be used if the extension is unlocked, while unencrypted state can be used\n * whether the extension is locked or unlocked.\n */\nexport type ClearStateOperation = {\n  operation: EnumToUnion<ManageStateOperation.ClearState>;\n  encrypted?: boolean;\n};\n\n/**\n * The get state operation, which retrieves the state.\n *\n * @property operation - The operation to perform on the state. Must be `get`.\n * @property encrypted - Whether to use the separate encrypted state, or the\n * unencrypted state. Defaults to the encrypted state. Encrypted state can only\n * be used if the extension is unlocked, while unencrypted state can be used\n * whether the extension is locked or unlocked.\n */\nexport type GetStateOperation = {\n  operation: EnumToUnion<ManageStateOperation.GetState>;\n  encrypted?: boolean;\n};\n\n/**\n * The update state operation, which updates the state.\n *\n * @property operation - The operation to perform on the state. Must be\n * `update`.\n * @property encrypted - Whether to use the separate encrypted state, or the\n * unencrypted state. Defaults to the encrypted state. Encrypted state can only\n * be used if the extension is unlocked, while unencrypted state can be used\n * whether the extension is locked or unlocked.\n * @property newState - The new state to set.\n */\nexport type UpdateStateOperation = {\n  operation: EnumToUnion<ManageStateOperation.UpdateState>;\n  encrypted?: boolean;\n  newState: Record<string, Json>;\n};\n\n/**\n * The request parameters for the `snap_manageState` method.\n *\n * @property operation - The operation to perform on the state.\n * @property encrypted - Whether to use the separate encrypted state, or the\n * unencrypted state. Defaults to the encrypted state.\n * @property newState - The new state to set. Only applicable for the `set`\n * operation.\n */\nexport type ManageStateParams =\n  | ClearStateOperation\n  | GetStateOperation\n  | UpdateStateOperation;\n\n/**\n * The result returned by the `snap_manageState` method.\n *\n * If the operation is `get`, the result is the state. Otherwise, the result is\n * `null`.\n */\nexport type ManageStateResult = Record<string, Json> | null;\n",
+        "import type { EnumToUnion } from '../../internals';\n\n/**\n * The types of notifications that can be displayed.\n *\n * - `InApp` - A notification that is displayed in by the MetaMask extension.\n * - `Native` - A notification that is displayed by the operating system.\n */\nexport enum NotificationType {\n  InApp = 'inApp',\n  Native = 'native',\n}\n\n/**\n * The request parameters for the `snap_notify` method.\n *\n * @property type - The type of notification to display.\n * @property message - The message to display in the notification.\n */\nexport type NotifyParams = {\n  type: EnumToUnion<NotificationType>;\n  message: string;\n};\n\n/**\n * The result returned by the `snap_notify` method.\n *\n * This method does not return anything.\n */\nexport type NotifyResult = null;\n",
+        "import { JsonStruct } from '@metamask/utils';\nimport type { Infer } from '@metamask/superstruct';\nimport { boolean, nullable, record, string, union } from '@metamask/superstruct';\n\nimport type { JSXElement } from '../jsx';\nimport { RootJSXElementStruct } from '../jsx';\nimport type { Component } from '../ui';\nimport { ComponentStruct } from '../ui';\nimport { FileStruct } from './handlers';\n\n/**\n * To avoid typing problems with the interface state when manipulating it we\n * have to differentiate the state of a form (that will be contained inside the\n * root state) and the root state since a key in the root stat can contain\n * either the value of an input or a sub-state of a form.\n */\n\nexport const StateStruct = union([FileStruct, string(), boolean()]);\n\nexport const FormStateStruct = record(string(), nullable(StateStruct));\n\nexport const InterfaceStateStruct = record(\n  string(),\n  union([FormStateStruct, nullable(StateStruct)]),\n);\n\nexport type State = Infer<typeof StateStruct>;\nexport type FormState = Infer<typeof FormStateStruct>;\nexport type InterfaceState = Infer<typeof InterfaceStateStruct>;\n\nexport type ComponentOrElement = Component | JSXElement;\nexport const ComponentOrElementStruct = union([\n  ComponentStruct,\n  RootJSXElementStruct,\n]);\n\nexport const InterfaceContextStruct = record(string(), JsonStruct);\nexport type InterfaceContext = Infer<typeof InterfaceContextStruct>;\n",
+        "import {\n  hasProperty,\n  HexChecksumAddressStruct,\n  isPlainObject,\n  JsonStruct,\n} from '@metamask/utils';\nimport type { Infer, Struct } from '@metamask/superstruct';\nimport {\n  is,\n  boolean,\n  optional,\n  array,\n  lazy,\n  nullable,\n  number,\n  object,\n  record,\n  string,\n  tuple,\n} from '@metamask/superstruct';\nimport type {\n  AnyStruct,\n  InferStructTuple,\n  ObjectSchema,\n} from '@metamask/superstruct';\n\nimport type { Describe } from '../internals';\nimport { literal, nullUnion, svg } from '../internals';\nimport type { EmptyObject } from '../types';\nimport type {\n  GenericSnapElement,\n  JsonObject,\n  Key,\n  Nestable,\n  SnapElement,\n  SnapsChildren,\n  StringElement,\n} from './component';\nimport type {\n  AddressElement,\n  BoldElement,\n  BoxElement,\n  ButtonElement,\n  CheckboxElement,\n  CopyableElement,\n  DividerElement,\n  DropdownElement,\n  OptionElement,\n  FieldElement,\n  FormElement,\n  HeadingElement,\n  ImageElement,\n  InputElement,\n  ItalicElement,\n  JSXElement,\n  LinkElement,\n  RowElement,\n  SpinnerElement,\n  StandardFormattingElement,\n  TextElement,\n  TooltipElement,\n  ValueElement,\n  FileInputElement,\n} from './components';\n\n/**\n * A struct for the {@link Key} type.\n */\nexport const KeyStruct: Describe<Key> = nullUnion([string(), number()]);\n\n/**\n * A struct for the {@link StringElement} type.\n */\nexport const StringElementStruct: Describe<StringElement> = children([\n  string(),\n]);\n\n/**\n * A struct for the {@link GenericSnapElement} type.\n */\nexport const ElementStruct: Describe<GenericSnapElement> = object({\n  type: string(),\n  props: record(string(), JsonStruct),\n  key: nullable(KeyStruct),\n});\n\n/**\n * A helper function for creating a struct for a {@link Nestable} type.\n *\n * @param struct - The struct for the type to test.\n * @returns The struct for the nestable type.\n */\nfunction nestable<Type, Schema>(\n  struct: Struct<Type, Schema>,\n): Struct<Nestable<Type>, any> {\n  const nestableStruct: Struct<Nestable<Type>> = nullUnion([\n    struct,\n    array(lazy(() => nestableStruct)),\n  ]);\n\n  return nestableStruct;\n}\n\n/**\n * A helper function for creating a struct which allows children of a specific\n * type, as well as `null` and `boolean`.\n *\n * @param structs - The structs to allow as children.\n * @returns The struct for the children.\n */\nfunction children<Head extends AnyStruct, Tail extends AnyStruct[]>(\n  structs: [head: Head, ...tail: Tail],\n): Struct<\n  Nestable<Infer<Head> | InferStructTuple<Tail>[number] | boolean | null>,\n  null\n> {\n  return nestable(nullable(nullUnion([...structs, boolean()])));\n}\n\n/**\n * A helper function for creating a struct for a JSX element.\n *\n * @param name - The name of the element.\n * @param props - The props of the element.\n * @returns The struct for the element.\n */\nfunction element<Name extends string, Props extends ObjectSchema = EmptyObject>(\n  name: Name,\n  props: Props = {} as Props,\n) {\n  return object({\n    type: literal(name) as unknown as Struct<Name, Name>,\n    props: object(props),\n    key: nullable(KeyStruct),\n  });\n}\n\n/**\n * A struct for the {@link ButtonElement} type.\n */\nexport const ButtonStruct: Describe<ButtonElement> = element('Button', {\n  children: StringElementStruct,\n  name: optional(string()),\n  type: optional(nullUnion([literal('button'), literal('submit')])),\n  variant: optional(nullUnion([literal('primary'), literal('destructive')])),\n  disabled: optional(boolean()),\n});\n\n/**\n * A struct for the {@link CheckboxElement} type.\n */\nexport const CheckboxStruct: Describe<CheckboxElement> = element('Checkbox', {\n  name: string(),\n  checked: optional(boolean()),\n  label: optional(string()),\n  variant: optional(nullUnion([literal('default'), literal('toggle')])),\n});\n\n/**\n * A struct for the {@link InputElement} type.\n */\nexport const InputStruct: Describe<InputElement> = element('Input', {\n  name: string(),\n  type: optional(\n    nullUnion([literal('text'), literal('password'), literal('number')]),\n  ),\n  value: optional(string()),\n  placeholder: optional(string()),\n});\n\n/**\n * A struct for the {@link OptionElement} type.\n */\nexport const OptionStruct: Describe<OptionElement> = element('Option', {\n  value: string(),\n  children: string(),\n});\n\n/**\n * A struct for the {@link DropdownElement} type.\n */\nexport const DropdownStruct: Describe<DropdownElement> = element('Dropdown', {\n  name: string(),\n  value: optional(string()),\n  children: children([OptionStruct]),\n});\n\n/**\n * A struct for the {@link FileInputElement} type.\n */\nexport const FileInputStruct: Describe<FileInputElement> = element(\n  'FileInput',\n  {\n    name: string(),\n    accept: nullUnion([optional(array(string()))]),\n    compact: optional(boolean()),\n  },\n);\n\n/**\n * A struct for the {@link FieldElement} type.\n */\nexport const FieldStruct: Describe<FieldElement> = element('Field', {\n  label: optional(string()),\n  error: optional(string()),\n  children: nullUnion([\n    tuple([InputStruct, ButtonStruct]),\n    DropdownStruct,\n    FileInputStruct,\n    InputStruct,\n    CheckboxStruct,\n  ]),\n});\n\n/**\n * A struct for the {@link FormElement} type.\n */\nexport const FormStruct: Describe<FormElement> = element('Form', {\n  children: children(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    [FieldStruct, lazy(() => BoxChildStruct)],\n  ) as unknown as Struct<SnapsChildren<GenericSnapElement>, null>,\n  name: string(),\n});\n\n/**\n * A struct for the {@link BoldElement} type.\n */\nexport const BoldStruct: Describe<BoldElement> = element('Bold', {\n  children: children([\n    string(),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    lazy(() => ItalicStruct) as unknown as Struct<\n      SnapElement<JsonObject, 'Italic'>\n    >,\n  ]),\n});\n\n/**\n * A struct for the {@link ItalicElement} type.\n */\nexport const ItalicStruct: Describe<ItalicElement> = element('Italic', {\n  children: children([\n    string(),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    lazy(() => BoldStruct) as unknown as Struct<\n      SnapElement<JsonObject, 'Bold'>\n    >,\n  ]),\n});\n\nexport const FormattingStruct: Describe<StandardFormattingElement> = nullUnion([\n  BoldStruct,\n  ItalicStruct,\n]);\n\n/**\n * A struct for the {@link AddressElement} type.\n */\nexport const AddressStruct: Describe<AddressElement> = element('Address', {\n  address: HexChecksumAddressStruct,\n});\n\n/**\n * A struct for the {@link BoxElement} type.\n */\nexport const BoxStruct: Describe<BoxElement> = element('Box', {\n  children: children(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    [lazy(() => BoxChildStruct)],\n  ) as unknown as Struct<SnapsChildren<GenericSnapElement>, null>,\n  direction: optional(nullUnion([literal('horizontal'), literal('vertical')])),\n  alignment: optional(\n    nullUnion([\n      literal('start'),\n      literal('center'),\n      literal('end'),\n      literal('space-between'),\n      literal('space-around'),\n    ]),\n  ),\n});\n\n/**\n * A struct for the {@link CopyableElement} type.\n */\nexport const CopyableStruct: Describe<CopyableElement> = element('Copyable', {\n  value: string(),\n  sensitive: optional(boolean()),\n});\n\n/**\n * A struct for the {@link DividerElement} type.\n */\nexport const DividerStruct: Describe<DividerElement> = element('Divider');\n\n/**\n * A struct for the {@link ValueElement} type.\n */\nexport const ValueStruct: Describe<ValueElement> = element('Value', {\n  value: string(),\n  extra: string(),\n});\n\n/**\n * A struct for the {@link HeadingElement} type.\n */\nexport const HeadingStruct: Describe<HeadingElement> = element('Heading', {\n  children: StringElementStruct,\n});\n\n/**\n * A struct for the {@link ImageElement} type.\n */\nexport const ImageStruct: Describe<ImageElement> = element('Image', {\n  src: svg(),\n  alt: optional(string()),\n});\n\n/**\n * A struct for the {@link LinkElement} type.\n */\nexport const LinkStruct: Describe<LinkElement> = element('Link', {\n  href: string(),\n  children: children([FormattingStruct, string()]),\n});\n\n/**\n * A struct for the {@link TextElement} type.\n */\nexport const TextStruct: Describe<TextElement> = element('Text', {\n  children: children([string(), BoldStruct, ItalicStruct, LinkStruct]),\n  alignment: optional(\n    nullUnion([literal('start'), literal('center'), literal('end')]),\n  ),\n});\n\n/**\n * A subset of JSX elements that are allowed as children of the Tooltip component.\n * This set should include all text components and the Image.\n */\nexport const TooltipChildStruct = nullUnion([\n  TextStruct,\n  BoldStruct,\n  ItalicStruct,\n  LinkStruct,\n  ImageStruct,\n  boolean(),\n]);\n\n/**\n * A subset of JSX elements that are allowed as content of the Tooltip component.\n * This set should include all text components.\n */\nexport const TooltipContentStruct = nullUnion([\n  TextStruct,\n  BoldStruct,\n  ItalicStruct,\n  LinkStruct,\n  string(),\n]);\n\n/**\n * A struct for the {@link TooltipElement} type.\n */\nexport const TooltipStruct: Describe<TooltipElement> = element('Tooltip', {\n  children: nullable(TooltipChildStruct),\n  content: TooltipContentStruct,\n});\n\n/**\n * A struct for the {@link RowElement} type.\n */\nexport const RowStruct: Describe<RowElement> = element('Row', {\n  label: string(),\n  children: nullUnion([AddressStruct, ImageStruct, TextStruct, ValueStruct]),\n  variant: optional(\n    nullUnion([literal('default'), literal('warning'), literal('critical')]),\n  ),\n  tooltip: optional(string()),\n});\n\n/**\n * A struct for the {@link SpinnerElement} type.\n */\nexport const SpinnerStruct: Describe<SpinnerElement> = element('Spinner');\n\n/**\n * A subset of JSX elements that are allowed as children of the Box component.\n * This set includes all components, except components that need to be nested in\n * another component (e.g., Field must be contained in a Form).\n */\nexport const BoxChildStruct = nullUnion([\n  AddressStruct,\n  BoldStruct,\n  BoxStruct,\n  ButtonStruct,\n  CopyableStruct,\n  DividerStruct,\n  DropdownStruct,\n  FileInputStruct,\n  FormStruct,\n  HeadingStruct,\n  InputStruct,\n  ImageStruct,\n  ItalicStruct,\n  LinkStruct,\n  RowStruct,\n  SpinnerStruct,\n  TextStruct,\n  TooltipStruct,\n  CheckboxStruct,\n]);\n\n/**\n * For now, the allowed JSX elements at the root are the same as the allowed\n * children of the Box component.\n */\nexport const RootJSXElementStruct = BoxChildStruct;\n\n/**\n * A struct for the {@link JSXElement} type.\n */\nexport const JSXElementStruct: Describe<JSXElement> = nullUnion([\n  ButtonStruct,\n  InputStruct,\n  FileInputStruct,\n  FieldStruct,\n  FormStruct,\n  BoldStruct,\n  ItalicStruct,\n  AddressStruct,\n  BoxStruct,\n  CopyableStruct,\n  DividerStruct,\n  HeadingStruct,\n  ImageStruct,\n  LinkStruct,\n  RowStruct,\n  SpinnerStruct,\n  TextStruct,\n  DropdownStruct,\n  OptionStruct,\n  ValueStruct,\n  TooltipStruct,\n  CheckboxStruct,\n]);\n\n/**\n * Check if a value is a JSX element.\n *\n * @param value - The value to check.\n * @returns True if the value is a JSX element, false otherwise.\n */\nexport function isJSXElement(value: unknown): value is JSXElement {\n  return is(value, JSXElementStruct);\n}\n\n/**\n * Check if a value is a JSX element, without validating all of its contents.\n * This is useful when you want to validate the structure of a value, but not\n * all the children.\n *\n * This should only be used when you are sure that the value is safe to use,\n * i.e., after using {@link isJSXElement}.\n *\n * @param value - The value to check.\n * @returns True if the value is a JSX element, false otherwise.\n */\nexport function isJSXElementUnsafe(value: unknown): value is JSXElement {\n  return (\n    isPlainObject(value) &&\n    hasProperty(value, 'type') &&\n    hasProperty(value, 'props') &&\n    hasProperty(value, 'key')\n  );\n}\n\n/**\n * Assert that a value is a JSX element.\n *\n * @param value - The value to check.\n * @throws If the value is not a JSX element.\n */\nexport function assertJSXElement(value: unknown): asserts value is JSXElement {\n  // TODO: We should use the error parsing utils from `snaps-utils` to improve\n  // the error messages. It currently includes colours and potentially other\n  // formatting that we might not want to include in the SDK.\n  if (!isJSXElement(value)) {\n    throw new Error(\n      `Expected a JSX element, but received ${JSON.stringify(\n        value,\n      )}. Please refer to the documentation for the supported JSX elements and their props.`,\n    );\n  }\n}\n"
+    ],
+    "mappings": "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",
+    "names": [
+        "error",
+        "superstructLiteral",
+        "superstructUnion",
+        "import_superstruct",
+        "import_utils",
+        "import_utils",
+        "import_utils",
+        "import_superstruct",
+        "import_utils",
+        "node",
+        "import_superstruct",
+        "NodeType",
+        "import_superstruct",
+        "import_superstruct",
+        "import_superstruct",
+        "import_superstruct",
+        "import_superstruct",
+        "import_superstruct",
+        "ButtonVariant",
+        "ButtonType",
+        "import_superstruct",
+        "import_superstruct",
+        "InputType",
+        "import_superstruct",
+        "import_superstruct",
+        "RowVariant",
+        "import_superstruct",
+        "import_utils",
+        "import_superstruct",
+        "SeverityLevel",
+        "import_superstruct",
+        "UserInputEventType",
+        "DialogType",
+        "AuxiliaryFileEncoding",
+        "ManageStateOperation",
+        "NotificationType",
+        "import_utils",
+        "import_superstruct",
+        "import_utils",
+        "import_superstruct",
+        "ButtonStruct",
+        "InputStruct",
+        "FormStruct",
+        "AddressStruct",
+        "CopyableStruct",
+        "DividerStruct",
+        "HeadingStruct",
+        "ImageStruct",
+        "TextStruct",
+        "RowStruct",
+        "SpinnerStruct"
+    ]
+}
\ No newline at end of file
diff --git a/dist/index.mjs.map b/dist/index.mjs.map
index d9c617eb5a025482055070d7d000215f44926838..ada98186b6ddd69bce003f4f834ea49ed65d09c5 100644
--- a/dist/index.mjs.map
+++ b/dist/index.mjs.map
@@ -1 +1 @@
-{"version":3,"sources":["../src/errors.ts","../src/internals/error-wrappers.ts","../src/internals/errors.ts","../src/internals/structs.ts","../src/internals/jsx.ts","../src/internals/svg.ts","../src/index.ts","../src/error-wrappers.ts","../src/images.ts","../src/ui/components/address.ts","../src/ui/builder.ts","../src/ui/nodes.ts","../src/ui/components/copyable.ts","../src/ui/components/divider.ts","../src/ui/components/heading.ts","../src/ui/components/image.ts","../src/ui/components/panel.ts","../src/ui/components/button.ts","../src/ui/components/form.ts","../src/ui/components/input.ts","../src/ui/components/row.ts","../src/ui/components/text.ts","../src/ui/components/spinner.ts","../src/ui/component.ts","../src/types/handlers/transaction.ts","../src/types/handlers/user-input.ts","../src/types/methods/dialog.ts","../src/types/methods/get-file.ts","../src/types/methods/manage-state.ts","../src/types/methods/notify.ts","../src/types/interface.ts","../src/jsx/validation.ts"],"sourcesContent":["import type { Json, JsonRpcError } from '@metamask/utils';\n\nimport {\n  getErrorCode,\n  getErrorData,\n  getErrorMessage,\n  SNAP_ERROR_CODE,\n  SNAP_ERROR_MESSAGE,\n} from './internals';\n\n/**\n * A generic error which can be thrown by a Snap, without it causing the Snap to\n * crash.\n */\nexport class SnapError extends Error {\n  readonly #code: number;\n\n  readonly #message: string;\n\n  readonly #data?: Record<string, Json>;\n\n  readonly #stack?: string;\n\n  /**\n   * Create a new `SnapError`.\n   *\n   * @param error - The error to create the `SnapError` from. If this is a\n   * `string`, it will be used as the error message. If this is an `Error`, its\n   * `message` property will be used as the error message. If this is a\n   * `JsonRpcError`, its `message` property will be used as the error message\n   * and its `code` property will be used as the error code. Otherwise, the\n   * error will be converted to a string and used as the error message.\n   * @param data - Additional data to include in the error. This will be merged\n   * with the error data, if any.\n   */\n  constructor(\n    error: string | Error | JsonRpcError,\n    data: Record<string, Json> = {},\n  ) {\n    const message = getErrorMessage(error);\n    super(message);\n\n    this.#message = message;\n    this.#code = getErrorCode(error);\n\n    const mergedData = { ...getErrorData(error), ...data };\n    if (Object.keys(mergedData).length > 0) {\n      this.#data = mergedData;\n    }\n\n    this.#stack = super.stack;\n  }\n\n  /**\n   * The error name.\n   *\n   * @returns The error name.\n   */\n  get name() {\n    return 'SnapError';\n  }\n\n  /**\n   * The error code.\n   *\n   * @returns The error code.\n   */\n  get code() {\n    return this.#code;\n  }\n\n  /**\n   * The error message.\n   *\n   * @returns The error message.\n   */\n  // This line is covered, but Jest doesn't pick it up for some reason.\n  /* istanbul ignore next */\n  get message() {\n    return this.#message;\n  }\n\n  /**\n   * Additional data for the error.\n   *\n   * @returns Additional data for the error.\n   */\n  get data() {\n    return this.#data;\n  }\n\n  /**\n   * The error stack.\n   *\n   * @returns The error stack.\n   */\n  // This line is covered, but Jest doesn't pick it up for some reason.\n  /* istanbul ignore next */\n  get stack() {\n    return this.#stack;\n  }\n\n  /**\n   * Convert the error to a JSON object.\n   *\n   * @returns The JSON object.\n   */\n  toJSON(): SerializedSnapError {\n    return {\n      code: SNAP_ERROR_CODE,\n      message: SNAP_ERROR_MESSAGE,\n      data: {\n        cause: {\n          code: this.code,\n          message: this.message,\n          stack: this.stack,\n          ...(this.data ? { data: this.data } : {}),\n        },\n      },\n    };\n  }\n\n  /**\n   * Serialize the error to a JSON object. This is called by\n   * `@metamask/rpc-errors` when serializing the error.\n   *\n   * @returns The JSON object.\n   */\n  serialize() {\n    return this.toJSON();\n  }\n}\n\n/**\n * A serialized {@link SnapError}. It's JSON-serializable, so it can be sent\n * over the RPC. The original error is wrapped in the `cause` property.\n *\n * @property code - The error code. This is always `-31002`.\n * @property message - The error message. This is always `'Snap Error'`.\n * @property data - The error data.\n * @property data.cause - The cause of the error.\n * @property data.cause.code - The error code.\n * @property data.cause.message - The error message.\n * @property data.cause.stack - The error stack.\n * @property data.cause.data - Additional data for the error.\n * @see SnapError\n */\nexport type SerializedSnapError = {\n  code: typeof SNAP_ERROR_CODE;\n  message: typeof SNAP_ERROR_MESSAGE;\n  data: {\n    cause: JsonRpcError;\n  };\n};\n","import type { rpcErrors } from '@metamask/rpc-errors';\nimport type { Json } from '@metamask/utils';\n\nimport { SnapError } from '../errors';\n\nexport type JsonRpcErrorFunction = typeof rpcErrors.parse;\n\n/**\n * Create a `SnapError` class from an error function from\n * `@metamask/rpc-errors`. This is useful for creating custom error classes\n * which can be thrown by a Snap.\n *\n * The created class will inherit the message, code, and data properties from\n * the error function.\n *\n * @param fn - The error function to create the class from.\n * @returns The created `SnapError` class.\n */\nexport function createSnapError(fn: JsonRpcErrorFunction) {\n  return class SnapJsonRpcError extends SnapError {\n    /**\n     * Create a new `SnapJsonRpcError` from a message.\n     *\n     * @param message - The message to create the error from.\n     */\n    constructor(message?: string);\n\n    /**\n     * Create a new `SnapJsonRpcError` from data.\n     *\n     * @param data - The data to create the error from.\n     */\n    constructor(data?: Record<string, Json>);\n\n    /**\n     * Create a new `SnapJsonRpcError` from a message and data.\n     *\n     * @param message - The message to create the error from.\n     * @param data - The data to create the error from.\n     */\n    constructor(\n      message?: string | Record<string, Json>,\n      data?: Record<string, Json>,\n    );\n\n    /**\n     * Create a new `SnapJsonRpcError` from a message and data.\n     *\n     * @param message - The message to create the error from.\n     * @param data - The data to create the error from.\n     */\n    constructor(\n      message?: string | Record<string, Json>,\n      data?: Record<string, Json>,\n    ) {\n      if (typeof message === 'object') {\n        const error = fn();\n        super({\n          code: error.code,\n          message: error.message,\n          data: message,\n        });\n\n        return;\n      }\n\n      const error = fn(message);\n      super({\n        code: error.code,\n        message: error.message,\n        data,\n      });\n    }\n  };\n}\n","import { hasProperty, isObject, isValidJson } from '@metamask/utils';\n\nexport const SNAP_ERROR_CODE = -31002;\nexport const SNAP_ERROR_MESSAGE = 'Snap Error';\n\n/**\n * Get the error message from an unknown error type.\n *\n * - If the error is an object with a `message` property, return the message.\n * - Otherwise, return the error converted to a string.\n *\n * @param error - The error to get the message from.\n * @returns The error message.\n * @internal\n */\nexport function getErrorMessage(error: unknown) {\n  if (\n    isObject(error) &&\n    hasProperty(error, 'message') &&\n    typeof error.message === 'string'\n  ) {\n    return error.message;\n  }\n\n  return String(error);\n}\n\n/**\n * Get the error stack from an unknown error type.\n *\n * @param error - The error to get the stack from.\n * @returns The error stack, or undefined if the error does not have a valid\n * stack.\n * @internal\n */\nexport function getErrorStack(error: unknown) {\n  if (\n    isObject(error) &&\n    hasProperty(error, 'stack') &&\n    typeof error.stack === 'string'\n  ) {\n    return error.stack;\n  }\n\n  return undefined;\n}\n\n/**\n * Get the error code from an unknown error type.\n *\n * @param error - The error to get the code from.\n * @returns The error code, or `-32603` if the error does not have a valid code.\n * @internal\n */\nexport function getErrorCode(error: unknown) {\n  if (\n    isObject(error) &&\n    hasProperty(error, 'code') &&\n    typeof error.code === 'number' &&\n    Number.isInteger(error.code)\n  ) {\n    return error.code;\n  }\n\n  return -32603;\n}\n\n/**\n * Get the error data from an unknown error type.\n *\n * @param error - The error to get the data from.\n * @returns The error data, or an empty object if the error does not have valid\n * data.\n * @internal\n */\nexport function getErrorData(error: unknown) {\n  if (\n    isObject(error) &&\n    hasProperty(error, 'data') &&\n    typeof error.data === 'object' &&\n    error.data !== null &&\n    isValidJson(error.data) &&\n    !Array.isArray(error.data)\n  ) {\n    return error.data;\n  }\n\n  return {};\n}\n","import type { Infer } from 'superstruct';\nimport {\n  Struct,\n  define,\n  literal as superstructLiteral,\n  union as superstructUnion,\n} from 'superstruct';\nimport type { AnyStruct, InferStructTuple } from 'superstruct/dist/utils';\n\nimport type { EnumToUnion } from './helpers';\n\n/**\n * A wrapper of `superstruct`'s `literal` struct that also defines the name of\n * the struct as the literal value.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n * For example, instead of returning an error like:\n *\n * ```\n * Expected the value to satisfy a union of `literal | literal`, but received: \\\"baz\\\"\n * ```\n *\n * This struct will return an error like:\n *\n * ```\n * Expected the value to satisfy a union of `\"foo\" | \"bar\"`, but received: \\\"baz\\\"\n * ```\n *\n * @param value - The literal value.\n * @returns The `superstruct` struct, which validates that the value is equal\n * to the literal value.\n */\nexport function literal<Type extends string | number | boolean>(value: Type) {\n  return define<Type>(\n    JSON.stringify(value),\n    superstructLiteral(value).validator,\n  );\n}\n\n/**\n * A wrapper of `superstruct`'s `union` struct that also defines the schema as\n * the union of the schemas of the structs.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n *\n * @param structs - The structs to union.\n * @param structs.\"0\" - The first struct.\n * @param structs.\"1\" - The remaining structs.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function union<Head extends AnyStruct, Tail extends AnyStruct[]>([\n  head,\n  ...tail\n]: [head: Head, ...tail: Tail]): Struct<\n  Infer<Head> | InferStructTuple<Tail>[number],\n  [head: Head, ...tail: Tail]\n> {\n  const struct = superstructUnion([head, ...tail]);\n\n  return new Struct({\n    ...struct,\n    schema: [head, ...tail],\n  });\n}\n\n/**\n * Superstruct struct for validating an enum value. This allows using both the\n * enum string values and the enum itself as values.\n *\n * @param constant - The enum to validate against.\n * @returns The superstruct struct.\n */\nexport function enumValue<Type extends string>(\n  constant: Type,\n): Struct<EnumToUnion<Type>, null> {\n  return literal(constant as EnumToUnion<Type>);\n}\n","import type { Infer, Struct } from 'superstruct';\nimport type {\n  AnyStruct,\n  EnumSchema,\n  InferStructTuple,\n  IsExactMatch,\n  IsMatch,\n  IsRecord,\n  IsTuple,\n  UnionToIntersection,\n} from 'superstruct/dist/utils';\n\nimport type { EmptyObject } from '../types';\nimport { union } from './structs';\n\n/**\n * Check if a type is a union. Infers `true` if it is a union, otherwise\n * `false`.\n */\ntype IsUnion<Type> = [Type] extends [UnionToIntersection<Type>] ? false : true;\n\n/**\n * Get a struct schema for a type.\n *\n * This is copied from `superstruct` but fixes some issues with the original\n * implementation.\n */\ntype StructSchema<Type> = IsUnion<Type> extends true\n  ? null\n  : [Type] extends [EmptyObject]\n  ? EmptyObject\n  : [Type] extends [string | undefined | null]\n  ? [Type] extends [`0x${string}`]\n    ? null\n    : [Type] extends [IsMatch<Type, string | undefined | null>]\n    ? null\n    : [Type] extends [IsUnion<Type>]\n    ? EnumSchema<Type>\n    : Type\n  : [Type] extends [number | undefined | null]\n  ? [Type] extends [IsMatch<Type, number | undefined | null>]\n    ? null\n    : [Type] extends [IsUnion<Type>]\n    ? EnumSchema<Type>\n    : Type\n  : [Type] extends [boolean]\n  ? [Type] extends [IsExactMatch<Type, boolean>]\n    ? null\n    : Type\n  : Type extends\n      | bigint\n      | symbol\n      | undefined\n      | null\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      | Function\n      | Date\n      | Error\n      | RegExp\n      | Map<any, any>\n      | WeakMap<any, any>\n      | Set<any>\n      | WeakSet<any>\n      | Promise<any>\n  ? null\n  : Type extends (infer E)[]\n  ? Type extends IsTuple<Type>\n    ? null\n    : Struct<E>\n  : Type extends object\n  ? Type extends IsRecord<Type>\n    ? null\n    : {\n        [InnerKey in keyof Type]: Describe<Type[InnerKey]>;\n      }\n  : null;\n\n/**\n * Describe a struct type.\n */\nexport type Describe<Type> = Struct<Type, StructSchema<Type>>;\n\n/**\n * Create a union struct that uses `null` for the schema type, for better\n * compatibility with `Describe`.\n *\n * @param structs - The structs to union.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function nullUnion<Head extends AnyStruct, Tail extends AnyStruct[]>(\n  structs: [head: Head, ...tail: Tail],\n): Struct<Infer<Head> | InferStructTuple<Tail>[number], null> {\n  return union(structs) as unknown as Struct<\n    Infer<Head> | InferStructTuple<Tail>[number],\n    null\n  >;\n}\n","import { refine, string } from 'superstruct';\n\n/**\n * Get a Struct that validates a string as a valid SVG.\n *\n * @returns A Struct that validates a string as a valid SVG.\n * @internal\n */\nexport function svg() {\n  return refine(string(), 'SVG', (value) => {\n    // This validation is intentionally very basic, we don't need to be that strict\n    // and merely have this extra validation as a helpful error if devs aren't\n    // passing in SVGs.\n    if (!value.includes('<svg')) {\n      return 'Value is not a valid SVG.';\n    }\n\n    return true;\n  });\n}\n","// Only internals that are used by other Snaps packages should be exported here.\nexport type { EnumToUnion } from './internals';\nexport {\n  getErrorData,\n  getErrorMessage,\n  getErrorStack,\n  SNAP_ERROR_CODE,\n  SNAP_ERROR_MESSAGE,\n  literal,\n  union,\n  enumValue,\n} from './internals';\n\n// Re-exported from `@metamask/utils` for convenience.\nexport type {\n  Json,\n  JsonRpcError,\n  JsonRpcRequest,\n  JsonRpcParams,\n} from '@metamask/utils';\nexport { assert } from '@metamask/utils';\n\nexport * from './errors';\nexport * from './error-wrappers';\nexport * from './images';\nexport * from './types';\nexport * from './ui';\n","import { providerErrors, rpcErrors } from '@metamask/rpc-errors';\n\nimport { createSnapError } from './internals';\n\n/**\n * A JSON-RPC 2.0 Internal (-32603) error.\n *\n * This can be thrown by a Snap to indicate that an internal error occurred,\n * without crashing the Snap.\n *\n * @see https://www.jsonrpc.org/specification#error_object\n */\nexport const InternalError = createSnapError(rpcErrors.internal);\n\n/**\n * An Ethereum JSON-RPC Invalid Input (-32000) error.\n *\n * This can be thrown by a Snap to indicate that the input to a method is\n * invalid, without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport const InvalidInputError = createSnapError(rpcErrors.invalidInput);\n\n/**\n * A JSON-RPC 2.0 Invalid Params (-32602) error.\n *\n * This can be thrown by a Snap to indicate that the parameters to a method are\n * invalid, without crashing the Snap.\n *\n * @see https://www.jsonrpc.org/specification#error_object\n */\nexport const InvalidParamsError = createSnapError(rpcErrors.invalidParams);\n\n/**\n * A JSON-RPC 2.0 Invalid Request (-32600) error.\n *\n * This can be thrown by a Snap to indicate that the request is invalid, without\n * crashing the Snap.\n *\n * @see https://www.jsonrpc.org/specification#error_object\n */\nexport const InvalidRequestError = createSnapError(rpcErrors.invalidRequest);\n\n/**\n * An Ethereum JSON-RPC Limit Exceeded (-32005) error.\n *\n * This can be thrown by a Snap to indicate that a limit has been exceeded,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport const LimitExceededError = createSnapError(rpcErrors.limitExceeded);\n\n/**\n * An Ethereum JSON-RPC Method Not Found (-32601) error.\n *\n * This can be thrown by a Snap to indicate that a method does not exist,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport const MethodNotFoundError = createSnapError(rpcErrors.methodNotFound);\n\n/**\n * An Ethereum JSON-RPC Method Not Supported (-32004) error.\n *\n * This can be thrown by a Snap to indicate that a method is not supported,\n * without crashing the Snap.\n */\nexport const MethodNotSupportedError = createSnapError(\n  rpcErrors.methodNotSupported,\n);\n\n/**\n * A JSON-RPC 2.0 Parse (-32700) error.\n *\n * This can be thrown by a Snap to indicate that a request is not valid JSON,\n * without crashing the Snap.\n *\n * @see https://www.jsonrpc.org/specification#error_object\n */\nexport const ParseError = createSnapError(rpcErrors.parse);\n\n/**\n * An Ethereum JSON-RPC Resource Not Found (-32001) error.\n *\n * This can be thrown by a Snap to indicate that a resource does not exist,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport const ResourceNotFoundError = createSnapError(\n  rpcErrors.resourceNotFound,\n);\n\n/**\n * An Ethereum JSON-RPC Resource Unavailable (-32002) error.\n *\n * This can be thrown by a Snap to indicate that a resource is unavailable,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport const ResourceUnavailableError = createSnapError(\n  rpcErrors.resourceUnavailable,\n);\n\n/**\n * An Ethereum JSON-RPC Transaction Rejected (-32003) error.\n *\n * This can be thrown by a Snap to indicate that a transaction was rejected,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport const TransactionRejected = createSnapError(\n  rpcErrors.transactionRejected,\n);\n\n/**\n * An Ethereum Provider Chain Disconnected (4901) error.\n *\n * This can be thrown by a Snap to indicate that the provider is disconnected\n * from the requested chain, without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport const ChainDisconnectedError = createSnapError(\n  providerErrors.chainDisconnected,\n);\n\n/**\n * An Ethereum Provider Disconnected (4900) error.\n *\n * This can be thrown by a Snap to indicate that the provider is disconnected,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport const DisconnectedError = createSnapError(providerErrors.disconnected);\n\n/**\n * An Ethereum Provider Unauthorized (4100) error.\n *\n * This can be thrown by a Snap to indicate that the requested method / account\n * is not authorized by the user, without crashing the Snap.\n */\nexport const UnauthorizedError = createSnapError(providerErrors.unauthorized);\n\n/**\n * An Ethereum Provider Unsupported Method (4200) error.\n *\n * This can be thrown by a Snap to indicate that the requested method is not\n * supported by the provider, without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport const UnsupportedMethodError = createSnapError(\n  providerErrors.unsupportedMethod,\n);\n\n/**\n * An Ethereum Provider User Rejected Request (4001) error.\n *\n * This can be thrown by a Snap to indicate that the user rejected the request,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport const UserRejectedRequestError = createSnapError(\n  providerErrors.userRejectedRequest,\n);\n","import { assert, bytesToBase64 } from '@metamask/utils';\n\nimport { image } from './ui';\n\n/**\n * Get raw image data from a URL.\n *\n * @param url - The URL to get the image data from.\n * @param options - The options to use when fetching the image data. This is\n * passed directly to `fetch`.\n * @returns A promise that resolves to the image data as a blob.\n */\nasync function getRawImageData(url: string, options?: RequestInit) {\n  if (typeof fetch !== 'function') {\n    throw new Error(\n      `Failed to fetch image data from \"${url}\": Using this function requires the \"endowment:network-access\" permission.`,\n    );\n  }\n\n  return fetch(url, options).then(async (response) => {\n    if (!response.ok) {\n      throw new Error(\n        `Failed to fetch image data from \"${url}\": ${response.status} ${response.statusText}`,\n      );\n    }\n\n    const blob = await response.blob();\n    assert(\n      blob.type === 'image/jpeg' || blob.type === 'image/png',\n      'Expected image data to be a JPEG or PNG image.',\n    );\n\n    return blob;\n  });\n}\n\n/**\n * Get image data as data-string from a URL. This is useful for embedding images\n * inside of SVGs. Only JPEG and PNG images are supported.\n *\n * Note: This function uses `fetch` to get the image data. This means that using\n * it requires the `endowment:network-access` permission.\n *\n * @example\n * const imageData = await getImageData('https://cataas.com/cat');\n * const svg = `\n *   <svg width=\"100\" height=\"100\" xmlns=\"http://www.w3.org/2000/svg\">\n *     <image href=\"${imageData}\" />\n *   </svg>\n * `;\n *\n * // Render the SVG in a Snap UI.\n * const ui = image(svg);\n * @param url - The URL to get the image data from.\n * @param options - The options to use when fetching the image data. This is\n * passed directly to `fetch`.\n * @returns A promise that resolves to the image data as a data-string.\n */\nexport async function getImageData(url: string, options?: RequestInit) {\n  const blob = await getRawImageData(url, options);\n  const bytes = new Uint8Array(await blob.arrayBuffer());\n\n  return `data:${blob.type};base64,${bytesToBase64(bytes)}`;\n}\n\n/**\n * Options for getting an SVG image element from a URL.\n *\n * @property width - The width of the image.\n * @property height - The height of the image. If this is not provided, the\n * width will be used as the height.\n * @property request - The options to use when fetching the image data. This is\n * passed directly to `fetch`.\n */\nexport type ImageOptions = {\n  width: number;\n  height?: number;\n  request?: RequestInit;\n};\n\n/**\n * Get an image component from a URL. This is useful for embedding images inside\n * Snap UIs. Only JPEG and PNG images are supported.\n *\n * Note: This function uses `fetch` to get the image data. This means that using\n * it requires the `endowment:network-access` permission.\n *\n * @example\n * const component = await getImage('https://cataas.com/cat');\n *\n * return await snap.request({\n *   method: 'snap_dialog',\n *   params: {\n *     type: 'alert',\n *     content: panel([\n *       component,\n *     ]),\n *   },\n * });\n * @param url - The URL to get the image data from.\n * @param options - The options to use when fetching and rendering the image.\n * @param options.width - The width of the image.\n * @param options.height - The height of the image. If this is not provided, the\n * width will be used as the height.\n * @param options.request - The options to use when fetching the image data.\n * This is passed directly to `fetch`.\n * @returns A promise that resolves to the image data as an image component.\n */\nexport async function getImageComponent(\n  url: string,\n  { width, height = width, request }: ImageOptions,\n) {\n  assert(\n    typeof width === 'number' && width > 0,\n    'Expected width to be a number greater than 0.',\n  );\n\n  assert(\n    typeof height === 'number' && height > 0,\n    'Expected height to be a number greater than 0.',\n  );\n\n  const imageData = await getImageData(url, request);\n  const size = `width=\"${width}\" height=\"${height}\"`;\n\n  return image(\n    `<svg ${size.trim()} xmlns=\"http://www.w3.org/2000/svg\"><image ${size.trim()} href=\"${imageData}\" /></svg>`,\n  );\n}\n","import { HexChecksumAddressStruct } from '@metamask/utils';\nimport type { Infer } from 'superstruct';\nimport { assign, literal, object } from 'superstruct';\n\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\n\nexport const AddressStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Address),\n    value: HexChecksumAddressStruct,\n  }),\n);\n\n/**\n * A address node, that renders an EVM-like address and its icon.\n *\n * @property type - The type of the node. Must be the string `address`.\n * @property value - The address in hexadecimal, including 0x.\n */\nexport type Address = Infer<typeof AddressStruct>;\n\n/**\n * Create an {@link Address} node.\n *\n * @param args - The node arguments. This can either be a string, or an object\n * with the `value` property.\n * @param args.value - The address to be rendered.\n * @returns The address node as an object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = address({ value: '0x4bbeeb066ed09b7aed07bf39eee0460dfa261520' });\n * const node = address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520');\n */\nexport const address = createBuilder(NodeType.Address, AddressStruct, [\n  'value',\n]);\n","import { assertStruct, isPlainObject } from '@metamask/utils';\nimport type { Struct } from 'superstruct';\n\nimport type { Component } from './components';\nimport type { NodeType } from './nodes';\n\n/**\n * A function that builds a {@link Component}. This infers the proper args type\n * from the given node.\n *\n * @internal\n */\ntype NodeBuilder<Node extends Component, Keys extends (keyof Node)[]> = Omit<\n  Node,\n  'type'\n> extends Record<string, never>\n  ? (...args: []) => Node\n  : (...args: [Omit<Node, 'type'>] | NodeArrayType<Node, Keys>) => Node;\n\n/**\n * Map from an array of node keys to the corresponding array type.\n *\n * @example\n * type Node = { type: 'node'; a: string; b: number; c: boolean };\n * type Keys = ['a', 'b', 'c'];\n *\n * type NodeArray = NodeArrayType<Node, Keys>; // [string, number, boolean]\n * @internal\n */\ntype NodeArrayType<Node extends Component, Keys extends (keyof Node)[]> = {\n  [Key in keyof Keys]: Node[Keys[Key]];\n};\n\n/**\n * A function that returns a function to \"build\" a {@link Component}. It infers\n * the type of the component from the given struct, and performs validation on\n * the created component.\n *\n * The returned function can handle the node arguments in two ways:\n * 1. As a single object, with the keys corresponding to the node's properties,\n * excluding the `type` property.\n * 2. As an array of arguments, with the order corresponding to the given keys.\n *\n * @param type - The type of the component to build.\n * @param struct - The struct to use to validate the component.\n * @param keys - The keys of the component to use as arguments to the builder.\n * The order of the keys determines the order of the arguments.\n * @returns A function that builds a component of the given type.\n * @internal\n */\nexport function createBuilder<\n  Node extends Component,\n  Keys extends (keyof Node)[] = [],\n>(\n  type: NodeType,\n  struct: Struct<Node>,\n  keys: Keys = [] as unknown as Keys,\n): NodeBuilder<Node, Keys> {\n  return (...args: [Omit<Node, 'type'>] | NodeArrayType<Node, Keys> | []) => {\n    // Node passed as a single object.\n    if (args.length === 1 && isPlainObject(args[0])) {\n      const node = { ...args[0], type };\n\n      // The user could be passing invalid values to the builder, so we need to\n      // validate them as per the component's struct.\n      assertStruct(node, struct, `Invalid ${type} component`);\n      return node;\n    }\n\n    // Node passed as an array of arguments.\n    const node = keys.reduce<Partial<Component>>(\n      (partialNode, key, index) => {\n        if (args[index] !== undefined) {\n          return {\n            ...partialNode,\n            [key]: args[index],\n          };\n        }\n\n        return partialNode;\n      },\n      { type },\n    );\n\n    // The user could be passing invalid values to the builder, so we need to\n    // validate them as per the component's struct.\n    assertStruct(node, struct, `Invalid ${type} component`);\n    return node;\n  };\n}\n","import type { Infer } from 'superstruct';\nimport { assign, object, string, unknown } from 'superstruct';\n\n/**\n * The supported node types. This is based on SIP-7.\n *\n * @see https://metamask.github.io/SIPs/SIPS/sip-7\n */\nexport enum NodeType {\n  Copyable = 'copyable',\n  Divider = 'divider',\n  Heading = 'heading',\n  Panel = 'panel',\n  Spinner = 'spinner',\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  Text = 'text',\n  Image = 'image',\n  Row = 'row',\n  Address = 'address',\n  Button = 'button',\n  Input = 'input',\n  Form = 'form',\n}\n\n/**\n * @internal\n */\nexport const NodeStruct = object({\n  type: string(),\n});\n\n/**\n * The base node type. All nodes extend this type.\n *\n * @property type - The type of the node. See {@link NodeType} for the supported\n * node types.\n * @internal\n */\nexport type Node = Infer<typeof NodeStruct>;\n\n/**\n * @internal\n */\nexport const LiteralStruct = assign(\n  NodeStruct,\n  object({\n    value: unknown(),\n  }),\n);\n\n/**\n * A node with a value. This is used for nodes that render a value, such as\n * {@link Text}.\n *\n * @property type - The type of the node.\n * @property value - The value of the node. The type of the value depends on the\n * node type.\n * @internal\n */\nexport type Literal = Infer<typeof LiteralStruct>;\n","import type { Infer } from 'superstruct';\nimport {\n  assign,\n  boolean,\n  literal,\n  object,\n  optional,\n  string,\n} from 'superstruct';\n\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\n\nexport const CopyableStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Copyable),\n    value: string(),\n    sensitive: optional(boolean()),\n  }),\n);\n\n/**\n * Text that can be copied to the clipboard. It can optionally be marked as\n * sensitive, in which case it will only be displayed to the user after clicking\n * on the component.\n *\n * @property type - The type of the node. Must be the string `copyable`.\n * @property value - The text to be copied.\n * @property sensitive - Whether the value is sensitive or not. Sensitive values\n * are only displayed to the user after clicking on the component. Defaults to\n * false.\n */\nexport type Copyable = Infer<typeof CopyableStruct>;\n\n/**\n * Create a {@link Copyable} component.\n *\n * @param args - The node arguments. This can either be a string, or an object\n * with the `text` property.\n * @param args.value - The text to be copied.\n * @param args.sensitive - Whether the value is sensitive or not. Sensitive\n * values are only displayed to the user after clicking on the component.\n * Defaults to false.\n * @returns A {@link Copyable} component.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = copyable('Hello, world!');\n * const node = copyable({ value: 'Hello, world!' });\n */\nexport const copyable = createBuilder(NodeType.Copyable, CopyableStruct, [\n  'value',\n  'sensitive',\n]);\n","import type { Infer } from 'superstruct';\nimport { assign, literal, object } from 'superstruct';\n\nimport { createBuilder } from '../builder';\nimport { NodeStruct, NodeType } from '../nodes';\n\nexport const DividerStruct = assign(\n  NodeStruct,\n  object({\n    type: literal(NodeType.Divider),\n  }),\n);\n\n/**\n * A divider node, that renders a line between other nodes.\n */\nexport type Divider = Infer<typeof DividerStruct>;\n\n/**\n * Create a {@link Divider} node.\n *\n * @returns The divider node as object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = divider();\n */\nexport const divider = createBuilder(NodeType.Divider, DividerStruct);\n","import type { Infer } from 'superstruct';\nimport { assign, literal, object, string } from 'superstruct';\n\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\n\nexport const HeadingStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Heading),\n    value: string(),\n  }),\n);\n\n/**\n * A heading node, that renders the text as a heading. The level of the heading\n * is determined by the depth of the heading in the document.\n *\n * @property type - The type of the node, must be the string 'text'.\n * @property value - The text content of the node, either as plain text, or as a\n * markdown string.\n */\nexport type Heading = Infer<typeof HeadingStruct>;\n\n/**\n * Create a {@link Heading} node.\n *\n * @param args - The node arguments. This can either be a string, or an object\n * with the `value` property.\n * @param args.value - The heading text.\n * @returns The heading node as object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = heading({ value: 'Hello, world!' });\n * const node = heading('Hello, world!');\n */\nexport const heading = createBuilder(NodeType.Heading, HeadingStruct, [\n  'value',\n]);\n","import type { Infer } from 'superstruct';\nimport { assign, literal, object } from 'superstruct';\n\nimport { svg } from '../../internals';\nimport { createBuilder } from '../builder';\nimport { NodeStruct, NodeType } from '../nodes';\n\nexport const ImageStruct = assign(\n  NodeStruct,\n  object({\n    type: literal(NodeType.Image),\n    value: svg(),\n  }),\n);\n\n/**\n * An image node, that renders an SVG image.\n *\n * @property type - The type of the node. Must be the string `image`.\n * @property value - The SVG image to be rendered.\n */\nexport type Image = Infer<typeof ImageStruct>;\n\n/**\n * Create an {@link Image} node.\n *\n * @param args - The node arguments. This can either be a string, or an object\n * with the `value` property.\n * @param args.value - The SVG image to be rendered. Must be a valid SVG string.\n * @returns The image node as object. Other image formats are supported by\n * embedding them as data URLs in the SVG.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = image({ value: '<svg />' });\n * const node = image('<svg />');\n */\nexport const image = createBuilder(NodeType.Image, ImageStruct, ['value']);\n","import type { Infer, Struct } from 'superstruct';\nimport { array, assign, lazy, literal, object, union } from 'superstruct';\n\nimport { createBuilder } from '../builder';\nimport { NodeStruct, NodeType } from '../nodes';\nimport { AddressStruct } from './address';\nimport { ButtonStruct } from './button';\nimport { CopyableStruct } from './copyable';\nimport { DividerStruct } from './divider';\nimport { FormStruct } from './form';\nimport { HeadingStruct } from './heading';\nimport { ImageStruct } from './image';\nimport { InputStruct } from './input';\nimport { RowStruct } from './row';\nimport { SpinnerStruct } from './spinner';\nimport { TextStruct } from './text';\n\n/**\n * @internal\n */\nexport const ParentStruct = assign(\n  NodeStruct,\n  object({\n    // This node references itself indirectly, so we need to use `lazy()`.\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    children: array(lazy(() => ComponentStruct)),\n  }),\n);\n\n/**\n * A node which supports child nodes. This is used for nodes that render their\n * children, such as {@link Panel}.\n *\n * @property type - The type of the node.\n * @property children - The children of the node\n * @internal\n */\nexport type Parent = Infer<typeof ParentStruct>;\n\n/**\n * @internal\n */\nexport const PanelStruct: Struct<Panel> = assign(\n  ParentStruct,\n  object({\n    type: literal(NodeType.Panel),\n  }),\n);\n\n/**\n * A panel node, which renders its children.\n *\n * @property type - The type of the node, must be the string 'text'.\n * @property value - The text content of the node, either as plain text, or as a\n * markdown string.\n */\n// This node references itself indirectly, so it cannot be inferred.\nexport type Panel = {\n  type: NodeType.Panel;\n  children: Component[];\n};\n\n/**\n * Create a {@link Panel} node.\n *\n * @param args - The node arguments. This can be either an array of children, or\n * an object with a `children` property.\n * @param args.children - The child nodes of the panel. This can be any valid\n * {@link Component}.\n * @returns The panel node as object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = panel({\n *  children: [\n *    heading({ text: 'Hello, world!' }),\n *    text({ text: 'This is a panel.' }),\n *  ],\n * });\n *\n * const node = panel([\n *   heading('Hello, world!'),\n *   text('This is a panel.'),\n * ]);\n */\nexport const panel = createBuilder(NodeType.Panel, PanelStruct, ['children']);\n\n// This is defined separately from `Component` to avoid circular dependencies.\nexport const ComponentStruct = union([\n  CopyableStruct,\n  DividerStruct,\n  HeadingStruct,\n  ImageStruct,\n  PanelStruct,\n  SpinnerStruct,\n  TextStruct,\n  RowStruct,\n  AddressStruct,\n  InputStruct,\n  FormStruct,\n  ButtonStruct,\n]);\n\n/**\n * All supported component types.\n */\nexport type Component = Infer<typeof ComponentStruct>;\n","import type { Infer } from 'superstruct';\nimport { assign, literal, object, optional, string, union } from 'superstruct';\n\nimport { enumValue } from '../../internals';\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\n\nexport enum ButtonVariant {\n  Primary = 'primary',\n  Secondary = 'secondary',\n}\n\nexport enum ButtonType {\n  Button = 'button',\n  Submit = 'submit',\n}\n\nexport const ButtonStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Button),\n    value: string(),\n    variant: optional(\n      union([\n        enumValue(ButtonVariant.Primary),\n        enumValue(ButtonVariant.Secondary),\n      ]),\n    ),\n    buttonType: optional(\n      union([enumValue(ButtonType.Button), enumValue(ButtonType.Submit)]),\n    ),\n    name: optional(string()),\n  }),\n);\n\n/**\n * A button node, that renders either a primary or a secondary button.\n *\n * @property type - The type of the node, must be the string 'button'.\n * @property variant - The style variant of the node, must be either 'primary' or 'secondary'.\n * @property value - The text content of the node as plain text.\n * @property buttonType - The type of the button, must be either 'button' or 'submit'.\n * @property name - An optional name to identify the button.\n */\nexport type Button = Infer<typeof ButtonStruct>;\n\n/**\n * Create a {@link Button} node.\n *\n * @param args - The node arguments. This can be either a string, or an object\n * with a `value` property. A set of optional properties can be passed.\n * @param args.variant - The optional variant of the button.\n * @param args.value - The text content of the node.\n * @param args.name - The optional name of the button.\n * @returns The text node as object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * ```typescript\n * const node = button({  variant: 'primary', text: 'Hello, world!', name: 'myButton' });\n * const node = button('Hello, world!', 'button', 'myButton', 'primary');\n * const node = button('Hello, world!');\n * ```\n */\nexport const button = createBuilder(NodeType.Button, ButtonStruct, [\n  'value',\n  'buttonType',\n  'name',\n  'variant',\n]);\n","import type { Infer } from 'superstruct';\nimport { array, assign, literal, object, string, union } from 'superstruct';\n\nimport { createBuilder } from '../builder';\nimport { NodeStruct, NodeType } from '../nodes';\nimport { ButtonStruct } from './button';\nimport { InputStruct } from './input';\n\nexport const FormComponentStruct = union([InputStruct, ButtonStruct]);\n\n/**\n * The subset of nodes allowed as children in the {@link Form} node.\n */\nexport type FormComponent = Infer<typeof FormComponentStruct>;\n\nexport const FormStruct = assign(\n  NodeStruct,\n  object({\n    type: literal(NodeType.Form),\n    children: array(FormComponentStruct),\n    name: string(),\n  }),\n);\n\n/**\n * A form node that takes children {@link FormComponent} nodes and renders a form.\n *\n * @property type - The type of the node. Must be the string `form`.\n * @property children - The children of the node. Only {@link FormComponent} nodes are allowed.\n * @property name - The form name used to identify it.\n */\nexport type Form = Infer<typeof FormStruct>;\n\n/**\n * Create a {@link Form} node.\n *\n * @param args - The node arguments. This can be either an array of children and a string, or\n * an object with a `name` and `children` property.\n * @param args.name - The form name used to identify it.\n * @param args.children - The child nodes of the form. This can be any valid\n * {@link FormComponent}.\n * @returns The form node as object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = form({\n *  name: 'myForm',\n *  children: [\n *    input({ name: 'myInput' }),\n *    button({ value: 'Hello, world!' }),\n *  ],\n * });\n *\n * const node = form('myForm', [input('myInput'), button('Hello, world!')]);\n */\nexport const form = createBuilder(NodeType.Form, FormStruct, [\n  'name',\n  'children',\n]);\n","import type { Infer } from 'superstruct';\nimport { assign, literal, object, optional, string, union } from 'superstruct';\n\nimport { enumValue } from '../../internals';\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\n\n/**\n * This replicates the available input types from the metamask extension.\n * https://github.com/MetaMask/metamask-extension/develop/ui/components/component-library/input/input.constants.js\n */\nexport enum InputType {\n  /* eslint-disable @typescript-eslint/no-shadow */\n  Text = 'text',\n  Number = 'number',\n  /* eslint-enable @typescript-eslint/no-shadow */\n  Password = 'password',\n}\n\nexport const InputStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Input),\n    value: optional(string()),\n    name: string(),\n    inputType: optional(\n      union([\n        enumValue(InputType.Text),\n        enumValue(InputType.Password),\n        enumValue(InputType.Number),\n      ]),\n    ),\n    placeholder: optional(string()),\n    label: optional(string()),\n    error: optional(string()),\n  }),\n);\n\n/**\n * An input node, that renders an input.\n *\n * @property type - The type of the node, must be the string 'input'.\n * @property name - The name for the input.\n * @property value - The value of the input.\n * @property inputType - An optional type, either `text`, `password` or `number`.\n * @property placeholder - An optional input placeholder.\n * @property label - An optional input label.\n * @property error - An optional error text.\n */\nexport type Input = Infer<typeof InputStruct>;\n\n/**\n * Create a {@link Input} node.\n *\n * @param args - The node arguments. This can either be a name and an optional variant, value and placeholder or an object\n * with the properties: `inputType`, `value`, `variant`, `placeholder` and `name`.\n * @param args.name - The name for the input.\n * @param args.value - The value of the input.\n * @param args.inputType - An optional type, either `text`, `password` or `number`.\n * @param args.placeholder - An optional input placeholder.\n * @param args.label - An optional input label.\n * @param args.error - An optional error text.\n * @returns The input node as an object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = input('myInput');\n * const node = input('myInput', InputType.Text, 'my placeholder', 'myValue', 'myLabel');\n * const node = input({ name: 'myInput' });\n * const node = input({name: 'myInput', value: 'myValue', inputType: InputType.Password, placeholder: 'placeholder'})\n */\nexport const input = createBuilder(NodeType.Input, InputStruct, [\n  'name',\n  'inputType',\n  'placeholder',\n  'value',\n  'label',\n]);\n","import type { Infer } from 'superstruct';\nimport { assign, literal, object, string, optional, union } from 'superstruct';\n\nimport { enumValue } from '../../internals';\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\nimport { AddressStruct } from './address';\nimport { ImageStruct } from './image';\nimport { TextStruct } from './text';\n\nexport enum RowVariant {\n  Default = 'default',\n  Critical = 'critical',\n  Warning = 'warning',\n}\n\n// A subset of components made available to the row\nconst RowComponentStruct = union([ImageStruct, TextStruct, AddressStruct]);\n\nexport const RowStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Row),\n    variant: optional(\n      union([\n        enumValue(RowVariant.Default),\n        enumValue(RowVariant.Critical),\n        enumValue(RowVariant.Warning),\n      ]),\n    ),\n    label: string(),\n    value: RowComponentStruct,\n  }),\n);\n\n/**\n * A row node, that renders a row with a label and a value.\n *\n * @property type - The type of the node. Must be the string `row`.\n * @property label - The label for the row.\n * @property value - A sub component to be rendered\n * on one side of the row.\n * @property variant - Optional variant for styling.\n */\nexport type Row = Infer<typeof RowStruct>;\n\n/**\n * Create a {@link Row} node.\n *\n * @param args - The node arguments. This can either be a string, a component and an optional variant or an object\n * with the properties: `label`, `value` and `variant`.\n * @param args.label - The label for the row.\n * @param args.value - Another component, is currently limited to `image`, `text` and `address`.\n * @param args.variant - An optional variant, either `default`, `warning` or `critical`.\n * @returns The row node as an object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = row({ label: 'Address', value: address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520') });\n * const node = row({ label: 'Address', value: address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520'), variant: RowVariant.Warning });\n * const node = row('Address', address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520'));\n * const node = row('Address', address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520'), RowVariant.Warning);\n */\nexport const row = createBuilder(NodeType.Row, RowStruct, [\n  'label',\n  'value',\n  'variant',\n]);\n","import type { Infer } from 'superstruct';\nimport {\n  assign,\n  boolean,\n  literal,\n  object,\n  optional,\n  string,\n} from 'superstruct';\n\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\n\nexport const TextStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Text),\n    value: string(),\n    markdown: optional(boolean()),\n  }),\n);\n\n/**\n * A text node, that renders the text as one or more paragraphs.\n *\n * @property type - The type of the node, must be the string 'text'.\n * @property value - The text content of the node, either as plain text, or as a\n * markdown string.\n * @property markdown - A flag to enable/disable markdown, if nothing is specified\n * markdown will be enabled.\n */\nexport type Text = Infer<typeof TextStruct>;\n\n/**\n * Create a {@link Text} node.\n *\n * @param args - The node arguments. This can be either a string\n * and a boolean, or an object with a `value` property\n * and an optional `markdown` property.\n * @param args.value - The text content of the node.\n * @param args.markdown - An optional flag to enable or disable markdown. This\n * is enabled by default.\n * @returns The text node as object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = text({ value: 'Hello, world!' });\n * const node = text('Hello, world!');\n * const node = text({ value: 'Hello, world!', markdown: false });\n * const node = text('Hello, world!', false);\n */\nexport const text = createBuilder(NodeType.Text, TextStruct, [\n  'value',\n  'markdown',\n]);\n","import type { Infer } from 'superstruct';\nimport { assign, literal, object } from 'superstruct';\n\nimport { createBuilder } from '../builder';\nimport { NodeStruct, NodeType } from '../nodes';\n\nexport const SpinnerStruct = assign(\n  NodeStruct,\n  object({\n    type: literal(NodeType.Spinner),\n  }),\n);\n\n/**\n * A spinner node, that renders a spinner, either as a full-screen overlay, or\n * inline when nested inside a {@link Panel}.\n */\nexport type Spinner = Infer<typeof SpinnerStruct>;\n\n/**\n * Create a {@link Spinner} node.\n *\n * @returns The spinner node as object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = spinner();\n */\nexport const spinner = createBuilder(NodeType.Spinner, SpinnerStruct);\n","import { assertStruct } from '@metamask/utils';\nimport { is } from 'superstruct';\n\nimport { ComponentStruct } from './components';\nimport type { Component } from './components';\n\n/**\n * Check if the given value is a {@link Component}. This performs recursive\n * validation of the component's children (if any).\n *\n * @param value - The value to check.\n * @returns `true` if the value is a {@link Component}, `false` otherwise.\n */\nexport function isComponent(value: unknown): value is Component {\n  return is(value, ComponentStruct);\n}\n\n/**\n * Assert that the given value is a {@link Component}. This performs recursive\n * validation of the component's children (if any).\n *\n * @param value - The value to check.\n * @throws If the value is not a {@link Component}.\n */\nexport function assertIsComponent(value: unknown): asserts value is Component {\n  assertStruct(value, ComponentStruct, 'Invalid component');\n}\n","import type { ComponentOrElement } from '..';\nimport type { EnumToUnion } from '../../internals';\nimport type { ChainId } from '../caip';\n\n/**\n * The severity level of content being returned from a transaction insight.\n * Currently only one level is supported:\n *\n * - `critical` - The transaction is critical and should not be submitted by the\n * user.\n */\nexport enum SeverityLevel {\n  Critical = 'critical',\n}\n\n/**\n * An EIP-1559 (type 2) transaction object.\n *\n * @property from - The address the transaction is being sent from.\n * @property to - The address the transaction is being sent to.\n * @property nonce - The nonce of the transaction.\n * @property value - The value of the transaction.\n * @property data - The data of the transaction.\n * @property gas - The gas limit of the transaction.\n * @property maxFeePerGas - The maximum fee per gas of the transaction.\n * @property maxPriorityFeePerGas - The maximum priority fee per gas of the\n * transaction.\n * @property estimateSuggested - The suggested gas price for the transaction.\n * @property estimateUsed - The gas price used for the transaction.\n * @see https://eips.ethereum.org/EIPS/eip-1559\n */\nexport type EIP1559Transaction = {\n  from: string;\n  to: string;\n  nonce: string;\n  value: string;\n  data: string;\n  gas: string;\n  maxFeePerGas: string;\n  maxPriorityFeePerGas: string;\n  estimateSuggested: string;\n  estimateUsed: string;\n};\n\n/**\n * A legacy (type \"0\") transaction object.\n *\n * @property from - The address the transaction is being sent from.\n * @property to - The address the transaction is being sent to.\n * @property nonce - The nonce of the transaction.\n * @property value - The value of the transaction.\n * @property data - The data of the transaction.\n * @property gas - The gas limit of the transaction.\n * @property gasPrice - The gas price of the transaction.\n * @property estimateSuggested - The suggested gas price for the transaction.\n * @property estimateUsed - The gas price used for the transaction.\n */\nexport type LegacyTransaction = {\n  from: string;\n  to: string;\n  nonce: string;\n  value: string;\n  data: string;\n  gas: string;\n  gasPrice: string;\n  estimateSuggested: string;\n  estimateUsed: string;\n};\n\n/**\n * A transaction object. This can be either an EIP-1559 transaction or a legacy\n * transaction.\n *\n * @see EIP1559Transaction\n * @see LegacyTransaction\n */\nexport type Transaction = EIP1559Transaction | LegacyTransaction;\n\n/**\n * The `onTransaction` handler. This is called whenever a transaction is\n * submitted to the snap. It can return insights about the transaction, which\n * will be displayed to the user.\n *\n * Note that using this handler requires the `endowment:transaction-insights`\n * permission.\n *\n * @param args - The request arguments.\n * @param args.transaction - The transaction object, containing the address,\n * value, data, and other properties of the transaction.\n * @param args.chainId - The CAIP-2 {@link ChainId} of the network the\n * transaction is being submitted to.\n * @param args.transactionOrigin - The origin of the transaction. This is the\n * URL of the website that submitted the transaction. This is only available if\n * the Snap has enabled the `allowTransactionOrigin` option in the\n * `endowment:transaction-insight` permission.\n * @returns An object containing insights about the transaction. See\n * {@link OnTransactionResponse}. Can also return `null` if no insights are\n * available.\n */\nexport type OnTransactionHandler = (args: {\n  transaction: Transaction;\n  chainId: ChainId;\n  transactionOrigin?: string;\n}) => Promise<OnTransactionResponse | null>;\n\n/**\n * The response from a Snap's `onTransaction` handler.\n *\n * @property component - A custom UI component, that will be shown in MetaMask.\n * @property id - A Snap interface ID.\n * @property severity - The severity level of the content. Currently only one\n * level is supported: `critical`.\n */\nexport type OnTransactionResponse =\n  | {\n      content: ComponentOrElement;\n      severity?: EnumToUnion<SeverityLevel>;\n    }\n  | {\n      id: string;\n      severity?: EnumToUnion<SeverityLevel>;\n    };\n","import type { Infer } from 'superstruct';\nimport {\n  number,\n  assign,\n  literal,\n  nullable,\n  object,\n  optional,\n  record,\n  string,\n  union,\n  boolean,\n} from 'superstruct';\n\nimport type { InterfaceContext } from '../interface';\n\n/**\n * The type of user input event fired.\n * Currently only three events are supported:\n *\n * - `ButtonClickEvent` - A button has been clicked in the UI.\n * - `FormSubmitEvent` - A Form has been submitted in the UI.\n * - `InputChangeEvent` - The value of an input field has changed in the UI.\n * - `FileUploadEvent` - A file has been uploaded in the UI.\n */\nexport enum UserInputEventType {\n  ButtonClickEvent = 'ButtonClickEvent',\n  FormSubmitEvent = 'FormSubmitEvent',\n  InputChangeEvent = 'InputChangeEvent',\n  FileUploadEvent = 'FileUploadEvent',\n}\n\nexport const GenericEventStruct = object({\n  type: string(),\n  name: optional(string()),\n});\n\nexport const ButtonClickEventStruct = assign(\n  GenericEventStruct,\n  object({\n    type: literal(UserInputEventType.ButtonClickEvent),\n    name: optional(string()),\n  }),\n);\n\n/**\n * A button click event fired in the UI. This is passed to the params of the\n * `onUserInput` handler.\n *\n * @property type - The type of event fired. See {@link UserInputEventType} for\n * the different types. This is always `ButtonClickEvent`.\n * @property name - The optional component name that fired the event.\n */\nexport type ButtonClickEvent = Infer<typeof ButtonClickEventStruct>;\n\nexport const FileStruct = object({\n  name: string(),\n  size: number(),\n  contentType: string(),\n  contents: string(),\n});\n\n/**\n * A file object containing the file name, size, content type, and the base64\n * encoded contents of the file.\n *\n * @property name - The name of the file.\n * @property size - The size of the file in bytes.\n * @property contentType - The content type of the file.\n * @property contents - The base64 encoded contents of the file.\n */\nexport type File = Infer<typeof FileStruct>;\n\nexport const FormSubmitEventStruct = assign(\n  GenericEventStruct,\n  object({\n    type: literal(UserInputEventType.FormSubmitEvent),\n    value: record(string(), nullable(union([string(), FileStruct, boolean()]))),\n    name: string(),\n  }),\n);\n\n/**\n * A form submit event, which is fired when a submit button is clicked.\n *\n * @property type - The type of event fired. This is always `FormSubmitEvent`.\n * @property name - The name of the form that was submitted.\n * @property value - The form values submitted as an object. The keys are the\n * names of the form fields and the values are the values of the form fields. If\n * a form field is empty, the value is `null` or an empty string.\n * @property files - The files uploaded in the form. The keys are the names of\n * the file input fields and the values are the file objects containing the file\n * name, size, content type, and the base64 encoded contents of the file. See\n * {@link File}.\n */\nexport type FormSubmitEvent = Infer<typeof FormSubmitEventStruct>;\n\nexport const InputChangeEventStruct = assign(\n  GenericEventStruct,\n  object({\n    type: literal(UserInputEventType.InputChangeEvent),\n    name: string(),\n    value: union([string(), boolean()]),\n  }),\n);\n\n/**\n * An input change event, which is fired when the value of an input field\n * changes.\n *\n * @property type - The type of event fired. This is always `InputChangeEvent`.\n * @property name - The name of the input field that changed.\n * @property value - The new value of the input field.\n */\nexport type InputChangeEvent = Infer<typeof InputChangeEventStruct>;\n\nexport const FileUploadEventStruct = assign(\n  GenericEventStruct,\n  object({\n    type: literal(UserInputEventType.FileUploadEvent),\n    name: string(),\n    file: nullable(FileStruct),\n  }),\n);\n\n/**\n * A file upload event, which is fired when a file is uploaded.\n *\n * @property type - The type of event fired. This is always `FileUploadEvent`.\n * @property name - The name of the file input field that was used to upload the\n * file.\n * @property file - The file object containing the file name, size,\n * content type, and the base64 encoded contents of the file.\n * @see File\n */\nexport type FileUploadEvent = Infer<typeof FileUploadEventStruct>;\n\nexport const UserInputEventStruct = union([\n  ButtonClickEventStruct,\n  FormSubmitEventStruct,\n  InputChangeEventStruct,\n  FileUploadEventStruct,\n]);\n\n/**\n * A user input event fired in the UI. This is passed to the params of the `onUserInput` handler.\n *\n * @property type - The type of event fired. See {@link UserInputEventType} for the different types.\n * @property name - The component name that fired the event. It is optional for\n * an {@link UserInputEventType.ButtonClickEvent}.\n * @property value - The value associated with the event. Only available when an\n * {@link UserInputEventType.FormSubmitEvent} is fired. It contains the form values submitted.\n */\nexport type UserInputEvent =\n  | ButtonClickEvent\n  | FormSubmitEvent\n  | InputChangeEvent\n  | FileUploadEvent;\n\n/**\n * The `onUserInput` handler. This is called when an user input event is fired in the UI.\n *\n * @param args - The user input event.\n * @param args.id - The user interface id.\n * @param args.event - The {@link UserInputEvent} object, containing the data about the fired event.\n */\nexport type OnUserInputHandler = (args: {\n  id: string;\n  event: UserInputEvent;\n  context: InterfaceContext | null;\n}) => Promise<void>;\n","import type { ComponentOrElement } from '..';\nimport type { EnumToUnion } from '../../internals';\n\n/**\n * The type of dialog to display.\n *\n * - `alert` - A dialog with a single button.\n * - `confirmation` - A dialog with two buttons, one to confirm and one to\n * cancel.\n * - `prompt` - A dialog with two buttons and a text input.\n */\nexport enum DialogType {\n  Alert = 'alert',\n  Confirmation = 'confirmation',\n  Prompt = 'prompt',\n}\n\n/**\n * An alert dialog.\n *\n * @property type - The type of dialog. Must be `alert`.\n * @property content - The content to display in the dialog.\n * @property id - The Snap interface ID.\n */\nexport type AlertDialog =\n  | {\n      type: EnumToUnion<DialogType.Alert>;\n      content: ComponentOrElement;\n    }\n  | {\n      type: EnumToUnion<DialogType.Alert>;\n      id: string;\n    };\n\n/**\n * A confirmation dialog.\n *\n * @property type - The type of dialog. Must be `confirmation`.\n * @property content - The content to display in the dialog.\n * @property id - The Snap interface ID.\n */\nexport type ConfirmationDialog =\n  | {\n      type: EnumToUnion<DialogType.Confirmation>;\n      content: ComponentOrElement;\n    }\n  | {\n      type: EnumToUnion<DialogType.Confirmation>;\n      id: string;\n    };\n\n/**\n * A prompt dialog.\n *\n * @property type - The type of dialog. Must be `prompt`.\n * @property content - The content to display in the dialog.\n * @property id - The Snap interface ID.\n * @property placeholder - An optional placeholder text to display in the text\n * input.\n */\nexport type PromptDialog =\n  | {\n      type: EnumToUnion<DialogType.Prompt>;\n      content: ComponentOrElement;\n      placeholder?: string;\n    }\n  | {\n      type: EnumToUnion<DialogType.Prompt>;\n      id: string;\n      placeholder?: string;\n    };\n\n/**\n * The request parameters for the `snap_dialog` method.\n *\n * @property type - The type of dialog to display.\n * @property content - The content to display in the dialog.\n * @property id - The Snap interface ID.\n * @property placeholder - The placeholder text to display in the dialog. Only\n * applicable for the `prompt` dialog.\n */\nexport type DialogParams = AlertDialog | ConfirmationDialog | PromptDialog;\n\n/**\n * The result returned by the `snap_dialog` method.\n *\n * - If the dialog is an `alert`, the result is `null`.\n * - If the dialog is a `confirmation`, the result is a boolean indicating\n * whether the user confirmed the dialog.\n * - If the dialog is a `prompt`, the result is the value entered by\n * the user.\n */\nexport type DialogResult = null | boolean | string;\n","import type { EnumToUnion } from '../../internals';\n\n/**\n * The encoding to use when retrieving the file. Defaults to `Base64`.\n */\nexport enum AuxiliaryFileEncoding {\n  Base64 = 'base64',\n  Hex = 'hex',\n  Utf8 = 'utf8',\n}\n\n/**\n * The request parameters for the `snap_getFile` method.\n *\n * @property path - The path to the file to retrieve.\n * @property encoding - The encoding to use when retrieving the file.\n */\nexport type GetFileParams = {\n  path: string;\n  encoding?: EnumToUnion<AuxiliaryFileEncoding>;\n};\n\n/**\n * The result returned by the `snap_getFile` method.\n */\nexport type GetFileResult = string;\n","import type { Json } from '@metamask/utils';\n\nimport type { EnumToUnion } from '../../internals';\n\n/**\n * The operations that can be performed on the state.\n */\nexport enum ManageStateOperation {\n  ClearState = 'clear',\n  GetState = 'get',\n  UpdateState = 'update',\n}\n\n/**\n * The clear state operation, which clears the state.\n *\n * @property operation - The operation to perform on the state. Must be `clear`.\n * @property encrypted - Whether to use the separate encrypted state, or the\n * unencrypted state. Defaults to the encrypted state. Encrypted state can only\n * be used if the extension is unlocked, while unencrypted state can be used\n * whether the extension is locked or unlocked.\n */\nexport type ClearStateOperation = {\n  operation: EnumToUnion<ManageStateOperation.ClearState>;\n  encrypted?: boolean;\n};\n\n/**\n * The get state operation, which retrieves the state.\n *\n * @property operation - The operation to perform on the state. Must be `get`.\n * @property encrypted - Whether to use the separate encrypted state, or the\n * unencrypted state. Defaults to the encrypted state. Encrypted state can only\n * be used if the extension is unlocked, while unencrypted state can be used\n * whether the extension is locked or unlocked.\n */\nexport type GetStateOperation = {\n  operation: EnumToUnion<ManageStateOperation.GetState>;\n  encrypted?: boolean;\n};\n\n/**\n * The update state operation, which updates the state.\n *\n * @property operation - The operation to perform on the state. Must be\n * `update`.\n * @property encrypted - Whether to use the separate encrypted state, or the\n * unencrypted state. Defaults to the encrypted state. Encrypted state can only\n * be used if the extension is unlocked, while unencrypted state can be used\n * whether the extension is locked or unlocked.\n * @property newState - The new state to set.\n */\nexport type UpdateStateOperation = {\n  operation: EnumToUnion<ManageStateOperation.UpdateState>;\n  encrypted?: boolean;\n  newState: Record<string, Json>;\n};\n\n/**\n * The request parameters for the `snap_manageState` method.\n *\n * @property operation - The operation to perform on the state.\n * @property encrypted - Whether to use the separate encrypted state, or the\n * unencrypted state. Defaults to the encrypted state.\n * @property newState - The new state to set. Only applicable for the `set`\n * operation.\n */\nexport type ManageStateParams =\n  | ClearStateOperation\n  | GetStateOperation\n  | UpdateStateOperation;\n\n/**\n * The result returned by the `snap_manageState` method.\n *\n * If the operation is `get`, the result is the state. Otherwise, the result is\n * `null`.\n */\nexport type ManageStateResult = Record<string, Json> | null;\n","import type { EnumToUnion } from '../../internals';\n\n/**\n * The types of notifications that can be displayed.\n *\n * - `InApp` - A notification that is displayed in by the MetaMask extension.\n * - `Native` - A notification that is displayed by the operating system.\n */\nexport enum NotificationType {\n  InApp = 'inApp',\n  Native = 'native',\n}\n\n/**\n * The request parameters for the `snap_notify` method.\n *\n * @property type - The type of notification to display.\n * @property message - The message to display in the notification.\n */\nexport type NotifyParams = {\n  type: EnumToUnion<NotificationType>;\n  message: string;\n};\n\n/**\n * The result returned by the `snap_notify` method.\n *\n * This method does not return anything.\n */\nexport type NotifyResult = null;\n","import { JsonStruct } from '@metamask/utils';\nimport type { Infer } from 'superstruct';\nimport { boolean, nullable, record, string, union } from 'superstruct';\n\nimport type { JSXElement } from '../jsx';\nimport { RootJSXElementStruct } from '../jsx';\nimport type { Component } from '../ui';\nimport { ComponentStruct } from '../ui';\nimport { FileStruct } from './handlers';\n\n/**\n * To avoid typing problems with the interface state when manipulating it we\n * have to differentiate the state of a form (that will be contained inside the\n * root state) and the root state since a key in the root stat can contain\n * either the value of an input or a sub-state of a form.\n */\n\nexport const StateStruct = union([FileStruct, string(), boolean()]);\n\nexport const FormStateStruct = record(string(), nullable(StateStruct));\n\nexport const InterfaceStateStruct = record(\n  string(),\n  union([FormStateStruct, nullable(StateStruct)]),\n);\n\nexport type State = Infer<typeof StateStruct>;\nexport type FormState = Infer<typeof FormStateStruct>;\nexport type InterfaceState = Infer<typeof InterfaceStateStruct>;\n\nexport type ComponentOrElement = Component | JSXElement;\nexport const ComponentOrElementStruct = union([\n  ComponentStruct,\n  RootJSXElementStruct,\n]);\n\nexport const InterfaceContextStruct = record(string(), JsonStruct);\nexport type InterfaceContext = Infer<typeof InterfaceContextStruct>;\n","import {\n  hasProperty,\n  HexChecksumAddressStruct,\n  isPlainObject,\n  JsonStruct,\n} from '@metamask/utils';\nimport type { Infer, Struct } from 'superstruct';\nimport {\n  is,\n  boolean,\n  optional,\n  array,\n  lazy,\n  nullable,\n  number,\n  object,\n  record,\n  string,\n  tuple,\n} from 'superstruct';\nimport type {\n  AnyStruct,\n  InferStructTuple,\n  ObjectSchema,\n} from 'superstruct/dist/utils';\n\nimport type { Describe } from '../internals';\nimport { literal, nullUnion, svg } from '../internals';\nimport type { EmptyObject } from '../types';\nimport type {\n  GenericSnapElement,\n  JsonObject,\n  Key,\n  Nestable,\n  SnapElement,\n  SnapsChildren,\n  StringElement,\n} from './component';\nimport type {\n  AddressElement,\n  BoldElement,\n  BoxElement,\n  ButtonElement,\n  CheckboxElement,\n  CopyableElement,\n  DividerElement,\n  DropdownElement,\n  OptionElement,\n  FieldElement,\n  FormElement,\n  HeadingElement,\n  ImageElement,\n  InputElement,\n  ItalicElement,\n  JSXElement,\n  LinkElement,\n  RowElement,\n  SpinnerElement,\n  StandardFormattingElement,\n  TextElement,\n  TooltipElement,\n  ValueElement,\n  FileInputElement,\n} from './components';\n\n/**\n * A struct for the {@link Key} type.\n */\nexport const KeyStruct: Describe<Key> = nullUnion([string(), number()]);\n\n/**\n * A struct for the {@link StringElement} type.\n */\nexport const StringElementStruct: Describe<StringElement> = children([\n  string(),\n]);\n\n/**\n * A struct for the {@link GenericSnapElement} type.\n */\nexport const ElementStruct: Describe<GenericSnapElement> = object({\n  type: string(),\n  props: record(string(), JsonStruct),\n  key: nullable(KeyStruct),\n});\n\n/**\n * A helper function for creating a struct for a {@link Nestable} type.\n *\n * @param struct - The struct for the type to test.\n * @returns The struct for the nestable type.\n */\nfunction nestable<Type, Schema>(\n  struct: Struct<Type, Schema>,\n): Struct<Nestable<Type>, any> {\n  const nestableStruct: Struct<Nestable<Type>> = nullUnion([\n    struct,\n    array(lazy(() => nestableStruct)),\n  ]);\n\n  return nestableStruct;\n}\n\n/**\n * A helper function for creating a struct which allows children of a specific\n * type, as well as `null` and `boolean`.\n *\n * @param structs - The structs to allow as children.\n * @returns The struct for the children.\n */\nfunction children<Head extends AnyStruct, Tail extends AnyStruct[]>(\n  structs: [head: Head, ...tail: Tail],\n): Struct<\n  Nestable<Infer<Head> | InferStructTuple<Tail>[number] | boolean | null>,\n  null\n> {\n  return nestable(nullable(nullUnion([...structs, boolean()])));\n}\n\n/**\n * A helper function for creating a struct for a JSX element.\n *\n * @param name - The name of the element.\n * @param props - The props of the element.\n * @returns The struct for the element.\n */\nfunction element<Name extends string, Props extends ObjectSchema = EmptyObject>(\n  name: Name,\n  props: Props = {} as Props,\n) {\n  return object({\n    type: literal(name) as unknown as Struct<Name, Name>,\n    props: object(props),\n    key: nullable(KeyStruct),\n  });\n}\n\n/**\n * A struct for the {@link ButtonElement} type.\n */\nexport const ButtonStruct: Describe<ButtonElement> = element('Button', {\n  children: StringElementStruct,\n  name: optional(string()),\n  type: optional(nullUnion([literal('button'), literal('submit')])),\n  variant: optional(nullUnion([literal('primary'), literal('destructive')])),\n  disabled: optional(boolean()),\n});\n\n/**\n * A struct for the {@link CheckboxElement} type.\n */\nexport const CheckboxStruct: Describe<CheckboxElement> = element('Checkbox', {\n  name: string(),\n  checked: optional(boolean()),\n  label: optional(string()),\n  variant: optional(nullUnion([literal('default'), literal('toggle')])),\n});\n\n/**\n * A struct for the {@link InputElement} type.\n */\nexport const InputStruct: Describe<InputElement> = element('Input', {\n  name: string(),\n  type: optional(\n    nullUnion([literal('text'), literal('password'), literal('number')]),\n  ),\n  value: optional(string()),\n  placeholder: optional(string()),\n});\n\n/**\n * A struct for the {@link OptionElement} type.\n */\nexport const OptionStruct: Describe<OptionElement> = element('Option', {\n  value: string(),\n  children: string(),\n});\n\n/**\n * A struct for the {@link DropdownElement} type.\n */\nexport const DropdownStruct: Describe<DropdownElement> = element('Dropdown', {\n  name: string(),\n  value: optional(string()),\n  children: children([OptionStruct]),\n});\n\n/**\n * A struct for the {@link FileInputElement} type.\n */\nexport const FileInputStruct: Describe<FileInputElement> = element(\n  'FileInput',\n  {\n    name: string(),\n    accept: nullUnion([optional(array(string()))]),\n    compact: optional(boolean()),\n  },\n);\n\n/**\n * A struct for the {@link FieldElement} type.\n */\nexport const FieldStruct: Describe<FieldElement> = element('Field', {\n  label: optional(string()),\n  error: optional(string()),\n  children: nullUnion([\n    tuple([InputStruct, ButtonStruct]),\n    DropdownStruct,\n    FileInputStruct,\n    InputStruct,\n    CheckboxStruct,\n  ]),\n});\n\n/**\n * A struct for the {@link FormElement} type.\n */\nexport const FormStruct: Describe<FormElement> = element('Form', {\n  children: children(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    [FieldStruct, lazy(() => BoxChildStruct)],\n  ) as unknown as Struct<SnapsChildren<GenericSnapElement>, null>,\n  name: string(),\n});\n\n/**\n * A struct for the {@link BoldElement} type.\n */\nexport const BoldStruct: Describe<BoldElement> = element('Bold', {\n  children: children([\n    string(),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    lazy(() => ItalicStruct) as unknown as Struct<\n      SnapElement<JsonObject, 'Italic'>\n    >,\n  ]),\n});\n\n/**\n * A struct for the {@link ItalicElement} type.\n */\nexport const ItalicStruct: Describe<ItalicElement> = element('Italic', {\n  children: children([\n    string(),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    lazy(() => BoldStruct) as unknown as Struct<\n      SnapElement<JsonObject, 'Bold'>\n    >,\n  ]),\n});\n\nexport const FormattingStruct: Describe<StandardFormattingElement> = nullUnion([\n  BoldStruct,\n  ItalicStruct,\n]);\n\n/**\n * A struct for the {@link AddressElement} type.\n */\nexport const AddressStruct: Describe<AddressElement> = element('Address', {\n  address: HexChecksumAddressStruct,\n});\n\n/**\n * A struct for the {@link BoxElement} type.\n */\nexport const BoxStruct: Describe<BoxElement> = element('Box', {\n  children: children(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    [lazy(() => BoxChildStruct)],\n  ) as unknown as Struct<SnapsChildren<GenericSnapElement>, null>,\n  direction: optional(nullUnion([literal('horizontal'), literal('vertical')])),\n  alignment: optional(\n    nullUnion([\n      literal('start'),\n      literal('center'),\n      literal('end'),\n      literal('space-between'),\n      literal('space-around'),\n    ]),\n  ),\n});\n\n/**\n * A struct for the {@link CopyableElement} type.\n */\nexport const CopyableStruct: Describe<CopyableElement> = element('Copyable', {\n  value: string(),\n  sensitive: optional(boolean()),\n});\n\n/**\n * A struct for the {@link DividerElement} type.\n */\nexport const DividerStruct: Describe<DividerElement> = element('Divider');\n\n/**\n * A struct for the {@link ValueElement} type.\n */\nexport const ValueStruct: Describe<ValueElement> = element('Value', {\n  value: string(),\n  extra: string(),\n});\n\n/**\n * A struct for the {@link HeadingElement} type.\n */\nexport const HeadingStruct: Describe<HeadingElement> = element('Heading', {\n  children: StringElementStruct,\n});\n\n/**\n * A struct for the {@link ImageElement} type.\n */\nexport const ImageStruct: Describe<ImageElement> = element('Image', {\n  src: svg(),\n  alt: optional(string()),\n});\n\n/**\n * A struct for the {@link LinkElement} type.\n */\nexport const LinkStruct: Describe<LinkElement> = element('Link', {\n  href: string(),\n  children: children([FormattingStruct, string()]),\n});\n\n/**\n * A struct for the {@link TextElement} type.\n */\nexport const TextStruct: Describe<TextElement> = element('Text', {\n  children: children([string(), BoldStruct, ItalicStruct, LinkStruct]),\n  alignment: optional(\n    nullUnion([literal('start'), literal('center'), literal('end')]),\n  ),\n});\n\n/**\n * A subset of JSX elements that are allowed as children of the Tooltip component.\n * This set should include all text components and the Image.\n */\nexport const TooltipChildStruct = nullUnion([\n  TextStruct,\n  BoldStruct,\n  ItalicStruct,\n  LinkStruct,\n  ImageStruct,\n  boolean(),\n]);\n\n/**\n * A subset of JSX elements that are allowed as content of the Tooltip component.\n * This set should include all text components.\n */\nexport const TooltipContentStruct = nullUnion([\n  TextStruct,\n  BoldStruct,\n  ItalicStruct,\n  LinkStruct,\n  string(),\n]);\n\n/**\n * A struct for the {@link TooltipElement} type.\n */\nexport const TooltipStruct: Describe<TooltipElement> = element('Tooltip', {\n  children: nullable(TooltipChildStruct),\n  content: TooltipContentStruct,\n});\n\n/**\n * A struct for the {@link RowElement} type.\n */\nexport const RowStruct: Describe<RowElement> = element('Row', {\n  label: string(),\n  children: nullUnion([AddressStruct, ImageStruct, TextStruct, ValueStruct]),\n  variant: optional(\n    nullUnion([literal('default'), literal('warning'), literal('critical')]),\n  ),\n  tooltip: optional(string()),\n});\n\n/**\n * A struct for the {@link SpinnerElement} type.\n */\nexport const SpinnerStruct: Describe<SpinnerElement> = element('Spinner');\n\n/**\n * A subset of JSX elements that are allowed as children of the Box component.\n * This set includes all components, except components that need to be nested in\n * another component (e.g., Field must be contained in a Form).\n */\nexport const BoxChildStruct = nullUnion([\n  AddressStruct,\n  BoldStruct,\n  BoxStruct,\n  ButtonStruct,\n  CopyableStruct,\n  DividerStruct,\n  DropdownStruct,\n  FileInputStruct,\n  FormStruct,\n  HeadingStruct,\n  InputStruct,\n  ImageStruct,\n  ItalicStruct,\n  LinkStruct,\n  RowStruct,\n  SpinnerStruct,\n  TextStruct,\n  TooltipStruct,\n  CheckboxStruct,\n]);\n\n/**\n * For now, the allowed JSX elements at the root are the same as the allowed\n * children of the Box component.\n */\nexport const RootJSXElementStruct = BoxChildStruct;\n\n/**\n * A struct for the {@link JSXElement} type.\n */\nexport const JSXElementStruct: Describe<JSXElement> = nullUnion([\n  ButtonStruct,\n  InputStruct,\n  FileInputStruct,\n  FieldStruct,\n  FormStruct,\n  BoldStruct,\n  ItalicStruct,\n  AddressStruct,\n  BoxStruct,\n  CopyableStruct,\n  DividerStruct,\n  HeadingStruct,\n  ImageStruct,\n  LinkStruct,\n  RowStruct,\n  SpinnerStruct,\n  TextStruct,\n  DropdownStruct,\n  OptionStruct,\n  ValueStruct,\n  TooltipStruct,\n  CheckboxStruct,\n]);\n\n/**\n * Check if a value is a JSX element.\n *\n * @param value - The value to check.\n * @returns True if the value is a JSX element, false otherwise.\n */\nexport function isJSXElement(value: unknown): value is JSXElement {\n  return is(value, JSXElementStruct);\n}\n\n/**\n * Check if a value is a JSX element, without validating all of its contents.\n * This is useful when you want to validate the structure of a value, but not\n * all the children.\n *\n * This should only be used when you are sure that the value is safe to use,\n * i.e., after using {@link isJSXElement}.\n *\n * @param value - The value to check.\n * @returns True if the value is a JSX element, false otherwise.\n */\nexport function isJSXElementUnsafe(value: unknown): value is JSXElement {\n  return (\n    isPlainObject(value) &&\n    hasProperty(value, 'type') &&\n    hasProperty(value, 'props') &&\n    hasProperty(value, 'key')\n  );\n}\n\n/**\n * Assert that a value is a JSX element.\n *\n * @param value - The value to check.\n * @throws If the value is not a JSX element.\n */\nexport function assertJSXElement(value: unknown): asserts value is JSXElement {\n  // TODO: We should use the error parsing utils from `snaps-utils` to improve\n  // the error messages. It currently includes colours and potentially other\n  // formatting that we might not want to include in the SDK.\n  if (!isJSXElement(value)) {\n    throw new Error(\n      `Expected a JSX element, but received ${JSON.stringify(\n        value,\n      )}. Please refer to the documentation for the supported JSX elements and their props.`,\n    );\n  }\n}\n"],"mappings":"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","names":["error","assert","assign","literal","object","node","string","NodeType","assign","object","literal","assign","literal","object","string","assign","object","literal","string","assign","literal","object","assign","object","literal","assign","literal","object","string","assign","object","literal","string","assign","literal","object","assign","object","literal","array","assign","literal","object","union","assign","literal","object","optional","string","union","ButtonVariant","ButtonType","assign","object","literal","string","optional","union","assign","literal","object","string","union","assign","literal","object","optional","string","union","InputType","assign","object","literal","optional","string","union","union","assign","object","literal","string","assign","literal","object","string","optional","union","assign","boolean","literal","object","optional","string","assign","object","literal","string","optional","boolean","RowVariant","union","assign","object","literal","optional","string","assign","literal","object","assign","object","literal","assign","object","array","literal","union","assertStruct","assertStruct","SeverityLevel","assign","literal","object","optional","string","union","boolean","UserInputEventType","DialogType","AuxiliaryFileEncoding","ManageStateOperation","NotificationType","JsonStruct","boolean","nullable","record","string","union","hasProperty","HexChecksumAddressStruct","isPlainObject","is","boolean","optional","array","lazy","nullable","number","object","record","string","string","number","object","record","nullable","array","lazy","boolean","ButtonStruct","optional","InputStruct","FormStruct","AddressStruct","HexChecksumAddressStruct","CopyableStruct","DividerStruct","HeadingStruct","ImageStruct","TextStruct","RowStruct","SpinnerStruct","union","string","boolean","record","nullable","JsonStruct"]}
\ No newline at end of file
+{"version":3,"sources":["../src/errors.ts","../src/internals/error-wrappers.ts","../src/internals/errors.ts","../src/internals/structs.ts","../src/internals/jsx.ts","../src/internals/svg.ts","../src/index.ts","../src/error-wrappers.ts","../src/images.ts","../src/ui/components/address.ts","../src/ui/builder.ts","../src/ui/nodes.ts","../src/ui/components/copyable.ts","../src/ui/components/divider.ts","../src/ui/components/heading.ts","../src/ui/components/image.ts","../src/ui/components/panel.ts","../src/ui/components/button.ts","../src/ui/components/form.ts","../src/ui/components/input.ts","../src/ui/components/row.ts","../src/ui/components/text.ts","../src/ui/components/spinner.ts","../src/ui/component.ts","../src/types/handlers/transaction.ts","../src/types/handlers/user-input.ts","../src/types/methods/dialog.ts","../src/types/methods/get-file.ts","../src/types/methods/manage-state.ts","../src/types/methods/notify.ts","../src/types/interface.ts","../src/jsx/validation.ts"],"sourcesContent":["import type { Json, JsonRpcError } from '@metamask/utils';\n\nimport {\n  getErrorCode,\n  getErrorData,\n  getErrorMessage,\n  SNAP_ERROR_CODE,\n  SNAP_ERROR_MESSAGE,\n} from './internals';\n\n/**\n * A generic error which can be thrown by a Snap, without it causing the Snap to\n * crash.\n */\nexport class SnapError extends Error {\n  readonly #code: number;\n\n  readonly #message: string;\n\n  readonly #data?: Record<string, Json>;\n\n  readonly #stack?: string;\n\n  /**\n   * Create a new `SnapError`.\n   *\n   * @param error - The error to create the `SnapError` from. If this is a\n   * `string`, it will be used as the error message. If this is an `Error`, its\n   * `message` property will be used as the error message. If this is a\n   * `JsonRpcError`, its `message` property will be used as the error message\n   * and its `code` property will be used as the error code. Otherwise, the\n   * error will be converted to a string and used as the error message.\n   * @param data - Additional data to include in the error. This will be merged\n   * with the error data, if any.\n   */\n  constructor(\n    error: string | Error | JsonRpcError,\n    data: Record<string, Json> = {},\n  ) {\n    const message = getErrorMessage(error);\n    super(message);\n\n    this.#message = message;\n    this.#code = getErrorCode(error);\n\n    const mergedData = { ...getErrorData(error), ...data };\n    if (Object.keys(mergedData).length > 0) {\n      this.#data = mergedData;\n    }\n\n    this.#stack = super.stack;\n  }\n\n  /**\n   * The error name.\n   *\n   * @returns The error name.\n   */\n  get name() {\n    return 'SnapError';\n  }\n\n  /**\n   * The error code.\n   *\n   * @returns The error code.\n   */\n  get code() {\n    return this.#code;\n  }\n\n  /**\n   * The error message.\n   *\n   * @returns The error message.\n   */\n  // This line is covered, but Jest doesn't pick it up for some reason.\n  /* istanbul ignore next */\n  get message() {\n    return this.#message;\n  }\n\n  /**\n   * Additional data for the error.\n   *\n   * @returns Additional data for the error.\n   */\n  get data() {\n    return this.#data;\n  }\n\n  /**\n   * The error stack.\n   *\n   * @returns The error stack.\n   */\n  // This line is covered, but Jest doesn't pick it up for some reason.\n  /* istanbul ignore next */\n  get stack() {\n    return this.#stack;\n  }\n\n  /**\n   * Convert the error to a JSON object.\n   *\n   * @returns The JSON object.\n   */\n  toJSON(): SerializedSnapError {\n    return {\n      code: SNAP_ERROR_CODE,\n      message: SNAP_ERROR_MESSAGE,\n      data: {\n        cause: {\n          code: this.code,\n          message: this.message,\n          stack: this.stack,\n          ...(this.data ? { data: this.data } : {}),\n        },\n      },\n    };\n  }\n\n  /**\n   * Serialize the error to a JSON object. This is called by\n   * `@metamask/rpc-errors` when serializing the error.\n   *\n   * @returns The JSON object.\n   */\n  serialize() {\n    return this.toJSON();\n  }\n}\n\n/**\n * A serialized {@link SnapError}. It's JSON-serializable, so it can be sent\n * over the RPC. The original error is wrapped in the `cause` property.\n *\n * @property code - The error code. This is always `-31002`.\n * @property message - The error message. This is always `'Snap Error'`.\n * @property data - The error data.\n * @property data.cause - The cause of the error.\n * @property data.cause.code - The error code.\n * @property data.cause.message - The error message.\n * @property data.cause.stack - The error stack.\n * @property data.cause.data - Additional data for the error.\n * @see SnapError\n */\nexport type SerializedSnapError = {\n  code: typeof SNAP_ERROR_CODE;\n  message: typeof SNAP_ERROR_MESSAGE;\n  data: {\n    cause: JsonRpcError;\n  };\n};\n","import type { rpcErrors } from '@metamask/rpc-errors';\nimport type { Json } from '@metamask/utils';\n\nimport { SnapError } from '../errors';\n\nexport type JsonRpcErrorFunction = typeof rpcErrors.parse;\n\n/**\n * Create a `SnapError` class from an error function from\n * `@metamask/rpc-errors`. This is useful for creating custom error classes\n * which can be thrown by a Snap.\n *\n * The created class will inherit the message, code, and data properties from\n * the error function.\n *\n * @param fn - The error function to create the class from.\n * @returns The created `SnapError` class.\n */\nexport function createSnapError(fn: JsonRpcErrorFunction) {\n  return class SnapJsonRpcError extends SnapError {\n    /**\n     * Create a new `SnapJsonRpcError` from a message.\n     *\n     * @param message - The message to create the error from.\n     */\n    constructor(message?: string);\n\n    /**\n     * Create a new `SnapJsonRpcError` from data.\n     *\n     * @param data - The data to create the error from.\n     */\n    constructor(data?: Record<string, Json>);\n\n    /**\n     * Create a new `SnapJsonRpcError` from a message and data.\n     *\n     * @param message - The message to create the error from.\n     * @param data - The data to create the error from.\n     */\n    constructor(\n      message?: string | Record<string, Json>,\n      data?: Record<string, Json>,\n    );\n\n    /**\n     * Create a new `SnapJsonRpcError` from a message and data.\n     *\n     * @param message - The message to create the error from.\n     * @param data - The data to create the error from.\n     */\n    constructor(\n      message?: string | Record<string, Json>,\n      data?: Record<string, Json>,\n    ) {\n      if (typeof message === 'object') {\n        const error = fn();\n        super({\n          code: error.code,\n          message: error.message,\n          data: message,\n        });\n\n        return;\n      }\n\n      const error = fn(message);\n      super({\n        code: error.code,\n        message: error.message,\n        data,\n      });\n    }\n  };\n}\n","import { hasProperty, isObject, isValidJson } from '@metamask/utils';\n\nexport const SNAP_ERROR_CODE = -31002;\nexport const SNAP_ERROR_MESSAGE = 'Snap Error';\n\n/**\n * Get the error message from an unknown error type.\n *\n * - If the error is an object with a `message` property, return the message.\n * - Otherwise, return the error converted to a string.\n *\n * @param error - The error to get the message from.\n * @returns The error message.\n * @internal\n */\nexport function getErrorMessage(error: unknown) {\n  if (\n    isObject(error) &&\n    hasProperty(error, 'message') &&\n    typeof error.message === 'string'\n  ) {\n    return error.message;\n  }\n\n  return String(error);\n}\n\n/**\n * Get the error stack from an unknown error type.\n *\n * @param error - The error to get the stack from.\n * @returns The error stack, or undefined if the error does not have a valid\n * stack.\n * @internal\n */\nexport function getErrorStack(error: unknown) {\n  if (\n    isObject(error) &&\n    hasProperty(error, 'stack') &&\n    typeof error.stack === 'string'\n  ) {\n    return error.stack;\n  }\n\n  return undefined;\n}\n\n/**\n * Get the error code from an unknown error type.\n *\n * @param error - The error to get the code from.\n * @returns The error code, or `-32603` if the error does not have a valid code.\n * @internal\n */\nexport function getErrorCode(error: unknown) {\n  if (\n    isObject(error) &&\n    hasProperty(error, 'code') &&\n    typeof error.code === 'number' &&\n    Number.isInteger(error.code)\n  ) {\n    return error.code;\n  }\n\n  return -32603;\n}\n\n/**\n * Get the error data from an unknown error type.\n *\n * @param error - The error to get the data from.\n * @returns The error data, or an empty object if the error does not have valid\n * data.\n * @internal\n */\nexport function getErrorData(error: unknown) {\n  if (\n    isObject(error) &&\n    hasProperty(error, 'data') &&\n    typeof error.data === 'object' &&\n    error.data !== null &&\n    isValidJson(error.data) &&\n    !Array.isArray(error.data)\n  ) {\n    return error.data;\n  }\n\n  return {};\n}\n","import type { Infer } from '@metamask/superstruct';\nimport {\n  Struct,\n  define,\n  literal as superstructLiteral,\n  union as superstructUnion,\n} from '@metamask/superstruct';\nimport type { AnyStruct, InferStructTuple } from '@metamask/superstruct';\n\nimport type { EnumToUnion } from './helpers';\n\n/**\n * A wrapper of `superstruct`'s `literal` struct that also defines the name of\n * the struct as the literal value.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n * For example, instead of returning an error like:\n *\n * ```\n * Expected the value to satisfy a union of `literal | literal`, but received: \\\"baz\\\"\n * ```\n *\n * This struct will return an error like:\n *\n * ```\n * Expected the value to satisfy a union of `\"foo\" | \"bar\"`, but received: \\\"baz\\\"\n * ```\n *\n * @param value - The literal value.\n * @returns The `superstruct` struct, which validates that the value is equal\n * to the literal value.\n */\nexport function literal<Type extends string | number | boolean>(value: Type) {\n  return define<Type>(\n    JSON.stringify(value),\n    superstructLiteral(value).validator,\n  );\n}\n\n/**\n * A wrapper of `superstruct`'s `union` struct that also defines the schema as\n * the union of the schemas of the structs.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n *\n * @param structs - The structs to union.\n * @param structs.\"0\" - The first struct.\n * @param structs.\"1\" - The remaining structs.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function union<Head extends AnyStruct, Tail extends AnyStruct[]>([\n  head,\n  ...tail\n]: [head: Head, ...tail: Tail]): Struct<\n  Infer<Head> | InferStructTuple<Tail>[number],\n  [head: Head, ...tail: Tail]\n> {\n  const struct = superstructUnion([head, ...tail]);\n\n  return new Struct({\n    ...struct,\n    schema: [head, ...tail],\n  });\n}\n\n/**\n * Superstruct struct for validating an enum value. This allows using both the\n * enum string values and the enum itself as values.\n *\n * @param constant - The enum to validate against.\n * @returns The superstruct struct.\n */\nexport function enumValue<Type extends string>(\n  constant: Type,\n): Struct<EnumToUnion<Type>, null> {\n  return literal(constant as EnumToUnion<Type>);\n}\n","import type { Infer, Struct } from '@metamask/superstruct';\nimport type {\n  AnyStruct,\n  EnumSchema,\n  InferStructTuple,\n  IsExactMatch,\n  IsMatch,\n  IsRecord,\n  IsTuple,\n  UnionToIntersection,\n} from '@metamask/superstruct';\n\nimport type { EmptyObject } from '../types';\nimport { union } from './structs';\n\n/**\n * Check if a type is a union. Infers `true` if it is a union, otherwise\n * `false`.\n */\ntype IsUnion<Type> = [Type] extends [UnionToIntersection<Type>] ? false : true;\n\n/**\n * Get a struct schema for a type.\n *\n * This is copied from `superstruct` but fixes some issues with the original\n * implementation.\n */\ntype StructSchema<Type> = IsUnion<Type> extends true\n  ? null\n  : [Type] extends [EmptyObject]\n  ? EmptyObject\n  : [Type] extends [string | undefined | null]\n  ? [Type] extends [`0x${string}`]\n    ? null\n    : [Type] extends [IsMatch<Type, string | undefined | null>]\n    ? null\n    : [Type] extends [IsUnion<Type>]\n    ? EnumSchema<Type>\n    : Type\n  : [Type] extends [number | undefined | null]\n  ? [Type] extends [IsMatch<Type, number | undefined | null>]\n    ? null\n    : [Type] extends [IsUnion<Type>]\n    ? EnumSchema<Type>\n    : Type\n  : [Type] extends [boolean]\n  ? [Type] extends [IsExactMatch<Type, boolean>]\n    ? null\n    : Type\n  : Type extends\n      | bigint\n      | symbol\n      | undefined\n      | null\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      | Function\n      | Date\n      | Error\n      | RegExp\n      | Map<any, any>\n      | WeakMap<any, any>\n      | Set<any>\n      | WeakSet<any>\n      | Promise<any>\n  ? null\n  : Type extends (infer E)[]\n  ? Type extends IsTuple<Type>\n    ? null\n    : Struct<E>\n  : Type extends object\n  ? Type extends IsRecord<Type>\n    ? null\n    : {\n        [InnerKey in keyof Type]: Describe<Type[InnerKey]>;\n      }\n  : null;\n\n/**\n * Describe a struct type.\n */\nexport type Describe<Type> = Struct<Type, StructSchema<Type>>;\n\n/**\n * Create a union struct that uses `null` for the schema type, for better\n * compatibility with `Describe`.\n *\n * @param structs - The structs to union.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function nullUnion<Head extends AnyStruct, Tail extends AnyStruct[]>(\n  structs: [head: Head, ...tail: Tail],\n): Struct<Infer<Head> | InferStructTuple<Tail>[number], null> {\n  return union(structs) as unknown as Struct<\n    Infer<Head> | InferStructTuple<Tail>[number],\n    null\n  >;\n}\n","import { refine, string } from '@metamask/superstruct';\n\n/**\n * Get a Struct that validates a string as a valid SVG.\n *\n * @returns A Struct that validates a string as a valid SVG.\n * @internal\n */\nexport function svg() {\n  return refine(string(), 'SVG', (value) => {\n    // This validation is intentionally very basic, we don't need to be that strict\n    // and merely have this extra validation as a helpful error if devs aren't\n    // passing in SVGs.\n    if (!value.includes('<svg')) {\n      return 'Value is not a valid SVG.';\n    }\n\n    return true;\n  });\n}\n","// Only internals that are used by other Snaps packages should be exported here.\nexport type { EnumToUnion } from './internals';\nexport {\n  getErrorData,\n  getErrorMessage,\n  getErrorStack,\n  SNAP_ERROR_CODE,\n  SNAP_ERROR_MESSAGE,\n  literal,\n  union,\n  enumValue,\n} from './internals';\n\n// Re-exported from `@metamask/utils` for convenience.\nexport type {\n  Json,\n  JsonRpcError,\n  JsonRpcRequest,\n  JsonRpcParams,\n} from '@metamask/utils';\nexport { assert } from '@metamask/utils';\n\nexport * from './errors';\nexport * from './error-wrappers';\nexport * from './images';\nexport * from './types';\nexport * from './ui';\n","import { providerErrors, rpcErrors } from '@metamask/rpc-errors';\n\nimport { createSnapError } from './internals';\n\n/**\n * A JSON-RPC 2.0 Internal (-32603) error.\n *\n * This can be thrown by a Snap to indicate that an internal error occurred,\n * without crashing the Snap.\n *\n * @see https://www.jsonrpc.org/specification#error_object\n */\nexport const InternalError = createSnapError(rpcErrors.internal);\n\n/**\n * An Ethereum JSON-RPC Invalid Input (-32000) error.\n *\n * This can be thrown by a Snap to indicate that the input to a method is\n * invalid, without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport const InvalidInputError = createSnapError(rpcErrors.invalidInput);\n\n/**\n * A JSON-RPC 2.0 Invalid Params (-32602) error.\n *\n * This can be thrown by a Snap to indicate that the parameters to a method are\n * invalid, without crashing the Snap.\n *\n * @see https://www.jsonrpc.org/specification#error_object\n */\nexport const InvalidParamsError = createSnapError(rpcErrors.invalidParams);\n\n/**\n * A JSON-RPC 2.0 Invalid Request (-32600) error.\n *\n * This can be thrown by a Snap to indicate that the request is invalid, without\n * crashing the Snap.\n *\n * @see https://www.jsonrpc.org/specification#error_object\n */\nexport const InvalidRequestError = createSnapError(rpcErrors.invalidRequest);\n\n/**\n * An Ethereum JSON-RPC Limit Exceeded (-32005) error.\n *\n * This can be thrown by a Snap to indicate that a limit has been exceeded,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport const LimitExceededError = createSnapError(rpcErrors.limitExceeded);\n\n/**\n * An Ethereum JSON-RPC Method Not Found (-32601) error.\n *\n * This can be thrown by a Snap to indicate that a method does not exist,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport const MethodNotFoundError = createSnapError(rpcErrors.methodNotFound);\n\n/**\n * An Ethereum JSON-RPC Method Not Supported (-32004) error.\n *\n * This can be thrown by a Snap to indicate that a method is not supported,\n * without crashing the Snap.\n */\nexport const MethodNotSupportedError = createSnapError(\n  rpcErrors.methodNotSupported,\n);\n\n/**\n * A JSON-RPC 2.0 Parse (-32700) error.\n *\n * This can be thrown by a Snap to indicate that a request is not valid JSON,\n * without crashing the Snap.\n *\n * @see https://www.jsonrpc.org/specification#error_object\n */\nexport const ParseError = createSnapError(rpcErrors.parse);\n\n/**\n * An Ethereum JSON-RPC Resource Not Found (-32001) error.\n *\n * This can be thrown by a Snap to indicate that a resource does not exist,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport const ResourceNotFoundError = createSnapError(\n  rpcErrors.resourceNotFound,\n);\n\n/**\n * An Ethereum JSON-RPC Resource Unavailable (-32002) error.\n *\n * This can be thrown by a Snap to indicate that a resource is unavailable,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport const ResourceUnavailableError = createSnapError(\n  rpcErrors.resourceUnavailable,\n);\n\n/**\n * An Ethereum JSON-RPC Transaction Rejected (-32003) error.\n *\n * This can be thrown by a Snap to indicate that a transaction was rejected,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport const TransactionRejected = createSnapError(\n  rpcErrors.transactionRejected,\n);\n\n/**\n * An Ethereum Provider Chain Disconnected (4901) error.\n *\n * This can be thrown by a Snap to indicate that the provider is disconnected\n * from the requested chain, without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport const ChainDisconnectedError = createSnapError(\n  providerErrors.chainDisconnected,\n);\n\n/**\n * An Ethereum Provider Disconnected (4900) error.\n *\n * This can be thrown by a Snap to indicate that the provider is disconnected,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport const DisconnectedError = createSnapError(providerErrors.disconnected);\n\n/**\n * An Ethereum Provider Unauthorized (4100) error.\n *\n * This can be thrown by a Snap to indicate that the requested method / account\n * is not authorized by the user, without crashing the Snap.\n */\nexport const UnauthorizedError = createSnapError(providerErrors.unauthorized);\n\n/**\n * An Ethereum Provider Unsupported Method (4200) error.\n *\n * This can be thrown by a Snap to indicate that the requested method is not\n * supported by the provider, without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport const UnsupportedMethodError = createSnapError(\n  providerErrors.unsupportedMethod,\n);\n\n/**\n * An Ethereum Provider User Rejected Request (4001) error.\n *\n * This can be thrown by a Snap to indicate that the user rejected the request,\n * without crashing the Snap.\n *\n * @see https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport const UserRejectedRequestError = createSnapError(\n  providerErrors.userRejectedRequest,\n);\n","import { assert, bytesToBase64 } from '@metamask/utils';\n\nimport { image } from './ui';\n\n/**\n * Get raw image data from a URL.\n *\n * @param url - The URL to get the image data from.\n * @param options - The options to use when fetching the image data. This is\n * passed directly to `fetch`.\n * @returns A promise that resolves to the image data as a blob.\n */\nasync function getRawImageData(url: string, options?: RequestInit) {\n  if (typeof fetch !== 'function') {\n    throw new Error(\n      `Failed to fetch image data from \"${url}\": Using this function requires the \"endowment:network-access\" permission.`,\n    );\n  }\n\n  return fetch(url, options).then(async (response) => {\n    if (!response.ok) {\n      throw new Error(\n        `Failed to fetch image data from \"${url}\": ${response.status} ${response.statusText}`,\n      );\n    }\n\n    const blob = await response.blob();\n    assert(\n      blob.type === 'image/jpeg' || blob.type === 'image/png',\n      'Expected image data to be a JPEG or PNG image.',\n    );\n\n    return blob;\n  });\n}\n\n/**\n * Get image data as data-string from a URL. This is useful for embedding images\n * inside of SVGs. Only JPEG and PNG images are supported.\n *\n * Note: This function uses `fetch` to get the image data. This means that using\n * it requires the `endowment:network-access` permission.\n *\n * @example\n * const imageData = await getImageData('https://cataas.com/cat');\n * const svg = `\n *   <svg width=\"100\" height=\"100\" xmlns=\"http://www.w3.org/2000/svg\">\n *     <image href=\"${imageData}\" />\n *   </svg>\n * `;\n *\n * // Render the SVG in a Snap UI.\n * const ui = image(svg);\n * @param url - The URL to get the image data from.\n * @param options - The options to use when fetching the image data. This is\n * passed directly to `fetch`.\n * @returns A promise that resolves to the image data as a data-string.\n */\nexport async function getImageData(url: string, options?: RequestInit) {\n  const blob = await getRawImageData(url, options);\n  const bytes = new Uint8Array(await blob.arrayBuffer());\n\n  return `data:${blob.type};base64,${bytesToBase64(bytes)}`;\n}\n\n/**\n * Options for getting an SVG image element from a URL.\n *\n * @property width - The width of the image.\n * @property height - The height of the image. If this is not provided, the\n * width will be used as the height.\n * @property request - The options to use when fetching the image data. This is\n * passed directly to `fetch`.\n */\nexport type ImageOptions = {\n  width: number;\n  height?: number;\n  request?: RequestInit;\n};\n\n/**\n * Get an image component from a URL. This is useful for embedding images inside\n * Snap UIs. Only JPEG and PNG images are supported.\n *\n * Note: This function uses `fetch` to get the image data. This means that using\n * it requires the `endowment:network-access` permission.\n *\n * @example\n * const component = await getImage('https://cataas.com/cat');\n *\n * return await snap.request({\n *   method: 'snap_dialog',\n *   params: {\n *     type: 'alert',\n *     content: panel([\n *       component,\n *     ]),\n *   },\n * });\n * @param url - The URL to get the image data from.\n * @param options - The options to use when fetching and rendering the image.\n * @param options.width - The width of the image.\n * @param options.height - The height of the image. If this is not provided, the\n * width will be used as the height.\n * @param options.request - The options to use when fetching the image data.\n * This is passed directly to `fetch`.\n * @returns A promise that resolves to the image data as an image component.\n */\nexport async function getImageComponent(\n  url: string,\n  { width, height = width, request }: ImageOptions,\n) {\n  assert(\n    typeof width === 'number' && width > 0,\n    'Expected width to be a number greater than 0.',\n  );\n\n  assert(\n    typeof height === 'number' && height > 0,\n    'Expected height to be a number greater than 0.',\n  );\n\n  const imageData = await getImageData(url, request);\n  const size = `width=\"${width}\" height=\"${height}\"`;\n\n  return image(\n    `<svg ${size.trim()} xmlns=\"http://www.w3.org/2000/svg\"><image ${size.trim()} href=\"${imageData}\" /></svg>`,\n  );\n}\n","import { HexChecksumAddressStruct } from '@metamask/utils';\nimport type { Infer } from '@metamask/superstruct';\nimport { assign, literal, object } from '@metamask/superstruct';\n\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\n\nexport const AddressStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Address),\n    value: HexChecksumAddressStruct,\n  }),\n);\n\n/**\n * A address node, that renders an EVM-like address and its icon.\n *\n * @property type - The type of the node. Must be the string `address`.\n * @property value - The address in hexadecimal, including 0x.\n */\nexport type Address = Infer<typeof AddressStruct>;\n\n/**\n * Create an {@link Address} node.\n *\n * @param args - The node arguments. This can either be a string, or an object\n * with the `value` property.\n * @param args.value - The address to be rendered.\n * @returns The address node as an object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = address({ value: '0x4bbeeb066ed09b7aed07bf39eee0460dfa261520' });\n * const node = address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520');\n */\nexport const address = createBuilder(NodeType.Address, AddressStruct, [\n  'value',\n]);\n","import { assertStruct, isPlainObject } from '@metamask/utils';\nimport type { Struct } from '@metamask/superstruct';\n\nimport type { Component } from './components';\nimport type { NodeType } from './nodes';\n\n/**\n * A function that builds a {@link Component}. This infers the proper args type\n * from the given node.\n *\n * @internal\n */\ntype NodeBuilder<Node extends Component, Keys extends (keyof Node)[]> = Omit<\n  Node,\n  'type'\n> extends Record<string, never>\n  ? (...args: []) => Node\n  : (...args: [Omit<Node, 'type'>] | NodeArrayType<Node, Keys>) => Node;\n\n/**\n * Map from an array of node keys to the corresponding array type.\n *\n * @example\n * type Node = { type: 'node'; a: string; b: number; c: boolean };\n * type Keys = ['a', 'b', 'c'];\n *\n * type NodeArray = NodeArrayType<Node, Keys>; // [string, number, boolean]\n * @internal\n */\ntype NodeArrayType<Node extends Component, Keys extends (keyof Node)[]> = {\n  [Key in keyof Keys]: Node[Keys[Key]];\n};\n\n/**\n * A function that returns a function to \"build\" a {@link Component}. It infers\n * the type of the component from the given struct, and performs validation on\n * the created component.\n *\n * The returned function can handle the node arguments in two ways:\n * 1. As a single object, with the keys corresponding to the node's properties,\n * excluding the `type` property.\n * 2. As an array of arguments, with the order corresponding to the given keys.\n *\n * @param type - The type of the component to build.\n * @param struct - The struct to use to validate the component.\n * @param keys - The keys of the component to use as arguments to the builder.\n * The order of the keys determines the order of the arguments.\n * @returns A function that builds a component of the given type.\n * @internal\n */\nexport function createBuilder<\n  Node extends Component,\n  Keys extends (keyof Node)[] = [],\n>(\n  type: NodeType,\n  struct: Struct<Node>,\n  keys: Keys = [] as unknown as Keys,\n): NodeBuilder<Node, Keys> {\n  return (...args: [Omit<Node, 'type'>] | NodeArrayType<Node, Keys> | []) => {\n    // Node passed as a single object.\n    if (args.length === 1 && isPlainObject(args[0])) {\n      const node = { ...args[0], type };\n\n      // The user could be passing invalid values to the builder, so we need to\n      // validate them as per the component's struct.\n      assertStruct(node, struct, `Invalid ${type} component`);\n      return node;\n    }\n\n    // Node passed as an array of arguments.\n    const node = keys.reduce<Partial<Component>>(\n      (partialNode, key, index) => {\n        if (args[index] !== undefined) {\n          return {\n            ...partialNode,\n            [key]: args[index],\n          };\n        }\n\n        return partialNode;\n      },\n      { type },\n    );\n\n    // The user could be passing invalid values to the builder, so we need to\n    // validate them as per the component's struct.\n    assertStruct(node, struct, `Invalid ${type} component`);\n    return node;\n  };\n}\n","import type { Infer } from '@metamask/superstruct';\nimport { assign, object, string, unknown } from '@metamask/superstruct';\n\n/**\n * The supported node types. This is based on SIP-7.\n *\n * @see https://metamask.github.io/SIPs/SIPS/sip-7\n */\nexport enum NodeType {\n  Copyable = 'copyable',\n  Divider = 'divider',\n  Heading = 'heading',\n  Panel = 'panel',\n  Spinner = 'spinner',\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  Text = 'text',\n  Image = 'image',\n  Row = 'row',\n  Address = 'address',\n  Button = 'button',\n  Input = 'input',\n  Form = 'form',\n}\n\n/**\n * @internal\n */\nexport const NodeStruct = object({\n  type: string(),\n});\n\n/**\n * The base node type. All nodes extend this type.\n *\n * @property type - The type of the node. See {@link NodeType} for the supported\n * node types.\n * @internal\n */\nexport type Node = Infer<typeof NodeStruct>;\n\n/**\n * @internal\n */\nexport const LiteralStruct = assign(\n  NodeStruct,\n  object({\n    value: unknown(),\n  }),\n);\n\n/**\n * A node with a value. This is used for nodes that render a value, such as\n * {@link Text}.\n *\n * @property type - The type of the node.\n * @property value - The value of the node. The type of the value depends on the\n * node type.\n * @internal\n */\nexport type Literal = Infer<typeof LiteralStruct>;\n","import type { Infer } from '@metamask/superstruct';\nimport {\n  assign,\n  boolean,\n  literal,\n  object,\n  optional,\n  string,\n} from '@metamask/superstruct';\n\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\n\nexport const CopyableStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Copyable),\n    value: string(),\n    sensitive: optional(boolean()),\n  }),\n);\n\n/**\n * Text that can be copied to the clipboard. It can optionally be marked as\n * sensitive, in which case it will only be displayed to the user after clicking\n * on the component.\n *\n * @property type - The type of the node. Must be the string `copyable`.\n * @property value - The text to be copied.\n * @property sensitive - Whether the value is sensitive or not. Sensitive values\n * are only displayed to the user after clicking on the component. Defaults to\n * false.\n */\nexport type Copyable = Infer<typeof CopyableStruct>;\n\n/**\n * Create a {@link Copyable} component.\n *\n * @param args - The node arguments. This can either be a string, or an object\n * with the `text` property.\n * @param args.value - The text to be copied.\n * @param args.sensitive - Whether the value is sensitive or not. Sensitive\n * values are only displayed to the user after clicking on the component.\n * Defaults to false.\n * @returns A {@link Copyable} component.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = copyable('Hello, world!');\n * const node = copyable({ value: 'Hello, world!' });\n */\nexport const copyable = createBuilder(NodeType.Copyable, CopyableStruct, [\n  'value',\n  'sensitive',\n]);\n","import type { Infer } from '@metamask/superstruct';\nimport { assign, literal, object } from '@metamask/superstruct';\n\nimport { createBuilder } from '../builder';\nimport { NodeStruct, NodeType } from '../nodes';\n\nexport const DividerStruct = assign(\n  NodeStruct,\n  object({\n    type: literal(NodeType.Divider),\n  }),\n);\n\n/**\n * A divider node, that renders a line between other nodes.\n */\nexport type Divider = Infer<typeof DividerStruct>;\n\n/**\n * Create a {@link Divider} node.\n *\n * @returns The divider node as object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = divider();\n */\nexport const divider = createBuilder(NodeType.Divider, DividerStruct);\n","import type { Infer } from '@metamask/superstruct';\nimport { assign, literal, object, string } from '@metamask/superstruct';\n\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\n\nexport const HeadingStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Heading),\n    value: string(),\n  }),\n);\n\n/**\n * A heading node, that renders the text as a heading. The level of the heading\n * is determined by the depth of the heading in the document.\n *\n * @property type - The type of the node, must be the string 'text'.\n * @property value - The text content of the node, either as plain text, or as a\n * markdown string.\n */\nexport type Heading = Infer<typeof HeadingStruct>;\n\n/**\n * Create a {@link Heading} node.\n *\n * @param args - The node arguments. This can either be a string, or an object\n * with the `value` property.\n * @param args.value - The heading text.\n * @returns The heading node as object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = heading({ value: 'Hello, world!' });\n * const node = heading('Hello, world!');\n */\nexport const heading = createBuilder(NodeType.Heading, HeadingStruct, [\n  'value',\n]);\n","import type { Infer } from '@metamask/superstruct';\nimport { assign, literal, object } from '@metamask/superstruct';\n\nimport { svg } from '../../internals';\nimport { createBuilder } from '../builder';\nimport { NodeStruct, NodeType } from '../nodes';\n\nexport const ImageStruct = assign(\n  NodeStruct,\n  object({\n    type: literal(NodeType.Image),\n    value: svg(),\n  }),\n);\n\n/**\n * An image node, that renders an SVG image.\n *\n * @property type - The type of the node. Must be the string `image`.\n * @property value - The SVG image to be rendered.\n */\nexport type Image = Infer<typeof ImageStruct>;\n\n/**\n * Create an {@link Image} node.\n *\n * @param args - The node arguments. This can either be a string, or an object\n * with the `value` property.\n * @param args.value - The SVG image to be rendered. Must be a valid SVG string.\n * @returns The image node as object. Other image formats are supported by\n * embedding them as data URLs in the SVG.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = image({ value: '<svg />' });\n * const node = image('<svg />');\n */\nexport const image = createBuilder(NodeType.Image, ImageStruct, ['value']);\n","import type { Infer, Struct } from '@metamask/superstruct';\nimport { array, assign, lazy, literal, object, union } from '@metamask/superstruct';\n\nimport { createBuilder } from '../builder';\nimport { NodeStruct, NodeType } from '../nodes';\nimport { AddressStruct } from './address';\nimport { ButtonStruct } from './button';\nimport { CopyableStruct } from './copyable';\nimport { DividerStruct } from './divider';\nimport { FormStruct } from './form';\nimport { HeadingStruct } from './heading';\nimport { ImageStruct } from './image';\nimport { InputStruct } from './input';\nimport { RowStruct } from './row';\nimport { SpinnerStruct } from './spinner';\nimport { TextStruct } from './text';\n\n/**\n * @internal\n */\nexport const ParentStruct = assign(\n  NodeStruct,\n  object({\n    // This node references itself indirectly, so we need to use `lazy()`.\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    children: array(lazy(() => ComponentStruct)),\n  }),\n);\n\n/**\n * A node which supports child nodes. This is used for nodes that render their\n * children, such as {@link Panel}.\n *\n * @property type - The type of the node.\n * @property children - The children of the node\n * @internal\n */\nexport type Parent = Infer<typeof ParentStruct>;\n\n/**\n * @internal\n */\nexport const PanelStruct: Struct<Panel> = assign(\n  ParentStruct,\n  object({\n    type: literal(NodeType.Panel),\n  }),\n);\n\n/**\n * A panel node, which renders its children.\n *\n * @property type - The type of the node, must be the string 'text'.\n * @property value - The text content of the node, either as plain text, or as a\n * markdown string.\n */\n// This node references itself indirectly, so it cannot be inferred.\nexport type Panel = {\n  type: NodeType.Panel;\n  children: Component[];\n};\n\n/**\n * Create a {@link Panel} node.\n *\n * @param args - The node arguments. This can be either an array of children, or\n * an object with a `children` property.\n * @param args.children - The child nodes of the panel. This can be any valid\n * {@link Component}.\n * @returns The panel node as object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = panel({\n *  children: [\n *    heading({ text: 'Hello, world!' }),\n *    text({ text: 'This is a panel.' }),\n *  ],\n * });\n *\n * const node = panel([\n *   heading('Hello, world!'),\n *   text('This is a panel.'),\n * ]);\n */\nexport const panel = createBuilder(NodeType.Panel, PanelStruct, ['children']);\n\n// This is defined separately from `Component` to avoid circular dependencies.\nexport const ComponentStruct = union([\n  CopyableStruct,\n  DividerStruct,\n  HeadingStruct,\n  ImageStruct,\n  PanelStruct,\n  SpinnerStruct,\n  TextStruct,\n  RowStruct,\n  AddressStruct,\n  InputStruct,\n  FormStruct,\n  ButtonStruct,\n]);\n\n/**\n * All supported component types.\n */\nexport type Component = Infer<typeof ComponentStruct>;\n","import type { Infer } from '@metamask/superstruct';\nimport { assign, literal, object, optional, string, union } from '@metamask/superstruct';\n\nimport { enumValue } from '../../internals';\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\n\nexport enum ButtonVariant {\n  Primary = 'primary',\n  Secondary = 'secondary',\n}\n\nexport enum ButtonType {\n  Button = 'button',\n  Submit = 'submit',\n}\n\nexport const ButtonStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Button),\n    value: string(),\n    variant: optional(\n      union([\n        enumValue(ButtonVariant.Primary),\n        enumValue(ButtonVariant.Secondary),\n      ]),\n    ),\n    buttonType: optional(\n      union([enumValue(ButtonType.Button), enumValue(ButtonType.Submit)]),\n    ),\n    name: optional(string()),\n  }),\n);\n\n/**\n * A button node, that renders either a primary or a secondary button.\n *\n * @property type - The type of the node, must be the string 'button'.\n * @property variant - The style variant of the node, must be either 'primary' or 'secondary'.\n * @property value - The text content of the node as plain text.\n * @property buttonType - The type of the button, must be either 'button' or 'submit'.\n * @property name - An optional name to identify the button.\n */\nexport type Button = Infer<typeof ButtonStruct>;\n\n/**\n * Create a {@link Button} node.\n *\n * @param args - The node arguments. This can be either a string, or an object\n * with a `value` property. A set of optional properties can be passed.\n * @param args.variant - The optional variant of the button.\n * @param args.value - The text content of the node.\n * @param args.name - The optional name of the button.\n * @returns The text node as object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * ```typescript\n * const node = button({  variant: 'primary', text: 'Hello, world!', name: 'myButton' });\n * const node = button('Hello, world!', 'button', 'myButton', 'primary');\n * const node = button('Hello, world!');\n * ```\n */\nexport const button = createBuilder(NodeType.Button, ButtonStruct, [\n  'value',\n  'buttonType',\n  'name',\n  'variant',\n]);\n","import type { Infer } from '@metamask/superstruct';\nimport { array, assign, literal, object, string, union } from '@metamask/superstruct';\n\nimport { createBuilder } from '../builder';\nimport { NodeStruct, NodeType } from '../nodes';\nimport { ButtonStruct } from './button';\nimport { InputStruct } from './input';\n\nexport const FormComponentStruct = union([InputStruct, ButtonStruct]);\n\n/**\n * The subset of nodes allowed as children in the {@link Form} node.\n */\nexport type FormComponent = Infer<typeof FormComponentStruct>;\n\nexport const FormStruct = assign(\n  NodeStruct,\n  object({\n    type: literal(NodeType.Form),\n    children: array(FormComponentStruct),\n    name: string(),\n  }),\n);\n\n/**\n * A form node that takes children {@link FormComponent} nodes and renders a form.\n *\n * @property type - The type of the node. Must be the string `form`.\n * @property children - The children of the node. Only {@link FormComponent} nodes are allowed.\n * @property name - The form name used to identify it.\n */\nexport type Form = Infer<typeof FormStruct>;\n\n/**\n * Create a {@link Form} node.\n *\n * @param args - The node arguments. This can be either an array of children and a string, or\n * an object with a `name` and `children` property.\n * @param args.name - The form name used to identify it.\n * @param args.children - The child nodes of the form. This can be any valid\n * {@link FormComponent}.\n * @returns The form node as object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = form({\n *  name: 'myForm',\n *  children: [\n *    input({ name: 'myInput' }),\n *    button({ value: 'Hello, world!' }),\n *  ],\n * });\n *\n * const node = form('myForm', [input('myInput'), button('Hello, world!')]);\n */\nexport const form = createBuilder(NodeType.Form, FormStruct, [\n  'name',\n  'children',\n]);\n","import type { Infer } from '@metamask/superstruct';\nimport { assign, literal, object, optional, string, union } from '@metamask/superstruct';\n\nimport { enumValue } from '../../internals';\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\n\n/**\n * This replicates the available input types from the metamask extension.\n * https://github.com/MetaMask/metamask-extension/develop/ui/components/component-library/input/input.constants.js\n */\nexport enum InputType {\n  /* eslint-disable @typescript-eslint/no-shadow */\n  Text = 'text',\n  Number = 'number',\n  /* eslint-enable @typescript-eslint/no-shadow */\n  Password = 'password',\n}\n\nexport const InputStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Input),\n    value: optional(string()),\n    name: string(),\n    inputType: optional(\n      union([\n        enumValue(InputType.Text),\n        enumValue(InputType.Password),\n        enumValue(InputType.Number),\n      ]),\n    ),\n    placeholder: optional(string()),\n    label: optional(string()),\n    error: optional(string()),\n  }),\n);\n\n/**\n * An input node, that renders an input.\n *\n * @property type - The type of the node, must be the string 'input'.\n * @property name - The name for the input.\n * @property value - The value of the input.\n * @property inputType - An optional type, either `text`, `password` or `number`.\n * @property placeholder - An optional input placeholder.\n * @property label - An optional input label.\n * @property error - An optional error text.\n */\nexport type Input = Infer<typeof InputStruct>;\n\n/**\n * Create a {@link Input} node.\n *\n * @param args - The node arguments. This can either be a name and an optional variant, value and placeholder or an object\n * with the properties: `inputType`, `value`, `variant`, `placeholder` and `name`.\n * @param args.name - The name for the input.\n * @param args.value - The value of the input.\n * @param args.inputType - An optional type, either `text`, `password` or `number`.\n * @param args.placeholder - An optional input placeholder.\n * @param args.label - An optional input label.\n * @param args.error - An optional error text.\n * @returns The input node as an object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = input('myInput');\n * const node = input('myInput', InputType.Text, 'my placeholder', 'myValue', 'myLabel');\n * const node = input({ name: 'myInput' });\n * const node = input({name: 'myInput', value: 'myValue', inputType: InputType.Password, placeholder: 'placeholder'})\n */\nexport const input = createBuilder(NodeType.Input, InputStruct, [\n  'name',\n  'inputType',\n  'placeholder',\n  'value',\n  'label',\n]);\n","import type { Infer } from '@metamask/superstruct';\nimport { assign, literal, object, string, optional, union } from '@metamask/superstruct';\n\nimport { enumValue } from '../../internals';\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\nimport { AddressStruct } from './address';\nimport { ImageStruct } from './image';\nimport { TextStruct } from './text';\n\nexport enum RowVariant {\n  Default = 'default',\n  Critical = 'critical',\n  Warning = 'warning',\n}\n\n// A subset of components made available to the row\nconst RowComponentStruct = union([ImageStruct, TextStruct, AddressStruct]);\n\nexport const RowStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Row),\n    variant: optional(\n      union([\n        enumValue(RowVariant.Default),\n        enumValue(RowVariant.Critical),\n        enumValue(RowVariant.Warning),\n      ]),\n    ),\n    label: string(),\n    value: RowComponentStruct,\n  }),\n);\n\n/**\n * A row node, that renders a row with a label and a value.\n *\n * @property type - The type of the node. Must be the string `row`.\n * @property label - The label for the row.\n * @property value - A sub component to be rendered\n * on one side of the row.\n * @property variant - Optional variant for styling.\n */\nexport type Row = Infer<typeof RowStruct>;\n\n/**\n * Create a {@link Row} node.\n *\n * @param args - The node arguments. This can either be a string, a component and an optional variant or an object\n * with the properties: `label`, `value` and `variant`.\n * @param args.label - The label for the row.\n * @param args.value - Another component, is currently limited to `image`, `text` and `address`.\n * @param args.variant - An optional variant, either `default`, `warning` or `critical`.\n * @returns The row node as an object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = row({ label: 'Address', value: address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520') });\n * const node = row({ label: 'Address', value: address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520'), variant: RowVariant.Warning });\n * const node = row('Address', address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520'));\n * const node = row('Address', address('0x4bbeeb066ed09b7aed07bf39eee0460dfa261520'), RowVariant.Warning);\n */\nexport const row = createBuilder(NodeType.Row, RowStruct, [\n  'label',\n  'value',\n  'variant',\n]);\n","import type { Infer } from '@metamask/superstruct';\nimport {\n  assign,\n  boolean,\n  literal,\n  object,\n  optional,\n  string,\n} from '@metamask/superstruct';\n\nimport { createBuilder } from '../builder';\nimport { LiteralStruct, NodeType } from '../nodes';\n\nexport const TextStruct = assign(\n  LiteralStruct,\n  object({\n    type: literal(NodeType.Text),\n    value: string(),\n    markdown: optional(boolean()),\n  }),\n);\n\n/**\n * A text node, that renders the text as one or more paragraphs.\n *\n * @property type - The type of the node, must be the string 'text'.\n * @property value - The text content of the node, either as plain text, or as a\n * markdown string.\n * @property markdown - A flag to enable/disable markdown, if nothing is specified\n * markdown will be enabled.\n */\nexport type Text = Infer<typeof TextStruct>;\n\n/**\n * Create a {@link Text} node.\n *\n * @param args - The node arguments. This can be either a string\n * and a boolean, or an object with a `value` property\n * and an optional `markdown` property.\n * @param args.value - The text content of the node.\n * @param args.markdown - An optional flag to enable or disable markdown. This\n * is enabled by default.\n * @returns The text node as object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = text({ value: 'Hello, world!' });\n * const node = text('Hello, world!');\n * const node = text({ value: 'Hello, world!', markdown: false });\n * const node = text('Hello, world!', false);\n */\nexport const text = createBuilder(NodeType.Text, TextStruct, [\n  'value',\n  'markdown',\n]);\n","import type { Infer } from '@metamask/superstruct';\nimport { assign, literal, object } from '@metamask/superstruct';\n\nimport { createBuilder } from '../builder';\nimport { NodeStruct, NodeType } from '../nodes';\n\nexport const SpinnerStruct = assign(\n  NodeStruct,\n  object({\n    type: literal(NodeType.Spinner),\n  }),\n);\n\n/**\n * A spinner node, that renders a spinner, either as a full-screen overlay, or\n * inline when nested inside a {@link Panel}.\n */\nexport type Spinner = Infer<typeof SpinnerStruct>;\n\n/**\n * Create a {@link Spinner} node.\n *\n * @returns The spinner node as object.\n * @deprecated Snaps component functions are deprecated, in favor of the new JSX\n * components. This function will be removed in a future release.\n * @example\n * const node = spinner();\n */\nexport const spinner = createBuilder(NodeType.Spinner, SpinnerStruct);\n","import { assertStruct } from '@metamask/utils';\nimport { is } from '@metamask/superstruct';\n\nimport { ComponentStruct } from './components';\nimport type { Component } from './components';\n\n/**\n * Check if the given value is a {@link Component}. This performs recursive\n * validation of the component's children (if any).\n *\n * @param value - The value to check.\n * @returns `true` if the value is a {@link Component}, `false` otherwise.\n */\nexport function isComponent(value: unknown): value is Component {\n  return is(value, ComponentStruct);\n}\n\n/**\n * Assert that the given value is a {@link Component}. This performs recursive\n * validation of the component's children (if any).\n *\n * @param value - The value to check.\n * @throws If the value is not a {@link Component}.\n */\nexport function assertIsComponent(value: unknown): asserts value is Component {\n  assertStruct(value, ComponentStruct, 'Invalid component');\n}\n","import type { ComponentOrElement } from '..';\nimport type { EnumToUnion } from '../../internals';\nimport type { ChainId } from '../caip';\n\n/**\n * The severity level of content being returned from a transaction insight.\n * Currently only one level is supported:\n *\n * - `critical` - The transaction is critical and should not be submitted by the\n * user.\n */\nexport enum SeverityLevel {\n  Critical = 'critical',\n}\n\n/**\n * An EIP-1559 (type 2) transaction object.\n *\n * @property from - The address the transaction is being sent from.\n * @property to - The address the transaction is being sent to.\n * @property nonce - The nonce of the transaction.\n * @property value - The value of the transaction.\n * @property data - The data of the transaction.\n * @property gas - The gas limit of the transaction.\n * @property maxFeePerGas - The maximum fee per gas of the transaction.\n * @property maxPriorityFeePerGas - The maximum priority fee per gas of the\n * transaction.\n * @property estimateSuggested - The suggested gas price for the transaction.\n * @property estimateUsed - The gas price used for the transaction.\n * @see https://eips.ethereum.org/EIPS/eip-1559\n */\nexport type EIP1559Transaction = {\n  from: string;\n  to: string;\n  nonce: string;\n  value: string;\n  data: string;\n  gas: string;\n  maxFeePerGas: string;\n  maxPriorityFeePerGas: string;\n  estimateSuggested: string;\n  estimateUsed: string;\n};\n\n/**\n * A legacy (type \"0\") transaction object.\n *\n * @property from - The address the transaction is being sent from.\n * @property to - The address the transaction is being sent to.\n * @property nonce - The nonce of the transaction.\n * @property value - The value of the transaction.\n * @property data - The data of the transaction.\n * @property gas - The gas limit of the transaction.\n * @property gasPrice - The gas price of the transaction.\n * @property estimateSuggested - The suggested gas price for the transaction.\n * @property estimateUsed - The gas price used for the transaction.\n */\nexport type LegacyTransaction = {\n  from: string;\n  to: string;\n  nonce: string;\n  value: string;\n  data: string;\n  gas: string;\n  gasPrice: string;\n  estimateSuggested: string;\n  estimateUsed: string;\n};\n\n/**\n * A transaction object. This can be either an EIP-1559 transaction or a legacy\n * transaction.\n *\n * @see EIP1559Transaction\n * @see LegacyTransaction\n */\nexport type Transaction = EIP1559Transaction | LegacyTransaction;\n\n/**\n * The `onTransaction` handler. This is called whenever a transaction is\n * submitted to the snap. It can return insights about the transaction, which\n * will be displayed to the user.\n *\n * Note that using this handler requires the `endowment:transaction-insights`\n * permission.\n *\n * @param args - The request arguments.\n * @param args.transaction - The transaction object, containing the address,\n * value, data, and other properties of the transaction.\n * @param args.chainId - The CAIP-2 {@link ChainId} of the network the\n * transaction is being submitted to.\n * @param args.transactionOrigin - The origin of the transaction. This is the\n * URL of the website that submitted the transaction. This is only available if\n * the Snap has enabled the `allowTransactionOrigin` option in the\n * `endowment:transaction-insight` permission.\n * @returns An object containing insights about the transaction. See\n * {@link OnTransactionResponse}. Can also return `null` if no insights are\n * available.\n */\nexport type OnTransactionHandler = (args: {\n  transaction: Transaction;\n  chainId: ChainId;\n  transactionOrigin?: string;\n}) => Promise<OnTransactionResponse | null>;\n\n/**\n * The response from a Snap's `onTransaction` handler.\n *\n * @property component - A custom UI component, that will be shown in MetaMask.\n * @property id - A Snap interface ID.\n * @property severity - The severity level of the content. Currently only one\n * level is supported: `critical`.\n */\nexport type OnTransactionResponse =\n  | {\n      content: ComponentOrElement;\n      severity?: EnumToUnion<SeverityLevel>;\n    }\n  | {\n      id: string;\n      severity?: EnumToUnion<SeverityLevel>;\n    };\n","import type { Infer } from '@metamask/superstruct';\nimport {\n  number,\n  assign,\n  literal,\n  nullable,\n  object,\n  optional,\n  record,\n  string,\n  union,\n  boolean,\n} from '@metamask/superstruct';\n\nimport type { InterfaceContext } from '../interface';\n\n/**\n * The type of user input event fired.\n * Currently only three events are supported:\n *\n * - `ButtonClickEvent` - A button has been clicked in the UI.\n * - `FormSubmitEvent` - A Form has been submitted in the UI.\n * - `InputChangeEvent` - The value of an input field has changed in the UI.\n * - `FileUploadEvent` - A file has been uploaded in the UI.\n */\nexport enum UserInputEventType {\n  ButtonClickEvent = 'ButtonClickEvent',\n  FormSubmitEvent = 'FormSubmitEvent',\n  InputChangeEvent = 'InputChangeEvent',\n  FileUploadEvent = 'FileUploadEvent',\n}\n\nexport const GenericEventStruct = object({\n  type: string(),\n  name: optional(string()),\n});\n\nexport const ButtonClickEventStruct = assign(\n  GenericEventStruct,\n  object({\n    type: literal(UserInputEventType.ButtonClickEvent),\n    name: optional(string()),\n  }),\n);\n\n/**\n * A button click event fired in the UI. This is passed to the params of the\n * `onUserInput` handler.\n *\n * @property type - The type of event fired. See {@link UserInputEventType} for\n * the different types. This is always `ButtonClickEvent`.\n * @property name - The optional component name that fired the event.\n */\nexport type ButtonClickEvent = Infer<typeof ButtonClickEventStruct>;\n\nexport const FileStruct = object({\n  name: string(),\n  size: number(),\n  contentType: string(),\n  contents: string(),\n});\n\n/**\n * A file object containing the file name, size, content type, and the base64\n * encoded contents of the file.\n *\n * @property name - The name of the file.\n * @property size - The size of the file in bytes.\n * @property contentType - The content type of the file.\n * @property contents - The base64 encoded contents of the file.\n */\nexport type File = Infer<typeof FileStruct>;\n\nexport const FormSubmitEventStruct = assign(\n  GenericEventStruct,\n  object({\n    type: literal(UserInputEventType.FormSubmitEvent),\n    value: record(string(), nullable(union([string(), FileStruct, boolean()]))),\n    name: string(),\n  }),\n);\n\n/**\n * A form submit event, which is fired when a submit button is clicked.\n *\n * @property type - The type of event fired. This is always `FormSubmitEvent`.\n * @property name - The name of the form that was submitted.\n * @property value - The form values submitted as an object. The keys are the\n * names of the form fields and the values are the values of the form fields. If\n * a form field is empty, the value is `null` or an empty string.\n * @property files - The files uploaded in the form. The keys are the names of\n * the file input fields and the values are the file objects containing the file\n * name, size, content type, and the base64 encoded contents of the file. See\n * {@link File}.\n */\nexport type FormSubmitEvent = Infer<typeof FormSubmitEventStruct>;\n\nexport const InputChangeEventStruct = assign(\n  GenericEventStruct,\n  object({\n    type: literal(UserInputEventType.InputChangeEvent),\n    name: string(),\n    value: union([string(), boolean()]),\n  }),\n);\n\n/**\n * An input change event, which is fired when the value of an input field\n * changes.\n *\n * @property type - The type of event fired. This is always `InputChangeEvent`.\n * @property name - The name of the input field that changed.\n * @property value - The new value of the input field.\n */\nexport type InputChangeEvent = Infer<typeof InputChangeEventStruct>;\n\nexport const FileUploadEventStruct = assign(\n  GenericEventStruct,\n  object({\n    type: literal(UserInputEventType.FileUploadEvent),\n    name: string(),\n    file: nullable(FileStruct),\n  }),\n);\n\n/**\n * A file upload event, which is fired when a file is uploaded.\n *\n * @property type - The type of event fired. This is always `FileUploadEvent`.\n * @property name - The name of the file input field that was used to upload the\n * file.\n * @property file - The file object containing the file name, size,\n * content type, and the base64 encoded contents of the file.\n * @see File\n */\nexport type FileUploadEvent = Infer<typeof FileUploadEventStruct>;\n\nexport const UserInputEventStruct = union([\n  ButtonClickEventStruct,\n  FormSubmitEventStruct,\n  InputChangeEventStruct,\n  FileUploadEventStruct,\n]);\n\n/**\n * A user input event fired in the UI. This is passed to the params of the `onUserInput` handler.\n *\n * @property type - The type of event fired. See {@link UserInputEventType} for the different types.\n * @property name - The component name that fired the event. It is optional for\n * an {@link UserInputEventType.ButtonClickEvent}.\n * @property value - The value associated with the event. Only available when an\n * {@link UserInputEventType.FormSubmitEvent} is fired. It contains the form values submitted.\n */\nexport type UserInputEvent =\n  | ButtonClickEvent\n  | FormSubmitEvent\n  | InputChangeEvent\n  | FileUploadEvent;\n\n/**\n * The `onUserInput` handler. This is called when an user input event is fired in the UI.\n *\n * @param args - The user input event.\n * @param args.id - The user interface id.\n * @param args.event - The {@link UserInputEvent} object, containing the data about the fired event.\n */\nexport type OnUserInputHandler = (args: {\n  id: string;\n  event: UserInputEvent;\n  context: InterfaceContext | null;\n}) => Promise<void>;\n","import type { ComponentOrElement } from '..';\nimport type { EnumToUnion } from '../../internals';\n\n/**\n * The type of dialog to display.\n *\n * - `alert` - A dialog with a single button.\n * - `confirmation` - A dialog with two buttons, one to confirm and one to\n * cancel.\n * - `prompt` - A dialog with two buttons and a text input.\n */\nexport enum DialogType {\n  Alert = 'alert',\n  Confirmation = 'confirmation',\n  Prompt = 'prompt',\n}\n\n/**\n * An alert dialog.\n *\n * @property type - The type of dialog. Must be `alert`.\n * @property content - The content to display in the dialog.\n * @property id - The Snap interface ID.\n */\nexport type AlertDialog =\n  | {\n      type: EnumToUnion<DialogType.Alert>;\n      content: ComponentOrElement;\n    }\n  | {\n      type: EnumToUnion<DialogType.Alert>;\n      id: string;\n    };\n\n/**\n * A confirmation dialog.\n *\n * @property type - The type of dialog. Must be `confirmation`.\n * @property content - The content to display in the dialog.\n * @property id - The Snap interface ID.\n */\nexport type ConfirmationDialog =\n  | {\n      type: EnumToUnion<DialogType.Confirmation>;\n      content: ComponentOrElement;\n    }\n  | {\n      type: EnumToUnion<DialogType.Confirmation>;\n      id: string;\n    };\n\n/**\n * A prompt dialog.\n *\n * @property type - The type of dialog. Must be `prompt`.\n * @property content - The content to display in the dialog.\n * @property id - The Snap interface ID.\n * @property placeholder - An optional placeholder text to display in the text\n * input.\n */\nexport type PromptDialog =\n  | {\n      type: EnumToUnion<DialogType.Prompt>;\n      content: ComponentOrElement;\n      placeholder?: string;\n    }\n  | {\n      type: EnumToUnion<DialogType.Prompt>;\n      id: string;\n      placeholder?: string;\n    };\n\n/**\n * The request parameters for the `snap_dialog` method.\n *\n * @property type - The type of dialog to display.\n * @property content - The content to display in the dialog.\n * @property id - The Snap interface ID.\n * @property placeholder - The placeholder text to display in the dialog. Only\n * applicable for the `prompt` dialog.\n */\nexport type DialogParams = AlertDialog | ConfirmationDialog | PromptDialog;\n\n/**\n * The result returned by the `snap_dialog` method.\n *\n * - If the dialog is an `alert`, the result is `null`.\n * - If the dialog is a `confirmation`, the result is a boolean indicating\n * whether the user confirmed the dialog.\n * - If the dialog is a `prompt`, the result is the value entered by\n * the user.\n */\nexport type DialogResult = null | boolean | string;\n","import type { EnumToUnion } from '../../internals';\n\n/**\n * The encoding to use when retrieving the file. Defaults to `Base64`.\n */\nexport enum AuxiliaryFileEncoding {\n  Base64 = 'base64',\n  Hex = 'hex',\n  Utf8 = 'utf8',\n}\n\n/**\n * The request parameters for the `snap_getFile` method.\n *\n * @property path - The path to the file to retrieve.\n * @property encoding - The encoding to use when retrieving the file.\n */\nexport type GetFileParams = {\n  path: string;\n  encoding?: EnumToUnion<AuxiliaryFileEncoding>;\n};\n\n/**\n * The result returned by the `snap_getFile` method.\n */\nexport type GetFileResult = string;\n","import type { Json } from '@metamask/utils';\n\nimport type { EnumToUnion } from '../../internals';\n\n/**\n * The operations that can be performed on the state.\n */\nexport enum ManageStateOperation {\n  ClearState = 'clear',\n  GetState = 'get',\n  UpdateState = 'update',\n}\n\n/**\n * The clear state operation, which clears the state.\n *\n * @property operation - The operation to perform on the state. Must be `clear`.\n * @property encrypted - Whether to use the separate encrypted state, or the\n * unencrypted state. Defaults to the encrypted state. Encrypted state can only\n * be used if the extension is unlocked, while unencrypted state can be used\n * whether the extension is locked or unlocked.\n */\nexport type ClearStateOperation = {\n  operation: EnumToUnion<ManageStateOperation.ClearState>;\n  encrypted?: boolean;\n};\n\n/**\n * The get state operation, which retrieves the state.\n *\n * @property operation - The operation to perform on the state. Must be `get`.\n * @property encrypted - Whether to use the separate encrypted state, or the\n * unencrypted state. Defaults to the encrypted state. Encrypted state can only\n * be used if the extension is unlocked, while unencrypted state can be used\n * whether the extension is locked or unlocked.\n */\nexport type GetStateOperation = {\n  operation: EnumToUnion<ManageStateOperation.GetState>;\n  encrypted?: boolean;\n};\n\n/**\n * The update state operation, which updates the state.\n *\n * @property operation - The operation to perform on the state. Must be\n * `update`.\n * @property encrypted - Whether to use the separate encrypted state, or the\n * unencrypted state. Defaults to the encrypted state. Encrypted state can only\n * be used if the extension is unlocked, while unencrypted state can be used\n * whether the extension is locked or unlocked.\n * @property newState - The new state to set.\n */\nexport type UpdateStateOperation = {\n  operation: EnumToUnion<ManageStateOperation.UpdateState>;\n  encrypted?: boolean;\n  newState: Record<string, Json>;\n};\n\n/**\n * The request parameters for the `snap_manageState` method.\n *\n * @property operation - The operation to perform on the state.\n * @property encrypted - Whether to use the separate encrypted state, or the\n * unencrypted state. Defaults to the encrypted state.\n * @property newState - The new state to set. Only applicable for the `set`\n * operation.\n */\nexport type ManageStateParams =\n  | ClearStateOperation\n  | GetStateOperation\n  | UpdateStateOperation;\n\n/**\n * The result returned by the `snap_manageState` method.\n *\n * If the operation is `get`, the result is the state. Otherwise, the result is\n * `null`.\n */\nexport type ManageStateResult = Record<string, Json> | null;\n","import type { EnumToUnion } from '../../internals';\n\n/**\n * The types of notifications that can be displayed.\n *\n * - `InApp` - A notification that is displayed in by the MetaMask extension.\n * - `Native` - A notification that is displayed by the operating system.\n */\nexport enum NotificationType {\n  InApp = 'inApp',\n  Native = 'native',\n}\n\n/**\n * The request parameters for the `snap_notify` method.\n *\n * @property type - The type of notification to display.\n * @property message - The message to display in the notification.\n */\nexport type NotifyParams = {\n  type: EnumToUnion<NotificationType>;\n  message: string;\n};\n\n/**\n * The result returned by the `snap_notify` method.\n *\n * This method does not return anything.\n */\nexport type NotifyResult = null;\n","import { JsonStruct } from '@metamask/utils';\nimport type { Infer } from '@metamask/superstruct';\nimport { boolean, nullable, record, string, union } from '@metamask/superstruct';\n\nimport type { JSXElement } from '../jsx';\nimport { RootJSXElementStruct } from '../jsx';\nimport type { Component } from '../ui';\nimport { ComponentStruct } from '../ui';\nimport { FileStruct } from './handlers';\n\n/**\n * To avoid typing problems with the interface state when manipulating it we\n * have to differentiate the state of a form (that will be contained inside the\n * root state) and the root state since a key in the root stat can contain\n * either the value of an input or a sub-state of a form.\n */\n\nexport const StateStruct = union([FileStruct, string(), boolean()]);\n\nexport const FormStateStruct = record(string(), nullable(StateStruct));\n\nexport const InterfaceStateStruct = record(\n  string(),\n  union([FormStateStruct, nullable(StateStruct)]),\n);\n\nexport type State = Infer<typeof StateStruct>;\nexport type FormState = Infer<typeof FormStateStruct>;\nexport type InterfaceState = Infer<typeof InterfaceStateStruct>;\n\nexport type ComponentOrElement = Component | JSXElement;\nexport const ComponentOrElementStruct = union([\n  ComponentStruct,\n  RootJSXElementStruct,\n]);\n\nexport const InterfaceContextStruct = record(string(), JsonStruct);\nexport type InterfaceContext = Infer<typeof InterfaceContextStruct>;\n","import {\n  hasProperty,\n  HexChecksumAddressStruct,\n  isPlainObject,\n  JsonStruct,\n} from '@metamask/utils';\nimport type { Infer, Struct } from '@metamask/superstruct';\nimport {\n  is,\n  boolean,\n  optional,\n  array,\n  lazy,\n  nullable,\n  number,\n  object,\n  record,\n  string,\n  tuple,\n} from '@metamask/superstruct';\nimport type {\n  AnyStruct,\n  InferStructTuple,\n  ObjectSchema,\n} from '@metamask/superstruct';\n\nimport type { Describe } from '../internals';\nimport { literal, nullUnion, svg } from '../internals';\nimport type { EmptyObject } from '../types';\nimport type {\n  GenericSnapElement,\n  JsonObject,\n  Key,\n  Nestable,\n  SnapElement,\n  SnapsChildren,\n  StringElement,\n} from './component';\nimport type {\n  AddressElement,\n  BoldElement,\n  BoxElement,\n  ButtonElement,\n  CheckboxElement,\n  CopyableElement,\n  DividerElement,\n  DropdownElement,\n  OptionElement,\n  FieldElement,\n  FormElement,\n  HeadingElement,\n  ImageElement,\n  InputElement,\n  ItalicElement,\n  JSXElement,\n  LinkElement,\n  RowElement,\n  SpinnerElement,\n  StandardFormattingElement,\n  TextElement,\n  TooltipElement,\n  ValueElement,\n  FileInputElement,\n} from './components';\n\n/**\n * A struct for the {@link Key} type.\n */\nexport const KeyStruct: Describe<Key> = nullUnion([string(), number()]);\n\n/**\n * A struct for the {@link StringElement} type.\n */\nexport const StringElementStruct: Describe<StringElement> = children([\n  string(),\n]);\n\n/**\n * A struct for the {@link GenericSnapElement} type.\n */\nexport const ElementStruct: Describe<GenericSnapElement> = object({\n  type: string(),\n  props: record(string(), JsonStruct),\n  key: nullable(KeyStruct),\n});\n\n/**\n * A helper function for creating a struct for a {@link Nestable} type.\n *\n * @param struct - The struct for the type to test.\n * @returns The struct for the nestable type.\n */\nfunction nestable<Type, Schema>(\n  struct: Struct<Type, Schema>,\n): Struct<Nestable<Type>, any> {\n  const nestableStruct: Struct<Nestable<Type>> = nullUnion([\n    struct,\n    array(lazy(() => nestableStruct)),\n  ]);\n\n  return nestableStruct;\n}\n\n/**\n * A helper function for creating a struct which allows children of a specific\n * type, as well as `null` and `boolean`.\n *\n * @param structs - The structs to allow as children.\n * @returns The struct for the children.\n */\nfunction children<Head extends AnyStruct, Tail extends AnyStruct[]>(\n  structs: [head: Head, ...tail: Tail],\n): Struct<\n  Nestable<Infer<Head> | InferStructTuple<Tail>[number] | boolean | null>,\n  null\n> {\n  return nestable(nullable(nullUnion([...structs, boolean()])));\n}\n\n/**\n * A helper function for creating a struct for a JSX element.\n *\n * @param name - The name of the element.\n * @param props - The props of the element.\n * @returns The struct for the element.\n */\nfunction element<Name extends string, Props extends ObjectSchema = EmptyObject>(\n  name: Name,\n  props: Props = {} as Props,\n) {\n  return object({\n    type: literal(name) as unknown as Struct<Name, Name>,\n    props: object(props),\n    key: nullable(KeyStruct),\n  });\n}\n\n/**\n * A struct for the {@link ButtonElement} type.\n */\nexport const ButtonStruct: Describe<ButtonElement> = element('Button', {\n  children: StringElementStruct,\n  name: optional(string()),\n  type: optional(nullUnion([literal('button'), literal('submit')])),\n  variant: optional(nullUnion([literal('primary'), literal('destructive')])),\n  disabled: optional(boolean()),\n});\n\n/**\n * A struct for the {@link CheckboxElement} type.\n */\nexport const CheckboxStruct: Describe<CheckboxElement> = element('Checkbox', {\n  name: string(),\n  checked: optional(boolean()),\n  label: optional(string()),\n  variant: optional(nullUnion([literal('default'), literal('toggle')])),\n});\n\n/**\n * A struct for the {@link InputElement} type.\n */\nexport const InputStruct: Describe<InputElement> = element('Input', {\n  name: string(),\n  type: optional(\n    nullUnion([literal('text'), literal('password'), literal('number')]),\n  ),\n  value: optional(string()),\n  placeholder: optional(string()),\n});\n\n/**\n * A struct for the {@link OptionElement} type.\n */\nexport const OptionStruct: Describe<OptionElement> = element('Option', {\n  value: string(),\n  children: string(),\n});\n\n/**\n * A struct for the {@link DropdownElement} type.\n */\nexport const DropdownStruct: Describe<DropdownElement> = element('Dropdown', {\n  name: string(),\n  value: optional(string()),\n  children: children([OptionStruct]),\n});\n\n/**\n * A struct for the {@link FileInputElement} type.\n */\nexport const FileInputStruct: Describe<FileInputElement> = element(\n  'FileInput',\n  {\n    name: string(),\n    accept: nullUnion([optional(array(string()))]),\n    compact: optional(boolean()),\n  },\n);\n\n/**\n * A struct for the {@link FieldElement} type.\n */\nexport const FieldStruct: Describe<FieldElement> = element('Field', {\n  label: optional(string()),\n  error: optional(string()),\n  children: nullUnion([\n    tuple([InputStruct, ButtonStruct]),\n    DropdownStruct,\n    FileInputStruct,\n    InputStruct,\n    CheckboxStruct,\n  ]),\n});\n\n/**\n * A struct for the {@link FormElement} type.\n */\nexport const FormStruct: Describe<FormElement> = element('Form', {\n  children: children(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    [FieldStruct, lazy(() => BoxChildStruct)],\n  ) as unknown as Struct<SnapsChildren<GenericSnapElement>, null>,\n  name: string(),\n});\n\n/**\n * A struct for the {@link BoldElement} type.\n */\nexport const BoldStruct: Describe<BoldElement> = element('Bold', {\n  children: children([\n    string(),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    lazy(() => ItalicStruct) as unknown as Struct<\n      SnapElement<JsonObject, 'Italic'>\n    >,\n  ]),\n});\n\n/**\n * A struct for the {@link ItalicElement} type.\n */\nexport const ItalicStruct: Describe<ItalicElement> = element('Italic', {\n  children: children([\n    string(),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    lazy(() => BoldStruct) as unknown as Struct<\n      SnapElement<JsonObject, 'Bold'>\n    >,\n  ]),\n});\n\nexport const FormattingStruct: Describe<StandardFormattingElement> = nullUnion([\n  BoldStruct,\n  ItalicStruct,\n]);\n\n/**\n * A struct for the {@link AddressElement} type.\n */\nexport const AddressStruct: Describe<AddressElement> = element('Address', {\n  address: HexChecksumAddressStruct,\n});\n\n/**\n * A struct for the {@link BoxElement} type.\n */\nexport const BoxStruct: Describe<BoxElement> = element('Box', {\n  children: children(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    [lazy(() => BoxChildStruct)],\n  ) as unknown as Struct<SnapsChildren<GenericSnapElement>, null>,\n  direction: optional(nullUnion([literal('horizontal'), literal('vertical')])),\n  alignment: optional(\n    nullUnion([\n      literal('start'),\n      literal('center'),\n      literal('end'),\n      literal('space-between'),\n      literal('space-around'),\n    ]),\n  ),\n});\n\n/**\n * A struct for the {@link CopyableElement} type.\n */\nexport const CopyableStruct: Describe<CopyableElement> = element('Copyable', {\n  value: string(),\n  sensitive: optional(boolean()),\n});\n\n/**\n * A struct for the {@link DividerElement} type.\n */\nexport const DividerStruct: Describe<DividerElement> = element('Divider');\n\n/**\n * A struct for the {@link ValueElement} type.\n */\nexport const ValueStruct: Describe<ValueElement> = element('Value', {\n  value: string(),\n  extra: string(),\n});\n\n/**\n * A struct for the {@link HeadingElement} type.\n */\nexport const HeadingStruct: Describe<HeadingElement> = element('Heading', {\n  children: StringElementStruct,\n});\n\n/**\n * A struct for the {@link ImageElement} type.\n */\nexport const ImageStruct: Describe<ImageElement> = element('Image', {\n  src: svg(),\n  alt: optional(string()),\n});\n\n/**\n * A struct for the {@link LinkElement} type.\n */\nexport const LinkStruct: Describe<LinkElement> = element('Link', {\n  href: string(),\n  children: children([FormattingStruct, string()]),\n});\n\n/**\n * A struct for the {@link TextElement} type.\n */\nexport const TextStruct: Describe<TextElement> = element('Text', {\n  children: children([string(), BoldStruct, ItalicStruct, LinkStruct]),\n  alignment: optional(\n    nullUnion([literal('start'), literal('center'), literal('end')]),\n  ),\n});\n\n/**\n * A subset of JSX elements that are allowed as children of the Tooltip component.\n * This set should include all text components and the Image.\n */\nexport const TooltipChildStruct = nullUnion([\n  TextStruct,\n  BoldStruct,\n  ItalicStruct,\n  LinkStruct,\n  ImageStruct,\n  boolean(),\n]);\n\n/**\n * A subset of JSX elements that are allowed as content of the Tooltip component.\n * This set should include all text components.\n */\nexport const TooltipContentStruct = nullUnion([\n  TextStruct,\n  BoldStruct,\n  ItalicStruct,\n  LinkStruct,\n  string(),\n]);\n\n/**\n * A struct for the {@link TooltipElement} type.\n */\nexport const TooltipStruct: Describe<TooltipElement> = element('Tooltip', {\n  children: nullable(TooltipChildStruct),\n  content: TooltipContentStruct,\n});\n\n/**\n * A struct for the {@link RowElement} type.\n */\nexport const RowStruct: Describe<RowElement> = element('Row', {\n  label: string(),\n  children: nullUnion([AddressStruct, ImageStruct, TextStruct, ValueStruct]),\n  variant: optional(\n    nullUnion([literal('default'), literal('warning'), literal('critical')]),\n  ),\n  tooltip: optional(string()),\n});\n\n/**\n * A struct for the {@link SpinnerElement} type.\n */\nexport const SpinnerStruct: Describe<SpinnerElement> = element('Spinner');\n\n/**\n * A subset of JSX elements that are allowed as children of the Box component.\n * This set includes all components, except components that need to be nested in\n * another component (e.g., Field must be contained in a Form).\n */\nexport const BoxChildStruct = nullUnion([\n  AddressStruct,\n  BoldStruct,\n  BoxStruct,\n  ButtonStruct,\n  CopyableStruct,\n  DividerStruct,\n  DropdownStruct,\n  FileInputStruct,\n  FormStruct,\n  HeadingStruct,\n  InputStruct,\n  ImageStruct,\n  ItalicStruct,\n  LinkStruct,\n  RowStruct,\n  SpinnerStruct,\n  TextStruct,\n  TooltipStruct,\n  CheckboxStruct,\n]);\n\n/**\n * For now, the allowed JSX elements at the root are the same as the allowed\n * children of the Box component.\n */\nexport const RootJSXElementStruct = BoxChildStruct;\n\n/**\n * A struct for the {@link JSXElement} type.\n */\nexport const JSXElementStruct: Describe<JSXElement> = nullUnion([\n  ButtonStruct,\n  InputStruct,\n  FileInputStruct,\n  FieldStruct,\n  FormStruct,\n  BoldStruct,\n  ItalicStruct,\n  AddressStruct,\n  BoxStruct,\n  CopyableStruct,\n  DividerStruct,\n  HeadingStruct,\n  ImageStruct,\n  LinkStruct,\n  RowStruct,\n  SpinnerStruct,\n  TextStruct,\n  DropdownStruct,\n  OptionStruct,\n  ValueStruct,\n  TooltipStruct,\n  CheckboxStruct,\n]);\n\n/**\n * Check if a value is a JSX element.\n *\n * @param value - The value to check.\n * @returns True if the value is a JSX element, false otherwise.\n */\nexport function isJSXElement(value: unknown): value is JSXElement {\n  return is(value, JSXElementStruct);\n}\n\n/**\n * Check if a value is a JSX element, without validating all of its contents.\n * This is useful when you want to validate the structure of a value, but not\n * all the children.\n *\n * This should only be used when you are sure that the value is safe to use,\n * i.e., after using {@link isJSXElement}.\n *\n * @param value - The value to check.\n * @returns True if the value is a JSX element, false otherwise.\n */\nexport function isJSXElementUnsafe(value: unknown): value is JSXElement {\n  return (\n    isPlainObject(value) &&\n    hasProperty(value, 'type') &&\n    hasProperty(value, 'props') &&\n    hasProperty(value, 'key')\n  );\n}\n\n/**\n * Assert that a value is a JSX element.\n *\n * @param value - The value to check.\n * @throws If the value is not a JSX element.\n */\nexport function assertJSXElement(value: unknown): asserts value is JSXElement {\n  // TODO: We should use the error parsing utils from `snaps-utils` to improve\n  // the error messages. It currently includes colours and potentially other\n  // formatting that we might not want to include in the SDK.\n  if (!isJSXElement(value)) {\n    throw new Error(\n      `Expected a JSX element, but received ${JSON.stringify(\n        value,\n      )}. Please refer to the documentation for the supported JSX elements and their props.`,\n    );\n  }\n}\n"],"mappings":"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","names":["error","assert","assign","literal","object","node","string","NodeType","assign","object","literal","assign","literal","object","string","assign","object","literal","string","assign","literal","object","assign","object","literal","assign","literal","object","string","assign","object","literal","string","assign","literal","object","assign","object","literal","array","assign","literal","object","union","assign","literal","object","optional","string","union","ButtonVariant","ButtonType","assign","object","literal","string","optional","union","assign","literal","object","string","union","assign","literal","object","optional","string","union","InputType","assign","object","literal","optional","string","union","union","assign","object","literal","string","assign","literal","object","string","optional","union","assign","boolean","literal","object","optional","string","assign","object","literal","string","optional","boolean","RowVariant","union","assign","object","literal","optional","string","assign","literal","object","assign","object","literal","assign","object","array","literal","union","assertStruct","assertStruct","SeverityLevel","assign","literal","object","optional","string","union","boolean","UserInputEventType","DialogType","AuxiliaryFileEncoding","ManageStateOperation","NotificationType","JsonStruct","boolean","nullable","record","string","union","hasProperty","HexChecksumAddressStruct","isPlainObject","is","boolean","optional","array","lazy","nullable","number","object","record","string","string","number","object","record","nullable","array","lazy","boolean","ButtonStruct","optional","InputStruct","FormStruct","AddressStruct","HexChecksumAddressStruct","CopyableStruct","DividerStruct","HeadingStruct","ImageStruct","TextStruct","RowStruct","SpinnerStruct","union","string","boolean","record","nullable","JsonStruct"]}
\ No newline at end of file
diff --git a/dist/jsx/index.js.map b/dist/jsx/index.js.map
index 9fda623ee0a5d0737fc1aa95e1479c8d83068206..be2ef2f3fe8a8e82844815880acb22a37f21867f 100644
--- a/dist/jsx/index.js.map
+++ b/dist/jsx/index.js.map
@@ -1 +1,96 @@
-{"version":3,"sources":["../../src/jsx/index.ts","../../src/jsx/component.ts","../../src/jsx/components/form/Button.ts","../../src/jsx/components/form/Checkbox.ts","../../src/jsx/components/form/Dropdown.ts","../../src/jsx/components/form/Option.ts","../../src/jsx/components/form/Field.ts","../../src/jsx/components/form/FileInput.ts","../../src/jsx/components/form/Form.ts","../../src/jsx/components/form/Input.ts","../../src/jsx/components/formatting/Bold.ts","../../src/jsx/components/formatting/Italic.ts","../../src/jsx/components/Address.ts","../../src/jsx/components/Box.ts","../../src/jsx/components/Copyable.ts","../../src/jsx/components/Divider.ts","../../src/jsx/components/Value.ts","../../src/jsx/components/Heading.ts","../../src/jsx/components/Image.ts","../../src/jsx/components/Link.ts","../../src/jsx/components/Row.ts","../../src/jsx/components/Spinner.ts","../../src/jsx/components/Text.ts","../../src/jsx/components/Tooltip.ts","../../src/jsx/jsx-runtime.ts","../../src/jsx/validation.ts","../../src/internals/structs.ts","../../src/internals/jsx.ts","../../src/internals/svg.ts","../../src/jsx/jsx-dev-runtime.ts"],"sourcesContent":["export * from './component';\nexport * from './components';\nexport * from './jsx-runtime';\nexport * from './jsx-dev-runtime';\nexport {\n  JSXElementStruct,\n  RootJSXElementStruct,\n  isJSXElement,\n  isJSXElementUnsafe,\n  assertJSXElement,\n} from './validation';\n","import type { Json } from '@metamask/utils';\n\n/**\n * A key, which can be a string or a number.\n */\nexport type Key = string | number;\n\n/**\n * A JSON object.\n */\nexport type JsonObject = Record<string, Json>;\n\n/**\n * A generic JSX element.\n *\n * @property type - The type of the element.\n * @property props - The props of the element.\n * @property key - The key of the element.\n */\nexport type GenericSnapElement = {\n  type: string;\n  props: JsonObject;\n  key: Key | null;\n};\n\n/**\n * A JSX element.\n *\n * @property type - The type of the element.\n * @property props - The props of the element.\n * @property key - The key of the element.\n */\nexport type SnapElement<\n  Props extends JsonObject = Record<string, never>,\n  Type extends string = string,\n> = {\n  type: Type;\n  props: Props;\n  key: Key | null;\n};\n\n/**\n * A type that can be a single value or an infinitely nestable array of values.\n *\n * @template Type - The type that can be an array.\n * @example\n * type NestableString = Nestable<string>;\n * const nestableString: NestableString = 'hello';\n * const nestableStringArray: NestableString = ['hello', 'world', ['foo', ['bar']]];\n */\nexport type Nestable<Type> = Type | Nestable<Type>[];\n\n/**\n * A type that can be a single value or an array of values, a boolean, or null.\n *\n * @template Type - The type that can be an array.\n */\nexport type SnapsChildren<Type> = Nestable<Type | boolean | null>;\n\n/**\n * A JSX node, which can be an element, a string, null, or an array of nodes.\n */\nexport type SnapNode = SnapsChildren<GenericSnapElement | string>;\n\n/**\n * A JSX string element, which can be a string or an array of strings, or\n * booleans (for conditional rendering).\n */\nexport type StringElement = SnapsChildren<string>;\n\n/**\n * A JSX component.\n */\nexport type SnapComponent<\n  Props extends JsonObject = Record<string, never>,\n  Type extends string = string,\n> = (props: Props & { key?: Key | null }) => SnapElement<Props, Type>;\n\n/**\n * Remove undefined props from an object.\n *\n * @param props - The object to remove undefined props from.\n * @returns The object without undefined props.\n */\nfunction removeUndefinedProps<Props extends JsonObject>(props: Props): Props {\n  return Object.fromEntries(\n    Object.entries(props).filter(([, value]) => value !== undefined),\n  ) as Props;\n}\n\n/**\n * Create a Snap component from a type. This is a helper function that creates a\n * Snap component function.\n *\n * @param type - The type of the component.\n * @returns A function that creates a Snap element.\n * @see SnapComponent\n */\nexport function createSnapComponent<\n  Props extends JsonObject = Record<string, never>,\n  Type extends string = string,\n>(type: Type): SnapComponent<Props, Type> {\n  return (props: Props & { key?: Key | null }) => {\n    const { key = null, ...rest } = props;\n    return {\n      type,\n      props: removeUndefinedProps(rest as Props),\n      key,\n    };\n  };\n}\n","import type { StringElement } from '../../component';\nimport { createSnapComponent } from '../../component';\n\n// TODO: Add the `onClick` prop to the `ButtonProps` type.\n\n/**\n * The props of the {@link Button} component.\n *\n * @property children - The text to display on the button.\n * @property name - The name of the button. This is used to identify the button\n * in the event handler.\n * @property type - The type of the button, i.e., `'button'` or `'submit'`.\n * Defaults to `'button'`.\n * @property variant - The variant of the button, i.e., `'primary'` or\n * `'destructive'`. Defaults to `'primary'`.\n * @property disabled - Whether the button is disabled. Defaults to `false`.\n */\nexport type ButtonProps = {\n  children: StringElement;\n  name?: string | undefined;\n  type?: 'button' | 'submit' | undefined;\n  variant?: 'primary' | 'destructive' | undefined;\n  disabled?: boolean | undefined;\n};\n\nconst TYPE = 'Button';\n\n/**\n * A button component, which is used to create a clickable button.\n *\n * @param props - The props of the component.\n * @param props.children - The text to display on the button. This should be a\n * string or an array of strings.\n * @returns A button element.\n * @example\n * <Button name=\"my-button\">Click me</Button>\n */\nexport const Button = createSnapComponent<ButtonProps, typeof TYPE>(TYPE);\n\n/**\n * A button element.\n *\n * @see Button\n */\nexport type ButtonElement = ReturnType<typeof Button>;\n","import { createSnapComponent } from '../../component';\n\n/**\n * The props of the {@link Checkbox} component.\n *\n * @property name - The name of the checkbox. This is used to identify the\n * state in the form data.\n * @property checked - Whether the checkbox is checked or not.\n * @property label - An optional label for the checkbox.\n * @property variant - An optional variant for the checkbox.\n */\nexport type CheckboxProps = {\n  name: string;\n  checked?: boolean | undefined;\n  label?: string | undefined;\n  variant?: 'default' | 'toggle' | undefined;\n};\n\nconst TYPE = 'Checkbox';\n\n/**\n * A checkbox component, which is used to create a checkbox.\n *\n * @param props - The props of the component.\n * @param props.name - The name of the checkbox. This is used to identify the\n * state in the form data.\n * @param props.checked - Whether the checkbox is checked or not.\n * @param props.label - An optional label for the checkbox.\n * @param props.variant - An optional variant for the checkbox.\n * @returns A checkbox element.\n * @example\n * <Checkbox name=\"accept-terms\" />\n */\nexport const Checkbox = createSnapComponent<CheckboxProps, typeof TYPE>(TYPE);\n\n/**\n * A checkbox element.\n *\n * @see Checkbox\n */\nexport type CheckboxElement = ReturnType<typeof Checkbox>;\n","import type { SnapsChildren } from '../../component';\nimport { createSnapComponent } from '../../component';\nimport type { OptionElement } from './Option';\n\n/**\n * The props of the {@link Dropdown} component.\n *\n * @property name - The name of the dropdown. This is used to identify the\n * state in the form data.\n * @property value - The selected value of the dropdown.\n * @property children - The children of the dropdown.\n */\nexport type DropdownProps = {\n  name: string;\n  value?: string | undefined;\n  children: SnapsChildren<OptionElement>;\n};\n\nconst TYPE = 'Dropdown';\n\n/**\n * A dropdown component, which is used to create a dropdown.\n *\n * @param props - The props of the component.\n * @param props.name - The name of the dropdown field. This is used to identify the\n * state in the form data.\n * @param props.value - The selected value of the dropdown.\n * @param props.children - The children of the dropdown.\n * @returns A dropdown element.\n * @example\n * <Dropdown name=\"dropdown\">\n *  <Option value=\"option1\">Option 1</Option>\n *  <Option value=\"option2\">Option 2</Option>\n *  <Option value=\"option3\">Option 3</Option>\n * </Dropdown>\n */\nexport const Dropdown = createSnapComponent<DropdownProps, typeof TYPE>(TYPE);\n\n/**\n * A dropdown element.\n *\n * @see Dropdown\n */\nexport type DropdownElement = ReturnType<typeof Dropdown>;\n","import { createSnapComponent } from '../../component';\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport { Dropdown } from './Dropdown';\n\n/**\n * The props of the {@link Option} component.\n *\n * @property value - The value of the dropdown option. This is used to populate the\n * state in the form data.\n * @property children - The text to display.\n */\ntype OptionProps = {\n  value: string;\n  children: string;\n};\n\nconst TYPE = 'Option';\n\n/**\n * A dropdown option component, which is used to create a dropdown option. This component\n * can only be used as a child of the {@link Dropdown} component.\n *\n * @param props - The props of the component.\n * @param props.value - The value of the dropdown option. This is used to populate the\n * state in the form data.\n * @param props.children - The text to display.\n * @returns A dropdown option element.\n * @example\n * <Dropdown name=\"dropdown\">\n *  <Option value=\"option1\">Option 1</Option>\n *  <Option value=\"option2\">Option 2</Option>\n *  <Option value=\"option3\">Option 3</Option>\n * </Dropdown>\n */\nexport const Option = createSnapComponent<OptionProps, typeof TYPE>(TYPE);\n\n/**\n * A dropdown option element.\n *\n * @see Option\n */\nexport type OptionElement = ReturnType<typeof Option>;\n","import { createSnapComponent } from '../../component';\nimport type { ButtonElement } from './Button';\nimport type { CheckboxElement } from './Checkbox';\nimport type { DropdownElement } from './Dropdown';\nimport type { FileInputElement } from './FileInput';\nimport type { InputElement } from './Input';\n\n/**\n * The props of the {@link Field} component.\n *\n * @property label - The label of the field.\n * @property error - The error message of the field.\n * @property children - The input field and the submit button.\n */\nexport type FieldProps = {\n  label?: string | undefined;\n  error?: string | undefined;\n  children:\n    | [InputElement, ButtonElement]\n    | DropdownElement\n    | FileInputElement\n    | InputElement\n    | CheckboxElement;\n};\n\nconst TYPE = 'Field';\n\n/**\n * A field component, which is used to create a form field. This component can\n * only be used as a child of the {@link Form} component.\n *\n * @param props - The props of the component.\n * @param props.label - The label of the field.\n * @param props.error - The error message of the field.\n * @param props.children - The input field and the submit button.\n * @returns A field element.\n * @example\n * <Field label=\"Username\">\n *   <Input name=\"username\" type=\"text\" />\n *   <Button type=\"submit\">Submit</Button>\n * </Field>\n * @example\n * <Field label=\"Upload file\">\n *   <FileInput name=\"file\" accept={['image/*']} multiple />\n * </Field>\n */\nexport const Field = createSnapComponent<FieldProps, typeof TYPE>(TYPE);\n\n/**\n * A field element.\n *\n * @see Field\n */\nexport type FieldElement = ReturnType<typeof Field>;\n","import { createSnapComponent } from '../../component';\n\n/**\n * The props of the {@link FileInput} component.\n *\n * @property name - The name of the file input field. This is used to identify\n * the file input field in the form data.\n * @property label - The label of the file input field.\n * @property accept - The file types that the file input field accepts. If not\n * specified, the file input field accepts all file types.\n * @property compact - Whether the file input field is compact. Default is\n * `false`.\n */\nexport type FileInputProps = {\n  name: string;\n  accept?: string[] | undefined;\n  compact?: boolean | undefined;\n};\n\nconst TYPE = 'FileInput';\n\n/**\n * A file input component, which is used to create a file input field. This\n * component can only be used as a child of the {@link Field} component.\n *\n * The total size of the files that can be uploaded may not exceed 64 MB.\n *\n * @param props - The props of the component.\n * @param props.name - The name of the file input field. This is used to\n * identify the file input field in the form data.\n * @param props.accept - The file types that the file input field accepts. If\n * not specified, the file input field accepts all file types. For examples of\n * valid values, see the [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/accept).\n * @param props.compact - Whether the file input field is compact. Default is\n * `false`.\n * @returns A file input element.\n * @example\n * <FileInput name=\"file\" accept={['image/*']} />\n * @example\n * <FileInput name=\"file\" compact />\n * @example\n * <Field label=\"Upload file\">\n *   <FileInput name=\"file\" />\n * </Field>\n */\nexport const FileInput = createSnapComponent<FileInputProps, typeof TYPE>(TYPE);\n\n/**\n * A file input element.\n *\n * @see FileInput\n */\nexport type FileInputElement = ReturnType<typeof FileInput>;\n","import type { GenericSnapElement, SnapsChildren } from '../../component';\nimport { createSnapComponent } from '../../component';\n\n// TODO: Add `onSubmit` prop to the `FormProps` type.\n\n/**\n * The props of the {@link Form} component.\n *\n * @property children - The children of the form.\n * @property name - The name of the form. This is used to identify the form in\n * the event handler.\n */\nexport type FormProps = {\n  children: SnapsChildren<GenericSnapElement>;\n  name: string;\n};\n\nconst TYPE = 'Form';\n\n/**\n * A form component, which is used to create a form.\n *\n * @param props - The props of the component.\n * @param props.children - The form fields. This should be a single field or an\n * array of fields.\n * @param props.name - The name of the form. This is used to identify the form\n * in the event handler.\n * @returns A form element.\n * @example\n * <Form name=\"my-form\">\n *   <Field label=\"Username\">\n *     <Input name=\"username\" type=\"text\" />\n *   </Field>\n *   <Button type=\"submit\">Submit</Button>\n * </Form>\n */\nexport const Form = createSnapComponent<FormProps, typeof TYPE>(TYPE);\n\n/**\n * A form element.\n *\n * @see Form\n */\nexport type FormElement = ReturnType<typeof Form>;\n","import { createSnapComponent } from '../../component';\n\n// TODO: Add the `onChange` prop to the `InputProps` type.\n\n/**\n * The props of the {@link Input} component.\n *\n * @property name - The name of the input field. This is used to identify the\n * input field in the form data.\n * @property type - The type of the input field. Defaults to `text`.\n * @property value - The value of the input field.\n * @property placeholder - The placeholder text of the input field.\n */\nexport type InputProps = {\n  name: string;\n  type?: 'text' | 'password' | 'number' | undefined;\n  value?: string | undefined;\n  placeholder?: string | undefined;\n};\n\nconst TYPE = 'Input';\n\n/**\n * An input component, which is used to create an input field.\n *\n * @param props - The props of the component.\n * @param props.name - The name of the input field. This is used to identify the\n * input field in the form data.\n * @param props.type - The type of the input field.\n * @param props.value - The value of the input field.\n * @param props.placeholder - The placeholder text of the input field.\n * @returns An input element.\n * @example\n * <Input name=\"username\" type=\"text\" />\n */\nexport const Input = createSnapComponent<InputProps, typeof TYPE>(TYPE);\n\n/**\n * An input element.\n *\n * @see Input\n */\nexport type InputElement = ReturnType<typeof Input>;\n","import type { JsonObject, SnapElement, SnapsChildren } from '../../component';\nimport { createSnapComponent } from '../../component';\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport { Text } from '../Text';\n\n/**\n * The children of the {@link Bold} component.\n */\nexport type BoldChildren = SnapsChildren<\n  | string\n  // We have to specify the type here to avoid a circular reference.\n  | SnapElement<JsonObject, 'Italic'>\n>;\n\n/**\n * The props of the {@link Bold} component.\n *\n * @property children - The text to display in bold.\n */\nexport type BoldProps = {\n  children: BoldChildren;\n};\n\nconst TYPE = 'Bold';\n\n/**\n * A bold component, which is used to display text in bold. This component can\n * only be used as a child of the {@link Text} component.\n *\n * @param props - The props of the component.\n * @param props.children - The text to display in bold.\n * @returns A bold element.\n * @example\n * <Text>\n *   Hello <Bold>world</Bold>!\n * </Text>\n */\nexport const Bold = createSnapComponent<BoldProps, typeof TYPE>(TYPE);\n\n/**\n * A bold element.\n *\n * @see Bold\n */\nexport type BoldElement = ReturnType<typeof Bold>;\n","import type { JsonObject, SnapElement, SnapsChildren } from '../../component';\nimport { createSnapComponent } from '../../component';\n\n/**\n * The children of the {@link Italic} component.\n */\nexport type ItalicChildren = SnapsChildren<\n  | string\n  // We have to specify the type here to avoid a circular reference.\n  | SnapElement<JsonObject, 'Bold'>\n>;\n\n/**\n * The props of the {@link Italic} component.\n *\n * @property children - The text to display in italic. This should be a string\n * or an array of strings.\n */\nexport type ItalicProps = {\n  children: ItalicChildren;\n};\n\nconst TYPE = 'Italic';\n\n/**\n * An italic component, which is used to display text in italic. This componen\n * can only be used as a child of the {@link Text} component.\n *\n * @param props - The props of the component.\n * @param props.children - The text to display in italic. This should be a\n * string or an array of strings.\n * @returns An italic element.\n * @example\n * <Text>\n *   Hello <Italic>world</Italic>!\n * </Text>\n */\nexport const Italic = createSnapComponent<ItalicProps, typeof TYPE>(TYPE);\n\n/**\n * An italic element.\n *\n * @see Italic\n */\nexport type ItalicElement = ReturnType<typeof Italic>;\n","import { createSnapComponent } from '../component';\n\n/**\n * The props of the {@link Address} component.\n *\n * @property address - The (Ethereum) address to display. This should be a\n * valid Ethereum address, starting with `0x`.\n */\nexport type AddressProps = {\n  address: `0x${string}`;\n};\n\nconst TYPE = 'Address';\n\n/**\n * An address component, which is used to display an Ethereum address.\n *\n * This component does not accept any children.\n *\n * @param props - The props of the component.\n * @param props.address - The (Ethereum) address to display. This should be a\n * valid Ethereum address, starting with `0x`.\n * @returns An address element.\n * @example\n * <Address address=\"0x1234567890123456789012345678901234567890\" />\n */\nexport const Address = createSnapComponent<AddressProps, typeof TYPE>(TYPE);\n\n/**\n * An address element.\n *\n * @see Address\n */\nexport type AddressElement = ReturnType<typeof Address>;\n","import type { GenericSnapElement, SnapsChildren } from '../component';\nimport { createSnapComponent } from '../component';\n\n/**\n * The props of the {@link Box} component.\n *\n * @property children - The children of the box.\n * @property direction - The direction to stack the components within the box. Defaults to `vertical`.\n * @property alignment - The alignment mode to use within the box. Defaults to `start`.\n */\nexport type BoxProps = {\n  // We can't use `JSXElement` because it causes a circular reference.\n  children: SnapsChildren<GenericSnapElement>;\n  direction?: 'vertical' | 'horizontal' | undefined;\n  alignment?:\n    | 'start'\n    | 'center'\n    | 'end'\n    | 'space-between'\n    | 'space-around'\n    | undefined;\n};\n\nconst TYPE = 'Box';\n\n/**\n * A box component, which is used to group multiple components together.\n *\n * @param props - The props of the component.\n * @param props.children - The children of the box.\n * @returns A box element.\n * @example\n * <Box>\n *   <Text>Hello world!</Text>\n * </Box>\n */\nexport const Box = createSnapComponent<BoxProps, typeof TYPE>(TYPE);\n\n/**\n * A box element.\n *\n * @see Box\n */\nexport type BoxElement = ReturnType<typeof Box>;\n","import { createSnapComponent } from '../component';\n\n/**\n * The props of the {@link Copyable} component.\n *\n * @property value - The value to copy when the user clicks on the copyable\n * element.\n * @property sensitive - Whether the value is sensitive. If `true`, the value\n * will be hidden when the user is not interacting with the copyable element.\n */\nexport type CopyableProps = {\n  value: string;\n  sensitive?: boolean | undefined;\n};\n\nconst TYPE = 'Copyable';\n\n/**\n * A copyable component, which is used to display text that can be copied by the\n * user.\n *\n * @param props - The props of the component.\n * @param props.value - The value to copy when the user clicks on the copyable\n * element.\n * @param props.sensitive - Whether the value is sensitive. If `true`, the value\n * will be hidden when the user is not interacting with the copyable element.\n * @example\n * <Copyable value=\"0x1234567890123456789012345678901234567890\" />\n * <Copyable value=\"0x1234567890123456789012345678901234567890\" sensitive />\n */\nexport const Copyable = createSnapComponent<CopyableProps, typeof TYPE>(TYPE);\n\n/**\n * A copyable element.\n *\n * @see Copyable\n */\nexport type CopyableElement = ReturnType<typeof Copyable>;\n","import { createSnapComponent } from '../component';\n\nconst TYPE = 'Divider';\n\n/**\n * A divider component, which is used to create a horizontal line between\n * elements.\n *\n * This component does not have any props.\n *\n * @returns A divider element.\n * @example\n * <Divider />\n */\nexport const Divider = createSnapComponent(TYPE);\n\n/**\n * A divider element.\n *\n * @see Divider\n */\nexport type DividerElement = ReturnType<typeof Divider>;\n","import { createSnapComponent } from '../component';\n\n/**\n * The props of the {@link Value} component.\n *\n * @property value - The value shown on the right side.\n * @property extra - The extra text shown on the left side.\n */\nexport type ValueProps = {\n  value: string;\n  extra: string;\n};\n\nconst TYPE = 'Value';\n\n/**\n * A value component, which can be used to display two different text values side by side.\n *\n * This component can only be used as a child of the {@link Row} component.\n *\n * This component does not accept any children.\n *\n * @param props - The props of the component.\n * @param props.value - The value shown on the right side.\n * @param props.extra - The extra text shown on the left side.\n * @returns A value element.\n * @example\n * <Value value=\"0.05 ETH\" extra=\"$200\" />\n */\nexport const Value = createSnapComponent<ValueProps, typeof TYPE>(TYPE);\n\n/**\n * A value element.\n *\n * @see Value\n */\nexport type ValueElement = ReturnType<typeof Value>;\n","import type { StringElement } from '../component';\nimport { createSnapComponent } from '../component';\n\n/**\n * The props of the {@link Heading} component.\n *\n * @property children - The text to display in the heading.\n */\ntype HeadingProps = {\n  children: StringElement;\n};\n\nconst TYPE = 'Heading';\n\n/**\n * A heading component, which is used to display heading text.\n *\n * @param props - The props of the component.\n * @param props.children - The text to display in the heading.\n * @returns A heading element.\n * @example\n * <Heading>Hello world!</Heading>\n */\nexport const Heading = createSnapComponent<HeadingProps, typeof TYPE>(TYPE);\n\n/**\n * A heading element.\n *\n * @see Heading\n */\nexport type HeadingElement = ReturnType<typeof Heading>;\n","import { createSnapComponent } from '../component';\n\n/**\n * The props of the {@link Image} component.\n *\n * @property src - The SVG image to display. This should be an SVG string, and\n * other formats such as PNG and JPEG are not supported directly. You can use\n * the `data:` URL scheme to embed images inside the SVG.\n * @property alt - The alternative text of the image, which describes the image\n * for users who cannot see it.\n */\ntype ImageProps = {\n  src: string;\n  alt?: string | undefined;\n};\n\nconst TYPE = 'Image';\n\n/**\n * An image component, which is used to display an image.\n *\n * This component does not accept any children.\n *\n * @param props - The props of the component.\n * @param props.src - The URL of the image to display. This should be an SVG\n * string, and other formats such as PNG and JPEG are not supported directly.\n * You can use the `data:` URL scheme to embed images inside the SVG.\n * @param props.alt - The alternative text of the image, which describes the\n * image for users who cannot see it.\n * @returns An image element.\n * @example\n * <Image src=\"<svg>...</svg>\" alt=\"An example image\" />\n */\nexport const Image = createSnapComponent<ImageProps, typeof TYPE>(TYPE);\n\n/**\n * An image element.\n *\n * @see Image\n */\nexport type ImageElement = ReturnType<typeof Image>;\n","import type { SnapsChildren } from '../component';\nimport { createSnapComponent } from '../component';\nimport type { StandardFormattingElement } from './formatting';\n\n/**\n * The children of the {@link Link} component.\n */\nexport type LinkChildren = SnapsChildren<string | StandardFormattingElement>;\n\n/**\n * The props of the {@link Link} component.\n *\n * @property children - The text to display in the link.\n * @property href - The URL to link to. This must be an `https` or `mailto` URL.\n * `http` is not allowed.\n */\nexport type LinkProps = {\n  children: LinkChildren;\n  href: string;\n};\n\nconst TYPE = 'Link';\n\n/**\n * A link component, which is used to display a hyperlink.\n *\n * @param props - The props of the component.\n * @param props.children - The text to display in the link.\n * @param props.href - The URL to link to. This must be an `https` or `mailto`\n * URL. `http` is not allowed.\n * @returns A link element.\n * @example\n * <Link href=\"https://example.com\">Click here</Link>\n */\nexport const Link = createSnapComponent<LinkProps, typeof TYPE>(TYPE);\n\n/**\n * A link element.\n *\n * @see Link\n */\nexport type LinkElement = ReturnType<typeof Link>;\n","import { createSnapComponent } from '../component';\nimport type { AddressElement } from './Address';\nimport type { ImageElement } from './Image';\nimport type { TextElement } from './Text';\nimport type { ValueElement } from './Value';\n\n/**\n * The children of a {@link Row} component.\n */\nexport type RowChildren =\n  | AddressElement\n  | ImageElement\n  | TextElement\n  | ValueElement;\n\n/**\n * The props of the {@link Row} component.\n *\n * @property label - The label of the row.\n * @property children - The content of the row. This can be an address, an\n * image, or text.\n * @property variant - The variant of the row.\n * @property tooltip - An optional tooltip to show for the row.\n */\nexport type RowProps = {\n  label: string;\n  children: RowChildren;\n  variant?: 'default' | 'warning' | 'critical' | undefined;\n  tooltip?: string | undefined;\n};\n\nconst TYPE = 'Row';\n\n/**\n * A row component, which is used to display a row of information.\n *\n * @param props - The props of the component.\n * @param props.label - The label of the row.\n * @param props.children - The content of the row. This can be an address, an\n * image, or text.\n * @param props.variant - The variant of the row.\n * @param props.tooltip - An optional tooltip to show for the row.\n * @returns A row element.\n * @example\n * <Row label=\"From\" variant=\"warning\" tooltip=\"This address has been deemed dangerous.\">\n *   <Address address=\"0x1234567890123456789012345678901234567890\" />\n * </Row>\n */\nexport const Row = createSnapComponent<RowProps, typeof TYPE>(TYPE);\n\n/**\n * A row element.\n *\n * @see Row\n */\nexport type RowElement = ReturnType<typeof Row>;\n","import { createSnapComponent } from '../component';\n\nconst TYPE = 'Spinner';\n\n/**\n * A spinner component, which is used to display a spinner, indicating that some\n * operation is in progress.\n *\n * This component does not accept any props.\n *\n * @returns A spinner element.\n * @example\n * <Spinner />\n */\nexport const Spinner = createSnapComponent(TYPE);\n\n/**\n * A spinner element.\n *\n * @see Spinner\n */\nexport type SpinnerElement = ReturnType<typeof Spinner>;\n","import type { SnapsChildren } from '../component';\nimport { createSnapComponent } from '../component';\nimport type { StandardFormattingElement } from './formatting';\nimport type { LinkElement } from './Link';\n\n/**\n * The children of the {@link Text} component.\n */\nexport type TextChildren = SnapsChildren<\n  string | StandardFormattingElement | LinkElement\n>;\n\n/**\n * The props of the {@link Text} component.\n *\n * @property children - The text to display.\n */\nexport type TextProps = {\n  children: TextChildren;\n  alignment?: 'start' | 'center' | 'end' | undefined;\n};\n\nconst TYPE = 'Text';\n\n/**\n * A text component, which is used to display text.\n *\n * @param props - The props of the component.\n * @param props.children - The text to display.\n * @returns A text element.\n * @example\n * <Text>\n *   Hello <Bold>world</Bold>!\n * </Text>\n * @example\n * <Text alignment=\"end\">\n *   Hello <Bold>world</Bold>!\n * </Text>\n */\nexport const Text = createSnapComponent<TextProps, typeof TYPE>(TYPE);\n\n/**\n * A text element.\n *\n * @see Text\n */\nexport type TextElement = ReturnType<typeof Text>;\n","import { createSnapComponent } from '../component';\nimport type { StandardFormattingElement } from './formatting';\nimport type { ImageElement } from './Image';\nimport type { LinkElement } from './Link';\nimport type { TextElement } from './Text';\n\nexport type TooltipChildren =\n  | TextElement\n  | StandardFormattingElement\n  | LinkElement\n  | ImageElement\n  | boolean\n  | null;\n\n/**\n * The props of the {@link Tooltip} component.\n *\n * @property children - The children of the box.\n * @property content - The text to display in the tooltip.\n */\nexport type TooltipProps = {\n  children: TooltipChildren;\n  content: TextElement | StandardFormattingElement | LinkElement | string;\n};\n\nconst TYPE = 'Tooltip';\n\n/**\n * A tooltip component, which is used to display text in a tooltip.\n *\n * @param props - The props of the component.\n * @param props.children - The children of the tooltip.\n * @param props.content - The text to display in the tooltip.\n * @returns A tooltip element.\n * @example\n * <Tooltip content=\"Tooltip text\">\n *   <Text>Hello world!</Text>\n * </Tooltip>\n * @example\n * <Tooltip content={<Text>Text with <Bold>formatting</Bold></Text>}>\n *   <Text>Hello world!</Text>\n * </Tooltip>\n */\nexport const Tooltip = createSnapComponent<TooltipProps, typeof TYPE>(TYPE);\n\n/**\n * A tooltip element.\n *\n * @see Tooltip\n */\nexport type TooltipElement = ReturnType<typeof Tooltip>;\n","import type { JsonObject, Key, SnapComponent } from './component';\n\n/**\n * The JSX runtime for Snaps SDK components. This function is used to render\n * Snap components into a format that can be used by the Snaps.\n *\n * This is the \"production\" version of the runtime, which does not include\n * additional validation, as it is handled by MetaMask. To use this runtime,\n * specify `@metamask/snaps-sdk` as import source for JSX, and use `react-jsx`\n * as the pragma.\n *\n * @param component - The component to render.\n * @param props - The props to pass to the component.\n * @param key - The key of the component.\n * @returns The rendered component.\n * @see https://www.typescriptlang.org/tsconfig/#jsx\n */\nexport function jsx<Props extends JsonObject>(\n  component: SnapComponent<Props>,\n  props: Props,\n  key: Key | null,\n): unknown | null {\n  if (typeof component === 'string') {\n    // If component is a string, it is a built-in HTML element. This is not\n    // supported in Snaps, so we throw an error.\n    throw new Error(\n      `An HTML element (\"${String(\n        component,\n      )}\") was used in a Snap component, which is not supported by Snaps UI. Please use one of the supported Snap components.`,\n    );\n  }\n\n  if (!component) {\n    // If component is undefined, a JSX fragment `<>...</>` was used, which is\n    // not supported in Snaps.\n    throw new Error(\n      'A JSX fragment was used in a Snap component, which is not supported by Snaps UI. Please use one of the supported Snap components.',\n    );\n  }\n\n  return component({ ...props, key });\n}\n\n/**\n * The JSX runtime for Snaps SDK components. This function is used to render\n * Snap components into a format that can be used by the Snaps.\n *\n * The `jsxs` function is used for rendering nested components.\n *\n * This is the \"production\" version of the runtime, which does not include\n * additional validation, as it is handled by MetaMask. To use this runtime,\n * specify `@metamask/snaps-sdk` as import source for JSX, and use `react-jsx`\n * as the pragma.\n *\n * @param component - The component to render.\n * @param props - The props to pass to the component.\n * @param key - The key of the component.\n * @returns The rendered component.\n * @see https://www.typescriptlang.org/tsconfig/#jsx\n */\nexport function jsxs<Props extends JsonObject>(\n  component: SnapComponent<Props>,\n  props: Props,\n  key: Key | null,\n): unknown | null {\n  return jsx(component, props, key);\n}\n","import {\n  hasProperty,\n  HexChecksumAddressStruct,\n  isPlainObject,\n  JsonStruct,\n} from '@metamask/utils';\nimport type { Infer, Struct } from 'superstruct';\nimport {\n  is,\n  boolean,\n  optional,\n  array,\n  lazy,\n  nullable,\n  number,\n  object,\n  record,\n  string,\n  tuple,\n} from 'superstruct';\nimport type {\n  AnyStruct,\n  InferStructTuple,\n  ObjectSchema,\n} from 'superstruct/dist/utils';\n\nimport type { Describe } from '../internals';\nimport { literal, nullUnion, svg } from '../internals';\nimport type { EmptyObject } from '../types';\nimport type {\n  GenericSnapElement,\n  JsonObject,\n  Key,\n  Nestable,\n  SnapElement,\n  SnapsChildren,\n  StringElement,\n} from './component';\nimport type {\n  AddressElement,\n  BoldElement,\n  BoxElement,\n  ButtonElement,\n  CheckboxElement,\n  CopyableElement,\n  DividerElement,\n  DropdownElement,\n  OptionElement,\n  FieldElement,\n  FormElement,\n  HeadingElement,\n  ImageElement,\n  InputElement,\n  ItalicElement,\n  JSXElement,\n  LinkElement,\n  RowElement,\n  SpinnerElement,\n  StandardFormattingElement,\n  TextElement,\n  TooltipElement,\n  ValueElement,\n  FileInputElement,\n} from './components';\n\n/**\n * A struct for the {@link Key} type.\n */\nexport const KeyStruct: Describe<Key> = nullUnion([string(), number()]);\n\n/**\n * A struct for the {@link StringElement} type.\n */\nexport const StringElementStruct: Describe<StringElement> = children([\n  string(),\n]);\n\n/**\n * A struct for the {@link GenericSnapElement} type.\n */\nexport const ElementStruct: Describe<GenericSnapElement> = object({\n  type: string(),\n  props: record(string(), JsonStruct),\n  key: nullable(KeyStruct),\n});\n\n/**\n * A helper function for creating a struct for a {@link Nestable} type.\n *\n * @param struct - The struct for the type to test.\n * @returns The struct for the nestable type.\n */\nfunction nestable<Type, Schema>(\n  struct: Struct<Type, Schema>,\n): Struct<Nestable<Type>, any> {\n  const nestableStruct: Struct<Nestable<Type>> = nullUnion([\n    struct,\n    array(lazy(() => nestableStruct)),\n  ]);\n\n  return nestableStruct;\n}\n\n/**\n * A helper function for creating a struct which allows children of a specific\n * type, as well as `null` and `boolean`.\n *\n * @param structs - The structs to allow as children.\n * @returns The struct for the children.\n */\nfunction children<Head extends AnyStruct, Tail extends AnyStruct[]>(\n  structs: [head: Head, ...tail: Tail],\n): Struct<\n  Nestable<Infer<Head> | InferStructTuple<Tail>[number] | boolean | null>,\n  null\n> {\n  return nestable(nullable(nullUnion([...structs, boolean()])));\n}\n\n/**\n * A helper function for creating a struct for a JSX element.\n *\n * @param name - The name of the element.\n * @param props - The props of the element.\n * @returns The struct for the element.\n */\nfunction element<Name extends string, Props extends ObjectSchema = EmptyObject>(\n  name: Name,\n  props: Props = {} as Props,\n) {\n  return object({\n    type: literal(name) as unknown as Struct<Name, Name>,\n    props: object(props),\n    key: nullable(KeyStruct),\n  });\n}\n\n/**\n * A struct for the {@link ButtonElement} type.\n */\nexport const ButtonStruct: Describe<ButtonElement> = element('Button', {\n  children: StringElementStruct,\n  name: optional(string()),\n  type: optional(nullUnion([literal('button'), literal('submit')])),\n  variant: optional(nullUnion([literal('primary'), literal('destructive')])),\n  disabled: optional(boolean()),\n});\n\n/**\n * A struct for the {@link CheckboxElement} type.\n */\nexport const CheckboxStruct: Describe<CheckboxElement> = element('Checkbox', {\n  name: string(),\n  checked: optional(boolean()),\n  label: optional(string()),\n  variant: optional(nullUnion([literal('default'), literal('toggle')])),\n});\n\n/**\n * A struct for the {@link InputElement} type.\n */\nexport const InputStruct: Describe<InputElement> = element('Input', {\n  name: string(),\n  type: optional(\n    nullUnion([literal('text'), literal('password'), literal('number')]),\n  ),\n  value: optional(string()),\n  placeholder: optional(string()),\n});\n\n/**\n * A struct for the {@link OptionElement} type.\n */\nexport const OptionStruct: Describe<OptionElement> = element('Option', {\n  value: string(),\n  children: string(),\n});\n\n/**\n * A struct for the {@link DropdownElement} type.\n */\nexport const DropdownStruct: Describe<DropdownElement> = element('Dropdown', {\n  name: string(),\n  value: optional(string()),\n  children: children([OptionStruct]),\n});\n\n/**\n * A struct for the {@link FileInputElement} type.\n */\nexport const FileInputStruct: Describe<FileInputElement> = element(\n  'FileInput',\n  {\n    name: string(),\n    accept: nullUnion([optional(array(string()))]),\n    compact: optional(boolean()),\n  },\n);\n\n/**\n * A struct for the {@link FieldElement} type.\n */\nexport const FieldStruct: Describe<FieldElement> = element('Field', {\n  label: optional(string()),\n  error: optional(string()),\n  children: nullUnion([\n    tuple([InputStruct, ButtonStruct]),\n    DropdownStruct,\n    FileInputStruct,\n    InputStruct,\n    CheckboxStruct,\n  ]),\n});\n\n/**\n * A struct for the {@link FormElement} type.\n */\nexport const FormStruct: Describe<FormElement> = element('Form', {\n  children: children(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    [FieldStruct, lazy(() => BoxChildStruct)],\n  ) as unknown as Struct<SnapsChildren<GenericSnapElement>, null>,\n  name: string(),\n});\n\n/**\n * A struct for the {@link BoldElement} type.\n */\nexport const BoldStruct: Describe<BoldElement> = element('Bold', {\n  children: children([\n    string(),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    lazy(() => ItalicStruct) as unknown as Struct<\n      SnapElement<JsonObject, 'Italic'>\n    >,\n  ]),\n});\n\n/**\n * A struct for the {@link ItalicElement} type.\n */\nexport const ItalicStruct: Describe<ItalicElement> = element('Italic', {\n  children: children([\n    string(),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    lazy(() => BoldStruct) as unknown as Struct<\n      SnapElement<JsonObject, 'Bold'>\n    >,\n  ]),\n});\n\nexport const FormattingStruct: Describe<StandardFormattingElement> = nullUnion([\n  BoldStruct,\n  ItalicStruct,\n]);\n\n/**\n * A struct for the {@link AddressElement} type.\n */\nexport const AddressStruct: Describe<AddressElement> = element('Address', {\n  address: HexChecksumAddressStruct,\n});\n\n/**\n * A struct for the {@link BoxElement} type.\n */\nexport const BoxStruct: Describe<BoxElement> = element('Box', {\n  children: children(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    [lazy(() => BoxChildStruct)],\n  ) as unknown as Struct<SnapsChildren<GenericSnapElement>, null>,\n  direction: optional(nullUnion([literal('horizontal'), literal('vertical')])),\n  alignment: optional(\n    nullUnion([\n      literal('start'),\n      literal('center'),\n      literal('end'),\n      literal('space-between'),\n      literal('space-around'),\n    ]),\n  ),\n});\n\n/**\n * A struct for the {@link CopyableElement} type.\n */\nexport const CopyableStruct: Describe<CopyableElement> = element('Copyable', {\n  value: string(),\n  sensitive: optional(boolean()),\n});\n\n/**\n * A struct for the {@link DividerElement} type.\n */\nexport const DividerStruct: Describe<DividerElement> = element('Divider');\n\n/**\n * A struct for the {@link ValueElement} type.\n */\nexport const ValueStruct: Describe<ValueElement> = element('Value', {\n  value: string(),\n  extra: string(),\n});\n\n/**\n * A struct for the {@link HeadingElement} type.\n */\nexport const HeadingStruct: Describe<HeadingElement> = element('Heading', {\n  children: StringElementStruct,\n});\n\n/**\n * A struct for the {@link ImageElement} type.\n */\nexport const ImageStruct: Describe<ImageElement> = element('Image', {\n  src: svg(),\n  alt: optional(string()),\n});\n\n/**\n * A struct for the {@link LinkElement} type.\n */\nexport const LinkStruct: Describe<LinkElement> = element('Link', {\n  href: string(),\n  children: children([FormattingStruct, string()]),\n});\n\n/**\n * A struct for the {@link TextElement} type.\n */\nexport const TextStruct: Describe<TextElement> = element('Text', {\n  children: children([string(), BoldStruct, ItalicStruct, LinkStruct]),\n  alignment: optional(\n    nullUnion([literal('start'), literal('center'), literal('end')]),\n  ),\n});\n\n/**\n * A subset of JSX elements that are allowed as children of the Tooltip component.\n * This set should include all text components and the Image.\n */\nexport const TooltipChildStruct = nullUnion([\n  TextStruct,\n  BoldStruct,\n  ItalicStruct,\n  LinkStruct,\n  ImageStruct,\n  boolean(),\n]);\n\n/**\n * A subset of JSX elements that are allowed as content of the Tooltip component.\n * This set should include all text components.\n */\nexport const TooltipContentStruct = nullUnion([\n  TextStruct,\n  BoldStruct,\n  ItalicStruct,\n  LinkStruct,\n  string(),\n]);\n\n/**\n * A struct for the {@link TooltipElement} type.\n */\nexport const TooltipStruct: Describe<TooltipElement> = element('Tooltip', {\n  children: nullable(TooltipChildStruct),\n  content: TooltipContentStruct,\n});\n\n/**\n * A struct for the {@link RowElement} type.\n */\nexport const RowStruct: Describe<RowElement> = element('Row', {\n  label: string(),\n  children: nullUnion([AddressStruct, ImageStruct, TextStruct, ValueStruct]),\n  variant: optional(\n    nullUnion([literal('default'), literal('warning'), literal('critical')]),\n  ),\n  tooltip: optional(string()),\n});\n\n/**\n * A struct for the {@link SpinnerElement} type.\n */\nexport const SpinnerStruct: Describe<SpinnerElement> = element('Spinner');\n\n/**\n * A subset of JSX elements that are allowed as children of the Box component.\n * This set includes all components, except components that need to be nested in\n * another component (e.g., Field must be contained in a Form).\n */\nexport const BoxChildStruct = nullUnion([\n  AddressStruct,\n  BoldStruct,\n  BoxStruct,\n  ButtonStruct,\n  CopyableStruct,\n  DividerStruct,\n  DropdownStruct,\n  FileInputStruct,\n  FormStruct,\n  HeadingStruct,\n  InputStruct,\n  ImageStruct,\n  ItalicStruct,\n  LinkStruct,\n  RowStruct,\n  SpinnerStruct,\n  TextStruct,\n  TooltipStruct,\n  CheckboxStruct,\n]);\n\n/**\n * For now, the allowed JSX elements at the root are the same as the allowed\n * children of the Box component.\n */\nexport const RootJSXElementStruct = BoxChildStruct;\n\n/**\n * A struct for the {@link JSXElement} type.\n */\nexport const JSXElementStruct: Describe<JSXElement> = nullUnion([\n  ButtonStruct,\n  InputStruct,\n  FileInputStruct,\n  FieldStruct,\n  FormStruct,\n  BoldStruct,\n  ItalicStruct,\n  AddressStruct,\n  BoxStruct,\n  CopyableStruct,\n  DividerStruct,\n  HeadingStruct,\n  ImageStruct,\n  LinkStruct,\n  RowStruct,\n  SpinnerStruct,\n  TextStruct,\n  DropdownStruct,\n  OptionStruct,\n  ValueStruct,\n  TooltipStruct,\n  CheckboxStruct,\n]);\n\n/**\n * Check if a value is a JSX element.\n *\n * @param value - The value to check.\n * @returns True if the value is a JSX element, false otherwise.\n */\nexport function isJSXElement(value: unknown): value is JSXElement {\n  return is(value, JSXElementStruct);\n}\n\n/**\n * Check if a value is a JSX element, without validating all of its contents.\n * This is useful when you want to validate the structure of a value, but not\n * all the children.\n *\n * This should only be used when you are sure that the value is safe to use,\n * i.e., after using {@link isJSXElement}.\n *\n * @param value - The value to check.\n * @returns True if the value is a JSX element, false otherwise.\n */\nexport function isJSXElementUnsafe(value: unknown): value is JSXElement {\n  return (\n    isPlainObject(value) &&\n    hasProperty(value, 'type') &&\n    hasProperty(value, 'props') &&\n    hasProperty(value, 'key')\n  );\n}\n\n/**\n * Assert that a value is a JSX element.\n *\n * @param value - The value to check.\n * @throws If the value is not a JSX element.\n */\nexport function assertJSXElement(value: unknown): asserts value is JSXElement {\n  // TODO: We should use the error parsing utils from `snaps-utils` to improve\n  // the error messages. It currently includes colours and potentially other\n  // formatting that we might not want to include in the SDK.\n  if (!isJSXElement(value)) {\n    throw new Error(\n      `Expected a JSX element, but received ${JSON.stringify(\n        value,\n      )}. Please refer to the documentation for the supported JSX elements and their props.`,\n    );\n  }\n}\n","import type { Infer } from 'superstruct';\nimport {\n  Struct,\n  define,\n  literal as superstructLiteral,\n  union as superstructUnion,\n} from 'superstruct';\nimport type { AnyStruct, InferStructTuple } from 'superstruct/dist/utils';\n\nimport type { EnumToUnion } from './helpers';\n\n/**\n * A wrapper of `superstruct`'s `literal` struct that also defines the name of\n * the struct as the literal value.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n * For example, instead of returning an error like:\n *\n * ```\n * Expected the value to satisfy a union of `literal | literal`, but received: \\\"baz\\\"\n * ```\n *\n * This struct will return an error like:\n *\n * ```\n * Expected the value to satisfy a union of `\"foo\" | \"bar\"`, but received: \\\"baz\\\"\n * ```\n *\n * @param value - The literal value.\n * @returns The `superstruct` struct, which validates that the value is equal\n * to the literal value.\n */\nexport function literal<Type extends string | number | boolean>(value: Type) {\n  return define<Type>(\n    JSON.stringify(value),\n    superstructLiteral(value).validator,\n  );\n}\n\n/**\n * A wrapper of `superstruct`'s `union` struct that also defines the schema as\n * the union of the schemas of the structs.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n *\n * @param structs - The structs to union.\n * @param structs.\"0\" - The first struct.\n * @param structs.\"1\" - The remaining structs.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function union<Head extends AnyStruct, Tail extends AnyStruct[]>([\n  head,\n  ...tail\n]: [head: Head, ...tail: Tail]): Struct<\n  Infer<Head> | InferStructTuple<Tail>[number],\n  [head: Head, ...tail: Tail]\n> {\n  const struct = superstructUnion([head, ...tail]);\n\n  return new Struct({\n    ...struct,\n    schema: [head, ...tail],\n  });\n}\n\n/**\n * Superstruct struct for validating an enum value. This allows using both the\n * enum string values and the enum itself as values.\n *\n * @param constant - The enum to validate against.\n * @returns The superstruct struct.\n */\nexport function enumValue<Type extends string>(\n  constant: Type,\n): Struct<EnumToUnion<Type>, null> {\n  return literal(constant as EnumToUnion<Type>);\n}\n","import type { Infer, Struct } from 'superstruct';\nimport type {\n  AnyStruct,\n  EnumSchema,\n  InferStructTuple,\n  IsExactMatch,\n  IsMatch,\n  IsRecord,\n  IsTuple,\n  UnionToIntersection,\n} from 'superstruct/dist/utils';\n\nimport type { EmptyObject } from '../types';\nimport { union } from './structs';\n\n/**\n * Check if a type is a union. Infers `true` if it is a union, otherwise\n * `false`.\n */\ntype IsUnion<Type> = [Type] extends [UnionToIntersection<Type>] ? false : true;\n\n/**\n * Get a struct schema for a type.\n *\n * This is copied from `superstruct` but fixes some issues with the original\n * implementation.\n */\ntype StructSchema<Type> = IsUnion<Type> extends true\n  ? null\n  : [Type] extends [EmptyObject]\n  ? EmptyObject\n  : [Type] extends [string | undefined | null]\n  ? [Type] extends [`0x${string}`]\n    ? null\n    : [Type] extends [IsMatch<Type, string | undefined | null>]\n    ? null\n    : [Type] extends [IsUnion<Type>]\n    ? EnumSchema<Type>\n    : Type\n  : [Type] extends [number | undefined | null]\n  ? [Type] extends [IsMatch<Type, number | undefined | null>]\n    ? null\n    : [Type] extends [IsUnion<Type>]\n    ? EnumSchema<Type>\n    : Type\n  : [Type] extends [boolean]\n  ? [Type] extends [IsExactMatch<Type, boolean>]\n    ? null\n    : Type\n  : Type extends\n      | bigint\n      | symbol\n      | undefined\n      | null\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      | Function\n      | Date\n      | Error\n      | RegExp\n      | Map<any, any>\n      | WeakMap<any, any>\n      | Set<any>\n      | WeakSet<any>\n      | Promise<any>\n  ? null\n  : Type extends (infer E)[]\n  ? Type extends IsTuple<Type>\n    ? null\n    : Struct<E>\n  : Type extends object\n  ? Type extends IsRecord<Type>\n    ? null\n    : {\n        [InnerKey in keyof Type]: Describe<Type[InnerKey]>;\n      }\n  : null;\n\n/**\n * Describe a struct type.\n */\nexport type Describe<Type> = Struct<Type, StructSchema<Type>>;\n\n/**\n * Create a union struct that uses `null` for the schema type, for better\n * compatibility with `Describe`.\n *\n * @param structs - The structs to union.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function nullUnion<Head extends AnyStruct, Tail extends AnyStruct[]>(\n  structs: [head: Head, ...tail: Tail],\n): Struct<Infer<Head> | InferStructTuple<Tail>[number], null> {\n  return union(structs) as unknown as Struct<\n    Infer<Head> | InferStructTuple<Tail>[number],\n    null\n  >;\n}\n","import { refine, string } from 'superstruct';\n\n/**\n * Get a Struct that validates a string as a valid SVG.\n *\n * @returns A Struct that validates a string as a valid SVG.\n * @internal\n */\nexport function svg() {\n  return refine(string(), 'SVG', (value) => {\n    // This validation is intentionally very basic, we don't need to be that strict\n    // and merely have this extra validation as a helpful error if devs aren't\n    // passing in SVGs.\n    if (!value.includes('<svg')) {\n      return 'Value is not a valid SVG.';\n    }\n\n    return true;\n  });\n}\n","import type { JsonObject, Key, SnapComponent } from './component';\nimport { jsx } from './jsx-runtime';\nimport { assertJSXElement } from './validation';\n\n/**\n * The JSX runtime for Snaps SDK components. This function is used to render\n * Snap components into a format that can be used by the Snaps.\n *\n * This is the \"development\" version of the runtime, which includes additional\n * validation, which is otherwise handled by MetaMask. To use this runtime,\n * specify `@metamask/snaps-sdk` as import source for JSX, and use\n * `react-jsxdev` as the pragma.\n *\n * @param component - The component to render.\n * @param props - The props to pass to the component.\n * @param key - The key of the component.\n * @returns The rendered component.\n * @see https://www.typescriptlang.org/tsconfig/#jsx\n */\nexport function jsxDEV<Props extends JsonObject>(\n  component: SnapComponent<Props>,\n  props: Props,\n  key: Key | null,\n): unknown | null {\n  const element = jsx(component, props, key);\n  assertJSXElement(element);\n\n  return element;\n}\n"],"mappings":"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","names":["TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","import_superstruct","superstructLiteral","superstructUnion","import_superstruct","element"]}
\ No newline at end of file
+{
+    "version": 3,
+    "sources": [
+        "../../src/jsx/index.ts",
+        "../../src/jsx/component.ts",
+        "../../src/jsx/components/form/Button.ts",
+        "../../src/jsx/components/form/Checkbox.ts",
+        "../../src/jsx/components/form/Dropdown.ts",
+        "../../src/jsx/components/form/Option.ts",
+        "../../src/jsx/components/form/Field.ts",
+        "../../src/jsx/components/form/FileInput.ts",
+        "../../src/jsx/components/form/Form.ts",
+        "../../src/jsx/components/form/Input.ts",
+        "../../src/jsx/components/formatting/Bold.ts",
+        "../../src/jsx/components/formatting/Italic.ts",
+        "../../src/jsx/components/Address.ts",
+        "../../src/jsx/components/Box.ts",
+        "../../src/jsx/components/Copyable.ts",
+        "../../src/jsx/components/Divider.ts",
+        "../../src/jsx/components/Value.ts",
+        "../../src/jsx/components/Heading.ts",
+        "../../src/jsx/components/Image.ts",
+        "../../src/jsx/components/Link.ts",
+        "../../src/jsx/components/Row.ts",
+        "../../src/jsx/components/Spinner.ts",
+        "../../src/jsx/components/Text.ts",
+        "../../src/jsx/components/Tooltip.ts",
+        "../../src/jsx/jsx-runtime.ts",
+        "../../src/jsx/validation.ts",
+        "../../src/internals/structs.ts",
+        "../../src/internals/jsx.ts",
+        "../../src/internals/svg.ts",
+        "../../src/jsx/jsx-dev-runtime.ts"
+    ],
+    "sourcesContent": [
+        "export * from './component';\nexport * from './components';\nexport * from './jsx-runtime';\nexport * from './jsx-dev-runtime';\nexport {\n  JSXElementStruct,\n  RootJSXElementStruct,\n  isJSXElement,\n  isJSXElementUnsafe,\n  assertJSXElement,\n} from './validation';\n",
+        "import type { Json } from '@metamask/utils';\n\n/**\n * A key, which can be a string or a number.\n */\nexport type Key = string | number;\n\n/**\n * A JSON object.\n */\nexport type JsonObject = Record<string, Json>;\n\n/**\n * A generic JSX element.\n *\n * @property type - The type of the element.\n * @property props - The props of the element.\n * @property key - The key of the element.\n */\nexport type GenericSnapElement = {\n  type: string;\n  props: JsonObject;\n  key: Key | null;\n};\n\n/**\n * A JSX element.\n *\n * @property type - The type of the element.\n * @property props - The props of the element.\n * @property key - The key of the element.\n */\nexport type SnapElement<\n  Props extends JsonObject = Record<string, never>,\n  Type extends string = string,\n> = {\n  type: Type;\n  props: Props;\n  key: Key | null;\n};\n\n/**\n * A type that can be a single value or an infinitely nestable array of values.\n *\n * @template Type - The type that can be an array.\n * @example\n * type NestableString = Nestable<string>;\n * const nestableString: NestableString = 'hello';\n * const nestableStringArray: NestableString = ['hello', 'world', ['foo', ['bar']]];\n */\nexport type Nestable<Type> = Type | Nestable<Type>[];\n\n/**\n * A type that can be a single value or an array of values, a boolean, or null.\n *\n * @template Type - The type that can be an array.\n */\nexport type SnapsChildren<Type> = Nestable<Type | boolean | null>;\n\n/**\n * A JSX node, which can be an element, a string, null, or an array of nodes.\n */\nexport type SnapNode = SnapsChildren<GenericSnapElement | string>;\n\n/**\n * A JSX string element, which can be a string or an array of strings, or\n * booleans (for conditional rendering).\n */\nexport type StringElement = SnapsChildren<string>;\n\n/**\n * A JSX component.\n */\nexport type SnapComponent<\n  Props extends JsonObject = Record<string, never>,\n  Type extends string = string,\n> = (props: Props & { key?: Key | null }) => SnapElement<Props, Type>;\n\n/**\n * Remove undefined props from an object.\n *\n * @param props - The object to remove undefined props from.\n * @returns The object without undefined props.\n */\nfunction removeUndefinedProps<Props extends JsonObject>(props: Props): Props {\n  return Object.fromEntries(\n    Object.entries(props).filter(([, value]) => value !== undefined),\n  ) as Props;\n}\n\n/**\n * Create a Snap component from a type. This is a helper function that creates a\n * Snap component function.\n *\n * @param type - The type of the component.\n * @returns A function that creates a Snap element.\n * @see SnapComponent\n */\nexport function createSnapComponent<\n  Props extends JsonObject = Record<string, never>,\n  Type extends string = string,\n>(type: Type): SnapComponent<Props, Type> {\n  return (props: Props & { key?: Key | null }) => {\n    const { key = null, ...rest } = props;\n    return {\n      type,\n      props: removeUndefinedProps(rest as Props),\n      key,\n    };\n  };\n}\n",
+        "import type { StringElement } from '../../component';\nimport { createSnapComponent } from '../../component';\n\n// TODO: Add the `onClick` prop to the `ButtonProps` type.\n\n/**\n * The props of the {@link Button} component.\n *\n * @property children - The text to display on the button.\n * @property name - The name of the button. This is used to identify the button\n * in the event handler.\n * @property type - The type of the button, i.e., `'button'` or `'submit'`.\n * Defaults to `'button'`.\n * @property variant - The variant of the button, i.e., `'primary'` or\n * `'destructive'`. Defaults to `'primary'`.\n * @property disabled - Whether the button is disabled. Defaults to `false`.\n */\nexport type ButtonProps = {\n  children: StringElement;\n  name?: string | undefined;\n  type?: 'button' | 'submit' | undefined;\n  variant?: 'primary' | 'destructive' | undefined;\n  disabled?: boolean | undefined;\n};\n\nconst TYPE = 'Button';\n\n/**\n * A button component, which is used to create a clickable button.\n *\n * @param props - The props of the component.\n * @param props.children - The text to display on the button. This should be a\n * string or an array of strings.\n * @returns A button element.\n * @example\n * <Button name=\"my-button\">Click me</Button>\n */\nexport const Button = createSnapComponent<ButtonProps, typeof TYPE>(TYPE);\n\n/**\n * A button element.\n *\n * @see Button\n */\nexport type ButtonElement = ReturnType<typeof Button>;\n",
+        "import { createSnapComponent } from '../../component';\n\n/**\n * The props of the {@link Checkbox} component.\n *\n * @property name - The name of the checkbox. This is used to identify the\n * state in the form data.\n * @property checked - Whether the checkbox is checked or not.\n * @property label - An optional label for the checkbox.\n * @property variant - An optional variant for the checkbox.\n */\nexport type CheckboxProps = {\n  name: string;\n  checked?: boolean | undefined;\n  label?: string | undefined;\n  variant?: 'default' | 'toggle' | undefined;\n};\n\nconst TYPE = 'Checkbox';\n\n/**\n * A checkbox component, which is used to create a checkbox.\n *\n * @param props - The props of the component.\n * @param props.name - The name of the checkbox. This is used to identify the\n * state in the form data.\n * @param props.checked - Whether the checkbox is checked or not.\n * @param props.label - An optional label for the checkbox.\n * @param props.variant - An optional variant for the checkbox.\n * @returns A checkbox element.\n * @example\n * <Checkbox name=\"accept-terms\" />\n */\nexport const Checkbox = createSnapComponent<CheckboxProps, typeof TYPE>(TYPE);\n\n/**\n * A checkbox element.\n *\n * @see Checkbox\n */\nexport type CheckboxElement = ReturnType<typeof Checkbox>;\n",
+        "import type { SnapsChildren } from '../../component';\nimport { createSnapComponent } from '../../component';\nimport type { OptionElement } from './Option';\n\n/**\n * The props of the {@link Dropdown} component.\n *\n * @property name - The name of the dropdown. This is used to identify the\n * state in the form data.\n * @property value - The selected value of the dropdown.\n * @property children - The children of the dropdown.\n */\nexport type DropdownProps = {\n  name: string;\n  value?: string | undefined;\n  children: SnapsChildren<OptionElement>;\n};\n\nconst TYPE = 'Dropdown';\n\n/**\n * A dropdown component, which is used to create a dropdown.\n *\n * @param props - The props of the component.\n * @param props.name - The name of the dropdown field. This is used to identify the\n * state in the form data.\n * @param props.value - The selected value of the dropdown.\n * @param props.children - The children of the dropdown.\n * @returns A dropdown element.\n * @example\n * <Dropdown name=\"dropdown\">\n *  <Option value=\"option1\">Option 1</Option>\n *  <Option value=\"option2\">Option 2</Option>\n *  <Option value=\"option3\">Option 3</Option>\n * </Dropdown>\n */\nexport const Dropdown = createSnapComponent<DropdownProps, typeof TYPE>(TYPE);\n\n/**\n * A dropdown element.\n *\n * @see Dropdown\n */\nexport type DropdownElement = ReturnType<typeof Dropdown>;\n",
+        "import { createSnapComponent } from '../../component';\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport { Dropdown } from './Dropdown';\n\n/**\n * The props of the {@link Option} component.\n *\n * @property value - The value of the dropdown option. This is used to populate the\n * state in the form data.\n * @property children - The text to display.\n */\ntype OptionProps = {\n  value: string;\n  children: string;\n};\n\nconst TYPE = 'Option';\n\n/**\n * A dropdown option component, which is used to create a dropdown option. This component\n * can only be used as a child of the {@link Dropdown} component.\n *\n * @param props - The props of the component.\n * @param props.value - The value of the dropdown option. This is used to populate the\n * state in the form data.\n * @param props.children - The text to display.\n * @returns A dropdown option element.\n * @example\n * <Dropdown name=\"dropdown\">\n *  <Option value=\"option1\">Option 1</Option>\n *  <Option value=\"option2\">Option 2</Option>\n *  <Option value=\"option3\">Option 3</Option>\n * </Dropdown>\n */\nexport const Option = createSnapComponent<OptionProps, typeof TYPE>(TYPE);\n\n/**\n * A dropdown option element.\n *\n * @see Option\n */\nexport type OptionElement = ReturnType<typeof Option>;\n",
+        "import { createSnapComponent } from '../../component';\nimport type { ButtonElement } from './Button';\nimport type { CheckboxElement } from './Checkbox';\nimport type { DropdownElement } from './Dropdown';\nimport type { FileInputElement } from './FileInput';\nimport type { InputElement } from './Input';\n\n/**\n * The props of the {@link Field} component.\n *\n * @property label - The label of the field.\n * @property error - The error message of the field.\n * @property children - The input field and the submit button.\n */\nexport type FieldProps = {\n  label?: string | undefined;\n  error?: string | undefined;\n  children:\n    | [InputElement, ButtonElement]\n    | DropdownElement\n    | FileInputElement\n    | InputElement\n    | CheckboxElement;\n};\n\nconst TYPE = 'Field';\n\n/**\n * A field component, which is used to create a form field. This component can\n * only be used as a child of the {@link Form} component.\n *\n * @param props - The props of the component.\n * @param props.label - The label of the field.\n * @param props.error - The error message of the field.\n * @param props.children - The input field and the submit button.\n * @returns A field element.\n * @example\n * <Field label=\"Username\">\n *   <Input name=\"username\" type=\"text\" />\n *   <Button type=\"submit\">Submit</Button>\n * </Field>\n * @example\n * <Field label=\"Upload file\">\n *   <FileInput name=\"file\" accept={['image/*']} multiple />\n * </Field>\n */\nexport const Field = createSnapComponent<FieldProps, typeof TYPE>(TYPE);\n\n/**\n * A field element.\n *\n * @see Field\n */\nexport type FieldElement = ReturnType<typeof Field>;\n",
+        "import { createSnapComponent } from '../../component';\n\n/**\n * The props of the {@link FileInput} component.\n *\n * @property name - The name of the file input field. This is used to identify\n * the file input field in the form data.\n * @property label - The label of the file input field.\n * @property accept - The file types that the file input field accepts. If not\n * specified, the file input field accepts all file types.\n * @property compact - Whether the file input field is compact. Default is\n * `false`.\n */\nexport type FileInputProps = {\n  name: string;\n  accept?: string[] | undefined;\n  compact?: boolean | undefined;\n};\n\nconst TYPE = 'FileInput';\n\n/**\n * A file input component, which is used to create a file input field. This\n * component can only be used as a child of the {@link Field} component.\n *\n * The total size of the files that can be uploaded may not exceed 64 MB.\n *\n * @param props - The props of the component.\n * @param props.name - The name of the file input field. This is used to\n * identify the file input field in the form data.\n * @param props.accept - The file types that the file input field accepts. If\n * not specified, the file input field accepts all file types. For examples of\n * valid values, see the [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/accept).\n * @param props.compact - Whether the file input field is compact. Default is\n * `false`.\n * @returns A file input element.\n * @example\n * <FileInput name=\"file\" accept={['image/*']} />\n * @example\n * <FileInput name=\"file\" compact />\n * @example\n * <Field label=\"Upload file\">\n *   <FileInput name=\"file\" />\n * </Field>\n */\nexport const FileInput = createSnapComponent<FileInputProps, typeof TYPE>(TYPE);\n\n/**\n * A file input element.\n *\n * @see FileInput\n */\nexport type FileInputElement = ReturnType<typeof FileInput>;\n",
+        "import type { GenericSnapElement, SnapsChildren } from '../../component';\nimport { createSnapComponent } from '../../component';\n\n// TODO: Add `onSubmit` prop to the `FormProps` type.\n\n/**\n * The props of the {@link Form} component.\n *\n * @property children - The children of the form.\n * @property name - The name of the form. This is used to identify the form in\n * the event handler.\n */\nexport type FormProps = {\n  children: SnapsChildren<GenericSnapElement>;\n  name: string;\n};\n\nconst TYPE = 'Form';\n\n/**\n * A form component, which is used to create a form.\n *\n * @param props - The props of the component.\n * @param props.children - The form fields. This should be a single field or an\n * array of fields.\n * @param props.name - The name of the form. This is used to identify the form\n * in the event handler.\n * @returns A form element.\n * @example\n * <Form name=\"my-form\">\n *   <Field label=\"Username\">\n *     <Input name=\"username\" type=\"text\" />\n *   </Field>\n *   <Button type=\"submit\">Submit</Button>\n * </Form>\n */\nexport const Form = createSnapComponent<FormProps, typeof TYPE>(TYPE);\n\n/**\n * A form element.\n *\n * @see Form\n */\nexport type FormElement = ReturnType<typeof Form>;\n",
+        "import { createSnapComponent } from '../../component';\n\n// TODO: Add the `onChange` prop to the `InputProps` type.\n\n/**\n * The props of the {@link Input} component.\n *\n * @property name - The name of the input field. This is used to identify the\n * input field in the form data.\n * @property type - The type of the input field. Defaults to `text`.\n * @property value - The value of the input field.\n * @property placeholder - The placeholder text of the input field.\n */\nexport type InputProps = {\n  name: string;\n  type?: 'text' | 'password' | 'number' | undefined;\n  value?: string | undefined;\n  placeholder?: string | undefined;\n};\n\nconst TYPE = 'Input';\n\n/**\n * An input component, which is used to create an input field.\n *\n * @param props - The props of the component.\n * @param props.name - The name of the input field. This is used to identify the\n * input field in the form data.\n * @param props.type - The type of the input field.\n * @param props.value - The value of the input field.\n * @param props.placeholder - The placeholder text of the input field.\n * @returns An input element.\n * @example\n * <Input name=\"username\" type=\"text\" />\n */\nexport const Input = createSnapComponent<InputProps, typeof TYPE>(TYPE);\n\n/**\n * An input element.\n *\n * @see Input\n */\nexport type InputElement = ReturnType<typeof Input>;\n",
+        "import type { JsonObject, SnapElement, SnapsChildren } from '../../component';\nimport { createSnapComponent } from '../../component';\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport { Text } from '../Text';\n\n/**\n * The children of the {@link Bold} component.\n */\nexport type BoldChildren = SnapsChildren<\n  | string\n  // We have to specify the type here to avoid a circular reference.\n  | SnapElement<JsonObject, 'Italic'>\n>;\n\n/**\n * The props of the {@link Bold} component.\n *\n * @property children - The text to display in bold.\n */\nexport type BoldProps = {\n  children: BoldChildren;\n};\n\nconst TYPE = 'Bold';\n\n/**\n * A bold component, which is used to display text in bold. This component can\n * only be used as a child of the {@link Text} component.\n *\n * @param props - The props of the component.\n * @param props.children - The text to display in bold.\n * @returns A bold element.\n * @example\n * <Text>\n *   Hello <Bold>world</Bold>!\n * </Text>\n */\nexport const Bold = createSnapComponent<BoldProps, typeof TYPE>(TYPE);\n\n/**\n * A bold element.\n *\n * @see Bold\n */\nexport type BoldElement = ReturnType<typeof Bold>;\n",
+        "import type { JsonObject, SnapElement, SnapsChildren } from '../../component';\nimport { createSnapComponent } from '../../component';\n\n/**\n * The children of the {@link Italic} component.\n */\nexport type ItalicChildren = SnapsChildren<\n  | string\n  // We have to specify the type here to avoid a circular reference.\n  | SnapElement<JsonObject, 'Bold'>\n>;\n\n/**\n * The props of the {@link Italic} component.\n *\n * @property children - The text to display in italic. This should be a string\n * or an array of strings.\n */\nexport type ItalicProps = {\n  children: ItalicChildren;\n};\n\nconst TYPE = 'Italic';\n\n/**\n * An italic component, which is used to display text in italic. This componen\n * can only be used as a child of the {@link Text} component.\n *\n * @param props - The props of the component.\n * @param props.children - The text to display in italic. This should be a\n * string or an array of strings.\n * @returns An italic element.\n * @example\n * <Text>\n *   Hello <Italic>world</Italic>!\n * </Text>\n */\nexport const Italic = createSnapComponent<ItalicProps, typeof TYPE>(TYPE);\n\n/**\n * An italic element.\n *\n * @see Italic\n */\nexport type ItalicElement = ReturnType<typeof Italic>;\n",
+        "import { createSnapComponent } from '../component';\n\n/**\n * The props of the {@link Address} component.\n *\n * @property address - The (Ethereum) address to display. This should be a\n * valid Ethereum address, starting with `0x`.\n */\nexport type AddressProps = {\n  address: `0x${string}`;\n};\n\nconst TYPE = 'Address';\n\n/**\n * An address component, which is used to display an Ethereum address.\n *\n * This component does not accept any children.\n *\n * @param props - The props of the component.\n * @param props.address - The (Ethereum) address to display. This should be a\n * valid Ethereum address, starting with `0x`.\n * @returns An address element.\n * @example\n * <Address address=\"0x1234567890123456789012345678901234567890\" />\n */\nexport const Address = createSnapComponent<AddressProps, typeof TYPE>(TYPE);\n\n/**\n * An address element.\n *\n * @see Address\n */\nexport type AddressElement = ReturnType<typeof Address>;\n",
+        "import type { GenericSnapElement, SnapsChildren } from '../component';\nimport { createSnapComponent } from '../component';\n\n/**\n * The props of the {@link Box} component.\n *\n * @property children - The children of the box.\n * @property direction - The direction to stack the components within the box. Defaults to `vertical`.\n * @property alignment - The alignment mode to use within the box. Defaults to `start`.\n */\nexport type BoxProps = {\n  // We can't use `JSXElement` because it causes a circular reference.\n  children: SnapsChildren<GenericSnapElement>;\n  direction?: 'vertical' | 'horizontal' | undefined;\n  alignment?:\n    | 'start'\n    | 'center'\n    | 'end'\n    | 'space-between'\n    | 'space-around'\n    | undefined;\n};\n\nconst TYPE = 'Box';\n\n/**\n * A box component, which is used to group multiple components together.\n *\n * @param props - The props of the component.\n * @param props.children - The children of the box.\n * @returns A box element.\n * @example\n * <Box>\n *   <Text>Hello world!</Text>\n * </Box>\n */\nexport const Box = createSnapComponent<BoxProps, typeof TYPE>(TYPE);\n\n/**\n * A box element.\n *\n * @see Box\n */\nexport type BoxElement = ReturnType<typeof Box>;\n",
+        "import { createSnapComponent } from '../component';\n\n/**\n * The props of the {@link Copyable} component.\n *\n * @property value - The value to copy when the user clicks on the copyable\n * element.\n * @property sensitive - Whether the value is sensitive. If `true`, the value\n * will be hidden when the user is not interacting with the copyable element.\n */\nexport type CopyableProps = {\n  value: string;\n  sensitive?: boolean | undefined;\n};\n\nconst TYPE = 'Copyable';\n\n/**\n * A copyable component, which is used to display text that can be copied by the\n * user.\n *\n * @param props - The props of the component.\n * @param props.value - The value to copy when the user clicks on the copyable\n * element.\n * @param props.sensitive - Whether the value is sensitive. If `true`, the value\n * will be hidden when the user is not interacting with the copyable element.\n * @example\n * <Copyable value=\"0x1234567890123456789012345678901234567890\" />\n * <Copyable value=\"0x1234567890123456789012345678901234567890\" sensitive />\n */\nexport const Copyable = createSnapComponent<CopyableProps, typeof TYPE>(TYPE);\n\n/**\n * A copyable element.\n *\n * @see Copyable\n */\nexport type CopyableElement = ReturnType<typeof Copyable>;\n",
+        "import { createSnapComponent } from '../component';\n\nconst TYPE = 'Divider';\n\n/**\n * A divider component, which is used to create a horizontal line between\n * elements.\n *\n * This component does not have any props.\n *\n * @returns A divider element.\n * @example\n * <Divider />\n */\nexport const Divider = createSnapComponent(TYPE);\n\n/**\n * A divider element.\n *\n * @see Divider\n */\nexport type DividerElement = ReturnType<typeof Divider>;\n",
+        "import { createSnapComponent } from '../component';\n\n/**\n * The props of the {@link Value} component.\n *\n * @property value - The value shown on the right side.\n * @property extra - The extra text shown on the left side.\n */\nexport type ValueProps = {\n  value: string;\n  extra: string;\n};\n\nconst TYPE = 'Value';\n\n/**\n * A value component, which can be used to display two different text values side by side.\n *\n * This component can only be used as a child of the {@link Row} component.\n *\n * This component does not accept any children.\n *\n * @param props - The props of the component.\n * @param props.value - The value shown on the right side.\n * @param props.extra - The extra text shown on the left side.\n * @returns A value element.\n * @example\n * <Value value=\"0.05 ETH\" extra=\"$200\" />\n */\nexport const Value = createSnapComponent<ValueProps, typeof TYPE>(TYPE);\n\n/**\n * A value element.\n *\n * @see Value\n */\nexport type ValueElement = ReturnType<typeof Value>;\n",
+        "import type { StringElement } from '../component';\nimport { createSnapComponent } from '../component';\n\n/**\n * The props of the {@link Heading} component.\n *\n * @property children - The text to display in the heading.\n */\ntype HeadingProps = {\n  children: StringElement;\n};\n\nconst TYPE = 'Heading';\n\n/**\n * A heading component, which is used to display heading text.\n *\n * @param props - The props of the component.\n * @param props.children - The text to display in the heading.\n * @returns A heading element.\n * @example\n * <Heading>Hello world!</Heading>\n */\nexport const Heading = createSnapComponent<HeadingProps, typeof TYPE>(TYPE);\n\n/**\n * A heading element.\n *\n * @see Heading\n */\nexport type HeadingElement = ReturnType<typeof Heading>;\n",
+        "import { createSnapComponent } from '../component';\n\n/**\n * The props of the {@link Image} component.\n *\n * @property src - The SVG image to display. This should be an SVG string, and\n * other formats such as PNG and JPEG are not supported directly. You can use\n * the `data:` URL scheme to embed images inside the SVG.\n * @property alt - The alternative text of the image, which describes the image\n * for users who cannot see it.\n */\ntype ImageProps = {\n  src: string;\n  alt?: string | undefined;\n};\n\nconst TYPE = 'Image';\n\n/**\n * An image component, which is used to display an image.\n *\n * This component does not accept any children.\n *\n * @param props - The props of the component.\n * @param props.src - The URL of the image to display. This should be an SVG\n * string, and other formats such as PNG and JPEG are not supported directly.\n * You can use the `data:` URL scheme to embed images inside the SVG.\n * @param props.alt - The alternative text of the image, which describes the\n * image for users who cannot see it.\n * @returns An image element.\n * @example\n * <Image src=\"<svg>...</svg>\" alt=\"An example image\" />\n */\nexport const Image = createSnapComponent<ImageProps, typeof TYPE>(TYPE);\n\n/**\n * An image element.\n *\n * @see Image\n */\nexport type ImageElement = ReturnType<typeof Image>;\n",
+        "import type { SnapsChildren } from '../component';\nimport { createSnapComponent } from '../component';\nimport type { StandardFormattingElement } from './formatting';\n\n/**\n * The children of the {@link Link} component.\n */\nexport type LinkChildren = SnapsChildren<string | StandardFormattingElement>;\n\n/**\n * The props of the {@link Link} component.\n *\n * @property children - The text to display in the link.\n * @property href - The URL to link to. This must be an `https` or `mailto` URL.\n * `http` is not allowed.\n */\nexport type LinkProps = {\n  children: LinkChildren;\n  href: string;\n};\n\nconst TYPE = 'Link';\n\n/**\n * A link component, which is used to display a hyperlink.\n *\n * @param props - The props of the component.\n * @param props.children - The text to display in the link.\n * @param props.href - The URL to link to. This must be an `https` or `mailto`\n * URL. `http` is not allowed.\n * @returns A link element.\n * @example\n * <Link href=\"https://example.com\">Click here</Link>\n */\nexport const Link = createSnapComponent<LinkProps, typeof TYPE>(TYPE);\n\n/**\n * A link element.\n *\n * @see Link\n */\nexport type LinkElement = ReturnType<typeof Link>;\n",
+        "import { createSnapComponent } from '../component';\nimport type { AddressElement } from './Address';\nimport type { ImageElement } from './Image';\nimport type { TextElement } from './Text';\nimport type { ValueElement } from './Value';\n\n/**\n * The children of a {@link Row} component.\n */\nexport type RowChildren =\n  | AddressElement\n  | ImageElement\n  | TextElement\n  | ValueElement;\n\n/**\n * The props of the {@link Row} component.\n *\n * @property label - The label of the row.\n * @property children - The content of the row. This can be an address, an\n * image, or text.\n * @property variant - The variant of the row.\n * @property tooltip - An optional tooltip to show for the row.\n */\nexport type RowProps = {\n  label: string;\n  children: RowChildren;\n  variant?: 'default' | 'warning' | 'critical' | undefined;\n  tooltip?: string | undefined;\n};\n\nconst TYPE = 'Row';\n\n/**\n * A row component, which is used to display a row of information.\n *\n * @param props - The props of the component.\n * @param props.label - The label of the row.\n * @param props.children - The content of the row. This can be an address, an\n * image, or text.\n * @param props.variant - The variant of the row.\n * @param props.tooltip - An optional tooltip to show for the row.\n * @returns A row element.\n * @example\n * <Row label=\"From\" variant=\"warning\" tooltip=\"This address has been deemed dangerous.\">\n *   <Address address=\"0x1234567890123456789012345678901234567890\" />\n * </Row>\n */\nexport const Row = createSnapComponent<RowProps, typeof TYPE>(TYPE);\n\n/**\n * A row element.\n *\n * @see Row\n */\nexport type RowElement = ReturnType<typeof Row>;\n",
+        "import { createSnapComponent } from '../component';\n\nconst TYPE = 'Spinner';\n\n/**\n * A spinner component, which is used to display a spinner, indicating that some\n * operation is in progress.\n *\n * This component does not accept any props.\n *\n * @returns A spinner element.\n * @example\n * <Spinner />\n */\nexport const Spinner = createSnapComponent(TYPE);\n\n/**\n * A spinner element.\n *\n * @see Spinner\n */\nexport type SpinnerElement = ReturnType<typeof Spinner>;\n",
+        "import type { SnapsChildren } from '../component';\nimport { createSnapComponent } from '../component';\nimport type { StandardFormattingElement } from './formatting';\nimport type { LinkElement } from './Link';\n\n/**\n * The children of the {@link Text} component.\n */\nexport type TextChildren = SnapsChildren<\n  string | StandardFormattingElement | LinkElement\n>;\n\n/**\n * The props of the {@link Text} component.\n *\n * @property children - The text to display.\n */\nexport type TextProps = {\n  children: TextChildren;\n  alignment?: 'start' | 'center' | 'end' | undefined;\n};\n\nconst TYPE = 'Text';\n\n/**\n * A text component, which is used to display text.\n *\n * @param props - The props of the component.\n * @param props.children - The text to display.\n * @returns A text element.\n * @example\n * <Text>\n *   Hello <Bold>world</Bold>!\n * </Text>\n * @example\n * <Text alignment=\"end\">\n *   Hello <Bold>world</Bold>!\n * </Text>\n */\nexport const Text = createSnapComponent<TextProps, typeof TYPE>(TYPE);\n\n/**\n * A text element.\n *\n * @see Text\n */\nexport type TextElement = ReturnType<typeof Text>;\n",
+        "import { createSnapComponent } from '../component';\nimport type { StandardFormattingElement } from './formatting';\nimport type { ImageElement } from './Image';\nimport type { LinkElement } from './Link';\nimport type { TextElement } from './Text';\n\nexport type TooltipChildren =\n  | TextElement\n  | StandardFormattingElement\n  | LinkElement\n  | ImageElement\n  | boolean\n  | null;\n\n/**\n * The props of the {@link Tooltip} component.\n *\n * @property children - The children of the box.\n * @property content - The text to display in the tooltip.\n */\nexport type TooltipProps = {\n  children: TooltipChildren;\n  content: TextElement | StandardFormattingElement | LinkElement | string;\n};\n\nconst TYPE = 'Tooltip';\n\n/**\n * A tooltip component, which is used to display text in a tooltip.\n *\n * @param props - The props of the component.\n * @param props.children - The children of the tooltip.\n * @param props.content - The text to display in the tooltip.\n * @returns A tooltip element.\n * @example\n * <Tooltip content=\"Tooltip text\">\n *   <Text>Hello world!</Text>\n * </Tooltip>\n * @example\n * <Tooltip content={<Text>Text with <Bold>formatting</Bold></Text>}>\n *   <Text>Hello world!</Text>\n * </Tooltip>\n */\nexport const Tooltip = createSnapComponent<TooltipProps, typeof TYPE>(TYPE);\n\n/**\n * A tooltip element.\n *\n * @see Tooltip\n */\nexport type TooltipElement = ReturnType<typeof Tooltip>;\n",
+        "import type { JsonObject, Key, SnapComponent } from './component';\n\n/**\n * The JSX runtime for Snaps SDK components. This function is used to render\n * Snap components into a format that can be used by the Snaps.\n *\n * This is the \"production\" version of the runtime, which does not include\n * additional validation, as it is handled by MetaMask. To use this runtime,\n * specify `@metamask/snaps-sdk` as import source for JSX, and use `react-jsx`\n * as the pragma.\n *\n * @param component - The component to render.\n * @param props - The props to pass to the component.\n * @param key - The key of the component.\n * @returns The rendered component.\n * @see https://www.typescriptlang.org/tsconfig/#jsx\n */\nexport function jsx<Props extends JsonObject>(\n  component: SnapComponent<Props>,\n  props: Props,\n  key: Key | null,\n): unknown | null {\n  if (typeof component === 'string') {\n    // If component is a string, it is a built-in HTML element. This is not\n    // supported in Snaps, so we throw an error.\n    throw new Error(\n      `An HTML element (\"${String(\n        component,\n      )}\") was used in a Snap component, which is not supported by Snaps UI. Please use one of the supported Snap components.`,\n    );\n  }\n\n  if (!component) {\n    // If component is undefined, a JSX fragment `<>...</>` was used, which is\n    // not supported in Snaps.\n    throw new Error(\n      'A JSX fragment was used in a Snap component, which is not supported by Snaps UI. Please use one of the supported Snap components.',\n    );\n  }\n\n  return component({ ...props, key });\n}\n\n/**\n * The JSX runtime for Snaps SDK components. This function is used to render\n * Snap components into a format that can be used by the Snaps.\n *\n * The `jsxs` function is used for rendering nested components.\n *\n * This is the \"production\" version of the runtime, which does not include\n * additional validation, as it is handled by MetaMask. To use this runtime,\n * specify `@metamask/snaps-sdk` as import source for JSX, and use `react-jsx`\n * as the pragma.\n *\n * @param component - The component to render.\n * @param props - The props to pass to the component.\n * @param key - The key of the component.\n * @returns The rendered component.\n * @see https://www.typescriptlang.org/tsconfig/#jsx\n */\nexport function jsxs<Props extends JsonObject>(\n  component: SnapComponent<Props>,\n  props: Props,\n  key: Key | null,\n): unknown | null {\n  return jsx(component, props, key);\n}\n",
+        "import {\n  hasProperty,\n  HexChecksumAddressStruct,\n  isPlainObject,\n  JsonStruct,\n} from '@metamask/utils';\nimport type { Infer, Struct } from '@metamask/superstruct';\nimport {\n  is,\n  boolean,\n  optional,\n  array,\n  lazy,\n  nullable,\n  number,\n  object,\n  record,\n  string,\n  tuple,\n} from '@metamask/superstruct';\nimport type {\n  AnyStruct,\n  InferStructTuple,\n  ObjectSchema,\n} from '@metamask/superstruct';\n\nimport type { Describe } from '../internals';\nimport { literal, nullUnion, svg } from '../internals';\nimport type { EmptyObject } from '../types';\nimport type {\n  GenericSnapElement,\n  JsonObject,\n  Key,\n  Nestable,\n  SnapElement,\n  SnapsChildren,\n  StringElement,\n} from './component';\nimport type {\n  AddressElement,\n  BoldElement,\n  BoxElement,\n  ButtonElement,\n  CheckboxElement,\n  CopyableElement,\n  DividerElement,\n  DropdownElement,\n  OptionElement,\n  FieldElement,\n  FormElement,\n  HeadingElement,\n  ImageElement,\n  InputElement,\n  ItalicElement,\n  JSXElement,\n  LinkElement,\n  RowElement,\n  SpinnerElement,\n  StandardFormattingElement,\n  TextElement,\n  TooltipElement,\n  ValueElement,\n  FileInputElement,\n} from './components';\n\n/**\n * A struct for the {@link Key} type.\n */\nexport const KeyStruct: Describe<Key> = nullUnion([string(), number()]);\n\n/**\n * A struct for the {@link StringElement} type.\n */\nexport const StringElementStruct: Describe<StringElement> = children([\n  string(),\n]);\n\n/**\n * A struct for the {@link GenericSnapElement} type.\n */\nexport const ElementStruct: Describe<GenericSnapElement> = object({\n  type: string(),\n  props: record(string(), JsonStruct),\n  key: nullable(KeyStruct),\n});\n\n/**\n * A helper function for creating a struct for a {@link Nestable} type.\n *\n * @param struct - The struct for the type to test.\n * @returns The struct for the nestable type.\n */\nfunction nestable<Type, Schema>(\n  struct: Struct<Type, Schema>,\n): Struct<Nestable<Type>, any> {\n  const nestableStruct: Struct<Nestable<Type>> = nullUnion([\n    struct,\n    array(lazy(() => nestableStruct)),\n  ]);\n\n  return nestableStruct;\n}\n\n/**\n * A helper function for creating a struct which allows children of a specific\n * type, as well as `null` and `boolean`.\n *\n * @param structs - The structs to allow as children.\n * @returns The struct for the children.\n */\nfunction children<Head extends AnyStruct, Tail extends AnyStruct[]>(\n  structs: [head: Head, ...tail: Tail],\n): Struct<\n  Nestable<Infer<Head> | InferStructTuple<Tail>[number] | boolean | null>,\n  null\n> {\n  return nestable(nullable(nullUnion([...structs, boolean()])));\n}\n\n/**\n * A helper function for creating a struct for a JSX element.\n *\n * @param name - The name of the element.\n * @param props - The props of the element.\n * @returns The struct for the element.\n */\nfunction element<Name extends string, Props extends ObjectSchema = EmptyObject>(\n  name: Name,\n  props: Props = {} as Props,\n) {\n  return object({\n    type: literal(name) as unknown as Struct<Name, Name>,\n    props: object(props),\n    key: nullable(KeyStruct),\n  });\n}\n\n/**\n * A struct for the {@link ButtonElement} type.\n */\nexport const ButtonStruct: Describe<ButtonElement> = element('Button', {\n  children: StringElementStruct,\n  name: optional(string()),\n  type: optional(nullUnion([literal('button'), literal('submit')])),\n  variant: optional(nullUnion([literal('primary'), literal('destructive')])),\n  disabled: optional(boolean()),\n});\n\n/**\n * A struct for the {@link CheckboxElement} type.\n */\nexport const CheckboxStruct: Describe<CheckboxElement> = element('Checkbox', {\n  name: string(),\n  checked: optional(boolean()),\n  label: optional(string()),\n  variant: optional(nullUnion([literal('default'), literal('toggle')])),\n});\n\n/**\n * A struct for the {@link InputElement} type.\n */\nexport const InputStruct: Describe<InputElement> = element('Input', {\n  name: string(),\n  type: optional(\n    nullUnion([literal('text'), literal('password'), literal('number')]),\n  ),\n  value: optional(string()),\n  placeholder: optional(string()),\n});\n\n/**\n * A struct for the {@link OptionElement} type.\n */\nexport const OptionStruct: Describe<OptionElement> = element('Option', {\n  value: string(),\n  children: string(),\n});\n\n/**\n * A struct for the {@link DropdownElement} type.\n */\nexport const DropdownStruct: Describe<DropdownElement> = element('Dropdown', {\n  name: string(),\n  value: optional(string()),\n  children: children([OptionStruct]),\n});\n\n/**\n * A struct for the {@link FileInputElement} type.\n */\nexport const FileInputStruct: Describe<FileInputElement> = element(\n  'FileInput',\n  {\n    name: string(),\n    accept: nullUnion([optional(array(string()))]),\n    compact: optional(boolean()),\n  },\n);\n\n/**\n * A struct for the {@link FieldElement} type.\n */\nexport const FieldStruct: Describe<FieldElement> = element('Field', {\n  label: optional(string()),\n  error: optional(string()),\n  children: nullUnion([\n    tuple([InputStruct, ButtonStruct]),\n    DropdownStruct,\n    FileInputStruct,\n    InputStruct,\n    CheckboxStruct,\n  ]),\n});\n\n/**\n * A struct for the {@link FormElement} type.\n */\nexport const FormStruct: Describe<FormElement> = element('Form', {\n  children: children(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    [FieldStruct, lazy(() => BoxChildStruct)],\n  ) as unknown as Struct<SnapsChildren<GenericSnapElement>, null>,\n  name: string(),\n});\n\n/**\n * A struct for the {@link BoldElement} type.\n */\nexport const BoldStruct: Describe<BoldElement> = element('Bold', {\n  children: children([\n    string(),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    lazy(() => ItalicStruct) as unknown as Struct<\n      SnapElement<JsonObject, 'Italic'>\n    >,\n  ]),\n});\n\n/**\n * A struct for the {@link ItalicElement} type.\n */\nexport const ItalicStruct: Describe<ItalicElement> = element('Italic', {\n  children: children([\n    string(),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    lazy(() => BoldStruct) as unknown as Struct<\n      SnapElement<JsonObject, 'Bold'>\n    >,\n  ]),\n});\n\nexport const FormattingStruct: Describe<StandardFormattingElement> = nullUnion([\n  BoldStruct,\n  ItalicStruct,\n]);\n\n/**\n * A struct for the {@link AddressElement} type.\n */\nexport const AddressStruct: Describe<AddressElement> = element('Address', {\n  address: HexChecksumAddressStruct,\n});\n\n/**\n * A struct for the {@link BoxElement} type.\n */\nexport const BoxStruct: Describe<BoxElement> = element('Box', {\n  children: children(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    [lazy(() => BoxChildStruct)],\n  ) as unknown as Struct<SnapsChildren<GenericSnapElement>, null>,\n  direction: optional(nullUnion([literal('horizontal'), literal('vertical')])),\n  alignment: optional(\n    nullUnion([\n      literal('start'),\n      literal('center'),\n      literal('end'),\n      literal('space-between'),\n      literal('space-around'),\n    ]),\n  ),\n});\n\n/**\n * A struct for the {@link CopyableElement} type.\n */\nexport const CopyableStruct: Describe<CopyableElement> = element('Copyable', {\n  value: string(),\n  sensitive: optional(boolean()),\n});\n\n/**\n * A struct for the {@link DividerElement} type.\n */\nexport const DividerStruct: Describe<DividerElement> = element('Divider');\n\n/**\n * A struct for the {@link ValueElement} type.\n */\nexport const ValueStruct: Describe<ValueElement> = element('Value', {\n  value: string(),\n  extra: string(),\n});\n\n/**\n * A struct for the {@link HeadingElement} type.\n */\nexport const HeadingStruct: Describe<HeadingElement> = element('Heading', {\n  children: StringElementStruct,\n});\n\n/**\n * A struct for the {@link ImageElement} type.\n */\nexport const ImageStruct: Describe<ImageElement> = element('Image', {\n  src: svg(),\n  alt: optional(string()),\n});\n\n/**\n * A struct for the {@link LinkElement} type.\n */\nexport const LinkStruct: Describe<LinkElement> = element('Link', {\n  href: string(),\n  children: children([FormattingStruct, string()]),\n});\n\n/**\n * A struct for the {@link TextElement} type.\n */\nexport const TextStruct: Describe<TextElement> = element('Text', {\n  children: children([string(), BoldStruct, ItalicStruct, LinkStruct]),\n  alignment: optional(\n    nullUnion([literal('start'), literal('center'), literal('end')]),\n  ),\n});\n\n/**\n * A subset of JSX elements that are allowed as children of the Tooltip component.\n * This set should include all text components and the Image.\n */\nexport const TooltipChildStruct = nullUnion([\n  TextStruct,\n  BoldStruct,\n  ItalicStruct,\n  LinkStruct,\n  ImageStruct,\n  boolean(),\n]);\n\n/**\n * A subset of JSX elements that are allowed as content of the Tooltip component.\n * This set should include all text components.\n */\nexport const TooltipContentStruct = nullUnion([\n  TextStruct,\n  BoldStruct,\n  ItalicStruct,\n  LinkStruct,\n  string(),\n]);\n\n/**\n * A struct for the {@link TooltipElement} type.\n */\nexport const TooltipStruct: Describe<TooltipElement> = element('Tooltip', {\n  children: nullable(TooltipChildStruct),\n  content: TooltipContentStruct,\n});\n\n/**\n * A struct for the {@link RowElement} type.\n */\nexport const RowStruct: Describe<RowElement> = element('Row', {\n  label: string(),\n  children: nullUnion([AddressStruct, ImageStruct, TextStruct, ValueStruct]),\n  variant: optional(\n    nullUnion([literal('default'), literal('warning'), literal('critical')]),\n  ),\n  tooltip: optional(string()),\n});\n\n/**\n * A struct for the {@link SpinnerElement} type.\n */\nexport const SpinnerStruct: Describe<SpinnerElement> = element('Spinner');\n\n/**\n * A subset of JSX elements that are allowed as children of the Box component.\n * This set includes all components, except components that need to be nested in\n * another component (e.g., Field must be contained in a Form).\n */\nexport const BoxChildStruct = nullUnion([\n  AddressStruct,\n  BoldStruct,\n  BoxStruct,\n  ButtonStruct,\n  CopyableStruct,\n  DividerStruct,\n  DropdownStruct,\n  FileInputStruct,\n  FormStruct,\n  HeadingStruct,\n  InputStruct,\n  ImageStruct,\n  ItalicStruct,\n  LinkStruct,\n  RowStruct,\n  SpinnerStruct,\n  TextStruct,\n  TooltipStruct,\n  CheckboxStruct,\n]);\n\n/**\n * For now, the allowed JSX elements at the root are the same as the allowed\n * children of the Box component.\n */\nexport const RootJSXElementStruct = BoxChildStruct;\n\n/**\n * A struct for the {@link JSXElement} type.\n */\nexport const JSXElementStruct: Describe<JSXElement> = nullUnion([\n  ButtonStruct,\n  InputStruct,\n  FileInputStruct,\n  FieldStruct,\n  FormStruct,\n  BoldStruct,\n  ItalicStruct,\n  AddressStruct,\n  BoxStruct,\n  CopyableStruct,\n  DividerStruct,\n  HeadingStruct,\n  ImageStruct,\n  LinkStruct,\n  RowStruct,\n  SpinnerStruct,\n  TextStruct,\n  DropdownStruct,\n  OptionStruct,\n  ValueStruct,\n  TooltipStruct,\n  CheckboxStruct,\n]);\n\n/**\n * Check if a value is a JSX element.\n *\n * @param value - The value to check.\n * @returns True if the value is a JSX element, false otherwise.\n */\nexport function isJSXElement(value: unknown): value is JSXElement {\n  return is(value, JSXElementStruct);\n}\n\n/**\n * Check if a value is a JSX element, without validating all of its contents.\n * This is useful when you want to validate the structure of a value, but not\n * all the children.\n *\n * This should only be used when you are sure that the value is safe to use,\n * i.e., after using {@link isJSXElement}.\n *\n * @param value - The value to check.\n * @returns True if the value is a JSX element, false otherwise.\n */\nexport function isJSXElementUnsafe(value: unknown): value is JSXElement {\n  return (\n    isPlainObject(value) &&\n    hasProperty(value, 'type') &&\n    hasProperty(value, 'props') &&\n    hasProperty(value, 'key')\n  );\n}\n\n/**\n * Assert that a value is a JSX element.\n *\n * @param value - The value to check.\n * @throws If the value is not a JSX element.\n */\nexport function assertJSXElement(value: unknown): asserts value is JSXElement {\n  // TODO: We should use the error parsing utils from `snaps-utils` to improve\n  // the error messages. It currently includes colours and potentially other\n  // formatting that we might not want to include in the SDK.\n  if (!isJSXElement(value)) {\n    throw new Error(\n      `Expected a JSX element, but received ${JSON.stringify(\n        value,\n      )}. Please refer to the documentation for the supported JSX elements and their props.`,\n    );\n  }\n}\n",
+        "import type { Infer } from '@metamask/superstruct';\nimport {\n  Struct,\n  define,\n  literal as superstructLiteral,\n  union as superstructUnion,\n} from '@metamask/superstruct';\nimport type { AnyStruct, InferStructTuple } from '@metamask/superstruct';\n\nimport type { EnumToUnion } from './helpers';\n\n/**\n * A wrapper of `superstruct`'s `literal` struct that also defines the name of\n * the struct as the literal value.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n * For example, instead of returning an error like:\n *\n * ```\n * Expected the value to satisfy a union of `literal | literal`, but received: \\\"baz\\\"\n * ```\n *\n * This struct will return an error like:\n *\n * ```\n * Expected the value to satisfy a union of `\"foo\" | \"bar\"`, but received: \\\"baz\\\"\n * ```\n *\n * @param value - The literal value.\n * @returns The `superstruct` struct, which validates that the value is equal\n * to the literal value.\n */\nexport function literal<Type extends string | number | boolean>(value: Type) {\n  return define<Type>(\n    JSON.stringify(value),\n    superstructLiteral(value).validator,\n  );\n}\n\n/**\n * A wrapper of `superstruct`'s `union` struct that also defines the schema as\n * the union of the schemas of the structs.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n *\n * @param structs - The structs to union.\n * @param structs.\"0\" - The first struct.\n * @param structs.\"1\" - The remaining structs.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function union<Head extends AnyStruct, Tail extends AnyStruct[]>([\n  head,\n  ...tail\n]: [head: Head, ...tail: Tail]): Struct<\n  Infer<Head> | InferStructTuple<Tail>[number],\n  [head: Head, ...tail: Tail]\n> {\n  const struct = superstructUnion([head, ...tail]);\n\n  return new Struct({\n    ...struct,\n    schema: [head, ...tail],\n  });\n}\n\n/**\n * Superstruct struct for validating an enum value. This allows using both the\n * enum string values and the enum itself as values.\n *\n * @param constant - The enum to validate against.\n * @returns The superstruct struct.\n */\nexport function enumValue<Type extends string>(\n  constant: Type,\n): Struct<EnumToUnion<Type>, null> {\n  return literal(constant as EnumToUnion<Type>);\n}\n",
+        "import type { Infer, Struct } from '@metamask/superstruct';\nimport type {\n  AnyStruct,\n  EnumSchema,\n  InferStructTuple,\n  IsExactMatch,\n  IsMatch,\n  IsRecord,\n  IsTuple,\n  UnionToIntersection,\n} from '@metamask/superstruct';\n\nimport type { EmptyObject } from '../types';\nimport { union } from './structs';\n\n/**\n * Check if a type is a union. Infers `true` if it is a union, otherwise\n * `false`.\n */\ntype IsUnion<Type> = [Type] extends [UnionToIntersection<Type>] ? false : true;\n\n/**\n * Get a struct schema for a type.\n *\n * This is copied from `superstruct` but fixes some issues with the original\n * implementation.\n */\ntype StructSchema<Type> = IsUnion<Type> extends true\n  ? null\n  : [Type] extends [EmptyObject]\n  ? EmptyObject\n  : [Type] extends [string | undefined | null]\n  ? [Type] extends [`0x${string}`]\n    ? null\n    : [Type] extends [IsMatch<Type, string | undefined | null>]\n    ? null\n    : [Type] extends [IsUnion<Type>]\n    ? EnumSchema<Type>\n    : Type\n  : [Type] extends [number | undefined | null]\n  ? [Type] extends [IsMatch<Type, number | undefined | null>]\n    ? null\n    : [Type] extends [IsUnion<Type>]\n    ? EnumSchema<Type>\n    : Type\n  : [Type] extends [boolean]\n  ? [Type] extends [IsExactMatch<Type, boolean>]\n    ? null\n    : Type\n  : Type extends\n      | bigint\n      | symbol\n      | undefined\n      | null\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      | Function\n      | Date\n      | Error\n      | RegExp\n      | Map<any, any>\n      | WeakMap<any, any>\n      | Set<any>\n      | WeakSet<any>\n      | Promise<any>\n  ? null\n  : Type extends (infer E)[]\n  ? Type extends IsTuple<Type>\n    ? null\n    : Struct<E>\n  : Type extends object\n  ? Type extends IsRecord<Type>\n    ? null\n    : {\n        [InnerKey in keyof Type]: Describe<Type[InnerKey]>;\n      }\n  : null;\n\n/**\n * Describe a struct type.\n */\nexport type Describe<Type> = Struct<Type, StructSchema<Type>>;\n\n/**\n * Create a union struct that uses `null` for the schema type, for better\n * compatibility with `Describe`.\n *\n * @param structs - The structs to union.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function nullUnion<Head extends AnyStruct, Tail extends AnyStruct[]>(\n  structs: [head: Head, ...tail: Tail],\n): Struct<Infer<Head> | InferStructTuple<Tail>[number], null> {\n  return union(structs) as unknown as Struct<\n    Infer<Head> | InferStructTuple<Tail>[number],\n    null\n  >;\n}\n",
+        "import { refine, string } from '@metamask/superstruct';\n\n/**\n * Get a Struct that validates a string as a valid SVG.\n *\n * @returns A Struct that validates a string as a valid SVG.\n * @internal\n */\nexport function svg() {\n  return refine(string(), 'SVG', (value) => {\n    // This validation is intentionally very basic, we don't need to be that strict\n    // and merely have this extra validation as a helpful error if devs aren't\n    // passing in SVGs.\n    if (!value.includes('<svg')) {\n      return 'Value is not a valid SVG.';\n    }\n\n    return true;\n  });\n}\n",
+        "import type { JsonObject, Key, SnapComponent } from './component';\nimport { jsx } from './jsx-runtime';\nimport { assertJSXElement } from './validation';\n\n/**\n * The JSX runtime for Snaps SDK components. This function is used to render\n * Snap components into a format that can be used by the Snaps.\n *\n * This is the \"development\" version of the runtime, which includes additional\n * validation, which is otherwise handled by MetaMask. To use this runtime,\n * specify `@metamask/snaps-sdk` as import source for JSX, and use\n * `react-jsxdev` as the pragma.\n *\n * @param component - The component to render.\n * @param props - The props to pass to the component.\n * @param key - The key of the component.\n * @returns The rendered component.\n * @see https://www.typescriptlang.org/tsconfig/#jsx\n */\nexport function jsxDEV<Props extends JsonObject>(\n  component: SnapComponent<Props>,\n  props: Props,\n  key: Key | null,\n): unknown | null {\n  const element = jsx(component, props, key);\n  assertJSXElement(element);\n\n  return element;\n}\n"
+    ],
+    "mappings": "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",
+    "names": [
+        "TYPE",
+        "TYPE",
+        "TYPE",
+        "TYPE",
+        "TYPE",
+        "TYPE",
+        "TYPE",
+        "TYPE",
+        "TYPE",
+        "TYPE",
+        "TYPE",
+        "TYPE",
+        "TYPE",
+        "TYPE",
+        "TYPE",
+        "TYPE",
+        "TYPE",
+        "TYPE",
+        "TYPE",
+        "TYPE",
+        "TYPE",
+        "import_superstruct",
+        "superstructLiteral",
+        "superstructUnion",
+        "import_superstruct",
+        "element"
+    ]
+}
\ No newline at end of file
diff --git a/dist/jsx/index.mjs.map b/dist/jsx/index.mjs.map
index f20039d01fa7d6a3299c584bdbb5dea4a7015b1c..59b66e001ec9c9d35d61842f2b6108e7671cf3b4 100644
--- a/dist/jsx/index.mjs.map
+++ b/dist/jsx/index.mjs.map
@@ -1 +1 @@
-{"version":3,"sources":["../../src/jsx/component.ts","../../src/jsx/components/form/Button.ts","../../src/jsx/components/form/Checkbox.ts","../../src/jsx/components/form/Dropdown.ts","../../src/jsx/components/form/Option.ts","../../src/jsx/components/form/Field.ts","../../src/jsx/components/form/FileInput.ts","../../src/jsx/components/form/Form.ts","../../src/jsx/components/form/Input.ts","../../src/jsx/components/formatting/Bold.ts","../../src/jsx/components/formatting/Italic.ts","../../src/jsx/components/Address.ts","../../src/jsx/components/Box.ts","../../src/jsx/components/Copyable.ts","../../src/jsx/components/Divider.ts","../../src/jsx/components/Value.ts","../../src/jsx/components/Heading.ts","../../src/jsx/components/Image.ts","../../src/jsx/components/Link.ts","../../src/jsx/components/Row.ts","../../src/jsx/components/Spinner.ts","../../src/jsx/components/Text.ts","../../src/jsx/components/Tooltip.ts","../../src/jsx/jsx-runtime.ts","../../src/jsx/validation.ts","../../src/internals/structs.ts","../../src/internals/jsx.ts","../../src/internals/svg.ts","../../src/jsx/jsx-dev-runtime.ts"],"sourcesContent":["import type { Json } from '@metamask/utils';\n\n/**\n * A key, which can be a string or a number.\n */\nexport type Key = string | number;\n\n/**\n * A JSON object.\n */\nexport type JsonObject = Record<string, Json>;\n\n/**\n * A generic JSX element.\n *\n * @property type - The type of the element.\n * @property props - The props of the element.\n * @property key - The key of the element.\n */\nexport type GenericSnapElement = {\n  type: string;\n  props: JsonObject;\n  key: Key | null;\n};\n\n/**\n * A JSX element.\n *\n * @property type - The type of the element.\n * @property props - The props of the element.\n * @property key - The key of the element.\n */\nexport type SnapElement<\n  Props extends JsonObject = Record<string, never>,\n  Type extends string = string,\n> = {\n  type: Type;\n  props: Props;\n  key: Key | null;\n};\n\n/**\n * A type that can be a single value or an infinitely nestable array of values.\n *\n * @template Type - The type that can be an array.\n * @example\n * type NestableString = Nestable<string>;\n * const nestableString: NestableString = 'hello';\n * const nestableStringArray: NestableString = ['hello', 'world', ['foo', ['bar']]];\n */\nexport type Nestable<Type> = Type | Nestable<Type>[];\n\n/**\n * A type that can be a single value or an array of values, a boolean, or null.\n *\n * @template Type - The type that can be an array.\n */\nexport type SnapsChildren<Type> = Nestable<Type | boolean | null>;\n\n/**\n * A JSX node, which can be an element, a string, null, or an array of nodes.\n */\nexport type SnapNode = SnapsChildren<GenericSnapElement | string>;\n\n/**\n * A JSX string element, which can be a string or an array of strings, or\n * booleans (for conditional rendering).\n */\nexport type StringElement = SnapsChildren<string>;\n\n/**\n * A JSX component.\n */\nexport type SnapComponent<\n  Props extends JsonObject = Record<string, never>,\n  Type extends string = string,\n> = (props: Props & { key?: Key | null }) => SnapElement<Props, Type>;\n\n/**\n * Remove undefined props from an object.\n *\n * @param props - The object to remove undefined props from.\n * @returns The object without undefined props.\n */\nfunction removeUndefinedProps<Props extends JsonObject>(props: Props): Props {\n  return Object.fromEntries(\n    Object.entries(props).filter(([, value]) => value !== undefined),\n  ) as Props;\n}\n\n/**\n * Create a Snap component from a type. This is a helper function that creates a\n * Snap component function.\n *\n * @param type - The type of the component.\n * @returns A function that creates a Snap element.\n * @see SnapComponent\n */\nexport function createSnapComponent<\n  Props extends JsonObject = Record<string, never>,\n  Type extends string = string,\n>(type: Type): SnapComponent<Props, Type> {\n  return (props: Props & { key?: Key | null }) => {\n    const { key = null, ...rest } = props;\n    return {\n      type,\n      props: removeUndefinedProps(rest as Props),\n      key,\n    };\n  };\n}\n","import type { StringElement } from '../../component';\nimport { createSnapComponent } from '../../component';\n\n// TODO: Add the `onClick` prop to the `ButtonProps` type.\n\n/**\n * The props of the {@link Button} component.\n *\n * @property children - The text to display on the button.\n * @property name - The name of the button. This is used to identify the button\n * in the event handler.\n * @property type - The type of the button, i.e., `'button'` or `'submit'`.\n * Defaults to `'button'`.\n * @property variant - The variant of the button, i.e., `'primary'` or\n * `'destructive'`. Defaults to `'primary'`.\n * @property disabled - Whether the button is disabled. Defaults to `false`.\n */\nexport type ButtonProps = {\n  children: StringElement;\n  name?: string | undefined;\n  type?: 'button' | 'submit' | undefined;\n  variant?: 'primary' | 'destructive' | undefined;\n  disabled?: boolean | undefined;\n};\n\nconst TYPE = 'Button';\n\n/**\n * A button component, which is used to create a clickable button.\n *\n * @param props - The props of the component.\n * @param props.children - The text to display on the button. This should be a\n * string or an array of strings.\n * @returns A button element.\n * @example\n * <Button name=\"my-button\">Click me</Button>\n */\nexport const Button = createSnapComponent<ButtonProps, typeof TYPE>(TYPE);\n\n/**\n * A button element.\n *\n * @see Button\n */\nexport type ButtonElement = ReturnType<typeof Button>;\n","import { createSnapComponent } from '../../component';\n\n/**\n * The props of the {@link Checkbox} component.\n *\n * @property name - The name of the checkbox. This is used to identify the\n * state in the form data.\n * @property checked - Whether the checkbox is checked or not.\n * @property label - An optional label for the checkbox.\n * @property variant - An optional variant for the checkbox.\n */\nexport type CheckboxProps = {\n  name: string;\n  checked?: boolean | undefined;\n  label?: string | undefined;\n  variant?: 'default' | 'toggle' | undefined;\n};\n\nconst TYPE = 'Checkbox';\n\n/**\n * A checkbox component, which is used to create a checkbox.\n *\n * @param props - The props of the component.\n * @param props.name - The name of the checkbox. This is used to identify the\n * state in the form data.\n * @param props.checked - Whether the checkbox is checked or not.\n * @param props.label - An optional label for the checkbox.\n * @param props.variant - An optional variant for the checkbox.\n * @returns A checkbox element.\n * @example\n * <Checkbox name=\"accept-terms\" />\n */\nexport const Checkbox = createSnapComponent<CheckboxProps, typeof TYPE>(TYPE);\n\n/**\n * A checkbox element.\n *\n * @see Checkbox\n */\nexport type CheckboxElement = ReturnType<typeof Checkbox>;\n","import type { SnapsChildren } from '../../component';\nimport { createSnapComponent } from '../../component';\nimport type { OptionElement } from './Option';\n\n/**\n * The props of the {@link Dropdown} component.\n *\n * @property name - The name of the dropdown. This is used to identify the\n * state in the form data.\n * @property value - The selected value of the dropdown.\n * @property children - The children of the dropdown.\n */\nexport type DropdownProps = {\n  name: string;\n  value?: string | undefined;\n  children: SnapsChildren<OptionElement>;\n};\n\nconst TYPE = 'Dropdown';\n\n/**\n * A dropdown component, which is used to create a dropdown.\n *\n * @param props - The props of the component.\n * @param props.name - The name of the dropdown field. This is used to identify the\n * state in the form data.\n * @param props.value - The selected value of the dropdown.\n * @param props.children - The children of the dropdown.\n * @returns A dropdown element.\n * @example\n * <Dropdown name=\"dropdown\">\n *  <Option value=\"option1\">Option 1</Option>\n *  <Option value=\"option2\">Option 2</Option>\n *  <Option value=\"option3\">Option 3</Option>\n * </Dropdown>\n */\nexport const Dropdown = createSnapComponent<DropdownProps, typeof TYPE>(TYPE);\n\n/**\n * A dropdown element.\n *\n * @see Dropdown\n */\nexport type DropdownElement = ReturnType<typeof Dropdown>;\n","import { createSnapComponent } from '../../component';\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport { Dropdown } from './Dropdown';\n\n/**\n * The props of the {@link Option} component.\n *\n * @property value - The value of the dropdown option. This is used to populate the\n * state in the form data.\n * @property children - The text to display.\n */\ntype OptionProps = {\n  value: string;\n  children: string;\n};\n\nconst TYPE = 'Option';\n\n/**\n * A dropdown option component, which is used to create a dropdown option. This component\n * can only be used as a child of the {@link Dropdown} component.\n *\n * @param props - The props of the component.\n * @param props.value - The value of the dropdown option. This is used to populate the\n * state in the form data.\n * @param props.children - The text to display.\n * @returns A dropdown option element.\n * @example\n * <Dropdown name=\"dropdown\">\n *  <Option value=\"option1\">Option 1</Option>\n *  <Option value=\"option2\">Option 2</Option>\n *  <Option value=\"option3\">Option 3</Option>\n * </Dropdown>\n */\nexport const Option = createSnapComponent<OptionProps, typeof TYPE>(TYPE);\n\n/**\n * A dropdown option element.\n *\n * @see Option\n */\nexport type OptionElement = ReturnType<typeof Option>;\n","import { createSnapComponent } from '../../component';\nimport type { ButtonElement } from './Button';\nimport type { CheckboxElement } from './Checkbox';\nimport type { DropdownElement } from './Dropdown';\nimport type { FileInputElement } from './FileInput';\nimport type { InputElement } from './Input';\n\n/**\n * The props of the {@link Field} component.\n *\n * @property label - The label of the field.\n * @property error - The error message of the field.\n * @property children - The input field and the submit button.\n */\nexport type FieldProps = {\n  label?: string | undefined;\n  error?: string | undefined;\n  children:\n    | [InputElement, ButtonElement]\n    | DropdownElement\n    | FileInputElement\n    | InputElement\n    | CheckboxElement;\n};\n\nconst TYPE = 'Field';\n\n/**\n * A field component, which is used to create a form field. This component can\n * only be used as a child of the {@link Form} component.\n *\n * @param props - The props of the component.\n * @param props.label - The label of the field.\n * @param props.error - The error message of the field.\n * @param props.children - The input field and the submit button.\n * @returns A field element.\n * @example\n * <Field label=\"Username\">\n *   <Input name=\"username\" type=\"text\" />\n *   <Button type=\"submit\">Submit</Button>\n * </Field>\n * @example\n * <Field label=\"Upload file\">\n *   <FileInput name=\"file\" accept={['image/*']} multiple />\n * </Field>\n */\nexport const Field = createSnapComponent<FieldProps, typeof TYPE>(TYPE);\n\n/**\n * A field element.\n *\n * @see Field\n */\nexport type FieldElement = ReturnType<typeof Field>;\n","import { createSnapComponent } from '../../component';\n\n/**\n * The props of the {@link FileInput} component.\n *\n * @property name - The name of the file input field. This is used to identify\n * the file input field in the form data.\n * @property label - The label of the file input field.\n * @property accept - The file types that the file input field accepts. If not\n * specified, the file input field accepts all file types.\n * @property compact - Whether the file input field is compact. Default is\n * `false`.\n */\nexport type FileInputProps = {\n  name: string;\n  accept?: string[] | undefined;\n  compact?: boolean | undefined;\n};\n\nconst TYPE = 'FileInput';\n\n/**\n * A file input component, which is used to create a file input field. This\n * component can only be used as a child of the {@link Field} component.\n *\n * The total size of the files that can be uploaded may not exceed 64 MB.\n *\n * @param props - The props of the component.\n * @param props.name - The name of the file input field. This is used to\n * identify the file input field in the form data.\n * @param props.accept - The file types that the file input field accepts. If\n * not specified, the file input field accepts all file types. For examples of\n * valid values, see the [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/accept).\n * @param props.compact - Whether the file input field is compact. Default is\n * `false`.\n * @returns A file input element.\n * @example\n * <FileInput name=\"file\" accept={['image/*']} />\n * @example\n * <FileInput name=\"file\" compact />\n * @example\n * <Field label=\"Upload file\">\n *   <FileInput name=\"file\" />\n * </Field>\n */\nexport const FileInput = createSnapComponent<FileInputProps, typeof TYPE>(TYPE);\n\n/**\n * A file input element.\n *\n * @see FileInput\n */\nexport type FileInputElement = ReturnType<typeof FileInput>;\n","import type { GenericSnapElement, SnapsChildren } from '../../component';\nimport { createSnapComponent } from '../../component';\n\n// TODO: Add `onSubmit` prop to the `FormProps` type.\n\n/**\n * The props of the {@link Form} component.\n *\n * @property children - The children of the form.\n * @property name - The name of the form. This is used to identify the form in\n * the event handler.\n */\nexport type FormProps = {\n  children: SnapsChildren<GenericSnapElement>;\n  name: string;\n};\n\nconst TYPE = 'Form';\n\n/**\n * A form component, which is used to create a form.\n *\n * @param props - The props of the component.\n * @param props.children - The form fields. This should be a single field or an\n * array of fields.\n * @param props.name - The name of the form. This is used to identify the form\n * in the event handler.\n * @returns A form element.\n * @example\n * <Form name=\"my-form\">\n *   <Field label=\"Username\">\n *     <Input name=\"username\" type=\"text\" />\n *   </Field>\n *   <Button type=\"submit\">Submit</Button>\n * </Form>\n */\nexport const Form = createSnapComponent<FormProps, typeof TYPE>(TYPE);\n\n/**\n * A form element.\n *\n * @see Form\n */\nexport type FormElement = ReturnType<typeof Form>;\n","import { createSnapComponent } from '../../component';\n\n// TODO: Add the `onChange` prop to the `InputProps` type.\n\n/**\n * The props of the {@link Input} component.\n *\n * @property name - The name of the input field. This is used to identify the\n * input field in the form data.\n * @property type - The type of the input field. Defaults to `text`.\n * @property value - The value of the input field.\n * @property placeholder - The placeholder text of the input field.\n */\nexport type InputProps = {\n  name: string;\n  type?: 'text' | 'password' | 'number' | undefined;\n  value?: string | undefined;\n  placeholder?: string | undefined;\n};\n\nconst TYPE = 'Input';\n\n/**\n * An input component, which is used to create an input field.\n *\n * @param props - The props of the component.\n * @param props.name - The name of the input field. This is used to identify the\n * input field in the form data.\n * @param props.type - The type of the input field.\n * @param props.value - The value of the input field.\n * @param props.placeholder - The placeholder text of the input field.\n * @returns An input element.\n * @example\n * <Input name=\"username\" type=\"text\" />\n */\nexport const Input = createSnapComponent<InputProps, typeof TYPE>(TYPE);\n\n/**\n * An input element.\n *\n * @see Input\n */\nexport type InputElement = ReturnType<typeof Input>;\n","import type { JsonObject, SnapElement, SnapsChildren } from '../../component';\nimport { createSnapComponent } from '../../component';\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport { Text } from '../Text';\n\n/**\n * The children of the {@link Bold} component.\n */\nexport type BoldChildren = SnapsChildren<\n  | string\n  // We have to specify the type here to avoid a circular reference.\n  | SnapElement<JsonObject, 'Italic'>\n>;\n\n/**\n * The props of the {@link Bold} component.\n *\n * @property children - The text to display in bold.\n */\nexport type BoldProps = {\n  children: BoldChildren;\n};\n\nconst TYPE = 'Bold';\n\n/**\n * A bold component, which is used to display text in bold. This component can\n * only be used as a child of the {@link Text} component.\n *\n * @param props - The props of the component.\n * @param props.children - The text to display in bold.\n * @returns A bold element.\n * @example\n * <Text>\n *   Hello <Bold>world</Bold>!\n * </Text>\n */\nexport const Bold = createSnapComponent<BoldProps, typeof TYPE>(TYPE);\n\n/**\n * A bold element.\n *\n * @see Bold\n */\nexport type BoldElement = ReturnType<typeof Bold>;\n","import type { JsonObject, SnapElement, SnapsChildren } from '../../component';\nimport { createSnapComponent } from '../../component';\n\n/**\n * The children of the {@link Italic} component.\n */\nexport type ItalicChildren = SnapsChildren<\n  | string\n  // We have to specify the type here to avoid a circular reference.\n  | SnapElement<JsonObject, 'Bold'>\n>;\n\n/**\n * The props of the {@link Italic} component.\n *\n * @property children - The text to display in italic. This should be a string\n * or an array of strings.\n */\nexport type ItalicProps = {\n  children: ItalicChildren;\n};\n\nconst TYPE = 'Italic';\n\n/**\n * An italic component, which is used to display text in italic. This componen\n * can only be used as a child of the {@link Text} component.\n *\n * @param props - The props of the component.\n * @param props.children - The text to display in italic. This should be a\n * string or an array of strings.\n * @returns An italic element.\n * @example\n * <Text>\n *   Hello <Italic>world</Italic>!\n * </Text>\n */\nexport const Italic = createSnapComponent<ItalicProps, typeof TYPE>(TYPE);\n\n/**\n * An italic element.\n *\n * @see Italic\n */\nexport type ItalicElement = ReturnType<typeof Italic>;\n","import { createSnapComponent } from '../component';\n\n/**\n * The props of the {@link Address} component.\n *\n * @property address - The (Ethereum) address to display. This should be a\n * valid Ethereum address, starting with `0x`.\n */\nexport type AddressProps = {\n  address: `0x${string}`;\n};\n\nconst TYPE = 'Address';\n\n/**\n * An address component, which is used to display an Ethereum address.\n *\n * This component does not accept any children.\n *\n * @param props - The props of the component.\n * @param props.address - The (Ethereum) address to display. This should be a\n * valid Ethereum address, starting with `0x`.\n * @returns An address element.\n * @example\n * <Address address=\"0x1234567890123456789012345678901234567890\" />\n */\nexport const Address = createSnapComponent<AddressProps, typeof TYPE>(TYPE);\n\n/**\n * An address element.\n *\n * @see Address\n */\nexport type AddressElement = ReturnType<typeof Address>;\n","import type { GenericSnapElement, SnapsChildren } from '../component';\nimport { createSnapComponent } from '../component';\n\n/**\n * The props of the {@link Box} component.\n *\n * @property children - The children of the box.\n * @property direction - The direction to stack the components within the box. Defaults to `vertical`.\n * @property alignment - The alignment mode to use within the box. Defaults to `start`.\n */\nexport type BoxProps = {\n  // We can't use `JSXElement` because it causes a circular reference.\n  children: SnapsChildren<GenericSnapElement>;\n  direction?: 'vertical' | 'horizontal' | undefined;\n  alignment?:\n    | 'start'\n    | 'center'\n    | 'end'\n    | 'space-between'\n    | 'space-around'\n    | undefined;\n};\n\nconst TYPE = 'Box';\n\n/**\n * A box component, which is used to group multiple components together.\n *\n * @param props - The props of the component.\n * @param props.children - The children of the box.\n * @returns A box element.\n * @example\n * <Box>\n *   <Text>Hello world!</Text>\n * </Box>\n */\nexport const Box = createSnapComponent<BoxProps, typeof TYPE>(TYPE);\n\n/**\n * A box element.\n *\n * @see Box\n */\nexport type BoxElement = ReturnType<typeof Box>;\n","import { createSnapComponent } from '../component';\n\n/**\n * The props of the {@link Copyable} component.\n *\n * @property value - The value to copy when the user clicks on the copyable\n * element.\n * @property sensitive - Whether the value is sensitive. If `true`, the value\n * will be hidden when the user is not interacting with the copyable element.\n */\nexport type CopyableProps = {\n  value: string;\n  sensitive?: boolean | undefined;\n};\n\nconst TYPE = 'Copyable';\n\n/**\n * A copyable component, which is used to display text that can be copied by the\n * user.\n *\n * @param props - The props of the component.\n * @param props.value - The value to copy when the user clicks on the copyable\n * element.\n * @param props.sensitive - Whether the value is sensitive. If `true`, the value\n * will be hidden when the user is not interacting with the copyable element.\n * @example\n * <Copyable value=\"0x1234567890123456789012345678901234567890\" />\n * <Copyable value=\"0x1234567890123456789012345678901234567890\" sensitive />\n */\nexport const Copyable = createSnapComponent<CopyableProps, typeof TYPE>(TYPE);\n\n/**\n * A copyable element.\n *\n * @see Copyable\n */\nexport type CopyableElement = ReturnType<typeof Copyable>;\n","import { createSnapComponent } from '../component';\n\nconst TYPE = 'Divider';\n\n/**\n * A divider component, which is used to create a horizontal line between\n * elements.\n *\n * This component does not have any props.\n *\n * @returns A divider element.\n * @example\n * <Divider />\n */\nexport const Divider = createSnapComponent(TYPE);\n\n/**\n * A divider element.\n *\n * @see Divider\n */\nexport type DividerElement = ReturnType<typeof Divider>;\n","import { createSnapComponent } from '../component';\n\n/**\n * The props of the {@link Value} component.\n *\n * @property value - The value shown on the right side.\n * @property extra - The extra text shown on the left side.\n */\nexport type ValueProps = {\n  value: string;\n  extra: string;\n};\n\nconst TYPE = 'Value';\n\n/**\n * A value component, which can be used to display two different text values side by side.\n *\n * This component can only be used as a child of the {@link Row} component.\n *\n * This component does not accept any children.\n *\n * @param props - The props of the component.\n * @param props.value - The value shown on the right side.\n * @param props.extra - The extra text shown on the left side.\n * @returns A value element.\n * @example\n * <Value value=\"0.05 ETH\" extra=\"$200\" />\n */\nexport const Value = createSnapComponent<ValueProps, typeof TYPE>(TYPE);\n\n/**\n * A value element.\n *\n * @see Value\n */\nexport type ValueElement = ReturnType<typeof Value>;\n","import type { StringElement } from '../component';\nimport { createSnapComponent } from '../component';\n\n/**\n * The props of the {@link Heading} component.\n *\n * @property children - The text to display in the heading.\n */\ntype HeadingProps = {\n  children: StringElement;\n};\n\nconst TYPE = 'Heading';\n\n/**\n * A heading component, which is used to display heading text.\n *\n * @param props - The props of the component.\n * @param props.children - The text to display in the heading.\n * @returns A heading element.\n * @example\n * <Heading>Hello world!</Heading>\n */\nexport const Heading = createSnapComponent<HeadingProps, typeof TYPE>(TYPE);\n\n/**\n * A heading element.\n *\n * @see Heading\n */\nexport type HeadingElement = ReturnType<typeof Heading>;\n","import { createSnapComponent } from '../component';\n\n/**\n * The props of the {@link Image} component.\n *\n * @property src - The SVG image to display. This should be an SVG string, and\n * other formats such as PNG and JPEG are not supported directly. You can use\n * the `data:` URL scheme to embed images inside the SVG.\n * @property alt - The alternative text of the image, which describes the image\n * for users who cannot see it.\n */\ntype ImageProps = {\n  src: string;\n  alt?: string | undefined;\n};\n\nconst TYPE = 'Image';\n\n/**\n * An image component, which is used to display an image.\n *\n * This component does not accept any children.\n *\n * @param props - The props of the component.\n * @param props.src - The URL of the image to display. This should be an SVG\n * string, and other formats such as PNG and JPEG are not supported directly.\n * You can use the `data:` URL scheme to embed images inside the SVG.\n * @param props.alt - The alternative text of the image, which describes the\n * image for users who cannot see it.\n * @returns An image element.\n * @example\n * <Image src=\"<svg>...</svg>\" alt=\"An example image\" />\n */\nexport const Image = createSnapComponent<ImageProps, typeof TYPE>(TYPE);\n\n/**\n * An image element.\n *\n * @see Image\n */\nexport type ImageElement = ReturnType<typeof Image>;\n","import type { SnapsChildren } from '../component';\nimport { createSnapComponent } from '../component';\nimport type { StandardFormattingElement } from './formatting';\n\n/**\n * The children of the {@link Link} component.\n */\nexport type LinkChildren = SnapsChildren<string | StandardFormattingElement>;\n\n/**\n * The props of the {@link Link} component.\n *\n * @property children - The text to display in the link.\n * @property href - The URL to link to. This must be an `https` or `mailto` URL.\n * `http` is not allowed.\n */\nexport type LinkProps = {\n  children: LinkChildren;\n  href: string;\n};\n\nconst TYPE = 'Link';\n\n/**\n * A link component, which is used to display a hyperlink.\n *\n * @param props - The props of the component.\n * @param props.children - The text to display in the link.\n * @param props.href - The URL to link to. This must be an `https` or `mailto`\n * URL. `http` is not allowed.\n * @returns A link element.\n * @example\n * <Link href=\"https://example.com\">Click here</Link>\n */\nexport const Link = createSnapComponent<LinkProps, typeof TYPE>(TYPE);\n\n/**\n * A link element.\n *\n * @see Link\n */\nexport type LinkElement = ReturnType<typeof Link>;\n","import { createSnapComponent } from '../component';\nimport type { AddressElement } from './Address';\nimport type { ImageElement } from './Image';\nimport type { TextElement } from './Text';\nimport type { ValueElement } from './Value';\n\n/**\n * The children of a {@link Row} component.\n */\nexport type RowChildren =\n  | AddressElement\n  | ImageElement\n  | TextElement\n  | ValueElement;\n\n/**\n * The props of the {@link Row} component.\n *\n * @property label - The label of the row.\n * @property children - The content of the row. This can be an address, an\n * image, or text.\n * @property variant - The variant of the row.\n * @property tooltip - An optional tooltip to show for the row.\n */\nexport type RowProps = {\n  label: string;\n  children: RowChildren;\n  variant?: 'default' | 'warning' | 'critical' | undefined;\n  tooltip?: string | undefined;\n};\n\nconst TYPE = 'Row';\n\n/**\n * A row component, which is used to display a row of information.\n *\n * @param props - The props of the component.\n * @param props.label - The label of the row.\n * @param props.children - The content of the row. This can be an address, an\n * image, or text.\n * @param props.variant - The variant of the row.\n * @param props.tooltip - An optional tooltip to show for the row.\n * @returns A row element.\n * @example\n * <Row label=\"From\" variant=\"warning\" tooltip=\"This address has been deemed dangerous.\">\n *   <Address address=\"0x1234567890123456789012345678901234567890\" />\n * </Row>\n */\nexport const Row = createSnapComponent<RowProps, typeof TYPE>(TYPE);\n\n/**\n * A row element.\n *\n * @see Row\n */\nexport type RowElement = ReturnType<typeof Row>;\n","import { createSnapComponent } from '../component';\n\nconst TYPE = 'Spinner';\n\n/**\n * A spinner component, which is used to display a spinner, indicating that some\n * operation is in progress.\n *\n * This component does not accept any props.\n *\n * @returns A spinner element.\n * @example\n * <Spinner />\n */\nexport const Spinner = createSnapComponent(TYPE);\n\n/**\n * A spinner element.\n *\n * @see Spinner\n */\nexport type SpinnerElement = ReturnType<typeof Spinner>;\n","import type { SnapsChildren } from '../component';\nimport { createSnapComponent } from '../component';\nimport type { StandardFormattingElement } from './formatting';\nimport type { LinkElement } from './Link';\n\n/**\n * The children of the {@link Text} component.\n */\nexport type TextChildren = SnapsChildren<\n  string | StandardFormattingElement | LinkElement\n>;\n\n/**\n * The props of the {@link Text} component.\n *\n * @property children - The text to display.\n */\nexport type TextProps = {\n  children: TextChildren;\n  alignment?: 'start' | 'center' | 'end' | undefined;\n};\n\nconst TYPE = 'Text';\n\n/**\n * A text component, which is used to display text.\n *\n * @param props - The props of the component.\n * @param props.children - The text to display.\n * @returns A text element.\n * @example\n * <Text>\n *   Hello <Bold>world</Bold>!\n * </Text>\n * @example\n * <Text alignment=\"end\">\n *   Hello <Bold>world</Bold>!\n * </Text>\n */\nexport const Text = createSnapComponent<TextProps, typeof TYPE>(TYPE);\n\n/**\n * A text element.\n *\n * @see Text\n */\nexport type TextElement = ReturnType<typeof Text>;\n","import { createSnapComponent } from '../component';\nimport type { StandardFormattingElement } from './formatting';\nimport type { ImageElement } from './Image';\nimport type { LinkElement } from './Link';\nimport type { TextElement } from './Text';\n\nexport type TooltipChildren =\n  | TextElement\n  | StandardFormattingElement\n  | LinkElement\n  | ImageElement\n  | boolean\n  | null;\n\n/**\n * The props of the {@link Tooltip} component.\n *\n * @property children - The children of the box.\n * @property content - The text to display in the tooltip.\n */\nexport type TooltipProps = {\n  children: TooltipChildren;\n  content: TextElement | StandardFormattingElement | LinkElement | string;\n};\n\nconst TYPE = 'Tooltip';\n\n/**\n * A tooltip component, which is used to display text in a tooltip.\n *\n * @param props - The props of the component.\n * @param props.children - The children of the tooltip.\n * @param props.content - The text to display in the tooltip.\n * @returns A tooltip element.\n * @example\n * <Tooltip content=\"Tooltip text\">\n *   <Text>Hello world!</Text>\n * </Tooltip>\n * @example\n * <Tooltip content={<Text>Text with <Bold>formatting</Bold></Text>}>\n *   <Text>Hello world!</Text>\n * </Tooltip>\n */\nexport const Tooltip = createSnapComponent<TooltipProps, typeof TYPE>(TYPE);\n\n/**\n * A tooltip element.\n *\n * @see Tooltip\n */\nexport type TooltipElement = ReturnType<typeof Tooltip>;\n","import type { JsonObject, Key, SnapComponent } from './component';\n\n/**\n * The JSX runtime for Snaps SDK components. This function is used to render\n * Snap components into a format that can be used by the Snaps.\n *\n * This is the \"production\" version of the runtime, which does not include\n * additional validation, as it is handled by MetaMask. To use this runtime,\n * specify `@metamask/snaps-sdk` as import source for JSX, and use `react-jsx`\n * as the pragma.\n *\n * @param component - The component to render.\n * @param props - The props to pass to the component.\n * @param key - The key of the component.\n * @returns The rendered component.\n * @see https://www.typescriptlang.org/tsconfig/#jsx\n */\nexport function jsx<Props extends JsonObject>(\n  component: SnapComponent<Props>,\n  props: Props,\n  key: Key | null,\n): unknown | null {\n  if (typeof component === 'string') {\n    // If component is a string, it is a built-in HTML element. This is not\n    // supported in Snaps, so we throw an error.\n    throw new Error(\n      `An HTML element (\"${String(\n        component,\n      )}\") was used in a Snap component, which is not supported by Snaps UI. Please use one of the supported Snap components.`,\n    );\n  }\n\n  if (!component) {\n    // If component is undefined, a JSX fragment `<>...</>` was used, which is\n    // not supported in Snaps.\n    throw new Error(\n      'A JSX fragment was used in a Snap component, which is not supported by Snaps UI. Please use one of the supported Snap components.',\n    );\n  }\n\n  return component({ ...props, key });\n}\n\n/**\n * The JSX runtime for Snaps SDK components. This function is used to render\n * Snap components into a format that can be used by the Snaps.\n *\n * The `jsxs` function is used for rendering nested components.\n *\n * This is the \"production\" version of the runtime, which does not include\n * additional validation, as it is handled by MetaMask. To use this runtime,\n * specify `@metamask/snaps-sdk` as import source for JSX, and use `react-jsx`\n * as the pragma.\n *\n * @param component - The component to render.\n * @param props - The props to pass to the component.\n * @param key - The key of the component.\n * @returns The rendered component.\n * @see https://www.typescriptlang.org/tsconfig/#jsx\n */\nexport function jsxs<Props extends JsonObject>(\n  component: SnapComponent<Props>,\n  props: Props,\n  key: Key | null,\n): unknown | null {\n  return jsx(component, props, key);\n}\n","import {\n  hasProperty,\n  HexChecksumAddressStruct,\n  isPlainObject,\n  JsonStruct,\n} from '@metamask/utils';\nimport type { Infer, Struct } from 'superstruct';\nimport {\n  is,\n  boolean,\n  optional,\n  array,\n  lazy,\n  nullable,\n  number,\n  object,\n  record,\n  string,\n  tuple,\n} from 'superstruct';\nimport type {\n  AnyStruct,\n  InferStructTuple,\n  ObjectSchema,\n} from 'superstruct/dist/utils';\n\nimport type { Describe } from '../internals';\nimport { literal, nullUnion, svg } from '../internals';\nimport type { EmptyObject } from '../types';\nimport type {\n  GenericSnapElement,\n  JsonObject,\n  Key,\n  Nestable,\n  SnapElement,\n  SnapsChildren,\n  StringElement,\n} from './component';\nimport type {\n  AddressElement,\n  BoldElement,\n  BoxElement,\n  ButtonElement,\n  CheckboxElement,\n  CopyableElement,\n  DividerElement,\n  DropdownElement,\n  OptionElement,\n  FieldElement,\n  FormElement,\n  HeadingElement,\n  ImageElement,\n  InputElement,\n  ItalicElement,\n  JSXElement,\n  LinkElement,\n  RowElement,\n  SpinnerElement,\n  StandardFormattingElement,\n  TextElement,\n  TooltipElement,\n  ValueElement,\n  FileInputElement,\n} from './components';\n\n/**\n * A struct for the {@link Key} type.\n */\nexport const KeyStruct: Describe<Key> = nullUnion([string(), number()]);\n\n/**\n * A struct for the {@link StringElement} type.\n */\nexport const StringElementStruct: Describe<StringElement> = children([\n  string(),\n]);\n\n/**\n * A struct for the {@link GenericSnapElement} type.\n */\nexport const ElementStruct: Describe<GenericSnapElement> = object({\n  type: string(),\n  props: record(string(), JsonStruct),\n  key: nullable(KeyStruct),\n});\n\n/**\n * A helper function for creating a struct for a {@link Nestable} type.\n *\n * @param struct - The struct for the type to test.\n * @returns The struct for the nestable type.\n */\nfunction nestable<Type, Schema>(\n  struct: Struct<Type, Schema>,\n): Struct<Nestable<Type>, any> {\n  const nestableStruct: Struct<Nestable<Type>> = nullUnion([\n    struct,\n    array(lazy(() => nestableStruct)),\n  ]);\n\n  return nestableStruct;\n}\n\n/**\n * A helper function for creating a struct which allows children of a specific\n * type, as well as `null` and `boolean`.\n *\n * @param structs - The structs to allow as children.\n * @returns The struct for the children.\n */\nfunction children<Head extends AnyStruct, Tail extends AnyStruct[]>(\n  structs: [head: Head, ...tail: Tail],\n): Struct<\n  Nestable<Infer<Head> | InferStructTuple<Tail>[number] | boolean | null>,\n  null\n> {\n  return nestable(nullable(nullUnion([...structs, boolean()])));\n}\n\n/**\n * A helper function for creating a struct for a JSX element.\n *\n * @param name - The name of the element.\n * @param props - The props of the element.\n * @returns The struct for the element.\n */\nfunction element<Name extends string, Props extends ObjectSchema = EmptyObject>(\n  name: Name,\n  props: Props = {} as Props,\n) {\n  return object({\n    type: literal(name) as unknown as Struct<Name, Name>,\n    props: object(props),\n    key: nullable(KeyStruct),\n  });\n}\n\n/**\n * A struct for the {@link ButtonElement} type.\n */\nexport const ButtonStruct: Describe<ButtonElement> = element('Button', {\n  children: StringElementStruct,\n  name: optional(string()),\n  type: optional(nullUnion([literal('button'), literal('submit')])),\n  variant: optional(nullUnion([literal('primary'), literal('destructive')])),\n  disabled: optional(boolean()),\n});\n\n/**\n * A struct for the {@link CheckboxElement} type.\n */\nexport const CheckboxStruct: Describe<CheckboxElement> = element('Checkbox', {\n  name: string(),\n  checked: optional(boolean()),\n  label: optional(string()),\n  variant: optional(nullUnion([literal('default'), literal('toggle')])),\n});\n\n/**\n * A struct for the {@link InputElement} type.\n */\nexport const InputStruct: Describe<InputElement> = element('Input', {\n  name: string(),\n  type: optional(\n    nullUnion([literal('text'), literal('password'), literal('number')]),\n  ),\n  value: optional(string()),\n  placeholder: optional(string()),\n});\n\n/**\n * A struct for the {@link OptionElement} type.\n */\nexport const OptionStruct: Describe<OptionElement> = element('Option', {\n  value: string(),\n  children: string(),\n});\n\n/**\n * A struct for the {@link DropdownElement} type.\n */\nexport const DropdownStruct: Describe<DropdownElement> = element('Dropdown', {\n  name: string(),\n  value: optional(string()),\n  children: children([OptionStruct]),\n});\n\n/**\n * A struct for the {@link FileInputElement} type.\n */\nexport const FileInputStruct: Describe<FileInputElement> = element(\n  'FileInput',\n  {\n    name: string(),\n    accept: nullUnion([optional(array(string()))]),\n    compact: optional(boolean()),\n  },\n);\n\n/**\n * A struct for the {@link FieldElement} type.\n */\nexport const FieldStruct: Describe<FieldElement> = element('Field', {\n  label: optional(string()),\n  error: optional(string()),\n  children: nullUnion([\n    tuple([InputStruct, ButtonStruct]),\n    DropdownStruct,\n    FileInputStruct,\n    InputStruct,\n    CheckboxStruct,\n  ]),\n});\n\n/**\n * A struct for the {@link FormElement} type.\n */\nexport const FormStruct: Describe<FormElement> = element('Form', {\n  children: children(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    [FieldStruct, lazy(() => BoxChildStruct)],\n  ) as unknown as Struct<SnapsChildren<GenericSnapElement>, null>,\n  name: string(),\n});\n\n/**\n * A struct for the {@link BoldElement} type.\n */\nexport const BoldStruct: Describe<BoldElement> = element('Bold', {\n  children: children([\n    string(),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    lazy(() => ItalicStruct) as unknown as Struct<\n      SnapElement<JsonObject, 'Italic'>\n    >,\n  ]),\n});\n\n/**\n * A struct for the {@link ItalicElement} type.\n */\nexport const ItalicStruct: Describe<ItalicElement> = element('Italic', {\n  children: children([\n    string(),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    lazy(() => BoldStruct) as unknown as Struct<\n      SnapElement<JsonObject, 'Bold'>\n    >,\n  ]),\n});\n\nexport const FormattingStruct: Describe<StandardFormattingElement> = nullUnion([\n  BoldStruct,\n  ItalicStruct,\n]);\n\n/**\n * A struct for the {@link AddressElement} type.\n */\nexport const AddressStruct: Describe<AddressElement> = element('Address', {\n  address: HexChecksumAddressStruct,\n});\n\n/**\n * A struct for the {@link BoxElement} type.\n */\nexport const BoxStruct: Describe<BoxElement> = element('Box', {\n  children: children(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    [lazy(() => BoxChildStruct)],\n  ) as unknown as Struct<SnapsChildren<GenericSnapElement>, null>,\n  direction: optional(nullUnion([literal('horizontal'), literal('vertical')])),\n  alignment: optional(\n    nullUnion([\n      literal('start'),\n      literal('center'),\n      literal('end'),\n      literal('space-between'),\n      literal('space-around'),\n    ]),\n  ),\n});\n\n/**\n * A struct for the {@link CopyableElement} type.\n */\nexport const CopyableStruct: Describe<CopyableElement> = element('Copyable', {\n  value: string(),\n  sensitive: optional(boolean()),\n});\n\n/**\n * A struct for the {@link DividerElement} type.\n */\nexport const DividerStruct: Describe<DividerElement> = element('Divider');\n\n/**\n * A struct for the {@link ValueElement} type.\n */\nexport const ValueStruct: Describe<ValueElement> = element('Value', {\n  value: string(),\n  extra: string(),\n});\n\n/**\n * A struct for the {@link HeadingElement} type.\n */\nexport const HeadingStruct: Describe<HeadingElement> = element('Heading', {\n  children: StringElementStruct,\n});\n\n/**\n * A struct for the {@link ImageElement} type.\n */\nexport const ImageStruct: Describe<ImageElement> = element('Image', {\n  src: svg(),\n  alt: optional(string()),\n});\n\n/**\n * A struct for the {@link LinkElement} type.\n */\nexport const LinkStruct: Describe<LinkElement> = element('Link', {\n  href: string(),\n  children: children([FormattingStruct, string()]),\n});\n\n/**\n * A struct for the {@link TextElement} type.\n */\nexport const TextStruct: Describe<TextElement> = element('Text', {\n  children: children([string(), BoldStruct, ItalicStruct, LinkStruct]),\n  alignment: optional(\n    nullUnion([literal('start'), literal('center'), literal('end')]),\n  ),\n});\n\n/**\n * A subset of JSX elements that are allowed as children of the Tooltip component.\n * This set should include all text components and the Image.\n */\nexport const TooltipChildStruct = nullUnion([\n  TextStruct,\n  BoldStruct,\n  ItalicStruct,\n  LinkStruct,\n  ImageStruct,\n  boolean(),\n]);\n\n/**\n * A subset of JSX elements that are allowed as content of the Tooltip component.\n * This set should include all text components.\n */\nexport const TooltipContentStruct = nullUnion([\n  TextStruct,\n  BoldStruct,\n  ItalicStruct,\n  LinkStruct,\n  string(),\n]);\n\n/**\n * A struct for the {@link TooltipElement} type.\n */\nexport const TooltipStruct: Describe<TooltipElement> = element('Tooltip', {\n  children: nullable(TooltipChildStruct),\n  content: TooltipContentStruct,\n});\n\n/**\n * A struct for the {@link RowElement} type.\n */\nexport const RowStruct: Describe<RowElement> = element('Row', {\n  label: string(),\n  children: nullUnion([AddressStruct, ImageStruct, TextStruct, ValueStruct]),\n  variant: optional(\n    nullUnion([literal('default'), literal('warning'), literal('critical')]),\n  ),\n  tooltip: optional(string()),\n});\n\n/**\n * A struct for the {@link SpinnerElement} type.\n */\nexport const SpinnerStruct: Describe<SpinnerElement> = element('Spinner');\n\n/**\n * A subset of JSX elements that are allowed as children of the Box component.\n * This set includes all components, except components that need to be nested in\n * another component (e.g., Field must be contained in a Form).\n */\nexport const BoxChildStruct = nullUnion([\n  AddressStruct,\n  BoldStruct,\n  BoxStruct,\n  ButtonStruct,\n  CopyableStruct,\n  DividerStruct,\n  DropdownStruct,\n  FileInputStruct,\n  FormStruct,\n  HeadingStruct,\n  InputStruct,\n  ImageStruct,\n  ItalicStruct,\n  LinkStruct,\n  RowStruct,\n  SpinnerStruct,\n  TextStruct,\n  TooltipStruct,\n  CheckboxStruct,\n]);\n\n/**\n * For now, the allowed JSX elements at the root are the same as the allowed\n * children of the Box component.\n */\nexport const RootJSXElementStruct = BoxChildStruct;\n\n/**\n * A struct for the {@link JSXElement} type.\n */\nexport const JSXElementStruct: Describe<JSXElement> = nullUnion([\n  ButtonStruct,\n  InputStruct,\n  FileInputStruct,\n  FieldStruct,\n  FormStruct,\n  BoldStruct,\n  ItalicStruct,\n  AddressStruct,\n  BoxStruct,\n  CopyableStruct,\n  DividerStruct,\n  HeadingStruct,\n  ImageStruct,\n  LinkStruct,\n  RowStruct,\n  SpinnerStruct,\n  TextStruct,\n  DropdownStruct,\n  OptionStruct,\n  ValueStruct,\n  TooltipStruct,\n  CheckboxStruct,\n]);\n\n/**\n * Check if a value is a JSX element.\n *\n * @param value - The value to check.\n * @returns True if the value is a JSX element, false otherwise.\n */\nexport function isJSXElement(value: unknown): value is JSXElement {\n  return is(value, JSXElementStruct);\n}\n\n/**\n * Check if a value is a JSX element, without validating all of its contents.\n * This is useful when you want to validate the structure of a value, but not\n * all the children.\n *\n * This should only be used when you are sure that the value is safe to use,\n * i.e., after using {@link isJSXElement}.\n *\n * @param value - The value to check.\n * @returns True if the value is a JSX element, false otherwise.\n */\nexport function isJSXElementUnsafe(value: unknown): value is JSXElement {\n  return (\n    isPlainObject(value) &&\n    hasProperty(value, 'type') &&\n    hasProperty(value, 'props') &&\n    hasProperty(value, 'key')\n  );\n}\n\n/**\n * Assert that a value is a JSX element.\n *\n * @param value - The value to check.\n * @throws If the value is not a JSX element.\n */\nexport function assertJSXElement(value: unknown): asserts value is JSXElement {\n  // TODO: We should use the error parsing utils from `snaps-utils` to improve\n  // the error messages. It currently includes colours and potentially other\n  // formatting that we might not want to include in the SDK.\n  if (!isJSXElement(value)) {\n    throw new Error(\n      `Expected a JSX element, but received ${JSON.stringify(\n        value,\n      )}. Please refer to the documentation for the supported JSX elements and their props.`,\n    );\n  }\n}\n","import type { Infer } from 'superstruct';\nimport {\n  Struct,\n  define,\n  literal as superstructLiteral,\n  union as superstructUnion,\n} from 'superstruct';\nimport type { AnyStruct, InferStructTuple } from 'superstruct/dist/utils';\n\nimport type { EnumToUnion } from './helpers';\n\n/**\n * A wrapper of `superstruct`'s `literal` struct that also defines the name of\n * the struct as the literal value.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n * For example, instead of returning an error like:\n *\n * ```\n * Expected the value to satisfy a union of `literal | literal`, but received: \\\"baz\\\"\n * ```\n *\n * This struct will return an error like:\n *\n * ```\n * Expected the value to satisfy a union of `\"foo\" | \"bar\"`, but received: \\\"baz\\\"\n * ```\n *\n * @param value - The literal value.\n * @returns The `superstruct` struct, which validates that the value is equal\n * to the literal value.\n */\nexport function literal<Type extends string | number | boolean>(value: Type) {\n  return define<Type>(\n    JSON.stringify(value),\n    superstructLiteral(value).validator,\n  );\n}\n\n/**\n * A wrapper of `superstruct`'s `union` struct that also defines the schema as\n * the union of the schemas of the structs.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n *\n * @param structs - The structs to union.\n * @param structs.\"0\" - The first struct.\n * @param structs.\"1\" - The remaining structs.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function union<Head extends AnyStruct, Tail extends AnyStruct[]>([\n  head,\n  ...tail\n]: [head: Head, ...tail: Tail]): Struct<\n  Infer<Head> | InferStructTuple<Tail>[number],\n  [head: Head, ...tail: Tail]\n> {\n  const struct = superstructUnion([head, ...tail]);\n\n  return new Struct({\n    ...struct,\n    schema: [head, ...tail],\n  });\n}\n\n/**\n * Superstruct struct for validating an enum value. This allows using both the\n * enum string values and the enum itself as values.\n *\n * @param constant - The enum to validate against.\n * @returns The superstruct struct.\n */\nexport function enumValue<Type extends string>(\n  constant: Type,\n): Struct<EnumToUnion<Type>, null> {\n  return literal(constant as EnumToUnion<Type>);\n}\n","import type { Infer, Struct } from 'superstruct';\nimport type {\n  AnyStruct,\n  EnumSchema,\n  InferStructTuple,\n  IsExactMatch,\n  IsMatch,\n  IsRecord,\n  IsTuple,\n  UnionToIntersection,\n} from 'superstruct/dist/utils';\n\nimport type { EmptyObject } from '../types';\nimport { union } from './structs';\n\n/**\n * Check if a type is a union. Infers `true` if it is a union, otherwise\n * `false`.\n */\ntype IsUnion<Type> = [Type] extends [UnionToIntersection<Type>] ? false : true;\n\n/**\n * Get a struct schema for a type.\n *\n * This is copied from `superstruct` but fixes some issues with the original\n * implementation.\n */\ntype StructSchema<Type> = IsUnion<Type> extends true\n  ? null\n  : [Type] extends [EmptyObject]\n  ? EmptyObject\n  : [Type] extends [string | undefined | null]\n  ? [Type] extends [`0x${string}`]\n    ? null\n    : [Type] extends [IsMatch<Type, string | undefined | null>]\n    ? null\n    : [Type] extends [IsUnion<Type>]\n    ? EnumSchema<Type>\n    : Type\n  : [Type] extends [number | undefined | null]\n  ? [Type] extends [IsMatch<Type, number | undefined | null>]\n    ? null\n    : [Type] extends [IsUnion<Type>]\n    ? EnumSchema<Type>\n    : Type\n  : [Type] extends [boolean]\n  ? [Type] extends [IsExactMatch<Type, boolean>]\n    ? null\n    : Type\n  : Type extends\n      | bigint\n      | symbol\n      | undefined\n      | null\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      | Function\n      | Date\n      | Error\n      | RegExp\n      | Map<any, any>\n      | WeakMap<any, any>\n      | Set<any>\n      | WeakSet<any>\n      | Promise<any>\n  ? null\n  : Type extends (infer E)[]\n  ? Type extends IsTuple<Type>\n    ? null\n    : Struct<E>\n  : Type extends object\n  ? Type extends IsRecord<Type>\n    ? null\n    : {\n        [InnerKey in keyof Type]: Describe<Type[InnerKey]>;\n      }\n  : null;\n\n/**\n * Describe a struct type.\n */\nexport type Describe<Type> = Struct<Type, StructSchema<Type>>;\n\n/**\n * Create a union struct that uses `null` for the schema type, for better\n * compatibility with `Describe`.\n *\n * @param structs - The structs to union.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function nullUnion<Head extends AnyStruct, Tail extends AnyStruct[]>(\n  structs: [head: Head, ...tail: Tail],\n): Struct<Infer<Head> | InferStructTuple<Tail>[number], null> {\n  return union(structs) as unknown as Struct<\n    Infer<Head> | InferStructTuple<Tail>[number],\n    null\n  >;\n}\n","import { refine, string } from 'superstruct';\n\n/**\n * Get a Struct that validates a string as a valid SVG.\n *\n * @returns A Struct that validates a string as a valid SVG.\n * @internal\n */\nexport function svg() {\n  return refine(string(), 'SVG', (value) => {\n    // This validation is intentionally very basic, we don't need to be that strict\n    // and merely have this extra validation as a helpful error if devs aren't\n    // passing in SVGs.\n    if (!value.includes('<svg')) {\n      return 'Value is not a valid SVG.';\n    }\n\n    return true;\n  });\n}\n","import type { JsonObject, Key, SnapComponent } from './component';\nimport { jsx } from './jsx-runtime';\nimport { assertJSXElement } from './validation';\n\n/**\n * The JSX runtime for Snaps SDK components. This function is used to render\n * Snap components into a format that can be used by the Snaps.\n *\n * This is the \"development\" version of the runtime, which includes additional\n * validation, which is otherwise handled by MetaMask. To use this runtime,\n * specify `@metamask/snaps-sdk` as import source for JSX, and use\n * `react-jsxdev` as the pragma.\n *\n * @param component - The component to render.\n * @param props - The props to pass to the component.\n * @param key - The key of the component.\n * @returns The rendered component.\n * @see https://www.typescriptlang.org/tsconfig/#jsx\n */\nexport function jsxDEV<Props extends JsonObject>(\n  component: SnapComponent<Props>,\n  props: Props,\n  key: Key | null,\n): unknown | null {\n  const element = jsx(component, props, key);\n  assertJSXElement(element);\n\n  return element;\n}\n"],"mappings":"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","names":["TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","string","string","element"]}
\ No newline at end of file
+{"version":3,"sources":["../../src/jsx/component.ts","../../src/jsx/components/form/Button.ts","../../src/jsx/components/form/Checkbox.ts","../../src/jsx/components/form/Dropdown.ts","../../src/jsx/components/form/Option.ts","../../src/jsx/components/form/Field.ts","../../src/jsx/components/form/FileInput.ts","../../src/jsx/components/form/Form.ts","../../src/jsx/components/form/Input.ts","../../src/jsx/components/formatting/Bold.ts","../../src/jsx/components/formatting/Italic.ts","../../src/jsx/components/Address.ts","../../src/jsx/components/Box.ts","../../src/jsx/components/Copyable.ts","../../src/jsx/components/Divider.ts","../../src/jsx/components/Value.ts","../../src/jsx/components/Heading.ts","../../src/jsx/components/Image.ts","../../src/jsx/components/Link.ts","../../src/jsx/components/Row.ts","../../src/jsx/components/Spinner.ts","../../src/jsx/components/Text.ts","../../src/jsx/components/Tooltip.ts","../../src/jsx/jsx-runtime.ts","../../src/jsx/validation.ts","../../src/internals/structs.ts","../../src/internals/jsx.ts","../../src/internals/svg.ts","../../src/jsx/jsx-dev-runtime.ts"],"sourcesContent":["import type { Json } from '@metamask/utils';\n\n/**\n * A key, which can be a string or a number.\n */\nexport type Key = string | number;\n\n/**\n * A JSON object.\n */\nexport type JsonObject = Record<string, Json>;\n\n/**\n * A generic JSX element.\n *\n * @property type - The type of the element.\n * @property props - The props of the element.\n * @property key - The key of the element.\n */\nexport type GenericSnapElement = {\n  type: string;\n  props: JsonObject;\n  key: Key | null;\n};\n\n/**\n * A JSX element.\n *\n * @property type - The type of the element.\n * @property props - The props of the element.\n * @property key - The key of the element.\n */\nexport type SnapElement<\n  Props extends JsonObject = Record<string, never>,\n  Type extends string = string,\n> = {\n  type: Type;\n  props: Props;\n  key: Key | null;\n};\n\n/**\n * A type that can be a single value or an infinitely nestable array of values.\n *\n * @template Type - The type that can be an array.\n * @example\n * type NestableString = Nestable<string>;\n * const nestableString: NestableString = 'hello';\n * const nestableStringArray: NestableString = ['hello', 'world', ['foo', ['bar']]];\n */\nexport type Nestable<Type> = Type | Nestable<Type>[];\n\n/**\n * A type that can be a single value or an array of values, a boolean, or null.\n *\n * @template Type - The type that can be an array.\n */\nexport type SnapsChildren<Type> = Nestable<Type | boolean | null>;\n\n/**\n * A JSX node, which can be an element, a string, null, or an array of nodes.\n */\nexport type SnapNode = SnapsChildren<GenericSnapElement | string>;\n\n/**\n * A JSX string element, which can be a string or an array of strings, or\n * booleans (for conditional rendering).\n */\nexport type StringElement = SnapsChildren<string>;\n\n/**\n * A JSX component.\n */\nexport type SnapComponent<\n  Props extends JsonObject = Record<string, never>,\n  Type extends string = string,\n> = (props: Props & { key?: Key | null }) => SnapElement<Props, Type>;\n\n/**\n * Remove undefined props from an object.\n *\n * @param props - The object to remove undefined props from.\n * @returns The object without undefined props.\n */\nfunction removeUndefinedProps<Props extends JsonObject>(props: Props): Props {\n  return Object.fromEntries(\n    Object.entries(props).filter(([, value]) => value !== undefined),\n  ) as Props;\n}\n\n/**\n * Create a Snap component from a type. This is a helper function that creates a\n * Snap component function.\n *\n * @param type - The type of the component.\n * @returns A function that creates a Snap element.\n * @see SnapComponent\n */\nexport function createSnapComponent<\n  Props extends JsonObject = Record<string, never>,\n  Type extends string = string,\n>(type: Type): SnapComponent<Props, Type> {\n  return (props: Props & { key?: Key | null }) => {\n    const { key = null, ...rest } = props;\n    return {\n      type,\n      props: removeUndefinedProps(rest as Props),\n      key,\n    };\n  };\n}\n","import type { StringElement } from '../../component';\nimport { createSnapComponent } from '../../component';\n\n// TODO: Add the `onClick` prop to the `ButtonProps` type.\n\n/**\n * The props of the {@link Button} component.\n *\n * @property children - The text to display on the button.\n * @property name - The name of the button. This is used to identify the button\n * in the event handler.\n * @property type - The type of the button, i.e., `'button'` or `'submit'`.\n * Defaults to `'button'`.\n * @property variant - The variant of the button, i.e., `'primary'` or\n * `'destructive'`. Defaults to `'primary'`.\n * @property disabled - Whether the button is disabled. Defaults to `false`.\n */\nexport type ButtonProps = {\n  children: StringElement;\n  name?: string | undefined;\n  type?: 'button' | 'submit' | undefined;\n  variant?: 'primary' | 'destructive' | undefined;\n  disabled?: boolean | undefined;\n};\n\nconst TYPE = 'Button';\n\n/**\n * A button component, which is used to create a clickable button.\n *\n * @param props - The props of the component.\n * @param props.children - The text to display on the button. This should be a\n * string or an array of strings.\n * @returns A button element.\n * @example\n * <Button name=\"my-button\">Click me</Button>\n */\nexport const Button = createSnapComponent<ButtonProps, typeof TYPE>(TYPE);\n\n/**\n * A button element.\n *\n * @see Button\n */\nexport type ButtonElement = ReturnType<typeof Button>;\n","import { createSnapComponent } from '../../component';\n\n/**\n * The props of the {@link Checkbox} component.\n *\n * @property name - The name of the checkbox. This is used to identify the\n * state in the form data.\n * @property checked - Whether the checkbox is checked or not.\n * @property label - An optional label for the checkbox.\n * @property variant - An optional variant for the checkbox.\n */\nexport type CheckboxProps = {\n  name: string;\n  checked?: boolean | undefined;\n  label?: string | undefined;\n  variant?: 'default' | 'toggle' | undefined;\n};\n\nconst TYPE = 'Checkbox';\n\n/**\n * A checkbox component, which is used to create a checkbox.\n *\n * @param props - The props of the component.\n * @param props.name - The name of the checkbox. This is used to identify the\n * state in the form data.\n * @param props.checked - Whether the checkbox is checked or not.\n * @param props.label - An optional label for the checkbox.\n * @param props.variant - An optional variant for the checkbox.\n * @returns A checkbox element.\n * @example\n * <Checkbox name=\"accept-terms\" />\n */\nexport const Checkbox = createSnapComponent<CheckboxProps, typeof TYPE>(TYPE);\n\n/**\n * A checkbox element.\n *\n * @see Checkbox\n */\nexport type CheckboxElement = ReturnType<typeof Checkbox>;\n","import type { SnapsChildren } from '../../component';\nimport { createSnapComponent } from '../../component';\nimport type { OptionElement } from './Option';\n\n/**\n * The props of the {@link Dropdown} component.\n *\n * @property name - The name of the dropdown. This is used to identify the\n * state in the form data.\n * @property value - The selected value of the dropdown.\n * @property children - The children of the dropdown.\n */\nexport type DropdownProps = {\n  name: string;\n  value?: string | undefined;\n  children: SnapsChildren<OptionElement>;\n};\n\nconst TYPE = 'Dropdown';\n\n/**\n * A dropdown component, which is used to create a dropdown.\n *\n * @param props - The props of the component.\n * @param props.name - The name of the dropdown field. This is used to identify the\n * state in the form data.\n * @param props.value - The selected value of the dropdown.\n * @param props.children - The children of the dropdown.\n * @returns A dropdown element.\n * @example\n * <Dropdown name=\"dropdown\">\n *  <Option value=\"option1\">Option 1</Option>\n *  <Option value=\"option2\">Option 2</Option>\n *  <Option value=\"option3\">Option 3</Option>\n * </Dropdown>\n */\nexport const Dropdown = createSnapComponent<DropdownProps, typeof TYPE>(TYPE);\n\n/**\n * A dropdown element.\n *\n * @see Dropdown\n */\nexport type DropdownElement = ReturnType<typeof Dropdown>;\n","import { createSnapComponent } from '../../component';\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport { Dropdown } from './Dropdown';\n\n/**\n * The props of the {@link Option} component.\n *\n * @property value - The value of the dropdown option. This is used to populate the\n * state in the form data.\n * @property children - The text to display.\n */\ntype OptionProps = {\n  value: string;\n  children: string;\n};\n\nconst TYPE = 'Option';\n\n/**\n * A dropdown option component, which is used to create a dropdown option. This component\n * can only be used as a child of the {@link Dropdown} component.\n *\n * @param props - The props of the component.\n * @param props.value - The value of the dropdown option. This is used to populate the\n * state in the form data.\n * @param props.children - The text to display.\n * @returns A dropdown option element.\n * @example\n * <Dropdown name=\"dropdown\">\n *  <Option value=\"option1\">Option 1</Option>\n *  <Option value=\"option2\">Option 2</Option>\n *  <Option value=\"option3\">Option 3</Option>\n * </Dropdown>\n */\nexport const Option = createSnapComponent<OptionProps, typeof TYPE>(TYPE);\n\n/**\n * A dropdown option element.\n *\n * @see Option\n */\nexport type OptionElement = ReturnType<typeof Option>;\n","import { createSnapComponent } from '../../component';\nimport type { ButtonElement } from './Button';\nimport type { CheckboxElement } from './Checkbox';\nimport type { DropdownElement } from './Dropdown';\nimport type { FileInputElement } from './FileInput';\nimport type { InputElement } from './Input';\n\n/**\n * The props of the {@link Field} component.\n *\n * @property label - The label of the field.\n * @property error - The error message of the field.\n * @property children - The input field and the submit button.\n */\nexport type FieldProps = {\n  label?: string | undefined;\n  error?: string | undefined;\n  children:\n    | [InputElement, ButtonElement]\n    | DropdownElement\n    | FileInputElement\n    | InputElement\n    | CheckboxElement;\n};\n\nconst TYPE = 'Field';\n\n/**\n * A field component, which is used to create a form field. This component can\n * only be used as a child of the {@link Form} component.\n *\n * @param props - The props of the component.\n * @param props.label - The label of the field.\n * @param props.error - The error message of the field.\n * @param props.children - The input field and the submit button.\n * @returns A field element.\n * @example\n * <Field label=\"Username\">\n *   <Input name=\"username\" type=\"text\" />\n *   <Button type=\"submit\">Submit</Button>\n * </Field>\n * @example\n * <Field label=\"Upload file\">\n *   <FileInput name=\"file\" accept={['image/*']} multiple />\n * </Field>\n */\nexport const Field = createSnapComponent<FieldProps, typeof TYPE>(TYPE);\n\n/**\n * A field element.\n *\n * @see Field\n */\nexport type FieldElement = ReturnType<typeof Field>;\n","import { createSnapComponent } from '../../component';\n\n/**\n * The props of the {@link FileInput} component.\n *\n * @property name - The name of the file input field. This is used to identify\n * the file input field in the form data.\n * @property label - The label of the file input field.\n * @property accept - The file types that the file input field accepts. If not\n * specified, the file input field accepts all file types.\n * @property compact - Whether the file input field is compact. Default is\n * `false`.\n */\nexport type FileInputProps = {\n  name: string;\n  accept?: string[] | undefined;\n  compact?: boolean | undefined;\n};\n\nconst TYPE = 'FileInput';\n\n/**\n * A file input component, which is used to create a file input field. This\n * component can only be used as a child of the {@link Field} component.\n *\n * The total size of the files that can be uploaded may not exceed 64 MB.\n *\n * @param props - The props of the component.\n * @param props.name - The name of the file input field. This is used to\n * identify the file input field in the form data.\n * @param props.accept - The file types that the file input field accepts. If\n * not specified, the file input field accepts all file types. For examples of\n * valid values, see the [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/accept).\n * @param props.compact - Whether the file input field is compact. Default is\n * `false`.\n * @returns A file input element.\n * @example\n * <FileInput name=\"file\" accept={['image/*']} />\n * @example\n * <FileInput name=\"file\" compact />\n * @example\n * <Field label=\"Upload file\">\n *   <FileInput name=\"file\" />\n * </Field>\n */\nexport const FileInput = createSnapComponent<FileInputProps, typeof TYPE>(TYPE);\n\n/**\n * A file input element.\n *\n * @see FileInput\n */\nexport type FileInputElement = ReturnType<typeof FileInput>;\n","import type { GenericSnapElement, SnapsChildren } from '../../component';\nimport { createSnapComponent } from '../../component';\n\n// TODO: Add `onSubmit` prop to the `FormProps` type.\n\n/**\n * The props of the {@link Form} component.\n *\n * @property children - The children of the form.\n * @property name - The name of the form. This is used to identify the form in\n * the event handler.\n */\nexport type FormProps = {\n  children: SnapsChildren<GenericSnapElement>;\n  name: string;\n};\n\nconst TYPE = 'Form';\n\n/**\n * A form component, which is used to create a form.\n *\n * @param props - The props of the component.\n * @param props.children - The form fields. This should be a single field or an\n * array of fields.\n * @param props.name - The name of the form. This is used to identify the form\n * in the event handler.\n * @returns A form element.\n * @example\n * <Form name=\"my-form\">\n *   <Field label=\"Username\">\n *     <Input name=\"username\" type=\"text\" />\n *   </Field>\n *   <Button type=\"submit\">Submit</Button>\n * </Form>\n */\nexport const Form = createSnapComponent<FormProps, typeof TYPE>(TYPE);\n\n/**\n * A form element.\n *\n * @see Form\n */\nexport type FormElement = ReturnType<typeof Form>;\n","import { createSnapComponent } from '../../component';\n\n// TODO: Add the `onChange` prop to the `InputProps` type.\n\n/**\n * The props of the {@link Input} component.\n *\n * @property name - The name of the input field. This is used to identify the\n * input field in the form data.\n * @property type - The type of the input field. Defaults to `text`.\n * @property value - The value of the input field.\n * @property placeholder - The placeholder text of the input field.\n */\nexport type InputProps = {\n  name: string;\n  type?: 'text' | 'password' | 'number' | undefined;\n  value?: string | undefined;\n  placeholder?: string | undefined;\n};\n\nconst TYPE = 'Input';\n\n/**\n * An input component, which is used to create an input field.\n *\n * @param props - The props of the component.\n * @param props.name - The name of the input field. This is used to identify the\n * input field in the form data.\n * @param props.type - The type of the input field.\n * @param props.value - The value of the input field.\n * @param props.placeholder - The placeholder text of the input field.\n * @returns An input element.\n * @example\n * <Input name=\"username\" type=\"text\" />\n */\nexport const Input = createSnapComponent<InputProps, typeof TYPE>(TYPE);\n\n/**\n * An input element.\n *\n * @see Input\n */\nexport type InputElement = ReturnType<typeof Input>;\n","import type { JsonObject, SnapElement, SnapsChildren } from '../../component';\nimport { createSnapComponent } from '../../component';\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport { Text } from '../Text';\n\n/**\n * The children of the {@link Bold} component.\n */\nexport type BoldChildren = SnapsChildren<\n  | string\n  // We have to specify the type here to avoid a circular reference.\n  | SnapElement<JsonObject, 'Italic'>\n>;\n\n/**\n * The props of the {@link Bold} component.\n *\n * @property children - The text to display in bold.\n */\nexport type BoldProps = {\n  children: BoldChildren;\n};\n\nconst TYPE = 'Bold';\n\n/**\n * A bold component, which is used to display text in bold. This component can\n * only be used as a child of the {@link Text} component.\n *\n * @param props - The props of the component.\n * @param props.children - The text to display in bold.\n * @returns A bold element.\n * @example\n * <Text>\n *   Hello <Bold>world</Bold>!\n * </Text>\n */\nexport const Bold = createSnapComponent<BoldProps, typeof TYPE>(TYPE);\n\n/**\n * A bold element.\n *\n * @see Bold\n */\nexport type BoldElement = ReturnType<typeof Bold>;\n","import type { JsonObject, SnapElement, SnapsChildren } from '../../component';\nimport { createSnapComponent } from '../../component';\n\n/**\n * The children of the {@link Italic} component.\n */\nexport type ItalicChildren = SnapsChildren<\n  | string\n  // We have to specify the type here to avoid a circular reference.\n  | SnapElement<JsonObject, 'Bold'>\n>;\n\n/**\n * The props of the {@link Italic} component.\n *\n * @property children - The text to display in italic. This should be a string\n * or an array of strings.\n */\nexport type ItalicProps = {\n  children: ItalicChildren;\n};\n\nconst TYPE = 'Italic';\n\n/**\n * An italic component, which is used to display text in italic. This componen\n * can only be used as a child of the {@link Text} component.\n *\n * @param props - The props of the component.\n * @param props.children - The text to display in italic. This should be a\n * string or an array of strings.\n * @returns An italic element.\n * @example\n * <Text>\n *   Hello <Italic>world</Italic>!\n * </Text>\n */\nexport const Italic = createSnapComponent<ItalicProps, typeof TYPE>(TYPE);\n\n/**\n * An italic element.\n *\n * @see Italic\n */\nexport type ItalicElement = ReturnType<typeof Italic>;\n","import { createSnapComponent } from '../component';\n\n/**\n * The props of the {@link Address} component.\n *\n * @property address - The (Ethereum) address to display. This should be a\n * valid Ethereum address, starting with `0x`.\n */\nexport type AddressProps = {\n  address: `0x${string}`;\n};\n\nconst TYPE = 'Address';\n\n/**\n * An address component, which is used to display an Ethereum address.\n *\n * This component does not accept any children.\n *\n * @param props - The props of the component.\n * @param props.address - The (Ethereum) address to display. This should be a\n * valid Ethereum address, starting with `0x`.\n * @returns An address element.\n * @example\n * <Address address=\"0x1234567890123456789012345678901234567890\" />\n */\nexport const Address = createSnapComponent<AddressProps, typeof TYPE>(TYPE);\n\n/**\n * An address element.\n *\n * @see Address\n */\nexport type AddressElement = ReturnType<typeof Address>;\n","import type { GenericSnapElement, SnapsChildren } from '../component';\nimport { createSnapComponent } from '../component';\n\n/**\n * The props of the {@link Box} component.\n *\n * @property children - The children of the box.\n * @property direction - The direction to stack the components within the box. Defaults to `vertical`.\n * @property alignment - The alignment mode to use within the box. Defaults to `start`.\n */\nexport type BoxProps = {\n  // We can't use `JSXElement` because it causes a circular reference.\n  children: SnapsChildren<GenericSnapElement>;\n  direction?: 'vertical' | 'horizontal' | undefined;\n  alignment?:\n    | 'start'\n    | 'center'\n    | 'end'\n    | 'space-between'\n    | 'space-around'\n    | undefined;\n};\n\nconst TYPE = 'Box';\n\n/**\n * A box component, which is used to group multiple components together.\n *\n * @param props - The props of the component.\n * @param props.children - The children of the box.\n * @returns A box element.\n * @example\n * <Box>\n *   <Text>Hello world!</Text>\n * </Box>\n */\nexport const Box = createSnapComponent<BoxProps, typeof TYPE>(TYPE);\n\n/**\n * A box element.\n *\n * @see Box\n */\nexport type BoxElement = ReturnType<typeof Box>;\n","import { createSnapComponent } from '../component';\n\n/**\n * The props of the {@link Copyable} component.\n *\n * @property value - The value to copy when the user clicks on the copyable\n * element.\n * @property sensitive - Whether the value is sensitive. If `true`, the value\n * will be hidden when the user is not interacting with the copyable element.\n */\nexport type CopyableProps = {\n  value: string;\n  sensitive?: boolean | undefined;\n};\n\nconst TYPE = 'Copyable';\n\n/**\n * A copyable component, which is used to display text that can be copied by the\n * user.\n *\n * @param props - The props of the component.\n * @param props.value - The value to copy when the user clicks on the copyable\n * element.\n * @param props.sensitive - Whether the value is sensitive. If `true`, the value\n * will be hidden when the user is not interacting with the copyable element.\n * @example\n * <Copyable value=\"0x1234567890123456789012345678901234567890\" />\n * <Copyable value=\"0x1234567890123456789012345678901234567890\" sensitive />\n */\nexport const Copyable = createSnapComponent<CopyableProps, typeof TYPE>(TYPE);\n\n/**\n * A copyable element.\n *\n * @see Copyable\n */\nexport type CopyableElement = ReturnType<typeof Copyable>;\n","import { createSnapComponent } from '../component';\n\nconst TYPE = 'Divider';\n\n/**\n * A divider component, which is used to create a horizontal line between\n * elements.\n *\n * This component does not have any props.\n *\n * @returns A divider element.\n * @example\n * <Divider />\n */\nexport const Divider = createSnapComponent(TYPE);\n\n/**\n * A divider element.\n *\n * @see Divider\n */\nexport type DividerElement = ReturnType<typeof Divider>;\n","import { createSnapComponent } from '../component';\n\n/**\n * The props of the {@link Value} component.\n *\n * @property value - The value shown on the right side.\n * @property extra - The extra text shown on the left side.\n */\nexport type ValueProps = {\n  value: string;\n  extra: string;\n};\n\nconst TYPE = 'Value';\n\n/**\n * A value component, which can be used to display two different text values side by side.\n *\n * This component can only be used as a child of the {@link Row} component.\n *\n * This component does not accept any children.\n *\n * @param props - The props of the component.\n * @param props.value - The value shown on the right side.\n * @param props.extra - The extra text shown on the left side.\n * @returns A value element.\n * @example\n * <Value value=\"0.05 ETH\" extra=\"$200\" />\n */\nexport const Value = createSnapComponent<ValueProps, typeof TYPE>(TYPE);\n\n/**\n * A value element.\n *\n * @see Value\n */\nexport type ValueElement = ReturnType<typeof Value>;\n","import type { StringElement } from '../component';\nimport { createSnapComponent } from '../component';\n\n/**\n * The props of the {@link Heading} component.\n *\n * @property children - The text to display in the heading.\n */\ntype HeadingProps = {\n  children: StringElement;\n};\n\nconst TYPE = 'Heading';\n\n/**\n * A heading component, which is used to display heading text.\n *\n * @param props - The props of the component.\n * @param props.children - The text to display in the heading.\n * @returns A heading element.\n * @example\n * <Heading>Hello world!</Heading>\n */\nexport const Heading = createSnapComponent<HeadingProps, typeof TYPE>(TYPE);\n\n/**\n * A heading element.\n *\n * @see Heading\n */\nexport type HeadingElement = ReturnType<typeof Heading>;\n","import { createSnapComponent } from '../component';\n\n/**\n * The props of the {@link Image} component.\n *\n * @property src - The SVG image to display. This should be an SVG string, and\n * other formats such as PNG and JPEG are not supported directly. You can use\n * the `data:` URL scheme to embed images inside the SVG.\n * @property alt - The alternative text of the image, which describes the image\n * for users who cannot see it.\n */\ntype ImageProps = {\n  src: string;\n  alt?: string | undefined;\n};\n\nconst TYPE = 'Image';\n\n/**\n * An image component, which is used to display an image.\n *\n * This component does not accept any children.\n *\n * @param props - The props of the component.\n * @param props.src - The URL of the image to display. This should be an SVG\n * string, and other formats such as PNG and JPEG are not supported directly.\n * You can use the `data:` URL scheme to embed images inside the SVG.\n * @param props.alt - The alternative text of the image, which describes the\n * image for users who cannot see it.\n * @returns An image element.\n * @example\n * <Image src=\"<svg>...</svg>\" alt=\"An example image\" />\n */\nexport const Image = createSnapComponent<ImageProps, typeof TYPE>(TYPE);\n\n/**\n * An image element.\n *\n * @see Image\n */\nexport type ImageElement = ReturnType<typeof Image>;\n","import type { SnapsChildren } from '../component';\nimport { createSnapComponent } from '../component';\nimport type { StandardFormattingElement } from './formatting';\n\n/**\n * The children of the {@link Link} component.\n */\nexport type LinkChildren = SnapsChildren<string | StandardFormattingElement>;\n\n/**\n * The props of the {@link Link} component.\n *\n * @property children - The text to display in the link.\n * @property href - The URL to link to. This must be an `https` or `mailto` URL.\n * `http` is not allowed.\n */\nexport type LinkProps = {\n  children: LinkChildren;\n  href: string;\n};\n\nconst TYPE = 'Link';\n\n/**\n * A link component, which is used to display a hyperlink.\n *\n * @param props - The props of the component.\n * @param props.children - The text to display in the link.\n * @param props.href - The URL to link to. This must be an `https` or `mailto`\n * URL. `http` is not allowed.\n * @returns A link element.\n * @example\n * <Link href=\"https://example.com\">Click here</Link>\n */\nexport const Link = createSnapComponent<LinkProps, typeof TYPE>(TYPE);\n\n/**\n * A link element.\n *\n * @see Link\n */\nexport type LinkElement = ReturnType<typeof Link>;\n","import { createSnapComponent } from '../component';\nimport type { AddressElement } from './Address';\nimport type { ImageElement } from './Image';\nimport type { TextElement } from './Text';\nimport type { ValueElement } from './Value';\n\n/**\n * The children of a {@link Row} component.\n */\nexport type RowChildren =\n  | AddressElement\n  | ImageElement\n  | TextElement\n  | ValueElement;\n\n/**\n * The props of the {@link Row} component.\n *\n * @property label - The label of the row.\n * @property children - The content of the row. This can be an address, an\n * image, or text.\n * @property variant - The variant of the row.\n * @property tooltip - An optional tooltip to show for the row.\n */\nexport type RowProps = {\n  label: string;\n  children: RowChildren;\n  variant?: 'default' | 'warning' | 'critical' | undefined;\n  tooltip?: string | undefined;\n};\n\nconst TYPE = 'Row';\n\n/**\n * A row component, which is used to display a row of information.\n *\n * @param props - The props of the component.\n * @param props.label - The label of the row.\n * @param props.children - The content of the row. This can be an address, an\n * image, or text.\n * @param props.variant - The variant of the row.\n * @param props.tooltip - An optional tooltip to show for the row.\n * @returns A row element.\n * @example\n * <Row label=\"From\" variant=\"warning\" tooltip=\"This address has been deemed dangerous.\">\n *   <Address address=\"0x1234567890123456789012345678901234567890\" />\n * </Row>\n */\nexport const Row = createSnapComponent<RowProps, typeof TYPE>(TYPE);\n\n/**\n * A row element.\n *\n * @see Row\n */\nexport type RowElement = ReturnType<typeof Row>;\n","import { createSnapComponent } from '../component';\n\nconst TYPE = 'Spinner';\n\n/**\n * A spinner component, which is used to display a spinner, indicating that some\n * operation is in progress.\n *\n * This component does not accept any props.\n *\n * @returns A spinner element.\n * @example\n * <Spinner />\n */\nexport const Spinner = createSnapComponent(TYPE);\n\n/**\n * A spinner element.\n *\n * @see Spinner\n */\nexport type SpinnerElement = ReturnType<typeof Spinner>;\n","import type { SnapsChildren } from '../component';\nimport { createSnapComponent } from '../component';\nimport type { StandardFormattingElement } from './formatting';\nimport type { LinkElement } from './Link';\n\n/**\n * The children of the {@link Text} component.\n */\nexport type TextChildren = SnapsChildren<\n  string | StandardFormattingElement | LinkElement\n>;\n\n/**\n * The props of the {@link Text} component.\n *\n * @property children - The text to display.\n */\nexport type TextProps = {\n  children: TextChildren;\n  alignment?: 'start' | 'center' | 'end' | undefined;\n};\n\nconst TYPE = 'Text';\n\n/**\n * A text component, which is used to display text.\n *\n * @param props - The props of the component.\n * @param props.children - The text to display.\n * @returns A text element.\n * @example\n * <Text>\n *   Hello <Bold>world</Bold>!\n * </Text>\n * @example\n * <Text alignment=\"end\">\n *   Hello <Bold>world</Bold>!\n * </Text>\n */\nexport const Text = createSnapComponent<TextProps, typeof TYPE>(TYPE);\n\n/**\n * A text element.\n *\n * @see Text\n */\nexport type TextElement = ReturnType<typeof Text>;\n","import { createSnapComponent } from '../component';\nimport type { StandardFormattingElement } from './formatting';\nimport type { ImageElement } from './Image';\nimport type { LinkElement } from './Link';\nimport type { TextElement } from './Text';\n\nexport type TooltipChildren =\n  | TextElement\n  | StandardFormattingElement\n  | LinkElement\n  | ImageElement\n  | boolean\n  | null;\n\n/**\n * The props of the {@link Tooltip} component.\n *\n * @property children - The children of the box.\n * @property content - The text to display in the tooltip.\n */\nexport type TooltipProps = {\n  children: TooltipChildren;\n  content: TextElement | StandardFormattingElement | LinkElement | string;\n};\n\nconst TYPE = 'Tooltip';\n\n/**\n * A tooltip component, which is used to display text in a tooltip.\n *\n * @param props - The props of the component.\n * @param props.children - The children of the tooltip.\n * @param props.content - The text to display in the tooltip.\n * @returns A tooltip element.\n * @example\n * <Tooltip content=\"Tooltip text\">\n *   <Text>Hello world!</Text>\n * </Tooltip>\n * @example\n * <Tooltip content={<Text>Text with <Bold>formatting</Bold></Text>}>\n *   <Text>Hello world!</Text>\n * </Tooltip>\n */\nexport const Tooltip = createSnapComponent<TooltipProps, typeof TYPE>(TYPE);\n\n/**\n * A tooltip element.\n *\n * @see Tooltip\n */\nexport type TooltipElement = ReturnType<typeof Tooltip>;\n","import type { JsonObject, Key, SnapComponent } from './component';\n\n/**\n * The JSX runtime for Snaps SDK components. This function is used to render\n * Snap components into a format that can be used by the Snaps.\n *\n * This is the \"production\" version of the runtime, which does not include\n * additional validation, as it is handled by MetaMask. To use this runtime,\n * specify `@metamask/snaps-sdk` as import source for JSX, and use `react-jsx`\n * as the pragma.\n *\n * @param component - The component to render.\n * @param props - The props to pass to the component.\n * @param key - The key of the component.\n * @returns The rendered component.\n * @see https://www.typescriptlang.org/tsconfig/#jsx\n */\nexport function jsx<Props extends JsonObject>(\n  component: SnapComponent<Props>,\n  props: Props,\n  key: Key | null,\n): unknown | null {\n  if (typeof component === 'string') {\n    // If component is a string, it is a built-in HTML element. This is not\n    // supported in Snaps, so we throw an error.\n    throw new Error(\n      `An HTML element (\"${String(\n        component,\n      )}\") was used in a Snap component, which is not supported by Snaps UI. Please use one of the supported Snap components.`,\n    );\n  }\n\n  if (!component) {\n    // If component is undefined, a JSX fragment `<>...</>` was used, which is\n    // not supported in Snaps.\n    throw new Error(\n      'A JSX fragment was used in a Snap component, which is not supported by Snaps UI. Please use one of the supported Snap components.',\n    );\n  }\n\n  return component({ ...props, key });\n}\n\n/**\n * The JSX runtime for Snaps SDK components. This function is used to render\n * Snap components into a format that can be used by the Snaps.\n *\n * The `jsxs` function is used for rendering nested components.\n *\n * This is the \"production\" version of the runtime, which does not include\n * additional validation, as it is handled by MetaMask. To use this runtime,\n * specify `@metamask/snaps-sdk` as import source for JSX, and use `react-jsx`\n * as the pragma.\n *\n * @param component - The component to render.\n * @param props - The props to pass to the component.\n * @param key - The key of the component.\n * @returns The rendered component.\n * @see https://www.typescriptlang.org/tsconfig/#jsx\n */\nexport function jsxs<Props extends JsonObject>(\n  component: SnapComponent<Props>,\n  props: Props,\n  key: Key | null,\n): unknown | null {\n  return jsx(component, props, key);\n}\n","import {\n  hasProperty,\n  HexChecksumAddressStruct,\n  isPlainObject,\n  JsonStruct,\n} from '@metamask/utils';\nimport type { Infer, Struct } from '@metamask/superstruct';\nimport {\n  is,\n  boolean,\n  optional,\n  array,\n  lazy,\n  nullable,\n  number,\n  object,\n  record,\n  string,\n  tuple,\n} from '@metamask/superstruct';\nimport type {\n  AnyStruct,\n  InferStructTuple,\n  ObjectSchema,\n} from '@metamask/superstruct';\n\nimport type { Describe } from '../internals';\nimport { literal, nullUnion, svg } from '../internals';\nimport type { EmptyObject } from '../types';\nimport type {\n  GenericSnapElement,\n  JsonObject,\n  Key,\n  Nestable,\n  SnapElement,\n  SnapsChildren,\n  StringElement,\n} from './component';\nimport type {\n  AddressElement,\n  BoldElement,\n  BoxElement,\n  ButtonElement,\n  CheckboxElement,\n  CopyableElement,\n  DividerElement,\n  DropdownElement,\n  OptionElement,\n  FieldElement,\n  FormElement,\n  HeadingElement,\n  ImageElement,\n  InputElement,\n  ItalicElement,\n  JSXElement,\n  LinkElement,\n  RowElement,\n  SpinnerElement,\n  StandardFormattingElement,\n  TextElement,\n  TooltipElement,\n  ValueElement,\n  FileInputElement,\n} from './components';\n\n/**\n * A struct for the {@link Key} type.\n */\nexport const KeyStruct: Describe<Key> = nullUnion([string(), number()]);\n\n/**\n * A struct for the {@link StringElement} type.\n */\nexport const StringElementStruct: Describe<StringElement> = children([\n  string(),\n]);\n\n/**\n * A struct for the {@link GenericSnapElement} type.\n */\nexport const ElementStruct: Describe<GenericSnapElement> = object({\n  type: string(),\n  props: record(string(), JsonStruct),\n  key: nullable(KeyStruct),\n});\n\n/**\n * A helper function for creating a struct for a {@link Nestable} type.\n *\n * @param struct - The struct for the type to test.\n * @returns The struct for the nestable type.\n */\nfunction nestable<Type, Schema>(\n  struct: Struct<Type, Schema>,\n): Struct<Nestable<Type>, any> {\n  const nestableStruct: Struct<Nestable<Type>> = nullUnion([\n    struct,\n    array(lazy(() => nestableStruct)),\n  ]);\n\n  return nestableStruct;\n}\n\n/**\n * A helper function for creating a struct which allows children of a specific\n * type, as well as `null` and `boolean`.\n *\n * @param structs - The structs to allow as children.\n * @returns The struct for the children.\n */\nfunction children<Head extends AnyStruct, Tail extends AnyStruct[]>(\n  structs: [head: Head, ...tail: Tail],\n): Struct<\n  Nestable<Infer<Head> | InferStructTuple<Tail>[number] | boolean | null>,\n  null\n> {\n  return nestable(nullable(nullUnion([...structs, boolean()])));\n}\n\n/**\n * A helper function for creating a struct for a JSX element.\n *\n * @param name - The name of the element.\n * @param props - The props of the element.\n * @returns The struct for the element.\n */\nfunction element<Name extends string, Props extends ObjectSchema = EmptyObject>(\n  name: Name,\n  props: Props = {} as Props,\n) {\n  return object({\n    type: literal(name) as unknown as Struct<Name, Name>,\n    props: object(props),\n    key: nullable(KeyStruct),\n  });\n}\n\n/**\n * A struct for the {@link ButtonElement} type.\n */\nexport const ButtonStruct: Describe<ButtonElement> = element('Button', {\n  children: StringElementStruct,\n  name: optional(string()),\n  type: optional(nullUnion([literal('button'), literal('submit')])),\n  variant: optional(nullUnion([literal('primary'), literal('destructive')])),\n  disabled: optional(boolean()),\n});\n\n/**\n * A struct for the {@link CheckboxElement} type.\n */\nexport const CheckboxStruct: Describe<CheckboxElement> = element('Checkbox', {\n  name: string(),\n  checked: optional(boolean()),\n  label: optional(string()),\n  variant: optional(nullUnion([literal('default'), literal('toggle')])),\n});\n\n/**\n * A struct for the {@link InputElement} type.\n */\nexport const InputStruct: Describe<InputElement> = element('Input', {\n  name: string(),\n  type: optional(\n    nullUnion([literal('text'), literal('password'), literal('number')]),\n  ),\n  value: optional(string()),\n  placeholder: optional(string()),\n});\n\n/**\n * A struct for the {@link OptionElement} type.\n */\nexport const OptionStruct: Describe<OptionElement> = element('Option', {\n  value: string(),\n  children: string(),\n});\n\n/**\n * A struct for the {@link DropdownElement} type.\n */\nexport const DropdownStruct: Describe<DropdownElement> = element('Dropdown', {\n  name: string(),\n  value: optional(string()),\n  children: children([OptionStruct]),\n});\n\n/**\n * A struct for the {@link FileInputElement} type.\n */\nexport const FileInputStruct: Describe<FileInputElement> = element(\n  'FileInput',\n  {\n    name: string(),\n    accept: nullUnion([optional(array(string()))]),\n    compact: optional(boolean()),\n  },\n);\n\n/**\n * A struct for the {@link FieldElement} type.\n */\nexport const FieldStruct: Describe<FieldElement> = element('Field', {\n  label: optional(string()),\n  error: optional(string()),\n  children: nullUnion([\n    tuple([InputStruct, ButtonStruct]),\n    DropdownStruct,\n    FileInputStruct,\n    InputStruct,\n    CheckboxStruct,\n  ]),\n});\n\n/**\n * A struct for the {@link FormElement} type.\n */\nexport const FormStruct: Describe<FormElement> = element('Form', {\n  children: children(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    [FieldStruct, lazy(() => BoxChildStruct)],\n  ) as unknown as Struct<SnapsChildren<GenericSnapElement>, null>,\n  name: string(),\n});\n\n/**\n * A struct for the {@link BoldElement} type.\n */\nexport const BoldStruct: Describe<BoldElement> = element('Bold', {\n  children: children([\n    string(),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    lazy(() => ItalicStruct) as unknown as Struct<\n      SnapElement<JsonObject, 'Italic'>\n    >,\n  ]),\n});\n\n/**\n * A struct for the {@link ItalicElement} type.\n */\nexport const ItalicStruct: Describe<ItalicElement> = element('Italic', {\n  children: children([\n    string(),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    lazy(() => BoldStruct) as unknown as Struct<\n      SnapElement<JsonObject, 'Bold'>\n    >,\n  ]),\n});\n\nexport const FormattingStruct: Describe<StandardFormattingElement> = nullUnion([\n  BoldStruct,\n  ItalicStruct,\n]);\n\n/**\n * A struct for the {@link AddressElement} type.\n */\nexport const AddressStruct: Describe<AddressElement> = element('Address', {\n  address: HexChecksumAddressStruct,\n});\n\n/**\n * A struct for the {@link BoxElement} type.\n */\nexport const BoxStruct: Describe<BoxElement> = element('Box', {\n  children: children(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    [lazy(() => BoxChildStruct)],\n  ) as unknown as Struct<SnapsChildren<GenericSnapElement>, null>,\n  direction: optional(nullUnion([literal('horizontal'), literal('vertical')])),\n  alignment: optional(\n    nullUnion([\n      literal('start'),\n      literal('center'),\n      literal('end'),\n      literal('space-between'),\n      literal('space-around'),\n    ]),\n  ),\n});\n\n/**\n * A struct for the {@link CopyableElement} type.\n */\nexport const CopyableStruct: Describe<CopyableElement> = element('Copyable', {\n  value: string(),\n  sensitive: optional(boolean()),\n});\n\n/**\n * A struct for the {@link DividerElement} type.\n */\nexport const DividerStruct: Describe<DividerElement> = element('Divider');\n\n/**\n * A struct for the {@link ValueElement} type.\n */\nexport const ValueStruct: Describe<ValueElement> = element('Value', {\n  value: string(),\n  extra: string(),\n});\n\n/**\n * A struct for the {@link HeadingElement} type.\n */\nexport const HeadingStruct: Describe<HeadingElement> = element('Heading', {\n  children: StringElementStruct,\n});\n\n/**\n * A struct for the {@link ImageElement} type.\n */\nexport const ImageStruct: Describe<ImageElement> = element('Image', {\n  src: svg(),\n  alt: optional(string()),\n});\n\n/**\n * A struct for the {@link LinkElement} type.\n */\nexport const LinkStruct: Describe<LinkElement> = element('Link', {\n  href: string(),\n  children: children([FormattingStruct, string()]),\n});\n\n/**\n * A struct for the {@link TextElement} type.\n */\nexport const TextStruct: Describe<TextElement> = element('Text', {\n  children: children([string(), BoldStruct, ItalicStruct, LinkStruct]),\n  alignment: optional(\n    nullUnion([literal('start'), literal('center'), literal('end')]),\n  ),\n});\n\n/**\n * A subset of JSX elements that are allowed as children of the Tooltip component.\n * This set should include all text components and the Image.\n */\nexport const TooltipChildStruct = nullUnion([\n  TextStruct,\n  BoldStruct,\n  ItalicStruct,\n  LinkStruct,\n  ImageStruct,\n  boolean(),\n]);\n\n/**\n * A subset of JSX elements that are allowed as content of the Tooltip component.\n * This set should include all text components.\n */\nexport const TooltipContentStruct = nullUnion([\n  TextStruct,\n  BoldStruct,\n  ItalicStruct,\n  LinkStruct,\n  string(),\n]);\n\n/**\n * A struct for the {@link TooltipElement} type.\n */\nexport const TooltipStruct: Describe<TooltipElement> = element('Tooltip', {\n  children: nullable(TooltipChildStruct),\n  content: TooltipContentStruct,\n});\n\n/**\n * A struct for the {@link RowElement} type.\n */\nexport const RowStruct: Describe<RowElement> = element('Row', {\n  label: string(),\n  children: nullUnion([AddressStruct, ImageStruct, TextStruct, ValueStruct]),\n  variant: optional(\n    nullUnion([literal('default'), literal('warning'), literal('critical')]),\n  ),\n  tooltip: optional(string()),\n});\n\n/**\n * A struct for the {@link SpinnerElement} type.\n */\nexport const SpinnerStruct: Describe<SpinnerElement> = element('Spinner');\n\n/**\n * A subset of JSX elements that are allowed as children of the Box component.\n * This set includes all components, except components that need to be nested in\n * another component (e.g., Field must be contained in a Form).\n */\nexport const BoxChildStruct = nullUnion([\n  AddressStruct,\n  BoldStruct,\n  BoxStruct,\n  ButtonStruct,\n  CopyableStruct,\n  DividerStruct,\n  DropdownStruct,\n  FileInputStruct,\n  FormStruct,\n  HeadingStruct,\n  InputStruct,\n  ImageStruct,\n  ItalicStruct,\n  LinkStruct,\n  RowStruct,\n  SpinnerStruct,\n  TextStruct,\n  TooltipStruct,\n  CheckboxStruct,\n]);\n\n/**\n * For now, the allowed JSX elements at the root are the same as the allowed\n * children of the Box component.\n */\nexport const RootJSXElementStruct = BoxChildStruct;\n\n/**\n * A struct for the {@link JSXElement} type.\n */\nexport const JSXElementStruct: Describe<JSXElement> = nullUnion([\n  ButtonStruct,\n  InputStruct,\n  FileInputStruct,\n  FieldStruct,\n  FormStruct,\n  BoldStruct,\n  ItalicStruct,\n  AddressStruct,\n  BoxStruct,\n  CopyableStruct,\n  DividerStruct,\n  HeadingStruct,\n  ImageStruct,\n  LinkStruct,\n  RowStruct,\n  SpinnerStruct,\n  TextStruct,\n  DropdownStruct,\n  OptionStruct,\n  ValueStruct,\n  TooltipStruct,\n  CheckboxStruct,\n]);\n\n/**\n * Check if a value is a JSX element.\n *\n * @param value - The value to check.\n * @returns True if the value is a JSX element, false otherwise.\n */\nexport function isJSXElement(value: unknown): value is JSXElement {\n  return is(value, JSXElementStruct);\n}\n\n/**\n * Check if a value is a JSX element, without validating all of its contents.\n * This is useful when you want to validate the structure of a value, but not\n * all the children.\n *\n * This should only be used when you are sure that the value is safe to use,\n * i.e., after using {@link isJSXElement}.\n *\n * @param value - The value to check.\n * @returns True if the value is a JSX element, false otherwise.\n */\nexport function isJSXElementUnsafe(value: unknown): value is JSXElement {\n  return (\n    isPlainObject(value) &&\n    hasProperty(value, 'type') &&\n    hasProperty(value, 'props') &&\n    hasProperty(value, 'key')\n  );\n}\n\n/**\n * Assert that a value is a JSX element.\n *\n * @param value - The value to check.\n * @throws If the value is not a JSX element.\n */\nexport function assertJSXElement(value: unknown): asserts value is JSXElement {\n  // TODO: We should use the error parsing utils from `snaps-utils` to improve\n  // the error messages. It currently includes colours and potentially other\n  // formatting that we might not want to include in the SDK.\n  if (!isJSXElement(value)) {\n    throw new Error(\n      `Expected a JSX element, but received ${JSON.stringify(\n        value,\n      )}. Please refer to the documentation for the supported JSX elements and their props.`,\n    );\n  }\n}\n","import type { Infer } from '@metamask/superstruct';\nimport {\n  Struct,\n  define,\n  literal as superstructLiteral,\n  union as superstructUnion,\n} from '@metamask/superstruct';\nimport type { AnyStruct, InferStructTuple } from '@metamask/superstruct';\n\nimport type { EnumToUnion } from './helpers';\n\n/**\n * A wrapper of `superstruct`'s `literal` struct that also defines the name of\n * the struct as the literal value.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n * For example, instead of returning an error like:\n *\n * ```\n * Expected the value to satisfy a union of `literal | literal`, but received: \\\"baz\\\"\n * ```\n *\n * This struct will return an error like:\n *\n * ```\n * Expected the value to satisfy a union of `\"foo\" | \"bar\"`, but received: \\\"baz\\\"\n * ```\n *\n * @param value - The literal value.\n * @returns The `superstruct` struct, which validates that the value is equal\n * to the literal value.\n */\nexport function literal<Type extends string | number | boolean>(value: Type) {\n  return define<Type>(\n    JSON.stringify(value),\n    superstructLiteral(value).validator,\n  );\n}\n\n/**\n * A wrapper of `superstruct`'s `union` struct that also defines the schema as\n * the union of the schemas of the structs.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n *\n * @param structs - The structs to union.\n * @param structs.\"0\" - The first struct.\n * @param structs.\"1\" - The remaining structs.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function union<Head extends AnyStruct, Tail extends AnyStruct[]>([\n  head,\n  ...tail\n]: [head: Head, ...tail: Tail]): Struct<\n  Infer<Head> | InferStructTuple<Tail>[number],\n  [head: Head, ...tail: Tail]\n> {\n  const struct = superstructUnion([head, ...tail]);\n\n  return new Struct({\n    ...struct,\n    schema: [head, ...tail],\n  });\n}\n\n/**\n * Superstruct struct for validating an enum value. This allows using both the\n * enum string values and the enum itself as values.\n *\n * @param constant - The enum to validate against.\n * @returns The superstruct struct.\n */\nexport function enumValue<Type extends string>(\n  constant: Type,\n): Struct<EnumToUnion<Type>, null> {\n  return literal(constant as EnumToUnion<Type>);\n}\n","import type { Infer, Struct } from '@metamask/superstruct';\nimport type {\n  AnyStruct,\n  EnumSchema,\n  InferStructTuple,\n  IsExactMatch,\n  IsMatch,\n  IsRecord,\n  IsTuple,\n  UnionToIntersection,\n} from '@metamask/superstruct';\n\nimport type { EmptyObject } from '../types';\nimport { union } from './structs';\n\n/**\n * Check if a type is a union. Infers `true` if it is a union, otherwise\n * `false`.\n */\ntype IsUnion<Type> = [Type] extends [UnionToIntersection<Type>] ? false : true;\n\n/**\n * Get a struct schema for a type.\n *\n * This is copied from `superstruct` but fixes some issues with the original\n * implementation.\n */\ntype StructSchema<Type> = IsUnion<Type> extends true\n  ? null\n  : [Type] extends [EmptyObject]\n  ? EmptyObject\n  : [Type] extends [string | undefined | null]\n  ? [Type] extends [`0x${string}`]\n    ? null\n    : [Type] extends [IsMatch<Type, string | undefined | null>]\n    ? null\n    : [Type] extends [IsUnion<Type>]\n    ? EnumSchema<Type>\n    : Type\n  : [Type] extends [number | undefined | null]\n  ? [Type] extends [IsMatch<Type, number | undefined | null>]\n    ? null\n    : [Type] extends [IsUnion<Type>]\n    ? EnumSchema<Type>\n    : Type\n  : [Type] extends [boolean]\n  ? [Type] extends [IsExactMatch<Type, boolean>]\n    ? null\n    : Type\n  : Type extends\n      | bigint\n      | symbol\n      | undefined\n      | null\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      | Function\n      | Date\n      | Error\n      | RegExp\n      | Map<any, any>\n      | WeakMap<any, any>\n      | Set<any>\n      | WeakSet<any>\n      | Promise<any>\n  ? null\n  : Type extends (infer E)[]\n  ? Type extends IsTuple<Type>\n    ? null\n    : Struct<E>\n  : Type extends object\n  ? Type extends IsRecord<Type>\n    ? null\n    : {\n        [InnerKey in keyof Type]: Describe<Type[InnerKey]>;\n      }\n  : null;\n\n/**\n * Describe a struct type.\n */\nexport type Describe<Type> = Struct<Type, StructSchema<Type>>;\n\n/**\n * Create a union struct that uses `null` for the schema type, for better\n * compatibility with `Describe`.\n *\n * @param structs - The structs to union.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function nullUnion<Head extends AnyStruct, Tail extends AnyStruct[]>(\n  structs: [head: Head, ...tail: Tail],\n): Struct<Infer<Head> | InferStructTuple<Tail>[number], null> {\n  return union(structs) as unknown as Struct<\n    Infer<Head> | InferStructTuple<Tail>[number],\n    null\n  >;\n}\n","import { refine, string } from '@metamask/superstruct';\n\n/**\n * Get a Struct that validates a string as a valid SVG.\n *\n * @returns A Struct that validates a string as a valid SVG.\n * @internal\n */\nexport function svg() {\n  return refine(string(), 'SVG', (value) => {\n    // This validation is intentionally very basic, we don't need to be that strict\n    // and merely have this extra validation as a helpful error if devs aren't\n    // passing in SVGs.\n    if (!value.includes('<svg')) {\n      return 'Value is not a valid SVG.';\n    }\n\n    return true;\n  });\n}\n","import type { JsonObject, Key, SnapComponent } from './component';\nimport { jsx } from './jsx-runtime';\nimport { assertJSXElement } from './validation';\n\n/**\n * The JSX runtime for Snaps SDK components. This function is used to render\n * Snap components into a format that can be used by the Snaps.\n *\n * This is the \"development\" version of the runtime, which includes additional\n * validation, which is otherwise handled by MetaMask. To use this runtime,\n * specify `@metamask/snaps-sdk` as import source for JSX, and use\n * `react-jsxdev` as the pragma.\n *\n * @param component - The component to render.\n * @param props - The props to pass to the component.\n * @param key - The key of the component.\n * @returns The rendered component.\n * @see https://www.typescriptlang.org/tsconfig/#jsx\n */\nexport function jsxDEV<Props extends JsonObject>(\n  component: SnapComponent<Props>,\n  props: Props,\n  key: Key | null,\n): unknown | null {\n  const element = jsx(component, props, key);\n  assertJSXElement(element);\n\n  return element;\n}\n"],"mappings":"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","names":["TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","string","string","element"]}
\ No newline at end of file
diff --git a/dist/jsx/jsx-dev-runtime.js.map b/dist/jsx/jsx-dev-runtime.js.map
index 1e5fc396137dbe46ac2b6d8d1b43d754e9144d5e..c3d6e09bfa464571f12c6497d55c4c8b009525cf 100644
--- a/dist/jsx/jsx-dev-runtime.js.map
+++ b/dist/jsx/jsx-dev-runtime.js.map
@@ -1 +1,27 @@
-{"version":3,"sources":["../../src/jsx/jsx-dev-runtime.ts","../../src/jsx/jsx-runtime.ts","../../src/jsx/validation.ts","../../src/internals/structs.ts","../../src/internals/jsx.ts","../../src/internals/svg.ts"],"sourcesContent":["import type { JsonObject, Key, SnapComponent } from './component';\nimport { jsx } from './jsx-runtime';\nimport { assertJSXElement } from './validation';\n\n/**\n * The JSX runtime for Snaps SDK components. This function is used to render\n * Snap components into a format that can be used by the Snaps.\n *\n * This is the \"development\" version of the runtime, which includes additional\n * validation, which is otherwise handled by MetaMask. To use this runtime,\n * specify `@metamask/snaps-sdk` as import source for JSX, and use\n * `react-jsxdev` as the pragma.\n *\n * @param component - The component to render.\n * @param props - The props to pass to the component.\n * @param key - The key of the component.\n * @returns The rendered component.\n * @see https://www.typescriptlang.org/tsconfig/#jsx\n */\nexport function jsxDEV<Props extends JsonObject>(\n  component: SnapComponent<Props>,\n  props: Props,\n  key: Key | null,\n): unknown | null {\n  const element = jsx(component, props, key);\n  assertJSXElement(element);\n\n  return element;\n}\n","import type { JsonObject, Key, SnapComponent } from './component';\n\n/**\n * The JSX runtime for Snaps SDK components. This function is used to render\n * Snap components into a format that can be used by the Snaps.\n *\n * This is the \"production\" version of the runtime, which does not include\n * additional validation, as it is handled by MetaMask. To use this runtime,\n * specify `@metamask/snaps-sdk` as import source for JSX, and use `react-jsx`\n * as the pragma.\n *\n * @param component - The component to render.\n * @param props - The props to pass to the component.\n * @param key - The key of the component.\n * @returns The rendered component.\n * @see https://www.typescriptlang.org/tsconfig/#jsx\n */\nexport function jsx<Props extends JsonObject>(\n  component: SnapComponent<Props>,\n  props: Props,\n  key: Key | null,\n): unknown | null {\n  if (typeof component === 'string') {\n    // If component is a string, it is a built-in HTML element. This is not\n    // supported in Snaps, so we throw an error.\n    throw new Error(\n      `An HTML element (\"${String(\n        component,\n      )}\") was used in a Snap component, which is not supported by Snaps UI. Please use one of the supported Snap components.`,\n    );\n  }\n\n  if (!component) {\n    // If component is undefined, a JSX fragment `<>...</>` was used, which is\n    // not supported in Snaps.\n    throw new Error(\n      'A JSX fragment was used in a Snap component, which is not supported by Snaps UI. Please use one of the supported Snap components.',\n    );\n  }\n\n  return component({ ...props, key });\n}\n\n/**\n * The JSX runtime for Snaps SDK components. This function is used to render\n * Snap components into a format that can be used by the Snaps.\n *\n * The `jsxs` function is used for rendering nested components.\n *\n * This is the \"production\" version of the runtime, which does not include\n * additional validation, as it is handled by MetaMask. To use this runtime,\n * specify `@metamask/snaps-sdk` as import source for JSX, and use `react-jsx`\n * as the pragma.\n *\n * @param component - The component to render.\n * @param props - The props to pass to the component.\n * @param key - The key of the component.\n * @returns The rendered component.\n * @see https://www.typescriptlang.org/tsconfig/#jsx\n */\nexport function jsxs<Props extends JsonObject>(\n  component: SnapComponent<Props>,\n  props: Props,\n  key: Key | null,\n): unknown | null {\n  return jsx(component, props, key);\n}\n","import {\n  hasProperty,\n  HexChecksumAddressStruct,\n  isPlainObject,\n  JsonStruct,\n} from '@metamask/utils';\nimport type { Infer, Struct } from 'superstruct';\nimport {\n  is,\n  boolean,\n  optional,\n  array,\n  lazy,\n  nullable,\n  number,\n  object,\n  record,\n  string,\n  tuple,\n} from 'superstruct';\nimport type {\n  AnyStruct,\n  InferStructTuple,\n  ObjectSchema,\n} from 'superstruct/dist/utils';\n\nimport type { Describe } from '../internals';\nimport { literal, nullUnion, svg } from '../internals';\nimport type { EmptyObject } from '../types';\nimport type {\n  GenericSnapElement,\n  JsonObject,\n  Key,\n  Nestable,\n  SnapElement,\n  SnapsChildren,\n  StringElement,\n} from './component';\nimport type {\n  AddressElement,\n  BoldElement,\n  BoxElement,\n  ButtonElement,\n  CheckboxElement,\n  CopyableElement,\n  DividerElement,\n  DropdownElement,\n  OptionElement,\n  FieldElement,\n  FormElement,\n  HeadingElement,\n  ImageElement,\n  InputElement,\n  ItalicElement,\n  JSXElement,\n  LinkElement,\n  RowElement,\n  SpinnerElement,\n  StandardFormattingElement,\n  TextElement,\n  TooltipElement,\n  ValueElement,\n  FileInputElement,\n} from './components';\n\n/**\n * A struct for the {@link Key} type.\n */\nexport const KeyStruct: Describe<Key> = nullUnion([string(), number()]);\n\n/**\n * A struct for the {@link StringElement} type.\n */\nexport const StringElementStruct: Describe<StringElement> = children([\n  string(),\n]);\n\n/**\n * A struct for the {@link GenericSnapElement} type.\n */\nexport const ElementStruct: Describe<GenericSnapElement> = object({\n  type: string(),\n  props: record(string(), JsonStruct),\n  key: nullable(KeyStruct),\n});\n\n/**\n * A helper function for creating a struct for a {@link Nestable} type.\n *\n * @param struct - The struct for the type to test.\n * @returns The struct for the nestable type.\n */\nfunction nestable<Type, Schema>(\n  struct: Struct<Type, Schema>,\n): Struct<Nestable<Type>, any> {\n  const nestableStruct: Struct<Nestable<Type>> = nullUnion([\n    struct,\n    array(lazy(() => nestableStruct)),\n  ]);\n\n  return nestableStruct;\n}\n\n/**\n * A helper function for creating a struct which allows children of a specific\n * type, as well as `null` and `boolean`.\n *\n * @param structs - The structs to allow as children.\n * @returns The struct for the children.\n */\nfunction children<Head extends AnyStruct, Tail extends AnyStruct[]>(\n  structs: [head: Head, ...tail: Tail],\n): Struct<\n  Nestable<Infer<Head> | InferStructTuple<Tail>[number] | boolean | null>,\n  null\n> {\n  return nestable(nullable(nullUnion([...structs, boolean()])));\n}\n\n/**\n * A helper function for creating a struct for a JSX element.\n *\n * @param name - The name of the element.\n * @param props - The props of the element.\n * @returns The struct for the element.\n */\nfunction element<Name extends string, Props extends ObjectSchema = EmptyObject>(\n  name: Name,\n  props: Props = {} as Props,\n) {\n  return object({\n    type: literal(name) as unknown as Struct<Name, Name>,\n    props: object(props),\n    key: nullable(KeyStruct),\n  });\n}\n\n/**\n * A struct for the {@link ButtonElement} type.\n */\nexport const ButtonStruct: Describe<ButtonElement> = element('Button', {\n  children: StringElementStruct,\n  name: optional(string()),\n  type: optional(nullUnion([literal('button'), literal('submit')])),\n  variant: optional(nullUnion([literal('primary'), literal('destructive')])),\n  disabled: optional(boolean()),\n});\n\n/**\n * A struct for the {@link CheckboxElement} type.\n */\nexport const CheckboxStruct: Describe<CheckboxElement> = element('Checkbox', {\n  name: string(),\n  checked: optional(boolean()),\n  label: optional(string()),\n  variant: optional(nullUnion([literal('default'), literal('toggle')])),\n});\n\n/**\n * A struct for the {@link InputElement} type.\n */\nexport const InputStruct: Describe<InputElement> = element('Input', {\n  name: string(),\n  type: optional(\n    nullUnion([literal('text'), literal('password'), literal('number')]),\n  ),\n  value: optional(string()),\n  placeholder: optional(string()),\n});\n\n/**\n * A struct for the {@link OptionElement} type.\n */\nexport const OptionStruct: Describe<OptionElement> = element('Option', {\n  value: string(),\n  children: string(),\n});\n\n/**\n * A struct for the {@link DropdownElement} type.\n */\nexport const DropdownStruct: Describe<DropdownElement> = element('Dropdown', {\n  name: string(),\n  value: optional(string()),\n  children: children([OptionStruct]),\n});\n\n/**\n * A struct for the {@link FileInputElement} type.\n */\nexport const FileInputStruct: Describe<FileInputElement> = element(\n  'FileInput',\n  {\n    name: string(),\n    accept: nullUnion([optional(array(string()))]),\n    compact: optional(boolean()),\n  },\n);\n\n/**\n * A struct for the {@link FieldElement} type.\n */\nexport const FieldStruct: Describe<FieldElement> = element('Field', {\n  label: optional(string()),\n  error: optional(string()),\n  children: nullUnion([\n    tuple([InputStruct, ButtonStruct]),\n    DropdownStruct,\n    FileInputStruct,\n    InputStruct,\n    CheckboxStruct,\n  ]),\n});\n\n/**\n * A struct for the {@link FormElement} type.\n */\nexport const FormStruct: Describe<FormElement> = element('Form', {\n  children: children(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    [FieldStruct, lazy(() => BoxChildStruct)],\n  ) as unknown as Struct<SnapsChildren<GenericSnapElement>, null>,\n  name: string(),\n});\n\n/**\n * A struct for the {@link BoldElement} type.\n */\nexport const BoldStruct: Describe<BoldElement> = element('Bold', {\n  children: children([\n    string(),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    lazy(() => ItalicStruct) as unknown as Struct<\n      SnapElement<JsonObject, 'Italic'>\n    >,\n  ]),\n});\n\n/**\n * A struct for the {@link ItalicElement} type.\n */\nexport const ItalicStruct: Describe<ItalicElement> = element('Italic', {\n  children: children([\n    string(),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    lazy(() => BoldStruct) as unknown as Struct<\n      SnapElement<JsonObject, 'Bold'>\n    >,\n  ]),\n});\n\nexport const FormattingStruct: Describe<StandardFormattingElement> = nullUnion([\n  BoldStruct,\n  ItalicStruct,\n]);\n\n/**\n * A struct for the {@link AddressElement} type.\n */\nexport const AddressStruct: Describe<AddressElement> = element('Address', {\n  address: HexChecksumAddressStruct,\n});\n\n/**\n * A struct for the {@link BoxElement} type.\n */\nexport const BoxStruct: Describe<BoxElement> = element('Box', {\n  children: children(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    [lazy(() => BoxChildStruct)],\n  ) as unknown as Struct<SnapsChildren<GenericSnapElement>, null>,\n  direction: optional(nullUnion([literal('horizontal'), literal('vertical')])),\n  alignment: optional(\n    nullUnion([\n      literal('start'),\n      literal('center'),\n      literal('end'),\n      literal('space-between'),\n      literal('space-around'),\n    ]),\n  ),\n});\n\n/**\n * A struct for the {@link CopyableElement} type.\n */\nexport const CopyableStruct: Describe<CopyableElement> = element('Copyable', {\n  value: string(),\n  sensitive: optional(boolean()),\n});\n\n/**\n * A struct for the {@link DividerElement} type.\n */\nexport const DividerStruct: Describe<DividerElement> = element('Divider');\n\n/**\n * A struct for the {@link ValueElement} type.\n */\nexport const ValueStruct: Describe<ValueElement> = element('Value', {\n  value: string(),\n  extra: string(),\n});\n\n/**\n * A struct for the {@link HeadingElement} type.\n */\nexport const HeadingStruct: Describe<HeadingElement> = element('Heading', {\n  children: StringElementStruct,\n});\n\n/**\n * A struct for the {@link ImageElement} type.\n */\nexport const ImageStruct: Describe<ImageElement> = element('Image', {\n  src: svg(),\n  alt: optional(string()),\n});\n\n/**\n * A struct for the {@link LinkElement} type.\n */\nexport const LinkStruct: Describe<LinkElement> = element('Link', {\n  href: string(),\n  children: children([FormattingStruct, string()]),\n});\n\n/**\n * A struct for the {@link TextElement} type.\n */\nexport const TextStruct: Describe<TextElement> = element('Text', {\n  children: children([string(), BoldStruct, ItalicStruct, LinkStruct]),\n  alignment: optional(\n    nullUnion([literal('start'), literal('center'), literal('end')]),\n  ),\n});\n\n/**\n * A subset of JSX elements that are allowed as children of the Tooltip component.\n * This set should include all text components and the Image.\n */\nexport const TooltipChildStruct = nullUnion([\n  TextStruct,\n  BoldStruct,\n  ItalicStruct,\n  LinkStruct,\n  ImageStruct,\n  boolean(),\n]);\n\n/**\n * A subset of JSX elements that are allowed as content of the Tooltip component.\n * This set should include all text components.\n */\nexport const TooltipContentStruct = nullUnion([\n  TextStruct,\n  BoldStruct,\n  ItalicStruct,\n  LinkStruct,\n  string(),\n]);\n\n/**\n * A struct for the {@link TooltipElement} type.\n */\nexport const TooltipStruct: Describe<TooltipElement> = element('Tooltip', {\n  children: nullable(TooltipChildStruct),\n  content: TooltipContentStruct,\n});\n\n/**\n * A struct for the {@link RowElement} type.\n */\nexport const RowStruct: Describe<RowElement> = element('Row', {\n  label: string(),\n  children: nullUnion([AddressStruct, ImageStruct, TextStruct, ValueStruct]),\n  variant: optional(\n    nullUnion([literal('default'), literal('warning'), literal('critical')]),\n  ),\n  tooltip: optional(string()),\n});\n\n/**\n * A struct for the {@link SpinnerElement} type.\n */\nexport const SpinnerStruct: Describe<SpinnerElement> = element('Spinner');\n\n/**\n * A subset of JSX elements that are allowed as children of the Box component.\n * This set includes all components, except components that need to be nested in\n * another component (e.g., Field must be contained in a Form).\n */\nexport const BoxChildStruct = nullUnion([\n  AddressStruct,\n  BoldStruct,\n  BoxStruct,\n  ButtonStruct,\n  CopyableStruct,\n  DividerStruct,\n  DropdownStruct,\n  FileInputStruct,\n  FormStruct,\n  HeadingStruct,\n  InputStruct,\n  ImageStruct,\n  ItalicStruct,\n  LinkStruct,\n  RowStruct,\n  SpinnerStruct,\n  TextStruct,\n  TooltipStruct,\n  CheckboxStruct,\n]);\n\n/**\n * For now, the allowed JSX elements at the root are the same as the allowed\n * children of the Box component.\n */\nexport const RootJSXElementStruct = BoxChildStruct;\n\n/**\n * A struct for the {@link JSXElement} type.\n */\nexport const JSXElementStruct: Describe<JSXElement> = nullUnion([\n  ButtonStruct,\n  InputStruct,\n  FileInputStruct,\n  FieldStruct,\n  FormStruct,\n  BoldStruct,\n  ItalicStruct,\n  AddressStruct,\n  BoxStruct,\n  CopyableStruct,\n  DividerStruct,\n  HeadingStruct,\n  ImageStruct,\n  LinkStruct,\n  RowStruct,\n  SpinnerStruct,\n  TextStruct,\n  DropdownStruct,\n  OptionStruct,\n  ValueStruct,\n  TooltipStruct,\n  CheckboxStruct,\n]);\n\n/**\n * Check if a value is a JSX element.\n *\n * @param value - The value to check.\n * @returns True if the value is a JSX element, false otherwise.\n */\nexport function isJSXElement(value: unknown): value is JSXElement {\n  return is(value, JSXElementStruct);\n}\n\n/**\n * Check if a value is a JSX element, without validating all of its contents.\n * This is useful when you want to validate the structure of a value, but not\n * all the children.\n *\n * This should only be used when you are sure that the value is safe to use,\n * i.e., after using {@link isJSXElement}.\n *\n * @param value - The value to check.\n * @returns True if the value is a JSX element, false otherwise.\n */\nexport function isJSXElementUnsafe(value: unknown): value is JSXElement {\n  return (\n    isPlainObject(value) &&\n    hasProperty(value, 'type') &&\n    hasProperty(value, 'props') &&\n    hasProperty(value, 'key')\n  );\n}\n\n/**\n * Assert that a value is a JSX element.\n *\n * @param value - The value to check.\n * @throws If the value is not a JSX element.\n */\nexport function assertJSXElement(value: unknown): asserts value is JSXElement {\n  // TODO: We should use the error parsing utils from `snaps-utils` to improve\n  // the error messages. It currently includes colours and potentially other\n  // formatting that we might not want to include in the SDK.\n  if (!isJSXElement(value)) {\n    throw new Error(\n      `Expected a JSX element, but received ${JSON.stringify(\n        value,\n      )}. Please refer to the documentation for the supported JSX elements and their props.`,\n    );\n  }\n}\n","import type { Infer } from 'superstruct';\nimport {\n  Struct,\n  define,\n  literal as superstructLiteral,\n  union as superstructUnion,\n} from 'superstruct';\nimport type { AnyStruct, InferStructTuple } from 'superstruct/dist/utils';\n\nimport type { EnumToUnion } from './helpers';\n\n/**\n * A wrapper of `superstruct`'s `literal` struct that also defines the name of\n * the struct as the literal value.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n * For example, instead of returning an error like:\n *\n * ```\n * Expected the value to satisfy a union of `literal | literal`, but received: \\\"baz\\\"\n * ```\n *\n * This struct will return an error like:\n *\n * ```\n * Expected the value to satisfy a union of `\"foo\" | \"bar\"`, but received: \\\"baz\\\"\n * ```\n *\n * @param value - The literal value.\n * @returns The `superstruct` struct, which validates that the value is equal\n * to the literal value.\n */\nexport function literal<Type extends string | number | boolean>(value: Type) {\n  return define<Type>(\n    JSON.stringify(value),\n    superstructLiteral(value).validator,\n  );\n}\n\n/**\n * A wrapper of `superstruct`'s `union` struct that also defines the schema as\n * the union of the schemas of the structs.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n *\n * @param structs - The structs to union.\n * @param structs.\"0\" - The first struct.\n * @param structs.\"1\" - The remaining structs.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function union<Head extends AnyStruct, Tail extends AnyStruct[]>([\n  head,\n  ...tail\n]: [head: Head, ...tail: Tail]): Struct<\n  Infer<Head> | InferStructTuple<Tail>[number],\n  [head: Head, ...tail: Tail]\n> {\n  const struct = superstructUnion([head, ...tail]);\n\n  return new Struct({\n    ...struct,\n    schema: [head, ...tail],\n  });\n}\n\n/**\n * Superstruct struct for validating an enum value. This allows using both the\n * enum string values and the enum itself as values.\n *\n * @param constant - The enum to validate against.\n * @returns The superstruct struct.\n */\nexport function enumValue<Type extends string>(\n  constant: Type,\n): Struct<EnumToUnion<Type>, null> {\n  return literal(constant as EnumToUnion<Type>);\n}\n","import type { Infer, Struct } from 'superstruct';\nimport type {\n  AnyStruct,\n  EnumSchema,\n  InferStructTuple,\n  IsExactMatch,\n  IsMatch,\n  IsRecord,\n  IsTuple,\n  UnionToIntersection,\n} from 'superstruct/dist/utils';\n\nimport type { EmptyObject } from '../types';\nimport { union } from './structs';\n\n/**\n * Check if a type is a union. Infers `true` if it is a union, otherwise\n * `false`.\n */\ntype IsUnion<Type> = [Type] extends [UnionToIntersection<Type>] ? false : true;\n\n/**\n * Get a struct schema for a type.\n *\n * This is copied from `superstruct` but fixes some issues with the original\n * implementation.\n */\ntype StructSchema<Type> = IsUnion<Type> extends true\n  ? null\n  : [Type] extends [EmptyObject]\n  ? EmptyObject\n  : [Type] extends [string | undefined | null]\n  ? [Type] extends [`0x${string}`]\n    ? null\n    : [Type] extends [IsMatch<Type, string | undefined | null>]\n    ? null\n    : [Type] extends [IsUnion<Type>]\n    ? EnumSchema<Type>\n    : Type\n  : [Type] extends [number | undefined | null]\n  ? [Type] extends [IsMatch<Type, number | undefined | null>]\n    ? null\n    : [Type] extends [IsUnion<Type>]\n    ? EnumSchema<Type>\n    : Type\n  : [Type] extends [boolean]\n  ? [Type] extends [IsExactMatch<Type, boolean>]\n    ? null\n    : Type\n  : Type extends\n      | bigint\n      | symbol\n      | undefined\n      | null\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      | Function\n      | Date\n      | Error\n      | RegExp\n      | Map<any, any>\n      | WeakMap<any, any>\n      | Set<any>\n      | WeakSet<any>\n      | Promise<any>\n  ? null\n  : Type extends (infer E)[]\n  ? Type extends IsTuple<Type>\n    ? null\n    : Struct<E>\n  : Type extends object\n  ? Type extends IsRecord<Type>\n    ? null\n    : {\n        [InnerKey in keyof Type]: Describe<Type[InnerKey]>;\n      }\n  : null;\n\n/**\n * Describe a struct type.\n */\nexport type Describe<Type> = Struct<Type, StructSchema<Type>>;\n\n/**\n * Create a union struct that uses `null` for the schema type, for better\n * compatibility with `Describe`.\n *\n * @param structs - The structs to union.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function nullUnion<Head extends AnyStruct, Tail extends AnyStruct[]>(\n  structs: [head: Head, ...tail: Tail],\n): Struct<Infer<Head> | InferStructTuple<Tail>[number], null> {\n  return union(structs) as unknown as Struct<\n    Infer<Head> | InferStructTuple<Tail>[number],\n    null\n  >;\n}\n","import { refine, string } from 'superstruct';\n\n/**\n * Get a Struct that validates a string as a valid SVG.\n *\n * @returns A Struct that validates a string as a valid SVG.\n * @internal\n */\nexport function svg() {\n  return refine(string(), 'SVG', (value) => {\n    // This validation is intentionally very basic, we don't need to be that strict\n    // and merely have this extra validation as a helpful error if devs aren't\n    // passing in SVGs.\n    if (!value.includes('<svg')) {\n      return 'Value is not a valid SVG.';\n    }\n\n    return true;\n  });\n}\n"],"mappings":"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","names":["import_superstruct","superstructLiteral","superstructUnion","import_superstruct","element"]}
\ No newline at end of file
+{
+    "version": 3,
+    "sources": [
+        "../../src/jsx/jsx-dev-runtime.ts",
+        "../../src/jsx/jsx-runtime.ts",
+        "../../src/jsx/validation.ts",
+        "../../src/internals/structs.ts",
+        "../../src/internals/jsx.ts",
+        "../../src/internals/svg.ts"
+    ],
+    "sourcesContent": [
+        "import type { JsonObject, Key, SnapComponent } from './component';\nimport { jsx } from './jsx-runtime';\nimport { assertJSXElement } from './validation';\n\n/**\n * The JSX runtime for Snaps SDK components. This function is used to render\n * Snap components into a format that can be used by the Snaps.\n *\n * This is the \"development\" version of the runtime, which includes additional\n * validation, which is otherwise handled by MetaMask. To use this runtime,\n * specify `@metamask/snaps-sdk` as import source for JSX, and use\n * `react-jsxdev` as the pragma.\n *\n * @param component - The component to render.\n * @param props - The props to pass to the component.\n * @param key - The key of the component.\n * @returns The rendered component.\n * @see https://www.typescriptlang.org/tsconfig/#jsx\n */\nexport function jsxDEV<Props extends JsonObject>(\n  component: SnapComponent<Props>,\n  props: Props,\n  key: Key | null,\n): unknown | null {\n  const element = jsx(component, props, key);\n  assertJSXElement(element);\n\n  return element;\n}\n",
+        "import type { JsonObject, Key, SnapComponent } from './component';\n\n/**\n * The JSX runtime for Snaps SDK components. This function is used to render\n * Snap components into a format that can be used by the Snaps.\n *\n * This is the \"production\" version of the runtime, which does not include\n * additional validation, as it is handled by MetaMask. To use this runtime,\n * specify `@metamask/snaps-sdk` as import source for JSX, and use `react-jsx`\n * as the pragma.\n *\n * @param component - The component to render.\n * @param props - The props to pass to the component.\n * @param key - The key of the component.\n * @returns The rendered component.\n * @see https://www.typescriptlang.org/tsconfig/#jsx\n */\nexport function jsx<Props extends JsonObject>(\n  component: SnapComponent<Props>,\n  props: Props,\n  key: Key | null,\n): unknown | null {\n  if (typeof component === 'string') {\n    // If component is a string, it is a built-in HTML element. This is not\n    // supported in Snaps, so we throw an error.\n    throw new Error(\n      `An HTML element (\"${String(\n        component,\n      )}\") was used in a Snap component, which is not supported by Snaps UI. Please use one of the supported Snap components.`,\n    );\n  }\n\n  if (!component) {\n    // If component is undefined, a JSX fragment `<>...</>` was used, which is\n    // not supported in Snaps.\n    throw new Error(\n      'A JSX fragment was used in a Snap component, which is not supported by Snaps UI. Please use one of the supported Snap components.',\n    );\n  }\n\n  return component({ ...props, key });\n}\n\n/**\n * The JSX runtime for Snaps SDK components. This function is used to render\n * Snap components into a format that can be used by the Snaps.\n *\n * The `jsxs` function is used for rendering nested components.\n *\n * This is the \"production\" version of the runtime, which does not include\n * additional validation, as it is handled by MetaMask. To use this runtime,\n * specify `@metamask/snaps-sdk` as import source for JSX, and use `react-jsx`\n * as the pragma.\n *\n * @param component - The component to render.\n * @param props - The props to pass to the component.\n * @param key - The key of the component.\n * @returns The rendered component.\n * @see https://www.typescriptlang.org/tsconfig/#jsx\n */\nexport function jsxs<Props extends JsonObject>(\n  component: SnapComponent<Props>,\n  props: Props,\n  key: Key | null,\n): unknown | null {\n  return jsx(component, props, key);\n}\n",
+        "import {\n  hasProperty,\n  HexChecksumAddressStruct,\n  isPlainObject,\n  JsonStruct,\n} from '@metamask/utils';\nimport type { Infer, Struct } from '@metamask/superstruct';\nimport {\n  is,\n  boolean,\n  optional,\n  array,\n  lazy,\n  nullable,\n  number,\n  object,\n  record,\n  string,\n  tuple,\n} from '@metamask/superstruct';\nimport type {\n  AnyStruct,\n  InferStructTuple,\n  ObjectSchema,\n} from '@metamask/superstruct';\n\nimport type { Describe } from '../internals';\nimport { literal, nullUnion, svg } from '../internals';\nimport type { EmptyObject } from '../types';\nimport type {\n  GenericSnapElement,\n  JsonObject,\n  Key,\n  Nestable,\n  SnapElement,\n  SnapsChildren,\n  StringElement,\n} from './component';\nimport type {\n  AddressElement,\n  BoldElement,\n  BoxElement,\n  ButtonElement,\n  CheckboxElement,\n  CopyableElement,\n  DividerElement,\n  DropdownElement,\n  OptionElement,\n  FieldElement,\n  FormElement,\n  HeadingElement,\n  ImageElement,\n  InputElement,\n  ItalicElement,\n  JSXElement,\n  LinkElement,\n  RowElement,\n  SpinnerElement,\n  StandardFormattingElement,\n  TextElement,\n  TooltipElement,\n  ValueElement,\n  FileInputElement,\n} from './components';\n\n/**\n * A struct for the {@link Key} type.\n */\nexport const KeyStruct: Describe<Key> = nullUnion([string(), number()]);\n\n/**\n * A struct for the {@link StringElement} type.\n */\nexport const StringElementStruct: Describe<StringElement> = children([\n  string(),\n]);\n\n/**\n * A struct for the {@link GenericSnapElement} type.\n */\nexport const ElementStruct: Describe<GenericSnapElement> = object({\n  type: string(),\n  props: record(string(), JsonStruct),\n  key: nullable(KeyStruct),\n});\n\n/**\n * A helper function for creating a struct for a {@link Nestable} type.\n *\n * @param struct - The struct for the type to test.\n * @returns The struct for the nestable type.\n */\nfunction nestable<Type, Schema>(\n  struct: Struct<Type, Schema>,\n): Struct<Nestable<Type>, any> {\n  const nestableStruct: Struct<Nestable<Type>> = nullUnion([\n    struct,\n    array(lazy(() => nestableStruct)),\n  ]);\n\n  return nestableStruct;\n}\n\n/**\n * A helper function for creating a struct which allows children of a specific\n * type, as well as `null` and `boolean`.\n *\n * @param structs - The structs to allow as children.\n * @returns The struct for the children.\n */\nfunction children<Head extends AnyStruct, Tail extends AnyStruct[]>(\n  structs: [head: Head, ...tail: Tail],\n): Struct<\n  Nestable<Infer<Head> | InferStructTuple<Tail>[number] | boolean | null>,\n  null\n> {\n  return nestable(nullable(nullUnion([...structs, boolean()])));\n}\n\n/**\n * A helper function for creating a struct for a JSX element.\n *\n * @param name - The name of the element.\n * @param props - The props of the element.\n * @returns The struct for the element.\n */\nfunction element<Name extends string, Props extends ObjectSchema = EmptyObject>(\n  name: Name,\n  props: Props = {} as Props,\n) {\n  return object({\n    type: literal(name) as unknown as Struct<Name, Name>,\n    props: object(props),\n    key: nullable(KeyStruct),\n  });\n}\n\n/**\n * A struct for the {@link ButtonElement} type.\n */\nexport const ButtonStruct: Describe<ButtonElement> = element('Button', {\n  children: StringElementStruct,\n  name: optional(string()),\n  type: optional(nullUnion([literal('button'), literal('submit')])),\n  variant: optional(nullUnion([literal('primary'), literal('destructive')])),\n  disabled: optional(boolean()),\n});\n\n/**\n * A struct for the {@link CheckboxElement} type.\n */\nexport const CheckboxStruct: Describe<CheckboxElement> = element('Checkbox', {\n  name: string(),\n  checked: optional(boolean()),\n  label: optional(string()),\n  variant: optional(nullUnion([literal('default'), literal('toggle')])),\n});\n\n/**\n * A struct for the {@link InputElement} type.\n */\nexport const InputStruct: Describe<InputElement> = element('Input', {\n  name: string(),\n  type: optional(\n    nullUnion([literal('text'), literal('password'), literal('number')]),\n  ),\n  value: optional(string()),\n  placeholder: optional(string()),\n});\n\n/**\n * A struct for the {@link OptionElement} type.\n */\nexport const OptionStruct: Describe<OptionElement> = element('Option', {\n  value: string(),\n  children: string(),\n});\n\n/**\n * A struct for the {@link DropdownElement} type.\n */\nexport const DropdownStruct: Describe<DropdownElement> = element('Dropdown', {\n  name: string(),\n  value: optional(string()),\n  children: children([OptionStruct]),\n});\n\n/**\n * A struct for the {@link FileInputElement} type.\n */\nexport const FileInputStruct: Describe<FileInputElement> = element(\n  'FileInput',\n  {\n    name: string(),\n    accept: nullUnion([optional(array(string()))]),\n    compact: optional(boolean()),\n  },\n);\n\n/**\n * A struct for the {@link FieldElement} type.\n */\nexport const FieldStruct: Describe<FieldElement> = element('Field', {\n  label: optional(string()),\n  error: optional(string()),\n  children: nullUnion([\n    tuple([InputStruct, ButtonStruct]),\n    DropdownStruct,\n    FileInputStruct,\n    InputStruct,\n    CheckboxStruct,\n  ]),\n});\n\n/**\n * A struct for the {@link FormElement} type.\n */\nexport const FormStruct: Describe<FormElement> = element('Form', {\n  children: children(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    [FieldStruct, lazy(() => BoxChildStruct)],\n  ) as unknown as Struct<SnapsChildren<GenericSnapElement>, null>,\n  name: string(),\n});\n\n/**\n * A struct for the {@link BoldElement} type.\n */\nexport const BoldStruct: Describe<BoldElement> = element('Bold', {\n  children: children([\n    string(),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    lazy(() => ItalicStruct) as unknown as Struct<\n      SnapElement<JsonObject, 'Italic'>\n    >,\n  ]),\n});\n\n/**\n * A struct for the {@link ItalicElement} type.\n */\nexport const ItalicStruct: Describe<ItalicElement> = element('Italic', {\n  children: children([\n    string(),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    lazy(() => BoldStruct) as unknown as Struct<\n      SnapElement<JsonObject, 'Bold'>\n    >,\n  ]),\n});\n\nexport const FormattingStruct: Describe<StandardFormattingElement> = nullUnion([\n  BoldStruct,\n  ItalicStruct,\n]);\n\n/**\n * A struct for the {@link AddressElement} type.\n */\nexport const AddressStruct: Describe<AddressElement> = element('Address', {\n  address: HexChecksumAddressStruct,\n});\n\n/**\n * A struct for the {@link BoxElement} type.\n */\nexport const BoxStruct: Describe<BoxElement> = element('Box', {\n  children: children(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    [lazy(() => BoxChildStruct)],\n  ) as unknown as Struct<SnapsChildren<GenericSnapElement>, null>,\n  direction: optional(nullUnion([literal('horizontal'), literal('vertical')])),\n  alignment: optional(\n    nullUnion([\n      literal('start'),\n      literal('center'),\n      literal('end'),\n      literal('space-between'),\n      literal('space-around'),\n    ]),\n  ),\n});\n\n/**\n * A struct for the {@link CopyableElement} type.\n */\nexport const CopyableStruct: Describe<CopyableElement> = element('Copyable', {\n  value: string(),\n  sensitive: optional(boolean()),\n});\n\n/**\n * A struct for the {@link DividerElement} type.\n */\nexport const DividerStruct: Describe<DividerElement> = element('Divider');\n\n/**\n * A struct for the {@link ValueElement} type.\n */\nexport const ValueStruct: Describe<ValueElement> = element('Value', {\n  value: string(),\n  extra: string(),\n});\n\n/**\n * A struct for the {@link HeadingElement} type.\n */\nexport const HeadingStruct: Describe<HeadingElement> = element('Heading', {\n  children: StringElementStruct,\n});\n\n/**\n * A struct for the {@link ImageElement} type.\n */\nexport const ImageStruct: Describe<ImageElement> = element('Image', {\n  src: svg(),\n  alt: optional(string()),\n});\n\n/**\n * A struct for the {@link LinkElement} type.\n */\nexport const LinkStruct: Describe<LinkElement> = element('Link', {\n  href: string(),\n  children: children([FormattingStruct, string()]),\n});\n\n/**\n * A struct for the {@link TextElement} type.\n */\nexport const TextStruct: Describe<TextElement> = element('Text', {\n  children: children([string(), BoldStruct, ItalicStruct, LinkStruct]),\n  alignment: optional(\n    nullUnion([literal('start'), literal('center'), literal('end')]),\n  ),\n});\n\n/**\n * A subset of JSX elements that are allowed as children of the Tooltip component.\n * This set should include all text components and the Image.\n */\nexport const TooltipChildStruct = nullUnion([\n  TextStruct,\n  BoldStruct,\n  ItalicStruct,\n  LinkStruct,\n  ImageStruct,\n  boolean(),\n]);\n\n/**\n * A subset of JSX elements that are allowed as content of the Tooltip component.\n * This set should include all text components.\n */\nexport const TooltipContentStruct = nullUnion([\n  TextStruct,\n  BoldStruct,\n  ItalicStruct,\n  LinkStruct,\n  string(),\n]);\n\n/**\n * A struct for the {@link TooltipElement} type.\n */\nexport const TooltipStruct: Describe<TooltipElement> = element('Tooltip', {\n  children: nullable(TooltipChildStruct),\n  content: TooltipContentStruct,\n});\n\n/**\n * A struct for the {@link RowElement} type.\n */\nexport const RowStruct: Describe<RowElement> = element('Row', {\n  label: string(),\n  children: nullUnion([AddressStruct, ImageStruct, TextStruct, ValueStruct]),\n  variant: optional(\n    nullUnion([literal('default'), literal('warning'), literal('critical')]),\n  ),\n  tooltip: optional(string()),\n});\n\n/**\n * A struct for the {@link SpinnerElement} type.\n */\nexport const SpinnerStruct: Describe<SpinnerElement> = element('Spinner');\n\n/**\n * A subset of JSX elements that are allowed as children of the Box component.\n * This set includes all components, except components that need to be nested in\n * another component (e.g., Field must be contained in a Form).\n */\nexport const BoxChildStruct = nullUnion([\n  AddressStruct,\n  BoldStruct,\n  BoxStruct,\n  ButtonStruct,\n  CopyableStruct,\n  DividerStruct,\n  DropdownStruct,\n  FileInputStruct,\n  FormStruct,\n  HeadingStruct,\n  InputStruct,\n  ImageStruct,\n  ItalicStruct,\n  LinkStruct,\n  RowStruct,\n  SpinnerStruct,\n  TextStruct,\n  TooltipStruct,\n  CheckboxStruct,\n]);\n\n/**\n * For now, the allowed JSX elements at the root are the same as the allowed\n * children of the Box component.\n */\nexport const RootJSXElementStruct = BoxChildStruct;\n\n/**\n * A struct for the {@link JSXElement} type.\n */\nexport const JSXElementStruct: Describe<JSXElement> = nullUnion([\n  ButtonStruct,\n  InputStruct,\n  FileInputStruct,\n  FieldStruct,\n  FormStruct,\n  BoldStruct,\n  ItalicStruct,\n  AddressStruct,\n  BoxStruct,\n  CopyableStruct,\n  DividerStruct,\n  HeadingStruct,\n  ImageStruct,\n  LinkStruct,\n  RowStruct,\n  SpinnerStruct,\n  TextStruct,\n  DropdownStruct,\n  OptionStruct,\n  ValueStruct,\n  TooltipStruct,\n  CheckboxStruct,\n]);\n\n/**\n * Check if a value is a JSX element.\n *\n * @param value - The value to check.\n * @returns True if the value is a JSX element, false otherwise.\n */\nexport function isJSXElement(value: unknown): value is JSXElement {\n  return is(value, JSXElementStruct);\n}\n\n/**\n * Check if a value is a JSX element, without validating all of its contents.\n * This is useful when you want to validate the structure of a value, but not\n * all the children.\n *\n * This should only be used when you are sure that the value is safe to use,\n * i.e., after using {@link isJSXElement}.\n *\n * @param value - The value to check.\n * @returns True if the value is a JSX element, false otherwise.\n */\nexport function isJSXElementUnsafe(value: unknown): value is JSXElement {\n  return (\n    isPlainObject(value) &&\n    hasProperty(value, 'type') &&\n    hasProperty(value, 'props') &&\n    hasProperty(value, 'key')\n  );\n}\n\n/**\n * Assert that a value is a JSX element.\n *\n * @param value - The value to check.\n * @throws If the value is not a JSX element.\n */\nexport function assertJSXElement(value: unknown): asserts value is JSXElement {\n  // TODO: We should use the error parsing utils from `snaps-utils` to improve\n  // the error messages. It currently includes colours and potentially other\n  // formatting that we might not want to include in the SDK.\n  if (!isJSXElement(value)) {\n    throw new Error(\n      `Expected a JSX element, but received ${JSON.stringify(\n        value,\n      )}. Please refer to the documentation for the supported JSX elements and their props.`,\n    );\n  }\n}\n",
+        "import type { Infer } from '@metamask/superstruct';\nimport {\n  Struct,\n  define,\n  literal as superstructLiteral,\n  union as superstructUnion,\n} from '@metamask/superstruct';\nimport type { AnyStruct, InferStructTuple } from '@metamask/superstruct';\n\nimport type { EnumToUnion } from './helpers';\n\n/**\n * A wrapper of `superstruct`'s `literal` struct that also defines the name of\n * the struct as the literal value.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n * For example, instead of returning an error like:\n *\n * ```\n * Expected the value to satisfy a union of `literal | literal`, but received: \\\"baz\\\"\n * ```\n *\n * This struct will return an error like:\n *\n * ```\n * Expected the value to satisfy a union of `\"foo\" | \"bar\"`, but received: \\\"baz\\\"\n * ```\n *\n * @param value - The literal value.\n * @returns The `superstruct` struct, which validates that the value is equal\n * to the literal value.\n */\nexport function literal<Type extends string | number | boolean>(value: Type) {\n  return define<Type>(\n    JSON.stringify(value),\n    superstructLiteral(value).validator,\n  );\n}\n\n/**\n * A wrapper of `superstruct`'s `union` struct that also defines the schema as\n * the union of the schemas of the structs.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n *\n * @param structs - The structs to union.\n * @param structs.\"0\" - The first struct.\n * @param structs.\"1\" - The remaining structs.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function union<Head extends AnyStruct, Tail extends AnyStruct[]>([\n  head,\n  ...tail\n]: [head: Head, ...tail: Tail]): Struct<\n  Infer<Head> | InferStructTuple<Tail>[number],\n  [head: Head, ...tail: Tail]\n> {\n  const struct = superstructUnion([head, ...tail]);\n\n  return new Struct({\n    ...struct,\n    schema: [head, ...tail],\n  });\n}\n\n/**\n * Superstruct struct for validating an enum value. This allows using both the\n * enum string values and the enum itself as values.\n *\n * @param constant - The enum to validate against.\n * @returns The superstruct struct.\n */\nexport function enumValue<Type extends string>(\n  constant: Type,\n): Struct<EnumToUnion<Type>, null> {\n  return literal(constant as EnumToUnion<Type>);\n}\n",
+        "import type { Infer, Struct } from '@metamask/superstruct';\nimport type {\n  AnyStruct,\n  EnumSchema,\n  InferStructTuple,\n  IsExactMatch,\n  IsMatch,\n  IsRecord,\n  IsTuple,\n  UnionToIntersection,\n} from '@metamask/superstruct';\n\nimport type { EmptyObject } from '../types';\nimport { union } from './structs';\n\n/**\n * Check if a type is a union. Infers `true` if it is a union, otherwise\n * `false`.\n */\ntype IsUnion<Type> = [Type] extends [UnionToIntersection<Type>] ? false : true;\n\n/**\n * Get a struct schema for a type.\n *\n * This is copied from `superstruct` but fixes some issues with the original\n * implementation.\n */\ntype StructSchema<Type> = IsUnion<Type> extends true\n  ? null\n  : [Type] extends [EmptyObject]\n  ? EmptyObject\n  : [Type] extends [string | undefined | null]\n  ? [Type] extends [`0x${string}`]\n    ? null\n    : [Type] extends [IsMatch<Type, string | undefined | null>]\n    ? null\n    : [Type] extends [IsUnion<Type>]\n    ? EnumSchema<Type>\n    : Type\n  : [Type] extends [number | undefined | null]\n  ? [Type] extends [IsMatch<Type, number | undefined | null>]\n    ? null\n    : [Type] extends [IsUnion<Type>]\n    ? EnumSchema<Type>\n    : Type\n  : [Type] extends [boolean]\n  ? [Type] extends [IsExactMatch<Type, boolean>]\n    ? null\n    : Type\n  : Type extends\n      | bigint\n      | symbol\n      | undefined\n      | null\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      | Function\n      | Date\n      | Error\n      | RegExp\n      | Map<any, any>\n      | WeakMap<any, any>\n      | Set<any>\n      | WeakSet<any>\n      | Promise<any>\n  ? null\n  : Type extends (infer E)[]\n  ? Type extends IsTuple<Type>\n    ? null\n    : Struct<E>\n  : Type extends object\n  ? Type extends IsRecord<Type>\n    ? null\n    : {\n        [InnerKey in keyof Type]: Describe<Type[InnerKey]>;\n      }\n  : null;\n\n/**\n * Describe a struct type.\n */\nexport type Describe<Type> = Struct<Type, StructSchema<Type>>;\n\n/**\n * Create a union struct that uses `null` for the schema type, for better\n * compatibility with `Describe`.\n *\n * @param structs - The structs to union.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function nullUnion<Head extends AnyStruct, Tail extends AnyStruct[]>(\n  structs: [head: Head, ...tail: Tail],\n): Struct<Infer<Head> | InferStructTuple<Tail>[number], null> {\n  return union(structs) as unknown as Struct<\n    Infer<Head> | InferStructTuple<Tail>[number],\n    null\n  >;\n}\n",
+        "import { refine, string } from '@metamask/superstruct';\n\n/**\n * Get a Struct that validates a string as a valid SVG.\n *\n * @returns A Struct that validates a string as a valid SVG.\n * @internal\n */\nexport function svg() {\n  return refine(string(), 'SVG', (value) => {\n    // This validation is intentionally very basic, we don't need to be that strict\n    // and merely have this extra validation as a helpful error if devs aren't\n    // passing in SVGs.\n    if (!value.includes('<svg')) {\n      return 'Value is not a valid SVG.';\n    }\n\n    return true;\n  });\n}\n"
+    ],
+    "mappings": "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",
+    "names": [
+        "import_superstruct",
+        "superstructLiteral",
+        "superstructUnion",
+        "import_superstruct",
+        "element"
+    ]
+}
\ No newline at end of file
diff --git a/dist/jsx/jsx-dev-runtime.mjs.map b/dist/jsx/jsx-dev-runtime.mjs.map
index d0ec2c98101c8627e826bb23ce02989c11486cf7..e47ffcf2fe1fb2ac2d13651ee6e6b337d89495ab 100644
--- a/dist/jsx/jsx-dev-runtime.mjs.map
+++ b/dist/jsx/jsx-dev-runtime.mjs.map
@@ -1 +1 @@
-{"version":3,"sources":["../../src/jsx/jsx-runtime.ts","../../src/jsx/validation.ts","../../src/internals/structs.ts","../../src/internals/jsx.ts","../../src/internals/svg.ts","../../src/jsx/jsx-dev-runtime.ts"],"sourcesContent":["import type { JsonObject, Key, SnapComponent } from './component';\n\n/**\n * The JSX runtime for Snaps SDK components. This function is used to render\n * Snap components into a format that can be used by the Snaps.\n *\n * This is the \"production\" version of the runtime, which does not include\n * additional validation, as it is handled by MetaMask. To use this runtime,\n * specify `@metamask/snaps-sdk` as import source for JSX, and use `react-jsx`\n * as the pragma.\n *\n * @param component - The component to render.\n * @param props - The props to pass to the component.\n * @param key - The key of the component.\n * @returns The rendered component.\n * @see https://www.typescriptlang.org/tsconfig/#jsx\n */\nexport function jsx<Props extends JsonObject>(\n  component: SnapComponent<Props>,\n  props: Props,\n  key: Key | null,\n): unknown | null {\n  if (typeof component === 'string') {\n    // If component is a string, it is a built-in HTML element. This is not\n    // supported in Snaps, so we throw an error.\n    throw new Error(\n      `An HTML element (\"${String(\n        component,\n      )}\") was used in a Snap component, which is not supported by Snaps UI. Please use one of the supported Snap components.`,\n    );\n  }\n\n  if (!component) {\n    // If component is undefined, a JSX fragment `<>...</>` was used, which is\n    // not supported in Snaps.\n    throw new Error(\n      'A JSX fragment was used in a Snap component, which is not supported by Snaps UI. Please use one of the supported Snap components.',\n    );\n  }\n\n  return component({ ...props, key });\n}\n\n/**\n * The JSX runtime for Snaps SDK components. This function is used to render\n * Snap components into a format that can be used by the Snaps.\n *\n * The `jsxs` function is used for rendering nested components.\n *\n * This is the \"production\" version of the runtime, which does not include\n * additional validation, as it is handled by MetaMask. To use this runtime,\n * specify `@metamask/snaps-sdk` as import source for JSX, and use `react-jsx`\n * as the pragma.\n *\n * @param component - The component to render.\n * @param props - The props to pass to the component.\n * @param key - The key of the component.\n * @returns The rendered component.\n * @see https://www.typescriptlang.org/tsconfig/#jsx\n */\nexport function jsxs<Props extends JsonObject>(\n  component: SnapComponent<Props>,\n  props: Props,\n  key: Key | null,\n): unknown | null {\n  return jsx(component, props, key);\n}\n","import {\n  hasProperty,\n  HexChecksumAddressStruct,\n  isPlainObject,\n  JsonStruct,\n} from '@metamask/utils';\nimport type { Infer, Struct } from 'superstruct';\nimport {\n  is,\n  boolean,\n  optional,\n  array,\n  lazy,\n  nullable,\n  number,\n  object,\n  record,\n  string,\n  tuple,\n} from 'superstruct';\nimport type {\n  AnyStruct,\n  InferStructTuple,\n  ObjectSchema,\n} from 'superstruct/dist/utils';\n\nimport type { Describe } from '../internals';\nimport { literal, nullUnion, svg } from '../internals';\nimport type { EmptyObject } from '../types';\nimport type {\n  GenericSnapElement,\n  JsonObject,\n  Key,\n  Nestable,\n  SnapElement,\n  SnapsChildren,\n  StringElement,\n} from './component';\nimport type {\n  AddressElement,\n  BoldElement,\n  BoxElement,\n  ButtonElement,\n  CheckboxElement,\n  CopyableElement,\n  DividerElement,\n  DropdownElement,\n  OptionElement,\n  FieldElement,\n  FormElement,\n  HeadingElement,\n  ImageElement,\n  InputElement,\n  ItalicElement,\n  JSXElement,\n  LinkElement,\n  RowElement,\n  SpinnerElement,\n  StandardFormattingElement,\n  TextElement,\n  TooltipElement,\n  ValueElement,\n  FileInputElement,\n} from './components';\n\n/**\n * A struct for the {@link Key} type.\n */\nexport const KeyStruct: Describe<Key> = nullUnion([string(), number()]);\n\n/**\n * A struct for the {@link StringElement} type.\n */\nexport const StringElementStruct: Describe<StringElement> = children([\n  string(),\n]);\n\n/**\n * A struct for the {@link GenericSnapElement} type.\n */\nexport const ElementStruct: Describe<GenericSnapElement> = object({\n  type: string(),\n  props: record(string(), JsonStruct),\n  key: nullable(KeyStruct),\n});\n\n/**\n * A helper function for creating a struct for a {@link Nestable} type.\n *\n * @param struct - The struct for the type to test.\n * @returns The struct for the nestable type.\n */\nfunction nestable<Type, Schema>(\n  struct: Struct<Type, Schema>,\n): Struct<Nestable<Type>, any> {\n  const nestableStruct: Struct<Nestable<Type>> = nullUnion([\n    struct,\n    array(lazy(() => nestableStruct)),\n  ]);\n\n  return nestableStruct;\n}\n\n/**\n * A helper function for creating a struct which allows children of a specific\n * type, as well as `null` and `boolean`.\n *\n * @param structs - The structs to allow as children.\n * @returns The struct for the children.\n */\nfunction children<Head extends AnyStruct, Tail extends AnyStruct[]>(\n  structs: [head: Head, ...tail: Tail],\n): Struct<\n  Nestable<Infer<Head> | InferStructTuple<Tail>[number] | boolean | null>,\n  null\n> {\n  return nestable(nullable(nullUnion([...structs, boolean()])));\n}\n\n/**\n * A helper function for creating a struct for a JSX element.\n *\n * @param name - The name of the element.\n * @param props - The props of the element.\n * @returns The struct for the element.\n */\nfunction element<Name extends string, Props extends ObjectSchema = EmptyObject>(\n  name: Name,\n  props: Props = {} as Props,\n) {\n  return object({\n    type: literal(name) as unknown as Struct<Name, Name>,\n    props: object(props),\n    key: nullable(KeyStruct),\n  });\n}\n\n/**\n * A struct for the {@link ButtonElement} type.\n */\nexport const ButtonStruct: Describe<ButtonElement> = element('Button', {\n  children: StringElementStruct,\n  name: optional(string()),\n  type: optional(nullUnion([literal('button'), literal('submit')])),\n  variant: optional(nullUnion([literal('primary'), literal('destructive')])),\n  disabled: optional(boolean()),\n});\n\n/**\n * A struct for the {@link CheckboxElement} type.\n */\nexport const CheckboxStruct: Describe<CheckboxElement> = element('Checkbox', {\n  name: string(),\n  checked: optional(boolean()),\n  label: optional(string()),\n  variant: optional(nullUnion([literal('default'), literal('toggle')])),\n});\n\n/**\n * A struct for the {@link InputElement} type.\n */\nexport const InputStruct: Describe<InputElement> = element('Input', {\n  name: string(),\n  type: optional(\n    nullUnion([literal('text'), literal('password'), literal('number')]),\n  ),\n  value: optional(string()),\n  placeholder: optional(string()),\n});\n\n/**\n * A struct for the {@link OptionElement} type.\n */\nexport const OptionStruct: Describe<OptionElement> = element('Option', {\n  value: string(),\n  children: string(),\n});\n\n/**\n * A struct for the {@link DropdownElement} type.\n */\nexport const DropdownStruct: Describe<DropdownElement> = element('Dropdown', {\n  name: string(),\n  value: optional(string()),\n  children: children([OptionStruct]),\n});\n\n/**\n * A struct for the {@link FileInputElement} type.\n */\nexport const FileInputStruct: Describe<FileInputElement> = element(\n  'FileInput',\n  {\n    name: string(),\n    accept: nullUnion([optional(array(string()))]),\n    compact: optional(boolean()),\n  },\n);\n\n/**\n * A struct for the {@link FieldElement} type.\n */\nexport const FieldStruct: Describe<FieldElement> = element('Field', {\n  label: optional(string()),\n  error: optional(string()),\n  children: nullUnion([\n    tuple([InputStruct, ButtonStruct]),\n    DropdownStruct,\n    FileInputStruct,\n    InputStruct,\n    CheckboxStruct,\n  ]),\n});\n\n/**\n * A struct for the {@link FormElement} type.\n */\nexport const FormStruct: Describe<FormElement> = element('Form', {\n  children: children(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    [FieldStruct, lazy(() => BoxChildStruct)],\n  ) as unknown as Struct<SnapsChildren<GenericSnapElement>, null>,\n  name: string(),\n});\n\n/**\n * A struct for the {@link BoldElement} type.\n */\nexport const BoldStruct: Describe<BoldElement> = element('Bold', {\n  children: children([\n    string(),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    lazy(() => ItalicStruct) as unknown as Struct<\n      SnapElement<JsonObject, 'Italic'>\n    >,\n  ]),\n});\n\n/**\n * A struct for the {@link ItalicElement} type.\n */\nexport const ItalicStruct: Describe<ItalicElement> = element('Italic', {\n  children: children([\n    string(),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    lazy(() => BoldStruct) as unknown as Struct<\n      SnapElement<JsonObject, 'Bold'>\n    >,\n  ]),\n});\n\nexport const FormattingStruct: Describe<StandardFormattingElement> = nullUnion([\n  BoldStruct,\n  ItalicStruct,\n]);\n\n/**\n * A struct for the {@link AddressElement} type.\n */\nexport const AddressStruct: Describe<AddressElement> = element('Address', {\n  address: HexChecksumAddressStruct,\n});\n\n/**\n * A struct for the {@link BoxElement} type.\n */\nexport const BoxStruct: Describe<BoxElement> = element('Box', {\n  children: children(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    [lazy(() => BoxChildStruct)],\n  ) as unknown as Struct<SnapsChildren<GenericSnapElement>, null>,\n  direction: optional(nullUnion([literal('horizontal'), literal('vertical')])),\n  alignment: optional(\n    nullUnion([\n      literal('start'),\n      literal('center'),\n      literal('end'),\n      literal('space-between'),\n      literal('space-around'),\n    ]),\n  ),\n});\n\n/**\n * A struct for the {@link CopyableElement} type.\n */\nexport const CopyableStruct: Describe<CopyableElement> = element('Copyable', {\n  value: string(),\n  sensitive: optional(boolean()),\n});\n\n/**\n * A struct for the {@link DividerElement} type.\n */\nexport const DividerStruct: Describe<DividerElement> = element('Divider');\n\n/**\n * A struct for the {@link ValueElement} type.\n */\nexport const ValueStruct: Describe<ValueElement> = element('Value', {\n  value: string(),\n  extra: string(),\n});\n\n/**\n * A struct for the {@link HeadingElement} type.\n */\nexport const HeadingStruct: Describe<HeadingElement> = element('Heading', {\n  children: StringElementStruct,\n});\n\n/**\n * A struct for the {@link ImageElement} type.\n */\nexport const ImageStruct: Describe<ImageElement> = element('Image', {\n  src: svg(),\n  alt: optional(string()),\n});\n\n/**\n * A struct for the {@link LinkElement} type.\n */\nexport const LinkStruct: Describe<LinkElement> = element('Link', {\n  href: string(),\n  children: children([FormattingStruct, string()]),\n});\n\n/**\n * A struct for the {@link TextElement} type.\n */\nexport const TextStruct: Describe<TextElement> = element('Text', {\n  children: children([string(), BoldStruct, ItalicStruct, LinkStruct]),\n  alignment: optional(\n    nullUnion([literal('start'), literal('center'), literal('end')]),\n  ),\n});\n\n/**\n * A subset of JSX elements that are allowed as children of the Tooltip component.\n * This set should include all text components and the Image.\n */\nexport const TooltipChildStruct = nullUnion([\n  TextStruct,\n  BoldStruct,\n  ItalicStruct,\n  LinkStruct,\n  ImageStruct,\n  boolean(),\n]);\n\n/**\n * A subset of JSX elements that are allowed as content of the Tooltip component.\n * This set should include all text components.\n */\nexport const TooltipContentStruct = nullUnion([\n  TextStruct,\n  BoldStruct,\n  ItalicStruct,\n  LinkStruct,\n  string(),\n]);\n\n/**\n * A struct for the {@link TooltipElement} type.\n */\nexport const TooltipStruct: Describe<TooltipElement> = element('Tooltip', {\n  children: nullable(TooltipChildStruct),\n  content: TooltipContentStruct,\n});\n\n/**\n * A struct for the {@link RowElement} type.\n */\nexport const RowStruct: Describe<RowElement> = element('Row', {\n  label: string(),\n  children: nullUnion([AddressStruct, ImageStruct, TextStruct, ValueStruct]),\n  variant: optional(\n    nullUnion([literal('default'), literal('warning'), literal('critical')]),\n  ),\n  tooltip: optional(string()),\n});\n\n/**\n * A struct for the {@link SpinnerElement} type.\n */\nexport const SpinnerStruct: Describe<SpinnerElement> = element('Spinner');\n\n/**\n * A subset of JSX elements that are allowed as children of the Box component.\n * This set includes all components, except components that need to be nested in\n * another component (e.g., Field must be contained in a Form).\n */\nexport const BoxChildStruct = nullUnion([\n  AddressStruct,\n  BoldStruct,\n  BoxStruct,\n  ButtonStruct,\n  CopyableStruct,\n  DividerStruct,\n  DropdownStruct,\n  FileInputStruct,\n  FormStruct,\n  HeadingStruct,\n  InputStruct,\n  ImageStruct,\n  ItalicStruct,\n  LinkStruct,\n  RowStruct,\n  SpinnerStruct,\n  TextStruct,\n  TooltipStruct,\n  CheckboxStruct,\n]);\n\n/**\n * For now, the allowed JSX elements at the root are the same as the allowed\n * children of the Box component.\n */\nexport const RootJSXElementStruct = BoxChildStruct;\n\n/**\n * A struct for the {@link JSXElement} type.\n */\nexport const JSXElementStruct: Describe<JSXElement> = nullUnion([\n  ButtonStruct,\n  InputStruct,\n  FileInputStruct,\n  FieldStruct,\n  FormStruct,\n  BoldStruct,\n  ItalicStruct,\n  AddressStruct,\n  BoxStruct,\n  CopyableStruct,\n  DividerStruct,\n  HeadingStruct,\n  ImageStruct,\n  LinkStruct,\n  RowStruct,\n  SpinnerStruct,\n  TextStruct,\n  DropdownStruct,\n  OptionStruct,\n  ValueStruct,\n  TooltipStruct,\n  CheckboxStruct,\n]);\n\n/**\n * Check if a value is a JSX element.\n *\n * @param value - The value to check.\n * @returns True if the value is a JSX element, false otherwise.\n */\nexport function isJSXElement(value: unknown): value is JSXElement {\n  return is(value, JSXElementStruct);\n}\n\n/**\n * Check if a value is a JSX element, without validating all of its contents.\n * This is useful when you want to validate the structure of a value, but not\n * all the children.\n *\n * This should only be used when you are sure that the value is safe to use,\n * i.e., after using {@link isJSXElement}.\n *\n * @param value - The value to check.\n * @returns True if the value is a JSX element, false otherwise.\n */\nexport function isJSXElementUnsafe(value: unknown): value is JSXElement {\n  return (\n    isPlainObject(value) &&\n    hasProperty(value, 'type') &&\n    hasProperty(value, 'props') &&\n    hasProperty(value, 'key')\n  );\n}\n\n/**\n * Assert that a value is a JSX element.\n *\n * @param value - The value to check.\n * @throws If the value is not a JSX element.\n */\nexport function assertJSXElement(value: unknown): asserts value is JSXElement {\n  // TODO: We should use the error parsing utils from `snaps-utils` to improve\n  // the error messages. It currently includes colours and potentially other\n  // formatting that we might not want to include in the SDK.\n  if (!isJSXElement(value)) {\n    throw new Error(\n      `Expected a JSX element, but received ${JSON.stringify(\n        value,\n      )}. Please refer to the documentation for the supported JSX elements and their props.`,\n    );\n  }\n}\n","import type { Infer } from 'superstruct';\nimport {\n  Struct,\n  define,\n  literal as superstructLiteral,\n  union as superstructUnion,\n} from 'superstruct';\nimport type { AnyStruct, InferStructTuple } from 'superstruct/dist/utils';\n\nimport type { EnumToUnion } from './helpers';\n\n/**\n * A wrapper of `superstruct`'s `literal` struct that also defines the name of\n * the struct as the literal value.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n * For example, instead of returning an error like:\n *\n * ```\n * Expected the value to satisfy a union of `literal | literal`, but received: \\\"baz\\\"\n * ```\n *\n * This struct will return an error like:\n *\n * ```\n * Expected the value to satisfy a union of `\"foo\" | \"bar\"`, but received: \\\"baz\\\"\n * ```\n *\n * @param value - The literal value.\n * @returns The `superstruct` struct, which validates that the value is equal\n * to the literal value.\n */\nexport function literal<Type extends string | number | boolean>(value: Type) {\n  return define<Type>(\n    JSON.stringify(value),\n    superstructLiteral(value).validator,\n  );\n}\n\n/**\n * A wrapper of `superstruct`'s `union` struct that also defines the schema as\n * the union of the schemas of the structs.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n *\n * @param structs - The structs to union.\n * @param structs.\"0\" - The first struct.\n * @param structs.\"1\" - The remaining structs.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function union<Head extends AnyStruct, Tail extends AnyStruct[]>([\n  head,\n  ...tail\n]: [head: Head, ...tail: Tail]): Struct<\n  Infer<Head> | InferStructTuple<Tail>[number],\n  [head: Head, ...tail: Tail]\n> {\n  const struct = superstructUnion([head, ...tail]);\n\n  return new Struct({\n    ...struct,\n    schema: [head, ...tail],\n  });\n}\n\n/**\n * Superstruct struct for validating an enum value. This allows using both the\n * enum string values and the enum itself as values.\n *\n * @param constant - The enum to validate against.\n * @returns The superstruct struct.\n */\nexport function enumValue<Type extends string>(\n  constant: Type,\n): Struct<EnumToUnion<Type>, null> {\n  return literal(constant as EnumToUnion<Type>);\n}\n","import type { Infer, Struct } from 'superstruct';\nimport type {\n  AnyStruct,\n  EnumSchema,\n  InferStructTuple,\n  IsExactMatch,\n  IsMatch,\n  IsRecord,\n  IsTuple,\n  UnionToIntersection,\n} from 'superstruct/dist/utils';\n\nimport type { EmptyObject } from '../types';\nimport { union } from './structs';\n\n/**\n * Check if a type is a union. Infers `true` if it is a union, otherwise\n * `false`.\n */\ntype IsUnion<Type> = [Type] extends [UnionToIntersection<Type>] ? false : true;\n\n/**\n * Get a struct schema for a type.\n *\n * This is copied from `superstruct` but fixes some issues with the original\n * implementation.\n */\ntype StructSchema<Type> = IsUnion<Type> extends true\n  ? null\n  : [Type] extends [EmptyObject]\n  ? EmptyObject\n  : [Type] extends [string | undefined | null]\n  ? [Type] extends [`0x${string}`]\n    ? null\n    : [Type] extends [IsMatch<Type, string | undefined | null>]\n    ? null\n    : [Type] extends [IsUnion<Type>]\n    ? EnumSchema<Type>\n    : Type\n  : [Type] extends [number | undefined | null]\n  ? [Type] extends [IsMatch<Type, number | undefined | null>]\n    ? null\n    : [Type] extends [IsUnion<Type>]\n    ? EnumSchema<Type>\n    : Type\n  : [Type] extends [boolean]\n  ? [Type] extends [IsExactMatch<Type, boolean>]\n    ? null\n    : Type\n  : Type extends\n      | bigint\n      | symbol\n      | undefined\n      | null\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      | Function\n      | Date\n      | Error\n      | RegExp\n      | Map<any, any>\n      | WeakMap<any, any>\n      | Set<any>\n      | WeakSet<any>\n      | Promise<any>\n  ? null\n  : Type extends (infer E)[]\n  ? Type extends IsTuple<Type>\n    ? null\n    : Struct<E>\n  : Type extends object\n  ? Type extends IsRecord<Type>\n    ? null\n    : {\n        [InnerKey in keyof Type]: Describe<Type[InnerKey]>;\n      }\n  : null;\n\n/**\n * Describe a struct type.\n */\nexport type Describe<Type> = Struct<Type, StructSchema<Type>>;\n\n/**\n * Create a union struct that uses `null` for the schema type, for better\n * compatibility with `Describe`.\n *\n * @param structs - The structs to union.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function nullUnion<Head extends AnyStruct, Tail extends AnyStruct[]>(\n  structs: [head: Head, ...tail: Tail],\n): Struct<Infer<Head> | InferStructTuple<Tail>[number], null> {\n  return union(structs) as unknown as Struct<\n    Infer<Head> | InferStructTuple<Tail>[number],\n    null\n  >;\n}\n","import { refine, string } from 'superstruct';\n\n/**\n * Get a Struct that validates a string as a valid SVG.\n *\n * @returns A Struct that validates a string as a valid SVG.\n * @internal\n */\nexport function svg() {\n  return refine(string(), 'SVG', (value) => {\n    // This validation is intentionally very basic, we don't need to be that strict\n    // and merely have this extra validation as a helpful error if devs aren't\n    // passing in SVGs.\n    if (!value.includes('<svg')) {\n      return 'Value is not a valid SVG.';\n    }\n\n    return true;\n  });\n}\n","import type { JsonObject, Key, SnapComponent } from './component';\nimport { jsx } from './jsx-runtime';\nimport { assertJSXElement } from './validation';\n\n/**\n * The JSX runtime for Snaps SDK components. This function is used to render\n * Snap components into a format that can be used by the Snaps.\n *\n * This is the \"development\" version of the runtime, which includes additional\n * validation, which is otherwise handled by MetaMask. To use this runtime,\n * specify `@metamask/snaps-sdk` as import source for JSX, and use\n * `react-jsxdev` as the pragma.\n *\n * @param component - The component to render.\n * @param props - The props to pass to the component.\n * @param key - The key of the component.\n * @returns The rendered component.\n * @see https://www.typescriptlang.org/tsconfig/#jsx\n */\nexport function jsxDEV<Props extends JsonObject>(\n  component: SnapComponent<Props>,\n  props: Props,\n  key: Key | null,\n): unknown | null {\n  const element = jsx(component, props, key);\n  assertJSXElement(element);\n\n  return element;\n}\n"],"mappings":"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","names":["string","string","element"]}
\ No newline at end of file
+{"version":3,"sources":["../../src/jsx/jsx-runtime.ts","../../src/jsx/validation.ts","../../src/internals/structs.ts","../../src/internals/jsx.ts","../../src/internals/svg.ts","../../src/jsx/jsx-dev-runtime.ts"],"sourcesContent":["import type { JsonObject, Key, SnapComponent } from './component';\n\n/**\n * The JSX runtime for Snaps SDK components. This function is used to render\n * Snap components into a format that can be used by the Snaps.\n *\n * This is the \"production\" version of the runtime, which does not include\n * additional validation, as it is handled by MetaMask. To use this runtime,\n * specify `@metamask/snaps-sdk` as import source for JSX, and use `react-jsx`\n * as the pragma.\n *\n * @param component - The component to render.\n * @param props - The props to pass to the component.\n * @param key - The key of the component.\n * @returns The rendered component.\n * @see https://www.typescriptlang.org/tsconfig/#jsx\n */\nexport function jsx<Props extends JsonObject>(\n  component: SnapComponent<Props>,\n  props: Props,\n  key: Key | null,\n): unknown | null {\n  if (typeof component === 'string') {\n    // If component is a string, it is a built-in HTML element. This is not\n    // supported in Snaps, so we throw an error.\n    throw new Error(\n      `An HTML element (\"${String(\n        component,\n      )}\") was used in a Snap component, which is not supported by Snaps UI. Please use one of the supported Snap components.`,\n    );\n  }\n\n  if (!component) {\n    // If component is undefined, a JSX fragment `<>...</>` was used, which is\n    // not supported in Snaps.\n    throw new Error(\n      'A JSX fragment was used in a Snap component, which is not supported by Snaps UI. Please use one of the supported Snap components.',\n    );\n  }\n\n  return component({ ...props, key });\n}\n\n/**\n * The JSX runtime for Snaps SDK components. This function is used to render\n * Snap components into a format that can be used by the Snaps.\n *\n * The `jsxs` function is used for rendering nested components.\n *\n * This is the \"production\" version of the runtime, which does not include\n * additional validation, as it is handled by MetaMask. To use this runtime,\n * specify `@metamask/snaps-sdk` as import source for JSX, and use `react-jsx`\n * as the pragma.\n *\n * @param component - The component to render.\n * @param props - The props to pass to the component.\n * @param key - The key of the component.\n * @returns The rendered component.\n * @see https://www.typescriptlang.org/tsconfig/#jsx\n */\nexport function jsxs<Props extends JsonObject>(\n  component: SnapComponent<Props>,\n  props: Props,\n  key: Key | null,\n): unknown | null {\n  return jsx(component, props, key);\n}\n","import {\n  hasProperty,\n  HexChecksumAddressStruct,\n  isPlainObject,\n  JsonStruct,\n} from '@metamask/utils';\nimport type { Infer, Struct } from '@metamask/superstruct';\nimport {\n  is,\n  boolean,\n  optional,\n  array,\n  lazy,\n  nullable,\n  number,\n  object,\n  record,\n  string,\n  tuple,\n} from '@metamask/superstruct';\nimport type {\n  AnyStruct,\n  InferStructTuple,\n  ObjectSchema,\n} from '@metamask/superstruct';\n\nimport type { Describe } from '../internals';\nimport { literal, nullUnion, svg } from '../internals';\nimport type { EmptyObject } from '../types';\nimport type {\n  GenericSnapElement,\n  JsonObject,\n  Key,\n  Nestable,\n  SnapElement,\n  SnapsChildren,\n  StringElement,\n} from './component';\nimport type {\n  AddressElement,\n  BoldElement,\n  BoxElement,\n  ButtonElement,\n  CheckboxElement,\n  CopyableElement,\n  DividerElement,\n  DropdownElement,\n  OptionElement,\n  FieldElement,\n  FormElement,\n  HeadingElement,\n  ImageElement,\n  InputElement,\n  ItalicElement,\n  JSXElement,\n  LinkElement,\n  RowElement,\n  SpinnerElement,\n  StandardFormattingElement,\n  TextElement,\n  TooltipElement,\n  ValueElement,\n  FileInputElement,\n} from './components';\n\n/**\n * A struct for the {@link Key} type.\n */\nexport const KeyStruct: Describe<Key> = nullUnion([string(), number()]);\n\n/**\n * A struct for the {@link StringElement} type.\n */\nexport const StringElementStruct: Describe<StringElement> = children([\n  string(),\n]);\n\n/**\n * A struct for the {@link GenericSnapElement} type.\n */\nexport const ElementStruct: Describe<GenericSnapElement> = object({\n  type: string(),\n  props: record(string(), JsonStruct),\n  key: nullable(KeyStruct),\n});\n\n/**\n * A helper function for creating a struct for a {@link Nestable} type.\n *\n * @param struct - The struct for the type to test.\n * @returns The struct for the nestable type.\n */\nfunction nestable<Type, Schema>(\n  struct: Struct<Type, Schema>,\n): Struct<Nestable<Type>, any> {\n  const nestableStruct: Struct<Nestable<Type>> = nullUnion([\n    struct,\n    array(lazy(() => nestableStruct)),\n  ]);\n\n  return nestableStruct;\n}\n\n/**\n * A helper function for creating a struct which allows children of a specific\n * type, as well as `null` and `boolean`.\n *\n * @param structs - The structs to allow as children.\n * @returns The struct for the children.\n */\nfunction children<Head extends AnyStruct, Tail extends AnyStruct[]>(\n  structs: [head: Head, ...tail: Tail],\n): Struct<\n  Nestable<Infer<Head> | InferStructTuple<Tail>[number] | boolean | null>,\n  null\n> {\n  return nestable(nullable(nullUnion([...structs, boolean()])));\n}\n\n/**\n * A helper function for creating a struct for a JSX element.\n *\n * @param name - The name of the element.\n * @param props - The props of the element.\n * @returns The struct for the element.\n */\nfunction element<Name extends string, Props extends ObjectSchema = EmptyObject>(\n  name: Name,\n  props: Props = {} as Props,\n) {\n  return object({\n    type: literal(name) as unknown as Struct<Name, Name>,\n    props: object(props),\n    key: nullable(KeyStruct),\n  });\n}\n\n/**\n * A struct for the {@link ButtonElement} type.\n */\nexport const ButtonStruct: Describe<ButtonElement> = element('Button', {\n  children: StringElementStruct,\n  name: optional(string()),\n  type: optional(nullUnion([literal('button'), literal('submit')])),\n  variant: optional(nullUnion([literal('primary'), literal('destructive')])),\n  disabled: optional(boolean()),\n});\n\n/**\n * A struct for the {@link CheckboxElement} type.\n */\nexport const CheckboxStruct: Describe<CheckboxElement> = element('Checkbox', {\n  name: string(),\n  checked: optional(boolean()),\n  label: optional(string()),\n  variant: optional(nullUnion([literal('default'), literal('toggle')])),\n});\n\n/**\n * A struct for the {@link InputElement} type.\n */\nexport const InputStruct: Describe<InputElement> = element('Input', {\n  name: string(),\n  type: optional(\n    nullUnion([literal('text'), literal('password'), literal('number')]),\n  ),\n  value: optional(string()),\n  placeholder: optional(string()),\n});\n\n/**\n * A struct for the {@link OptionElement} type.\n */\nexport const OptionStruct: Describe<OptionElement> = element('Option', {\n  value: string(),\n  children: string(),\n});\n\n/**\n * A struct for the {@link DropdownElement} type.\n */\nexport const DropdownStruct: Describe<DropdownElement> = element('Dropdown', {\n  name: string(),\n  value: optional(string()),\n  children: children([OptionStruct]),\n});\n\n/**\n * A struct for the {@link FileInputElement} type.\n */\nexport const FileInputStruct: Describe<FileInputElement> = element(\n  'FileInput',\n  {\n    name: string(),\n    accept: nullUnion([optional(array(string()))]),\n    compact: optional(boolean()),\n  },\n);\n\n/**\n * A struct for the {@link FieldElement} type.\n */\nexport const FieldStruct: Describe<FieldElement> = element('Field', {\n  label: optional(string()),\n  error: optional(string()),\n  children: nullUnion([\n    tuple([InputStruct, ButtonStruct]),\n    DropdownStruct,\n    FileInputStruct,\n    InputStruct,\n    CheckboxStruct,\n  ]),\n});\n\n/**\n * A struct for the {@link FormElement} type.\n */\nexport const FormStruct: Describe<FormElement> = element('Form', {\n  children: children(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    [FieldStruct, lazy(() => BoxChildStruct)],\n  ) as unknown as Struct<SnapsChildren<GenericSnapElement>, null>,\n  name: string(),\n});\n\n/**\n * A struct for the {@link BoldElement} type.\n */\nexport const BoldStruct: Describe<BoldElement> = element('Bold', {\n  children: children([\n    string(),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    lazy(() => ItalicStruct) as unknown as Struct<\n      SnapElement<JsonObject, 'Italic'>\n    >,\n  ]),\n});\n\n/**\n * A struct for the {@link ItalicElement} type.\n */\nexport const ItalicStruct: Describe<ItalicElement> = element('Italic', {\n  children: children([\n    string(),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    lazy(() => BoldStruct) as unknown as Struct<\n      SnapElement<JsonObject, 'Bold'>\n    >,\n  ]),\n});\n\nexport const FormattingStruct: Describe<StandardFormattingElement> = nullUnion([\n  BoldStruct,\n  ItalicStruct,\n]);\n\n/**\n * A struct for the {@link AddressElement} type.\n */\nexport const AddressStruct: Describe<AddressElement> = element('Address', {\n  address: HexChecksumAddressStruct,\n});\n\n/**\n * A struct for the {@link BoxElement} type.\n */\nexport const BoxStruct: Describe<BoxElement> = element('Box', {\n  children: children(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    [lazy(() => BoxChildStruct)],\n  ) as unknown as Struct<SnapsChildren<GenericSnapElement>, null>,\n  direction: optional(nullUnion([literal('horizontal'), literal('vertical')])),\n  alignment: optional(\n    nullUnion([\n      literal('start'),\n      literal('center'),\n      literal('end'),\n      literal('space-between'),\n      literal('space-around'),\n    ]),\n  ),\n});\n\n/**\n * A struct for the {@link CopyableElement} type.\n */\nexport const CopyableStruct: Describe<CopyableElement> = element('Copyable', {\n  value: string(),\n  sensitive: optional(boolean()),\n});\n\n/**\n * A struct for the {@link DividerElement} type.\n */\nexport const DividerStruct: Describe<DividerElement> = element('Divider');\n\n/**\n * A struct for the {@link ValueElement} type.\n */\nexport const ValueStruct: Describe<ValueElement> = element('Value', {\n  value: string(),\n  extra: string(),\n});\n\n/**\n * A struct for the {@link HeadingElement} type.\n */\nexport const HeadingStruct: Describe<HeadingElement> = element('Heading', {\n  children: StringElementStruct,\n});\n\n/**\n * A struct for the {@link ImageElement} type.\n */\nexport const ImageStruct: Describe<ImageElement> = element('Image', {\n  src: svg(),\n  alt: optional(string()),\n});\n\n/**\n * A struct for the {@link LinkElement} type.\n */\nexport const LinkStruct: Describe<LinkElement> = element('Link', {\n  href: string(),\n  children: children([FormattingStruct, string()]),\n});\n\n/**\n * A struct for the {@link TextElement} type.\n */\nexport const TextStruct: Describe<TextElement> = element('Text', {\n  children: children([string(), BoldStruct, ItalicStruct, LinkStruct]),\n  alignment: optional(\n    nullUnion([literal('start'), literal('center'), literal('end')]),\n  ),\n});\n\n/**\n * A subset of JSX elements that are allowed as children of the Tooltip component.\n * This set should include all text components and the Image.\n */\nexport const TooltipChildStruct = nullUnion([\n  TextStruct,\n  BoldStruct,\n  ItalicStruct,\n  LinkStruct,\n  ImageStruct,\n  boolean(),\n]);\n\n/**\n * A subset of JSX elements that are allowed as content of the Tooltip component.\n * This set should include all text components.\n */\nexport const TooltipContentStruct = nullUnion([\n  TextStruct,\n  BoldStruct,\n  ItalicStruct,\n  LinkStruct,\n  string(),\n]);\n\n/**\n * A struct for the {@link TooltipElement} type.\n */\nexport const TooltipStruct: Describe<TooltipElement> = element('Tooltip', {\n  children: nullable(TooltipChildStruct),\n  content: TooltipContentStruct,\n});\n\n/**\n * A struct for the {@link RowElement} type.\n */\nexport const RowStruct: Describe<RowElement> = element('Row', {\n  label: string(),\n  children: nullUnion([AddressStruct, ImageStruct, TextStruct, ValueStruct]),\n  variant: optional(\n    nullUnion([literal('default'), literal('warning'), literal('critical')]),\n  ),\n  tooltip: optional(string()),\n});\n\n/**\n * A struct for the {@link SpinnerElement} type.\n */\nexport const SpinnerStruct: Describe<SpinnerElement> = element('Spinner');\n\n/**\n * A subset of JSX elements that are allowed as children of the Box component.\n * This set includes all components, except components that need to be nested in\n * another component (e.g., Field must be contained in a Form).\n */\nexport const BoxChildStruct = nullUnion([\n  AddressStruct,\n  BoldStruct,\n  BoxStruct,\n  ButtonStruct,\n  CopyableStruct,\n  DividerStruct,\n  DropdownStruct,\n  FileInputStruct,\n  FormStruct,\n  HeadingStruct,\n  InputStruct,\n  ImageStruct,\n  ItalicStruct,\n  LinkStruct,\n  RowStruct,\n  SpinnerStruct,\n  TextStruct,\n  TooltipStruct,\n  CheckboxStruct,\n]);\n\n/**\n * For now, the allowed JSX elements at the root are the same as the allowed\n * children of the Box component.\n */\nexport const RootJSXElementStruct = BoxChildStruct;\n\n/**\n * A struct for the {@link JSXElement} type.\n */\nexport const JSXElementStruct: Describe<JSXElement> = nullUnion([\n  ButtonStruct,\n  InputStruct,\n  FileInputStruct,\n  FieldStruct,\n  FormStruct,\n  BoldStruct,\n  ItalicStruct,\n  AddressStruct,\n  BoxStruct,\n  CopyableStruct,\n  DividerStruct,\n  HeadingStruct,\n  ImageStruct,\n  LinkStruct,\n  RowStruct,\n  SpinnerStruct,\n  TextStruct,\n  DropdownStruct,\n  OptionStruct,\n  ValueStruct,\n  TooltipStruct,\n  CheckboxStruct,\n]);\n\n/**\n * Check if a value is a JSX element.\n *\n * @param value - The value to check.\n * @returns True if the value is a JSX element, false otherwise.\n */\nexport function isJSXElement(value: unknown): value is JSXElement {\n  return is(value, JSXElementStruct);\n}\n\n/**\n * Check if a value is a JSX element, without validating all of its contents.\n * This is useful when you want to validate the structure of a value, but not\n * all the children.\n *\n * This should only be used when you are sure that the value is safe to use,\n * i.e., after using {@link isJSXElement}.\n *\n * @param value - The value to check.\n * @returns True if the value is a JSX element, false otherwise.\n */\nexport function isJSXElementUnsafe(value: unknown): value is JSXElement {\n  return (\n    isPlainObject(value) &&\n    hasProperty(value, 'type') &&\n    hasProperty(value, 'props') &&\n    hasProperty(value, 'key')\n  );\n}\n\n/**\n * Assert that a value is a JSX element.\n *\n * @param value - The value to check.\n * @throws If the value is not a JSX element.\n */\nexport function assertJSXElement(value: unknown): asserts value is JSXElement {\n  // TODO: We should use the error parsing utils from `snaps-utils` to improve\n  // the error messages. It currently includes colours and potentially other\n  // formatting that we might not want to include in the SDK.\n  if (!isJSXElement(value)) {\n    throw new Error(\n      `Expected a JSX element, but received ${JSON.stringify(\n        value,\n      )}. Please refer to the documentation for the supported JSX elements and their props.`,\n    );\n  }\n}\n","import type { Infer } from '@metamask/superstruct';\nimport {\n  Struct,\n  define,\n  literal as superstructLiteral,\n  union as superstructUnion,\n} from '@metamask/superstruct';\nimport type { AnyStruct, InferStructTuple } from '@metamask/superstruct';\n\nimport type { EnumToUnion } from './helpers';\n\n/**\n * A wrapper of `superstruct`'s `literal` struct that also defines the name of\n * the struct as the literal value.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n * For example, instead of returning an error like:\n *\n * ```\n * Expected the value to satisfy a union of `literal | literal`, but received: \\\"baz\\\"\n * ```\n *\n * This struct will return an error like:\n *\n * ```\n * Expected the value to satisfy a union of `\"foo\" | \"bar\"`, but received: \\\"baz\\\"\n * ```\n *\n * @param value - The literal value.\n * @returns The `superstruct` struct, which validates that the value is equal\n * to the literal value.\n */\nexport function literal<Type extends string | number | boolean>(value: Type) {\n  return define<Type>(\n    JSON.stringify(value),\n    superstructLiteral(value).validator,\n  );\n}\n\n/**\n * A wrapper of `superstruct`'s `union` struct that also defines the schema as\n * the union of the schemas of the structs.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n *\n * @param structs - The structs to union.\n * @param structs.\"0\" - The first struct.\n * @param structs.\"1\" - The remaining structs.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function union<Head extends AnyStruct, Tail extends AnyStruct[]>([\n  head,\n  ...tail\n]: [head: Head, ...tail: Tail]): Struct<\n  Infer<Head> | InferStructTuple<Tail>[number],\n  [head: Head, ...tail: Tail]\n> {\n  const struct = superstructUnion([head, ...tail]);\n\n  return new Struct({\n    ...struct,\n    schema: [head, ...tail],\n  });\n}\n\n/**\n * Superstruct struct for validating an enum value. This allows using both the\n * enum string values and the enum itself as values.\n *\n * @param constant - The enum to validate against.\n * @returns The superstruct struct.\n */\nexport function enumValue<Type extends string>(\n  constant: Type,\n): Struct<EnumToUnion<Type>, null> {\n  return literal(constant as EnumToUnion<Type>);\n}\n","import type { Infer, Struct } from '@metamask/superstruct';\nimport type {\n  AnyStruct,\n  EnumSchema,\n  InferStructTuple,\n  IsExactMatch,\n  IsMatch,\n  IsRecord,\n  IsTuple,\n  UnionToIntersection,\n} from '@metamask/superstruct';\n\nimport type { EmptyObject } from '../types';\nimport { union } from './structs';\n\n/**\n * Check if a type is a union. Infers `true` if it is a union, otherwise\n * `false`.\n */\ntype IsUnion<Type> = [Type] extends [UnionToIntersection<Type>] ? false : true;\n\n/**\n * Get a struct schema for a type.\n *\n * This is copied from `superstruct` but fixes some issues with the original\n * implementation.\n */\ntype StructSchema<Type> = IsUnion<Type> extends true\n  ? null\n  : [Type] extends [EmptyObject]\n  ? EmptyObject\n  : [Type] extends [string | undefined | null]\n  ? [Type] extends [`0x${string}`]\n    ? null\n    : [Type] extends [IsMatch<Type, string | undefined | null>]\n    ? null\n    : [Type] extends [IsUnion<Type>]\n    ? EnumSchema<Type>\n    : Type\n  : [Type] extends [number | undefined | null]\n  ? [Type] extends [IsMatch<Type, number | undefined | null>]\n    ? null\n    : [Type] extends [IsUnion<Type>]\n    ? EnumSchema<Type>\n    : Type\n  : [Type] extends [boolean]\n  ? [Type] extends [IsExactMatch<Type, boolean>]\n    ? null\n    : Type\n  : Type extends\n      | bigint\n      | symbol\n      | undefined\n      | null\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      | Function\n      | Date\n      | Error\n      | RegExp\n      | Map<any, any>\n      | WeakMap<any, any>\n      | Set<any>\n      | WeakSet<any>\n      | Promise<any>\n  ? null\n  : Type extends (infer E)[]\n  ? Type extends IsTuple<Type>\n    ? null\n    : Struct<E>\n  : Type extends object\n  ? Type extends IsRecord<Type>\n    ? null\n    : {\n        [InnerKey in keyof Type]: Describe<Type[InnerKey]>;\n      }\n  : null;\n\n/**\n * Describe a struct type.\n */\nexport type Describe<Type> = Struct<Type, StructSchema<Type>>;\n\n/**\n * Create a union struct that uses `null` for the schema type, for better\n * compatibility with `Describe`.\n *\n * @param structs - The structs to union.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function nullUnion<Head extends AnyStruct, Tail extends AnyStruct[]>(\n  structs: [head: Head, ...tail: Tail],\n): Struct<Infer<Head> | InferStructTuple<Tail>[number], null> {\n  return union(structs) as unknown as Struct<\n    Infer<Head> | InferStructTuple<Tail>[number],\n    null\n  >;\n}\n","import { refine, string } from '@metamask/superstruct';\n\n/**\n * Get a Struct that validates a string as a valid SVG.\n *\n * @returns A Struct that validates a string as a valid SVG.\n * @internal\n */\nexport function svg() {\n  return refine(string(), 'SVG', (value) => {\n    // This validation is intentionally very basic, we don't need to be that strict\n    // and merely have this extra validation as a helpful error if devs aren't\n    // passing in SVGs.\n    if (!value.includes('<svg')) {\n      return 'Value is not a valid SVG.';\n    }\n\n    return true;\n  });\n}\n","import type { JsonObject, Key, SnapComponent } from './component';\nimport { jsx } from './jsx-runtime';\nimport { assertJSXElement } from './validation';\n\n/**\n * The JSX runtime for Snaps SDK components. This function is used to render\n * Snap components into a format that can be used by the Snaps.\n *\n * This is the \"development\" version of the runtime, which includes additional\n * validation, which is otherwise handled by MetaMask. To use this runtime,\n * specify `@metamask/snaps-sdk` as import source for JSX, and use\n * `react-jsxdev` as the pragma.\n *\n * @param component - The component to render.\n * @param props - The props to pass to the component.\n * @param key - The key of the component.\n * @returns The rendered component.\n * @see https://www.typescriptlang.org/tsconfig/#jsx\n */\nexport function jsxDEV<Props extends JsonObject>(\n  component: SnapComponent<Props>,\n  props: Props,\n  key: Key | null,\n): unknown | null {\n  const element = jsx(component, props, key);\n  assertJSXElement(element);\n\n  return element;\n}\n"],"mappings":"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","names":["string","string","element"]}
\ No newline at end of file
diff --git a/dist/types/internals/jsx.d.ts b/dist/types/internals/jsx.d.ts
index 29e858a8689399c6b322fca954fb45416b4e49c9..5c948dd3f7d5e76947f4ef8d40038f197e8e69a2 100644
--- a/dist/types/internals/jsx.d.ts
+++ b/dist/types/internals/jsx.d.ts
@@ -1,5 +1,5 @@
-import type { Infer, Struct } from 'superstruct';
-import type { AnyStruct, EnumSchema, InferStructTuple, IsExactMatch, IsMatch, IsRecord, IsTuple, UnionToIntersection } from 'superstruct/dist/utils';
+import type { Infer, Struct } from '@metamask/superstruct';
+import type { AnyStruct, EnumSchema, InferStructTuple, IsExactMatch, IsMatch, IsRecord, IsTuple, UnionToIntersection } from '@metamask/superstruct';
 import type { EmptyObject } from '../types';
 /**
  * Check if a type is a union. Infers `true` if it is a union, otherwise
diff --git a/dist/types/internals/structs.d.ts b/dist/types/internals/structs.d.ts
index bbfc1289001614aa48dca8aef392f619be8281bb..f4f2d1187c88f28d68b9ddae42bd535bfd1cbfed 100644
--- a/dist/types/internals/structs.d.ts
+++ b/dist/types/internals/structs.d.ts
@@ -1,6 +1,6 @@
-import type { Infer } from 'superstruct';
-import { Struct } from 'superstruct';
-import type { AnyStruct, InferStructTuple } from 'superstruct/dist/utils';
+import type { Infer } from '@metamask/superstruct';
+import { Struct } from '@metamask/superstruct';
+import type { AnyStruct, InferStructTuple } from '@metamask/superstruct';
 import type { EnumToUnion } from './helpers';
 /**
  * A wrapper of `superstruct`'s `literal` struct that also defines the name of
diff --git a/dist/types/internals/svg.d.ts b/dist/types/internals/svg.d.ts
index cda3bd7e7b1cde37099c830ce451ac6d5c190b4a..cd4a5d29aa53d1eac86eac29533d468d160e5d8c 100644
--- a/dist/types/internals/svg.d.ts
+++ b/dist/types/internals/svg.d.ts
@@ -4,4 +4,4 @@
  * @returns A Struct that validates a string as a valid SVG.
  * @internal
  */
-export declare function svg(): import("superstruct").Struct<string, null>;
+export declare function svg(): import("@metamask/superstruct").Struct<string, null>;
diff --git a/dist/types/jsx/validation.d.ts b/dist/types/jsx/validation.d.ts
index 21db53ee2779ef671a7b850f3d5bfb44fd9ff658..8574d03c250f8d4b932af45266f8f48a529b2b5a 100644
--- a/dist/types/jsx/validation.d.ts
+++ b/dist/types/jsx/validation.d.ts
@@ -1,4 +1,4 @@
-import type { Struct } from 'superstruct';
+import type { Struct } from '@metamask/superstruct';
 import type { Describe } from '../internals';
 import type { GenericSnapElement, Key, SnapElement, StringElement } from './component';
 import type { AddressElement, BoldElement, BoxElement, ButtonElement, CheckboxElement, CopyableElement, DividerElement, DropdownElement, OptionElement, FieldElement, FormElement, HeadingElement, ImageElement, InputElement, ItalicElement, JSXElement, LinkElement, RowElement, SpinnerElement, StandardFormattingElement, TextElement, TooltipElement, ValueElement, FileInputElement } from './components';
diff --git a/dist/types/types/handlers/user-input.d.ts b/dist/types/types/handlers/user-input.d.ts
index d62972089a6492d765da7389902eb00c2aff6069..44afb0ee2c2a7ea0e4c8ab1460409b7df1adbcab 100644
--- a/dist/types/types/handlers/user-input.d.ts
+++ b/dist/types/types/handlers/user-input.d.ts
@@ -1,4 +1,4 @@
-import type { Infer } from 'superstruct';
+import type { Infer } from '@metamask/superstruct';
 import type { InterfaceContext } from '../interface';
 /**
  * The type of user input event fired.
@@ -15,19 +15,19 @@ export declare enum UserInputEventType {
     InputChangeEvent = "InputChangeEvent",
     FileUploadEvent = "FileUploadEvent"
 }
-export declare const GenericEventStruct: import("superstruct").Struct<{
+export declare const GenericEventStruct: import("@metamask/superstruct").Struct<{
     type: string;
     name?: string | undefined;
 }, {
-    type: import("superstruct").Struct<string, null>;
-    name: import("superstruct").Struct<string | undefined, null>;
+    type: import("@metamask/superstruct").Struct<string, null>;
+    name: import("@metamask/superstruct").Struct<string | undefined, null>;
 }>;
-export declare const ButtonClickEventStruct: import("superstruct").Struct<{
+export declare const ButtonClickEventStruct: import("@metamask/superstruct").Struct<{
     type: UserInputEventType.ButtonClickEvent;
     name?: string | undefined;
 }, {
-    type: import("superstruct").Struct<UserInputEventType.ButtonClickEvent, UserInputEventType.ButtonClickEvent>;
-    name: import("superstruct").Struct<string | undefined, null>;
+    type: import("@metamask/superstruct").Struct<UserInputEventType.ButtonClickEvent, UserInputEventType.ButtonClickEvent>;
+    name: import("@metamask/superstruct").Struct<string | undefined, null>;
 }>;
 /**
  * A button click event fired in the UI. This is passed to the params of the
@@ -38,16 +38,16 @@ export declare const ButtonClickEventStruct: import("superstruct").Struct<{
  * @property name - The optional component name that fired the event.
  */
 export declare type ButtonClickEvent = Infer<typeof ButtonClickEventStruct>;
-export declare const FileStruct: import("superstruct").Struct<{
+export declare const FileStruct: import("@metamask/superstruct").Struct<{
     name: string;
     size: number;
     contentType: string;
     contents: string;
 }, {
-    name: import("superstruct").Struct<string, null>;
-    size: import("superstruct").Struct<number, null>;
-    contentType: import("superstruct").Struct<string, null>;
-    contents: import("superstruct").Struct<string, null>;
+    name: import("@metamask/superstruct").Struct<string, null>;
+    size: import("@metamask/superstruct").Struct<number, null>;
+    contentType: import("@metamask/superstruct").Struct<string, null>;
+    contents: import("@metamask/superstruct").Struct<string, null>;
 }>;
 /**
  * A file object containing the file name, size, content type, and the base64
@@ -59,7 +59,7 @@ export declare const FileStruct: import("superstruct").Struct<{
  * @property contents - The base64 encoded contents of the file.
  */
 export declare type File = Infer<typeof FileStruct>;
-export declare const FormSubmitEventStruct: import("superstruct").Struct<{
+export declare const FormSubmitEventStruct: import("@metamask/superstruct").Struct<{
     value: Record<string, string | boolean | {
         name: string;
         size: number;
@@ -69,14 +69,14 @@ export declare const FormSubmitEventStruct: import("superstruct").Struct<{
     type: UserInputEventType.FormSubmitEvent;
     name: string;
 }, {
-    type: import("superstruct").Struct<UserInputEventType.FormSubmitEvent, UserInputEventType.FormSubmitEvent>;
-    value: import("superstruct").Struct<Record<string, string | boolean | {
+    type: import("@metamask/superstruct").Struct<UserInputEventType.FormSubmitEvent, UserInputEventType.FormSubmitEvent>;
+    value: import("@metamask/superstruct").Struct<Record<string, string | boolean | {
         name: string;
         size: number;
         contentType: string;
         contents: string;
     } | null>, null>;
-    name: import("superstruct").Struct<string, null>;
+    name: import("@metamask/superstruct").Struct<string, null>;
 }>;
 /**
  * A form submit event, which is fired when a submit button is clicked.
@@ -92,14 +92,14 @@ export declare const FormSubmitEventStruct: import("superstruct").Struct<{
  * {@link File}.
  */
 export declare type FormSubmitEvent = Infer<typeof FormSubmitEventStruct>;
-export declare const InputChangeEventStruct: import("superstruct").Struct<{
+export declare const InputChangeEventStruct: import("@metamask/superstruct").Struct<{
     value: string | boolean;
     type: UserInputEventType.InputChangeEvent;
     name: string;
 }, {
-    type: import("superstruct").Struct<UserInputEventType.InputChangeEvent, UserInputEventType.InputChangeEvent>;
-    name: import("superstruct").Struct<string, null>;
-    value: import("superstruct").Struct<string | boolean, null>;
+    type: import("@metamask/superstruct").Struct<UserInputEventType.InputChangeEvent, UserInputEventType.InputChangeEvent>;
+    name: import("@metamask/superstruct").Struct<string, null>;
+    value: import("@metamask/superstruct").Struct<string | boolean, null>;
 }>;
 /**
  * An input change event, which is fired when the value of an input field
@@ -110,7 +110,7 @@ export declare const InputChangeEventStruct: import("superstruct").Struct<{
  * @property value - The new value of the input field.
  */
 export declare type InputChangeEvent = Infer<typeof InputChangeEventStruct>;
-export declare const FileUploadEventStruct: import("superstruct").Struct<{
+export declare const FileUploadEventStruct: import("@metamask/superstruct").Struct<{
     type: UserInputEventType.FileUploadEvent;
     name: string;
     file: {
@@ -120,18 +120,18 @@ export declare const FileUploadEventStruct: import("superstruct").Struct<{
         contents: string;
     } | null;
 }, {
-    type: import("superstruct").Struct<UserInputEventType.FileUploadEvent, UserInputEventType.FileUploadEvent>;
-    name: import("superstruct").Struct<string, null>;
-    file: import("superstruct").Struct<{
+    type: import("@metamask/superstruct").Struct<UserInputEventType.FileUploadEvent, UserInputEventType.FileUploadEvent>;
+    name: import("@metamask/superstruct").Struct<string, null>;
+    file: import("@metamask/superstruct").Struct<{
         name: string;
         size: number;
         contentType: string;
         contents: string;
     } | null, {
-        name: import("superstruct").Struct<string, null>;
-        size: import("superstruct").Struct<number, null>;
-        contentType: import("superstruct").Struct<string, null>;
-        contents: import("superstruct").Struct<string, null>;
+        name: import("@metamask/superstruct").Struct<string, null>;
+        size: import("@metamask/superstruct").Struct<number, null>;
+        contentType: import("@metamask/superstruct").Struct<string, null>;
+        contents: import("@metamask/superstruct").Struct<string, null>;
     }>;
 }>;
 /**
@@ -145,7 +145,7 @@ export declare const FileUploadEventStruct: import("superstruct").Struct<{
  * @see File
  */
 export declare type FileUploadEvent = Infer<typeof FileUploadEventStruct>;
-export declare const UserInputEventStruct: import("superstruct").Struct<{
+export declare const UserInputEventStruct: import("@metamask/superstruct").Struct<{
     type: UserInputEventType.ButtonClickEvent;
     name?: string | undefined;
 } | {
diff --git a/dist/types/types/interface.d.ts b/dist/types/types/interface.d.ts
index a927a12f5a07f0f7a1a239499ae7a88015b7ffa8..7d7bd5b46ccf0435b3e9e032f8380d7dfffcf3a4 100644
--- a/dist/types/types/interface.d.ts
+++ b/dist/types/types/interface.d.ts
@@ -1,4 +1,4 @@
-import type { Infer } from 'superstruct';
+import type { Infer } from '@metamask/superstruct';
 import type { JSXElement } from '../jsx';
 import type { Component } from '../ui';
 /**
@@ -7,19 +7,19 @@ import type { Component } from '../ui';
  * root state) and the root state since a key in the root stat can contain
  * either the value of an input or a sub-state of a form.
  */
-export declare const StateStruct: import("superstruct").Struct<string | boolean | {
+export declare const StateStruct: import("@metamask/superstruct").Struct<string | boolean | {
     name: string;
     size: number;
     contentType: string;
     contents: string;
 }, null>;
-export declare const FormStateStruct: import("superstruct").Struct<Record<string, string | boolean | {
+export declare const FormStateStruct: import("@metamask/superstruct").Struct<Record<string, string | boolean | {
     name: string;
     size: number;
     contentType: string;
     contents: string;
 } | null>, null>;
-export declare const InterfaceStateStruct: import("superstruct").Struct<Record<string, string | boolean | {
+export declare const InterfaceStateStruct: import("@metamask/superstruct").Struct<Record<string, string | boolean | {
     name: string;
     size: number;
     contentType: string;
@@ -34,7 +34,7 @@ export declare type State = Infer<typeof StateStruct>;
 export declare type FormState = Infer<typeof FormStateStruct>;
 export declare type InterfaceState = Infer<typeof InterfaceStateStruct>;
 export declare type ComponentOrElement = Component | JSXElement;
-export declare const ComponentOrElementStruct: import("superstruct").Struct<{
+export declare const ComponentOrElementStruct: import("@metamask/superstruct").Struct<{
     value: string;
     type: import("../ui").NodeType.Copyable;
     sensitive?: boolean | undefined;
@@ -108,5 +108,5 @@ export declare const ComponentOrElementStruct: import("superstruct").Struct<{
     src: string;
     alt?: string | undefined;
 }, "Image"> | import("../jsx").SnapElement<import("../jsx").LinkProps, "Link"> | import("../jsx").SnapElement<import("../jsx").TextProps, "Text"> | import("../jsx").SnapElement<import("../jsx").RowProps, "Row"> | import("../jsx").SnapElement<Record<string, never>, "Spinner"> | import("../jsx").SnapElement<import("../jsx").TooltipProps, "Tooltip">, null>;
-export declare const InterfaceContextStruct: import("superstruct").Struct<Record<string, import("@metamask/utils").Json>, null>;
+export declare const InterfaceContextStruct: import("@metamask/superstruct").Struct<Record<string, import("@metamask/utils").Json>, null>;
 export declare type InterfaceContext = Infer<typeof InterfaceContextStruct>;
diff --git a/dist/types/ui/builder.d.ts b/dist/types/ui/builder.d.ts
index cdbb9fec64a64302ee6d8b0441faa872c6d4b48f..b03d1adb44a055a2af2e1442aa5395f614a89219 100644
--- a/dist/types/ui/builder.d.ts
+++ b/dist/types/ui/builder.d.ts
@@ -1,4 +1,4 @@
-import type { Struct } from 'superstruct';
+import type { Struct } from '@metamask/superstruct';
 import type { Component } from './components';
 import type { NodeType } from './nodes';
 /**
diff --git a/dist/types/ui/components/address.d.ts b/dist/types/ui/components/address.d.ts
index fc348d22cba13fba7ada95b86df12371268b0c82..e813400f74734a036aefb4c638dd87dcafac97dd 100644
--- a/dist/types/ui/components/address.d.ts
+++ b/dist/types/ui/components/address.d.ts
@@ -1,11 +1,11 @@
-import type { Infer } from 'superstruct';
+import type { Infer } from '@metamask/superstruct';
 import { NodeType } from '../nodes';
-export declare const AddressStruct: import("superstruct").Struct<{
+export declare const AddressStruct: import("@metamask/superstruct").Struct<{
     value: `0x${string}`;
     type: NodeType.Address;
 }, {
-    type: import("superstruct").Struct<NodeType.Address, NodeType.Address>;
-    value: import("superstruct").Struct<`0x${string}`, null>;
+    type: import("@metamask/superstruct").Struct<NodeType.Address, NodeType.Address>;
+    value: import("@metamask/superstruct").Struct<`0x${string}`, null>;
 }>;
 /**
  * A address node, that renders an EVM-like address and its icon.
diff --git a/dist/types/ui/components/button.d.ts b/dist/types/ui/components/button.d.ts
index 93e515c52bc31e95c8737a1ebe3efd2b89037aed..f986028d23272e3f5ac56c406c14b5e1ee0c4034 100644
--- a/dist/types/ui/components/button.d.ts
+++ b/dist/types/ui/components/button.d.ts
@@ -1,4 +1,4 @@
-import type { Infer } from 'superstruct';
+import type { Infer } from '@metamask/superstruct';
 import { NodeType } from '../nodes';
 export declare enum ButtonVariant {
     Primary = "primary",
@@ -8,18 +8,18 @@ export declare enum ButtonType {
     Button = "button",
     Submit = "submit"
 }
-export declare const ButtonStruct: import("superstruct").Struct<{
+export declare const ButtonStruct: import("@metamask/superstruct").Struct<{
     value: string;
     type: NodeType.Button;
     name?: string | undefined;
     variant?: "primary" | "secondary" | undefined;
     buttonType?: "button" | "submit" | undefined;
 }, {
-    type: import("superstruct").Struct<NodeType.Button, NodeType.Button>;
-    value: import("superstruct").Struct<string, null>;
-    variant: import("superstruct").Struct<"primary" | "secondary" | undefined, null>;
-    buttonType: import("superstruct").Struct<"button" | "submit" | undefined, null>;
-    name: import("superstruct").Struct<string | undefined, null>;
+    type: import("@metamask/superstruct").Struct<NodeType.Button, NodeType.Button>;
+    value: import("@metamask/superstruct").Struct<string, null>;
+    variant: import("@metamask/superstruct").Struct<"primary" | "secondary" | undefined, null>;
+    buttonType: import("@metamask/superstruct").Struct<"button" | "submit" | undefined, null>;
+    name: import("@metamask/superstruct").Struct<string | undefined, null>;
 }>;
 /**
  * A button node, that renders either a primary or a secondary button.
diff --git a/dist/types/ui/components/copyable.d.ts b/dist/types/ui/components/copyable.d.ts
index f89ae230dc0631692934113df5659fe6dd428f69..2949ed74cc6881e034332e67427c742b918b3b12 100644
--- a/dist/types/ui/components/copyable.d.ts
+++ b/dist/types/ui/components/copyable.d.ts
@@ -1,13 +1,13 @@
-import type { Infer } from 'superstruct';
+import type { Infer } from '@metamask/superstruct';
 import { NodeType } from '../nodes';
-export declare const CopyableStruct: import("superstruct").Struct<{
+export declare const CopyableStruct: import("@metamask/superstruct").Struct<{
     value: string;
     type: NodeType.Copyable;
     sensitive?: boolean | undefined;
 }, {
-    type: import("superstruct").Struct<NodeType.Copyable, NodeType.Copyable>;
-    value: import("superstruct").Struct<string, null>;
-    sensitive: import("superstruct").Struct<boolean | undefined, null>;
+    type: import("@metamask/superstruct").Struct<NodeType.Copyable, NodeType.Copyable>;
+    value: import("@metamask/superstruct").Struct<string, null>;
+    sensitive: import("@metamask/superstruct").Struct<boolean | undefined, null>;
 }>;
 /**
  * Text that can be copied to the clipboard. It can optionally be marked as
diff --git a/dist/types/ui/components/divider.d.ts b/dist/types/ui/components/divider.d.ts
index c083b5254173b6bf1f251a7a6dfef439fedde091..768552d67230c39db125bb6e8c0a351a521f2652 100644
--- a/dist/types/ui/components/divider.d.ts
+++ b/dist/types/ui/components/divider.d.ts
@@ -1,9 +1,9 @@
-import type { Infer } from 'superstruct';
+import type { Infer } from '@metamask/superstruct';
 import { NodeType } from '../nodes';
-export declare const DividerStruct: import("superstruct").Struct<{
+export declare const DividerStruct: import("@metamask/superstruct").Struct<{
     type: NodeType.Divider;
 }, {
-    type: import("superstruct").Struct<NodeType.Divider, NodeType.Divider>;
+    type: import("@metamask/superstruct").Struct<NodeType.Divider, NodeType.Divider>;
 }>;
 /**
  * A divider node, that renders a line between other nodes.
diff --git a/dist/types/ui/components/form.d.ts b/dist/types/ui/components/form.d.ts
index 0e2490c9a6686cd5687d5d51a2a0480622a9e3e7..e968d4743baf19e92f2f2c572577ed08f2b59e2f 100644
--- a/dist/types/ui/components/form.d.ts
+++ b/dist/types/ui/components/form.d.ts
@@ -1,6 +1,6 @@
-import type { Infer } from 'superstruct';
+import type { Infer } from '@metamask/superstruct';
 import { NodeType } from '../nodes';
-export declare const FormComponentStruct: import("superstruct").Struct<{
+export declare const FormComponentStruct: import("@metamask/superstruct").Struct<{
     type: NodeType.Input;
     name: string;
     value?: string | undefined;
@@ -19,7 +19,7 @@ export declare const FormComponentStruct: import("superstruct").Struct<{
  * The subset of nodes allowed as children in the {@link Form} node.
  */
 export declare type FormComponent = Infer<typeof FormComponentStruct>;
-export declare const FormStruct: import("superstruct").Struct<{
+export declare const FormStruct: import("@metamask/superstruct").Struct<{
     type: NodeType.Form;
     name: string;
     children: ({
@@ -38,8 +38,8 @@ export declare const FormStruct: import("superstruct").Struct<{
         buttonType?: "button" | "submit" | undefined;
     })[];
 }, {
-    type: import("superstruct").Struct<NodeType.Form, NodeType.Form>;
-    children: import("superstruct").Struct<({
+    type: import("@metamask/superstruct").Struct<NodeType.Form, NodeType.Form>;
+    children: import("@metamask/superstruct").Struct<({
         type: NodeType.Input;
         name: string;
         value?: string | undefined;
@@ -53,7 +53,7 @@ export declare const FormStruct: import("superstruct").Struct<{
         name?: string | undefined;
         variant?: "primary" | "secondary" | undefined;
         buttonType?: "button" | "submit" | undefined;
-    })[], import("superstruct").Struct<{
+    })[], import("@metamask/superstruct").Struct<{
         type: NodeType.Input;
         name: string;
         value?: string | undefined;
@@ -68,7 +68,7 @@ export declare const FormStruct: import("superstruct").Struct<{
         variant?: "primary" | "secondary" | undefined;
         buttonType?: "button" | "submit" | undefined;
     }, null>>;
-    name: import("superstruct").Struct<string, null>;
+    name: import("@metamask/superstruct").Struct<string, null>;
 }>;
 /**
  * A form node that takes children {@link FormComponent} nodes and renders a form.
diff --git a/dist/types/ui/components/heading.d.ts b/dist/types/ui/components/heading.d.ts
index 0c88af706c0e9fa06356a0ff0e3ce39e3396fc01..5822d5120181f3d44b5b8455895e0bb7e3620fdf 100644
--- a/dist/types/ui/components/heading.d.ts
+++ b/dist/types/ui/components/heading.d.ts
@@ -1,11 +1,11 @@
-import type { Infer } from 'superstruct';
+import type { Infer } from '@metamask/superstruct';
 import { NodeType } from '../nodes';
-export declare const HeadingStruct: import("superstruct").Struct<{
+export declare const HeadingStruct: import("@metamask/superstruct").Struct<{
     value: string;
     type: NodeType.Heading;
 }, {
-    type: import("superstruct").Struct<NodeType.Heading, NodeType.Heading>;
-    value: import("superstruct").Struct<string, null>;
+    type: import("@metamask/superstruct").Struct<NodeType.Heading, NodeType.Heading>;
+    value: import("@metamask/superstruct").Struct<string, null>;
 }>;
 /**
  * A heading node, that renders the text as a heading. The level of the heading
diff --git a/dist/types/ui/components/image.d.ts b/dist/types/ui/components/image.d.ts
index 1a98bf991bb019cf4a0bbf28d336f1ba03904a63..191073b8984b739d601a1224521280dcb3e54511 100644
--- a/dist/types/ui/components/image.d.ts
+++ b/dist/types/ui/components/image.d.ts
@@ -1,11 +1,11 @@
-import type { Infer } from 'superstruct';
+import type { Infer } from '@metamask/superstruct';
 import { NodeType } from '../nodes';
-export declare const ImageStruct: import("superstruct").Struct<{
+export declare const ImageStruct: import("@metamask/superstruct").Struct<{
     value: string;
     type: NodeType.Image;
 }, {
-    type: import("superstruct").Struct<NodeType.Image, NodeType.Image>;
-    value: import("superstruct").Struct<string, null>;
+    type: import("@metamask/superstruct").Struct<NodeType.Image, NodeType.Image>;
+    value: import("@metamask/superstruct").Struct<string, null>;
 }>;
 /**
  * An image node, that renders an SVG image.
diff --git a/dist/types/ui/components/input.d.ts b/dist/types/ui/components/input.d.ts
index 51dd69f485dbab7c47aa594288ffae11df7a5334..a488eeaea8eba90ce79de8fbb96fd95f089b7739 100644
--- a/dist/types/ui/components/input.d.ts
+++ b/dist/types/ui/components/input.d.ts
@@ -1,4 +1,4 @@
-import type { Infer } from 'superstruct';
+import type { Infer } from '@metamask/superstruct';
 import { NodeType } from '../nodes';
 /**
  * This replicates the available input types from the metamask extension.
@@ -9,7 +9,7 @@ export declare enum InputType {
     Number = "number",
     Password = "password"
 }
-export declare const InputStruct: import("superstruct").Struct<{
+export declare const InputStruct: import("@metamask/superstruct").Struct<{
     type: NodeType.Input;
     name: string;
     value?: string | undefined;
@@ -18,13 +18,13 @@ export declare const InputStruct: import("superstruct").Struct<{
     inputType?: "number" | "text" | "password" | undefined;
     placeholder?: string | undefined;
 }, {
-    type: import("superstruct").Struct<NodeType.Input, NodeType.Input>;
-    value: import("superstruct").Struct<string | undefined, null>;
-    name: import("superstruct").Struct<string, null>;
-    inputType: import("superstruct").Struct<"number" | "text" | "password" | undefined, null>;
-    placeholder: import("superstruct").Struct<string | undefined, null>;
-    label: import("superstruct").Struct<string | undefined, null>;
-    error: import("superstruct").Struct<string | undefined, null>;
+    type: import("@metamask/superstruct").Struct<NodeType.Input, NodeType.Input>;
+    value: import("@metamask/superstruct").Struct<string | undefined, null>;
+    name: import("@metamask/superstruct").Struct<string, null>;
+    inputType: import("@metamask/superstruct").Struct<"number" | "text" | "password" | undefined, null>;
+    placeholder: import("@metamask/superstruct").Struct<string | undefined, null>;
+    label: import("@metamask/superstruct").Struct<string | undefined, null>;
+    error: import("@metamask/superstruct").Struct<string | undefined, null>;
 }>;
 /**
  * An input node, that renders an input.
diff --git a/dist/types/ui/components/panel.d.ts b/dist/types/ui/components/panel.d.ts
index da4a2742eb6b6e47a06588636d48ed39b6bbcec3..d57f2a6c6e21daefe20f66041cb3fb3b5717acda 100644
--- a/dist/types/ui/components/panel.d.ts
+++ b/dist/types/ui/components/panel.d.ts
@@ -1,4 +1,4 @@
-import type { Infer, Struct } from 'superstruct';
+import type { Infer, Struct } from '@metamask/superstruct';
 import { NodeType } from '../nodes';
 /**
  * @internal
diff --git a/dist/types/ui/components/row.d.ts b/dist/types/ui/components/row.d.ts
index 048e044f3cca6be0a9a0e8577dd26e139dc00dcb..3a9cf456be9f78bbb1843c1097d715e2a5febc8b 100644
--- a/dist/types/ui/components/row.d.ts
+++ b/dist/types/ui/components/row.d.ts
@@ -1,11 +1,11 @@
-import type { Infer } from 'superstruct';
+import type { Infer } from '@metamask/superstruct';
 import { NodeType } from '../nodes';
 export declare enum RowVariant {
     Default = "default",
     Critical = "critical",
     Warning = "warning"
 }
-export declare const RowStruct: import("superstruct").Struct<{
+export declare const RowStruct: import("@metamask/superstruct").Struct<{
     value: {
         value: string;
         type: NodeType.Image;
@@ -21,10 +21,10 @@ export declare const RowStruct: import("superstruct").Struct<{
     label: string;
     variant?: "default" | "warning" | "critical" | undefined;
 }, {
-    type: import("superstruct").Struct<NodeType.Row, NodeType.Row>;
-    variant: import("superstruct").Struct<"default" | "warning" | "critical" | undefined, null>;
-    label: import("superstruct").Struct<string, null>;
-    value: import("superstruct").Struct<{
+    type: import("@metamask/superstruct").Struct<NodeType.Row, NodeType.Row>;
+    variant: import("@metamask/superstruct").Struct<"default" | "warning" | "critical" | undefined, null>;
+    label: import("@metamask/superstruct").Struct<string, null>;
+    value: import("@metamask/superstruct").Struct<{
         value: string;
         type: NodeType.Image;
     } | {
diff --git a/dist/types/ui/components/spinner.d.ts b/dist/types/ui/components/spinner.d.ts
index da3ab733eb22ce714cb7060130cb48ee05e6890a..6e1f57718b358b36d451e5cbbed09c8ab0799c14 100644
--- a/dist/types/ui/components/spinner.d.ts
+++ b/dist/types/ui/components/spinner.d.ts
@@ -1,9 +1,9 @@
-import type { Infer } from 'superstruct';
+import type { Infer } from '@metamask/superstruct';
 import { NodeType } from '../nodes';
-export declare const SpinnerStruct: import("superstruct").Struct<{
+export declare const SpinnerStruct: import("@metamask/superstruct").Struct<{
     type: NodeType.Spinner;
 }, {
-    type: import("superstruct").Struct<NodeType.Spinner, NodeType.Spinner>;
+    type: import("@metamask/superstruct").Struct<NodeType.Spinner, NodeType.Spinner>;
 }>;
 /**
  * A spinner node, that renders a spinner, either as a full-screen overlay, or
diff --git a/dist/types/ui/components/text.d.ts b/dist/types/ui/components/text.d.ts
index 9b2b9531277adde01591a71909718c5f4f172173..711b43681686983b310999c4d0fc59537fc1c8de 100644
--- a/dist/types/ui/components/text.d.ts
+++ b/dist/types/ui/components/text.d.ts
@@ -1,13 +1,13 @@
-import type { Infer } from 'superstruct';
+import type { Infer } from '@metamask/superstruct';
 import { NodeType } from '../nodes';
-export declare const TextStruct: import("superstruct").Struct<{
+export declare const TextStruct: import("@metamask/superstruct").Struct<{
     value: string;
     type: NodeType.Text;
     markdown?: boolean | undefined;
 }, {
-    type: import("superstruct").Struct<NodeType.Text, NodeType.Text>;
-    value: import("superstruct").Struct<string, null>;
-    markdown: import("superstruct").Struct<boolean | undefined, null>;
+    type: import("@metamask/superstruct").Struct<NodeType.Text, NodeType.Text>;
+    value: import("@metamask/superstruct").Struct<string, null>;
+    markdown: import("@metamask/superstruct").Struct<boolean | undefined, null>;
 }>;
 /**
  * A text node, that renders the text as one or more paragraphs.
diff --git a/dist/types/ui/nodes.d.ts b/dist/types/ui/nodes.d.ts
index f1d76b68a43850f65ebf645f69d34247e6ed6b7b..dc1da5ba43f20aba1d7f5c4b84ee7ca56a73ec38 100644
--- a/dist/types/ui/nodes.d.ts
+++ b/dist/types/ui/nodes.d.ts
@@ -1,4 +1,4 @@
-import type { Infer } from 'superstruct';
+import type { Infer } from '@metamask/superstruct';
 /**
  * The supported node types. This is based on SIP-7.
  *
@@ -21,10 +21,10 @@ export declare enum NodeType {
 /**
  * @internal
  */
-export declare const NodeStruct: import("superstruct").Struct<{
+export declare const NodeStruct: import("@metamask/superstruct").Struct<{
     type: string;
 }, {
-    type: import("superstruct").Struct<string, null>;
+    type: import("@metamask/superstruct").Struct<string, null>;
 }>;
 /**
  * The base node type. All nodes extend this type.
@@ -37,12 +37,12 @@ export declare type Node = Infer<typeof NodeStruct>;
 /**
  * @internal
  */
-export declare const LiteralStruct: import("superstruct").Struct<{
+export declare const LiteralStruct: import("@metamask/superstruct").Struct<{
     value: unknown;
     type: string;
 }, {
-    value: import("superstruct").Struct<unknown, null>;
-    type: import("superstruct").Struct<string, null>;
+    value: import("@metamask/superstruct").Struct<unknown, null>;
+    type: import("@metamask/superstruct").Struct<string, null>;
 }>;
 /**
  * A node with a value. This is used for nodes that render a value, such as
diff --git a/package.json b/package.json
index c78de173e59c45bdeb07cd4a19b31a328d2b6bef..706e553b6079739e6fb9740e96bb36a80154b0be 100644
--- a/package.json
+++ b/package.json
@@ -58,12 +58,15 @@
     "lint:dependencies": "depcheck",
     "build:ci": "tsup --clean"
   },
+  "resolutions": {
+    "@metamask/superstruct": "3.1.0"
+  },
   "dependencies": {
     "@metamask/key-tree": "^9.1.1",
     "@metamask/providers": "^17.0.0",
     "@metamask/rpc-errors": "^6.2.1",
-    "@metamask/utils": "^8.3.0",
-    "superstruct": "^1.0.3"
+    "@metamask/superstruct": "^3.1.0",
+    "@metamask/utils": "^8.3.0"
   },
   "devDependencies": {
     "@lavamoat/allow-scripts": "^3.0.4",
