diff --git a/dist/superstruct.d.ts b/dist/superstruct.d.ts
index 0297c3e9321713e6b84040e393bdc8a38c75f11b..4758932e7ddc007e36c48568726f278531dcaa07 100644
--- a/dist/superstruct.d.ts
+++ b/dist/superstruct.d.ts
@@ -1,6 +1,6 @@
 import type { Infer } from 'superstruct';
 import { Struct } from 'superstruct';
-import type { ObjectSchema, OmitBy, Optionalize, PickBy, Simplify } from 'superstruct/dist/utils';
+import type { ObjectSchema, OmitBy, Optionalize, PickBy, Simplify } from 'superstruct';
 declare const ExactOptionalSymbol: unique symbol;
 export declare type ExactOptionalTag = {
     type: typeof ExactOptionalSymbol;
diff --git a/dist/superstruct.js.map b/dist/superstruct.js.map
index 13f57141d1dff4b920d3da3c2052ac54fa3f4590..aef7c243e6b37fc5a12a9ad71711ccab7922f3ec 100644
--- a/dist/superstruct.js.map
+++ b/dist/superstruct.js.map
@@ -1 +1 @@
-{"version":3,"file":"superstruct.js","sourceRoot":"","sources":["../src/superstruct.ts"],"names":[],"mappings":";;;AACA,6CAAyE;AAkDzE;;;;;;GAMG;AACH,SAAgB,MAAM,CACpB,MAAc;IAEd,OAAO,IAAA,oBAAQ,EAAC,MAAM,CAAQ,CAAC;AACjC,CAAC;AAJD,wBAIC;AAED;;;;;GAKG;AACH,SAAS,WAAW,CAAC,GAAY;IAC/B,MAAM,QAAQ,GAAW,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IACvD,MAAM,MAAM,GAA4B,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IAE1E,OAAO,QAAQ,IAAI,MAAM,CAAC;AAC5B,CAAC;AAED;;;;;;;;;;;;GAYG;AACH,SAAgB,aAAa,CAC3B,MAA4B;IAE5B,OAAO,IAAI,oBAAM,CAAC;QAChB,GAAG,MAAM;QAET,SAAS,EAAE,CAAC,KAAK,EAAE,GAAG,EAAE,EAAE,CACxB,CAAC,WAAW,CAAC,GAAG,CAAC,IAAI,MAAM,CAAC,SAAS,CAAC,KAAK,EAAE,GAAG,CAAC;QAEnD,OAAO,EAAE,CAAC,KAAK,EAAE,GAAG,EAAE,EAAE,CACtB,CAAC,WAAW,CAAC,GAAG,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,KAAa,EAAE,GAAG,CAAC;KAC1D,CAAC,CAAC;AACL,CAAC;AAZD,sCAYC;AAED;;;;;;;;;;;;GAYG;AACH,SAAgB,aAAa,CAC3B,IAAY,EACZ,OAAe;IAEf,OAAO,IAAA,oBAAM,EACX,IAAI,EACJ,CAAC,KAAc,EAAW,EAAE,CAC1B,OAAO,KAAK,KAAK,QAAQ,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CACnD,CAAC;AACJ,CAAC;AATD,sCASC;AAED;;;;;;;;;;GAUG;AACH,SAAgB,UAAU,CACxB,KAAc,EACd,MAA4B,EAC5B,OAAgB;IAEhB,IAAA,oBAAM,EAAC,KAAK,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC;IAC/B,OAAO,KAAK,CAAC;AACf,CAAC;AAPD,gCAOC","sourcesContent":["import type { Infer, Context } from 'superstruct';\nimport { Struct, assert, define, object as stObject } from 'superstruct';\nimport type {\n  ObjectSchema,\n  OmitBy,\n  Optionalize,\n  PickBy,\n  Simplify,\n} from 'superstruct/dist/utils';\n\ndeclare const ExactOptionalSymbol: unique symbol;\n\nexport type ExactOptionalTag = {\n  type: typeof ExactOptionalSymbol;\n};\n\n/**\n * Exclude type `Type` from the properties of `Obj`.\n *\n * ```ts\n * type Foo = { a: string | null; b: number };\n * type Bar = ExcludeType<Foo, null>;\n * // Bar = { a: string, b: number }\n * ```\n */\nexport type ExcludeType<Obj, Type> = {\n  [K in keyof Obj]: Exclude<Obj[K], Type>;\n};\n\n/**\n * Make optional all properties that have the `ExactOptionalTag` type.\n *\n * ```ts\n * type Foo = { a: string | ExactOptionalTag; b: number};\n * type Bar = ExactOptionalize<Foo>;\n * // Bar = { a?: string; b: number}\n * ```\n */\nexport type ExactOptionalize<Schema extends object> = OmitBy<\n  Schema,\n  ExactOptionalTag\n> &\n  Partial<ExcludeType<PickBy<Schema, ExactOptionalTag>, ExactOptionalTag>>;\n\n/**\n * Infer a type from an superstruct object schema.\n */\nexport type ObjectType<Schema extends ObjectSchema> = Simplify<\n  ExactOptionalize<Optionalize<{ [K in keyof Schema]: Infer<Schema[K]> }>>\n>;\n\n/**\n * Change the return type of a superstruct object struct to support exact\n * optional properties.\n *\n * @param schema - The object schema.\n * @returns A struct representing an object with a known set of properties.\n */\nexport function object<Schema extends ObjectSchema>(\n  schema: Schema,\n): Struct<ObjectType<Schema>, Schema> {\n  return stObject(schema) as any;\n}\n\n/**\n * Check if the current property is present in its parent object.\n *\n * @param ctx - The context to check.\n * @returns `true` if the property is present, `false` otherwise.\n */\nfunction hasOptional(ctx: Context): boolean {\n  const property: string = ctx.path[ctx.path.length - 1];\n  const parent: Record<string, unknown> = ctx.branch[ctx.branch.length - 2];\n\n  return property in parent;\n}\n\n/**\n * Augment a struct to allow exact-optional values. Exact-optional values can\n * be omitted but cannot be `undefined`.\n *\n * ```ts\n * const foo = object({ bar: exactOptional(string()) });\n * type Foo = Infer<typeof foo>;\n * // Foo = { bar?: string }\n * ```\n *\n * @param struct - The struct to augment.\n * @returns The augmented struct.\n */\nexport function exactOptional<Type, Schema>(\n  struct: Struct<Type, Schema>,\n): Struct<Type | ExactOptionalTag, Schema> {\n  return new Struct({\n    ...struct,\n\n    validator: (value, ctx) =>\n      !hasOptional(ctx) || struct.validator(value, ctx),\n\n    refiner: (value, ctx) =>\n      !hasOptional(ctx) || struct.refiner(value as Type, ctx),\n  });\n}\n\n/**\n * Defines a new string-struct matching a regular expression.\n *\n * Example:\n *\n * ```ts\n * const EthAddressStruct = definePattern('EthAddress', /^0x[0-9a-f]{40}$/iu);\n * ```\n *\n * @param name - Type name.\n * @param pattern - Regular expression to match.\n * @returns A new string-struct that matches the given pattern.\n */\nexport function definePattern(\n  name: string,\n  pattern: RegExp,\n): Struct<string, null> {\n  return define<string>(\n    name,\n    (value: unknown): boolean =>\n      typeof value === 'string' && pattern.test(value),\n  );\n}\n\n/**\n * Assert that a value is valid according to a struct.\n *\n * It is similar to superstruct's mask function, but it does not ignore extra\n * properties.\n *\n * @param value - Value to check.\n * @param struct - Struct to validate the value against.\n * @param message - Error message to throw if the value is not valid.\n * @returns The value if it is valid.\n */\nexport function strictMask<Type, Schema>(\n  value: unknown,\n  struct: Struct<Type, Schema>,\n  message?: string,\n): Type {\n  assert(value, struct, message);\n  return value;\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"superstruct.js","sourceRoot":"","sources":["../src/superstruct.ts"],"names":[],"mappings":";;;AACA,6CAAyE;AAkDzE;;;;;;GAMG;AACH,SAAgB,MAAM,CACpB,MAAc;IAEd,OAAO,IAAA,oBAAQ,EAAC,MAAM,CAAQ,CAAC;AACjC,CAAC;AAJD,wBAIC;AAED;;;;;GAKG;AACH,SAAS,WAAW,CAAC,GAAY;IAC/B,MAAM,QAAQ,GAAW,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IACvD,MAAM,MAAM,GAA4B,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IAE1E,OAAO,QAAQ,IAAI,MAAM,CAAC;AAC5B,CAAC;AAED;;;;;;;;;;;;GAYG;AACH,SAAgB,aAAa,CAC3B,MAA4B;IAE5B,OAAO,IAAI,oBAAM,CAAC;QAChB,GAAG,MAAM;QAET,SAAS,EAAE,CAAC,KAAK,EAAE,GAAG,EAAE,EAAE,CACxB,CAAC,WAAW,CAAC,GAAG,CAAC,IAAI,MAAM,CAAC,SAAS,CAAC,KAAK,EAAE,GAAG,CAAC;QAEnD,OAAO,EAAE,CAAC,KAAK,EAAE,GAAG,EAAE,EAAE,CACtB,CAAC,WAAW,CAAC,GAAG,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,KAAa,EAAE,GAAG,CAAC;KAC1D,CAAC,CAAC;AACL,CAAC;AAZD,sCAYC;AAED;;;;;;;;;;;;GAYG;AACH,SAAgB,aAAa,CAC3B,IAAY,EACZ,OAAe;IAEf,OAAO,IAAA,oBAAM,EACX,IAAI,EACJ,CAAC,KAAc,EAAW,EAAE,CAC1B,OAAO,KAAK,KAAK,QAAQ,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CACnD,CAAC;AACJ,CAAC;AATD,sCASC;AAED;;;;;;;;;;GAUG;AACH,SAAgB,UAAU,CACxB,KAAc,EACd,MAA4B,EAC5B,OAAgB;IAEhB,IAAA,oBAAM,EAAC,KAAK,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC;IAC/B,OAAO,KAAK,CAAC;AACf,CAAC;AAPD,gCAOC","sourcesContent":["import type { Infer, Context } from 'superstruct';\nimport { Struct, assert, define, object as stObject } from 'superstruct';\nimport type {\n  ObjectSchema,\n  OmitBy,\n  Optionalize,\n  PickBy,\n  Simplify,\n} from 'superstruct';\n\ndeclare const ExactOptionalSymbol: unique symbol;\n\nexport type ExactOptionalTag = {\n  type: typeof ExactOptionalSymbol;\n};\n\n/**\n * Exclude type `Type` from the properties of `Obj`.\n *\n * ```ts\n * type Foo = { a: string | null; b: number };\n * type Bar = ExcludeType<Foo, null>;\n * // Bar = { a: string, b: number }\n * ```\n */\nexport type ExcludeType<Obj, Type> = {\n  [K in keyof Obj]: Exclude<Obj[K], Type>;\n};\n\n/**\n * Make optional all properties that have the `ExactOptionalTag` type.\n *\n * ```ts\n * type Foo = { a: string | ExactOptionalTag; b: number};\n * type Bar = ExactOptionalize<Foo>;\n * // Bar = { a?: string; b: number}\n * ```\n */\nexport type ExactOptionalize<Schema extends object> = OmitBy<\n  Schema,\n  ExactOptionalTag\n> &\n  Partial<ExcludeType<PickBy<Schema, ExactOptionalTag>, ExactOptionalTag>>;\n\n/**\n * Infer a type from an superstruct object schema.\n */\nexport type ObjectType<Schema extends ObjectSchema> = Simplify<\n  ExactOptionalize<Optionalize<{ [K in keyof Schema]: Infer<Schema[K]> }>>\n>;\n\n/**\n * Change the return type of a superstruct object struct to support exact\n * optional properties.\n *\n * @param schema - The object schema.\n * @returns A struct representing an object with a known set of properties.\n */\nexport function object<Schema extends ObjectSchema>(\n  schema: Schema,\n): Struct<ObjectType<Schema>, Schema> {\n  return stObject(schema) as any;\n}\n\n/**\n * Check if the current property is present in its parent object.\n *\n * @param ctx - The context to check.\n * @returns `true` if the property is present, `false` otherwise.\n */\nfunction hasOptional(ctx: Context): boolean {\n  const property: string = ctx.path[ctx.path.length - 1];\n  const parent: Record<string, unknown> = ctx.branch[ctx.branch.length - 2];\n\n  return property in parent;\n}\n\n/**\n * Augment a struct to allow exact-optional values. Exact-optional values can\n * be omitted but cannot be `undefined`.\n *\n * ```ts\n * const foo = object({ bar: exactOptional(string()) });\n * type Foo = Infer<typeof foo>;\n * // Foo = { bar?: string }\n * ```\n *\n * @param struct - The struct to augment.\n * @returns The augmented struct.\n */\nexport function exactOptional<Type, Schema>(\n  struct: Struct<Type, Schema>,\n): Struct<Type | ExactOptionalTag, Schema> {\n  return new Struct({\n    ...struct,\n\n    validator: (value, ctx) =>\n      !hasOptional(ctx) || struct.validator(value, ctx),\n\n    refiner: (value, ctx) =>\n      !hasOptional(ctx) || struct.refiner(value as Type, ctx),\n  });\n}\n\n/**\n * Defines a new string-struct matching a regular expression.\n *\n * Example:\n *\n * ```ts\n * const EthAddressStruct = definePattern('EthAddress', /^0x[0-9a-f]{40}$/iu);\n * ```\n *\n * @param name - Type name.\n * @param pattern - Regular expression to match.\n * @returns A new string-struct that matches the given pattern.\n */\nexport function definePattern(\n  name: string,\n  pattern: RegExp,\n): Struct<string, null> {\n  return define<string>(\n    name,\n    (value: unknown): boolean =>\n      typeof value === 'string' && pattern.test(value),\n  );\n}\n\n/**\n * Assert that a value is valid according to a struct.\n *\n * It is similar to superstruct's mask function, but it does not ignore extra\n * properties.\n *\n * @param value - Value to check.\n * @param struct - Struct to validate the value against.\n * @param message - Error message to throw if the value is not valid.\n * @returns The value if it is valid.\n */\nexport function strictMask<Type, Schema>(\n  value: unknown,\n  struct: Struct<Type, Schema>,\n  message?: string,\n): Type {\n  assert(value, struct, message);\n  return value;\n}\n"]}
\ No newline at end of file
